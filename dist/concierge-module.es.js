import { jsx as P, jsxs as M, Fragment as nf } from "react/jsx-runtime";
import * as se from "react";
import { useState as L, useRef as Be, useEffect as H, useCallback as Ga, createContext as sf, useContext as of, forwardRef as Sg, useImperativeHandle as Cg } from "react";
import { motion as af } from "framer-motion";
import { Bot as dc, RotateCcw as Rg, Loader2 as ka, ChevronDown as Pg, ChevronUp as bg, Send as wg, Mic as Eg, MicOff as Ig, Upload as Ag, HelpCircle as Tg, ChevronLeft as _g, ChevronRight as kg, GraduationCap as Og, Sparkles as Mg, MessageSquare as Dg, ThumbsUp as Ng, ThumbsDown as xg } from "lucide-react";
import Oa from "react-markdown";
import { useLocation as zg } from "wouter";
import * as ms from "@radix-ui/react-tooltip";
import { useVideoTrack as cf, DailyVideo as Lg, useLocalSessionId as uf, useDaily as Fs, useDevices as jg, useAudioTrack as qg, useDailyEvent as Fg, useParticipantIds as Bg, useAppMessage as Ug, DailyAudio as $g, DailyProvider as Vg } from "@daily-co/daily-react";
import Wg from "@mui/icons-material/CallEnd";
import { initReactI18next as Hg } from "react-i18next";
function hc(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Kg(...e) {
  return (t) => {
    let r = !1;
    const s = e.map((i) => {
      const a = hc(i, t);
      return !r && typeof a == "function" && (r = !0), a;
    });
    if (r)
      return () => {
        for (let i = 0; i < s.length; i++) {
          const a = s[i];
          typeof a == "function" ? a() : hc(e[i], null);
        }
      };
  };
}
// @__NO_SIDE_EFFECTS__
function Jg(e) {
  const t = /* @__PURE__ */ Qg(e), r = se.forwardRef((s, i) => {
    const { children: a, ...o } = s, n = se.Children.toArray(a), c = n.find(Zg);
    if (c) {
      const u = c.props.children, l = n.map((p) => p === c ? se.Children.count(u) > 1 ? se.Children.only(null) : se.isValidElement(u) ? u.props.children : null : p);
      return /* @__PURE__ */ P(t, { ...o, ref: i, children: se.isValidElement(u) ? se.cloneElement(u, void 0, l) : null });
    }
    return /* @__PURE__ */ P(t, { ...o, ref: i, children: a });
  });
  return r.displayName = `${e}.Slot`, r;
}
var Gg = /* @__PURE__ */ Jg("Slot");
// @__NO_SIDE_EFFECTS__
function Qg(e) {
  const t = se.forwardRef((r, s) => {
    const { children: i, ...a } = r;
    if (se.isValidElement(i)) {
      const o = em(i), n = Xg(a, i.props);
      return i.type !== se.Fragment && (n.ref = s ? Kg(s, o) : o), se.cloneElement(i, n);
    }
    return se.Children.count(i) > 1 ? se.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Yg = Symbol("radix.slottable");
function Zg(e) {
  return se.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Yg;
}
function Xg(e, t) {
  const r = { ...t };
  for (const s in t) {
    const i = e[s], a = t[s];
    /^on[A-Z]/.test(s) ? i && a ? r[s] = (...n) => {
      const c = a(...n);
      return i(...n), c;
    } : i && (r[s] = i) : s === "style" ? r[s] = { ...i, ...a } : s === "className" && (r[s] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...r };
}
function em(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
function lf(e) {
  var t, r, s = "";
  if (typeof e == "string" || typeof e == "number") s += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = lf(e[t])) && (s && (s += " "), s += r);
  } else for (r in e) e[r] && (s && (s += " "), s += r);
  return s;
}
function pf() {
  for (var e, t, r = 0, s = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = lf(e)) && (s && (s += " "), s += t);
  return s;
}
const fc = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, vc = pf, tm = (e, t) => (r) => {
  var s;
  if (t?.variants == null) return vc(e, r?.class, r?.className);
  const { variants: i, defaultVariants: a } = t, o = Object.keys(i).map((u) => {
    const l = r?.[u], p = a?.[u];
    if (l === null) return null;
    const d = fc(l) || fc(p);
    return i[u][d];
  }), n = r && Object.entries(r).reduce((u, l) => {
    let [p, d] = l;
    return d === void 0 || (u[p] = d), u;
  }, {}), c = t == null || (s = t.compoundVariants) === null || s === void 0 ? void 0 : s.reduce((u, l) => {
    let { class: p, className: d, ...h } = l;
    return Object.entries(h).every((f) => {
      let [g, m] = f;
      return Array.isArray(m) ? m.includes({
        ...a,
        ...n
      }[g]) : {
        ...a,
        ...n
      }[g] === m;
    }) ? [
      ...u,
      p,
      d
    ] : u;
  }, []);
  return vc(e, o, c, r?.class, r?.className);
}, Qa = "-", rm = (e) => {
  const t = im(e), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: s
  } = e;
  return {
    getClassGroupId: (o) => {
      const n = o.split(Qa);
      return n[0] === "" && n.length !== 1 && n.shift(), df(n, t) || nm(o);
    },
    getConflictingClassGroupIds: (o, n) => {
      const c = r[o] || [];
      return n && s[o] ? [...c, ...s[o]] : c;
    }
  };
}, df = (e, t) => {
  if (e.length === 0)
    return t.classGroupId;
  const r = e[0], s = t.nextPart.get(r), i = s ? df(e.slice(1), s) : void 0;
  if (i)
    return i;
  if (t.validators.length === 0)
    return;
  const a = e.join(Qa);
  return t.validators.find(({
    validator: o
  }) => o(a))?.classGroupId;
}, gc = /^\[(.+)\]$/, nm = (e) => {
  if (gc.test(e)) {
    const t = gc.exec(e)[1], r = t?.substring(0, t.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, im = (e) => {
  const {
    theme: t,
    prefix: r
  } = e, s = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return om(Object.entries(e.classGroups), r).forEach(([a, o]) => {
    Ma(o, s, a, t);
  }), s;
}, Ma = (e, t, r, s) => {
  e.forEach((i) => {
    if (typeof i == "string") {
      const a = i === "" ? t : mc(t, i);
      a.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (sm(i)) {
        Ma(i(s), t, r, s);
        return;
      }
      t.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([a, o]) => {
      Ma(o, mc(t, a), r, s);
    });
  });
}, mc = (e, t) => {
  let r = e;
  return t.split(Qa).forEach((s) => {
    r.nextPart.has(s) || r.nextPart.set(s, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(s);
  }), r;
}, sm = (e) => e.isThemeGetter, om = (e, t) => t ? e.map(([r, s]) => {
  const i = s.map((a) => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([o, n]) => [t + o, n])) : a);
  return [r, i];
}) : e, am = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, r = /* @__PURE__ */ new Map(), s = /* @__PURE__ */ new Map();
  const i = (a, o) => {
    r.set(a, o), t++, t > e && (t = 0, s = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(a) {
      let o = r.get(a);
      if (o !== void 0)
        return o;
      if ((o = s.get(a)) !== void 0)
        return i(a, o), o;
    },
    set(a, o) {
      r.has(a) ? r.set(a, o) : i(a, o);
    }
  };
}, hf = "!", cm = (e) => {
  const {
    separator: t,
    experimentalParseClassName: r
  } = e, s = t.length === 1, i = t[0], a = t.length, o = (n) => {
    const c = [];
    let u = 0, l = 0, p;
    for (let m = 0; m < n.length; m++) {
      let v = n[m];
      if (u === 0) {
        if (v === i && (s || n.slice(m, m + a) === t)) {
          c.push(n.slice(l, m)), l = m + a;
          continue;
        }
        if (v === "/") {
          p = m;
          continue;
        }
      }
      v === "[" ? u++ : v === "]" && u--;
    }
    const d = c.length === 0 ? n : n.substring(l), h = d.startsWith(hf), f = h ? d.substring(1) : d, g = p && p > l ? p - l : void 0;
    return {
      modifiers: c,
      hasImportantModifier: h,
      baseClassName: f,
      maybePostfixModifierPosition: g
    };
  };
  return r ? (n) => r({
    className: n,
    parseClassName: o
  }) : o;
}, um = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let r = [];
  return e.forEach((s) => {
    s[0] === "[" ? (t.push(...r.sort(), s), r = []) : r.push(s);
  }), t.push(...r.sort()), t;
}, lm = (e) => ({
  cache: am(e.cacheSize),
  parseClassName: cm(e),
  ...rm(e)
}), pm = /\s+/, dm = (e, t) => {
  const {
    parseClassName: r,
    getClassGroupId: s,
    getConflictingClassGroupIds: i
  } = t, a = [], o = e.trim().split(pm);
  let n = "";
  for (let c = o.length - 1; c >= 0; c -= 1) {
    const u = o[c], {
      modifiers: l,
      hasImportantModifier: p,
      baseClassName: d,
      maybePostfixModifierPosition: h
    } = r(u);
    let f = !!h, g = s(f ? d.substring(0, h) : d);
    if (!g) {
      if (!f) {
        n = u + (n.length > 0 ? " " + n : n);
        continue;
      }
      if (g = s(d), !g) {
        n = u + (n.length > 0 ? " " + n : n);
        continue;
      }
      f = !1;
    }
    const m = um(l).join(":"), v = p ? m + hf : m, y = v + g;
    if (a.includes(y))
      continue;
    a.push(y);
    const S = i(g, f);
    for (let C = 0; C < S.length; ++C) {
      const R = S[C];
      a.push(v + R);
    }
    n = u + (n.length > 0 ? " " + n : n);
  }
  return n;
};
function hm() {
  let e = 0, t, r, s = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (r = ff(t)) && (s && (s += " "), s += r);
  return s;
}
const ff = (e) => {
  if (typeof e == "string")
    return e;
  let t, r = "";
  for (let s = 0; s < e.length; s++)
    e[s] && (t = ff(e[s])) && (r && (r += " "), r += t);
  return r;
};
function fm(e, ...t) {
  let r, s, i, a = o;
  function o(c) {
    const u = t.reduce((l, p) => p(l), e());
    return r = lm(u), s = r.cache.get, i = r.cache.set, a = n, n(c);
  }
  function n(c) {
    const u = s(c);
    if (u)
      return u;
    const l = dm(c, r);
    return i(c, l), l;
  }
  return function() {
    return a(hm.apply(null, arguments));
  };
}
const G = (e) => {
  const t = (r) => r[e] || [];
  return t.isThemeGetter = !0, t;
}, vf = /^\[(?:([a-z-]+):)?(.+)\]$/i, vm = /^\d+\/\d+$/, gm = /* @__PURE__ */ new Set(["px", "full", "screen"]), mm = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, ym = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Sm = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Cm = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Rm = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Ne = (e) => $t(e) || gm.has(e) || vm.test(e), Je = (e) => Vt(e, "length", _m), $t = (e) => !!e && !Number.isNaN(Number(e)), so = (e) => Vt(e, "number", $t), Xt = (e) => !!e && Number.isInteger(Number(e)), Pm = (e) => e.endsWith("%") && $t(e.slice(0, -1)), j = (e) => vf.test(e), Ge = (e) => mm.test(e), bm = /* @__PURE__ */ new Set(["length", "size", "percentage"]), wm = (e) => Vt(e, bm, gf), Em = (e) => Vt(e, "position", gf), Im = /* @__PURE__ */ new Set(["image", "url"]), Am = (e) => Vt(e, Im, Om), Tm = (e) => Vt(e, "", km), er = () => !0, Vt = (e, t, r) => {
  const s = vf.exec(e);
  return s ? s[1] ? typeof t == "string" ? s[1] === t : t.has(s[1]) : r(s[2]) : !1;
}, _m = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  ym.test(e) && !Sm.test(e)
), gf = () => !1, km = (e) => Cm.test(e), Om = (e) => Rm.test(e), Mm = () => {
  const e = G("colors"), t = G("spacing"), r = G("blur"), s = G("brightness"), i = G("borderColor"), a = G("borderRadius"), o = G("borderSpacing"), n = G("borderWidth"), c = G("contrast"), u = G("grayscale"), l = G("hueRotate"), p = G("invert"), d = G("gap"), h = G("gradientColorStops"), f = G("gradientColorStopPositions"), g = G("inset"), m = G("margin"), v = G("opacity"), y = G("padding"), S = G("saturate"), C = G("scale"), R = G("sepia"), w = G("skew"), I = G("space"), E = G("translate"), T = () => ["auto", "contain", "none"], b = () => ["auto", "hidden", "clip", "visible", "scroll"], _ = () => ["auto", j, t], k = () => [j, t], B = () => ["", Ne, Je], V = () => ["auto", $t, j], Q = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], K = () => ["solid", "dashed", "dotted", "double", "none"], le = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], he = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], J = () => ["", "0", j], re = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], Y = () => [$t, j];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [er],
      spacing: [Ne, Je],
      blur: ["none", "", Ge, j],
      brightness: Y(),
      borderColor: [e],
      borderRadius: ["none", "", "full", Ge, j],
      borderSpacing: k(),
      borderWidth: B(),
      contrast: Y(),
      grayscale: J(),
      hueRotate: Y(),
      invert: J(),
      gap: k(),
      gradientColorStops: [e],
      gradientColorStopPositions: [Pm, Je],
      inset: _(),
      margin: _(),
      opacity: Y(),
      padding: k(),
      saturate: Y(),
      scale: Y(),
      sepia: J(),
      skew: Y(),
      space: k(),
      translate: k()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", j]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ge]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": re()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": re()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...Q(), j]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: b()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": b()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": b()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: T()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": T()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": T()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Xt, j]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: _()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", j]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: J()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: J()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Xt, j]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [er]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Xt, j]
        }, j]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": V()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": V()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [er]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Xt, j]
        }, j]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": V()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": V()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", j]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", j]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [d]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [d]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [d]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...he()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...he(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...he(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [y]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [y]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [y]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [y]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [y]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [y]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [y]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [y]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [y]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [m]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [m]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [m]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [m]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [m]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [m]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [m]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [m]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [m]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [I]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [I]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", j, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [j, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [j, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [Ge]
        }, Ge]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [j, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [j, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [j, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [j, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Ge, Je]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", so]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [er]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", j]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", $t, so]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Ne, j]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", j]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", j]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [v]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [v]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...K(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Ne, Je]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Ne, j]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: k()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", j]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", j]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [v]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...Q(), Em]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", wm]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Am]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [f]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [f]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [f]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [n]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [n]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [n]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [n]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [n]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [n]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [n]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [n]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [n]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [v]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...K(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [n]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [n]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [v]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: K()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...K()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Ne, j]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Ne, Je]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: B()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [v]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Ne, Je]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Ge, Tm]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [er]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [v]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...le(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": le()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [s]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [c]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Ge, j]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [u]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [l]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [S]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [R]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [s]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [c]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [u]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [l]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [v]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [S]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [R]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [o]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [o]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [o]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", j]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: Y()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", j]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: Y()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", j]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [C]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [C]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [C]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Xt, j]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [E]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [E]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [w]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [w]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", j]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", j]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": k()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": k()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": k()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": k()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": k()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": k()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": k()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": k()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": k()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": k()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": k()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": k()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": k()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": k()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": k()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": k()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": k()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": k()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", j]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Ne, Je, so]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Dm = /* @__PURE__ */ fm(Mm);
function ls(...e) {
  return Dm(pf(e));
}
const Nm = tm(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Te = se.forwardRef(
  ({ className: e, variant: t, size: r, asChild: s = !1, ...i }, a) => /* @__PURE__ */ P(
    s ? Gg : "button",
    {
      className: ls(Nm({ variant: t, size: r, className: e })),
      ref: a,
      ...i
    }
  )
);
Te.displayName = "Button";
function yc(e, t) {
  const r = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let s = 0, i = r.indexOf(t);
  for (; i !== -1; )
    s++, i = r.indexOf(t, i + t.length);
  return s;
}
const ds = Us(/[A-Za-z]/), Ya = Us(/[\dA-Za-z]/);
function xm(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
function Ut(e) {
  return e !== null && e < -2;
}
function de(e) {
  return e !== null && (e < 0 || e === 32);
}
function qe(e) {
  return e === -2 || e === -1 || e === 32;
}
const Bs = Us(new RegExp("\\p{P}|\\p{S}", "u")), Ot = Us(/\s/);
function Us(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function zm(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const $s = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return Fm;
    if (typeof e == "function")
      return Vs(e);
    if (typeof e == "object")
      return Array.isArray(e) ? Lm(e) : jm(e);
    if (typeof e == "string")
      return qm(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function Lm(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = $s(e[r]);
  return Vs(s);
  function s(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function jm(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Vs(r);
  function r(s) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      s
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function qm(e) {
  return Vs(t);
  function t(r) {
    return r && r.type === e;
  }
}
function Vs(e) {
  return t;
  function t(r, s, i) {
    return !!(Bm(r) && e.call(
      this,
      r,
      typeof s == "number" ? s : void 0,
      i || void 0
    ));
  }
}
function Fm() {
  return !0;
}
function Bm(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const mf = [], Um = !0, Da = !1, $m = "skip";
function yf(e, t, r, s) {
  let i;
  typeof t == "function" && typeof r != "function" ? (s = r, r = t) : i = t;
  const a = $s(i), o = s ? -1 : 1;
  n(e, void 0, [])();
  function n(c, u, l) {
    const p = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof p.type == "string") {
      const h = (
        // `hast`
        typeof p.tagName == "string" ? p.tagName : (
          // `xast`
          typeof p.name == "string" ? p.name : void 0
        )
      );
      Object.defineProperty(d, "name", {
        value: "node (" + (c.type + (h ? "<" + h + ">" : "")) + ")"
      });
    }
    return d;
    function d() {
      let h = mf, f, g, m;
      if ((!t || a(c, u, l[l.length - 1] || void 0)) && (h = Vm(r(c, l)), h[0] === Da))
        return h;
      if ("children" in c && c.children) {
        const v = (
          /** @type {UnistParent} */
          c
        );
        if (v.children && h[0] !== $m)
          for (g = (s ? v.children.length : -1) + o, m = l.concat(v); g > -1 && g < v.children.length; ) {
            const y = v.children[g];
            if (f = n(y, g, m)(), f[0] === Da)
              return f;
            g = typeof f[1] == "number" ? f[1] : g + o;
          }
      }
      return h;
    }
  }
}
function Vm(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Um, e] : e == null ? mf : [e];
}
function Wm(e, t, r) {
  const i = $s((r || {}).ignore || []), a = Hm(t);
  let o = -1;
  for (; ++o < a.length; )
    yf(e, "text", n);
  function n(u, l) {
    let p = -1, d;
    for (; ++p < l.length; ) {
      const h = l[p], f = d ? d.children : void 0;
      if (i(
        h,
        f ? f.indexOf(h) : void 0,
        d
      ))
        return;
      d = h;
    }
    if (d)
      return c(u, l);
  }
  function c(u, l) {
    const p = l[l.length - 1], d = a[o][0], h = a[o][1];
    let f = 0;
    const m = p.children.indexOf(u);
    let v = !1, y = [];
    d.lastIndex = 0;
    let S = d.exec(u.value);
    for (; S; ) {
      const C = S.index, R = {
        index: S.index,
        input: S.input,
        stack: [...l, u]
      };
      let w = h(...S, R);
      if (typeof w == "string" && (w = w.length > 0 ? { type: "text", value: w } : void 0), w === !1 ? d.lastIndex = C + 1 : (f !== C && y.push({
        type: "text",
        value: u.value.slice(f, C)
      }), Array.isArray(w) ? y.push(...w) : w && y.push(w), f = C + S[0].length, v = !0), !d.global)
        break;
      S = d.exec(u.value);
    }
    return v ? (f < u.value.length && y.push({ type: "text", value: u.value.slice(f) }), p.children.splice(m, 1, ...y)) : y = [u], m + y.length;
  }
}
function Hm(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const r = !e[0] || Array.isArray(e[0]) ? e : [e];
  let s = -1;
  for (; ++s < r.length; ) {
    const i = r[s];
    t.push([Km(i[0]), Jm(i[1])]);
  }
  return t;
}
function Km(e) {
  return typeof e == "string" ? new RegExp(zm(e), "g") : e;
}
function Jm(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const oo = "phrasing", ao = ["autolink", "link", "image", "label"];
function Gm() {
  return {
    transforms: [ry],
    enter: {
      literalAutolink: Ym,
      literalAutolinkEmail: co,
      literalAutolinkHttp: co,
      literalAutolinkWww: co
    },
    exit: {
      literalAutolink: ty,
      literalAutolinkEmail: ey,
      literalAutolinkHttp: Zm,
      literalAutolinkWww: Xm
    }
  };
}
function Qm() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: oo,
        notInConstruct: ao
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: oo,
        notInConstruct: ao
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: oo,
        notInConstruct: ao
      }
    ]
  };
}
function Ym(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function co(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function Zm(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function Xm(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function ey(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function ty(e) {
  this.exit(e);
}
function ry(e) {
  Wm(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, ny],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), iy]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function ny(e, t, r, s, i) {
  let a = "";
  if (!Sf(i) || (/^w/i.test(t) && (r = t + r, t = "", a = "http://"), !sy(r)))
    return !1;
  const o = oy(r + s);
  if (!o[0]) return !1;
  const n = {
    type: "link",
    title: null,
    url: a + t + o[0],
    children: [{ type: "text", value: t + o[0] }]
  };
  return o[1] ? [n, { type: "text", value: o[1] }] : n;
}
function iy(e, t, r, s) {
  return (
    // Not an expected previous character.
    !Sf(s, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(r) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + r,
      children: [{ type: "text", value: t + "@" + r }]
    }
  );
}
function sy(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function oy(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let r = t[0], s = r.indexOf(")");
  const i = yc(e, "(");
  let a = yc(e, ")");
  for (; s !== -1 && i > a; )
    e += r.slice(0, s + 1), r = r.slice(s + 1), s = r.indexOf(")"), a++;
  return [e, r];
}
function Sf(e, t) {
  const r = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Ot(r) || Bs(r)) && // If it’s an email, the previous character should not be a slash.
  (!t || r !== 47);
}
function ys(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
Cf.peek = vy;
function ay() {
  this.buffer();
}
function cy(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function uy() {
  this.buffer();
}
function ly(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function py(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = ys(
    this.sliceSerialize(e)
  ).toLowerCase(), r.label = t;
}
function dy(e) {
  this.exit(e);
}
function hy(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = ys(
    this.sliceSerialize(e)
  ).toLowerCase(), r.label = t;
}
function fy(e) {
  this.exit(e);
}
function vy() {
  return "[";
}
function Cf(e, t, r, s) {
  const i = r.createTracker(s);
  let a = i.move("[^");
  const o = r.enter("footnoteReference"), n = r.enter("reference");
  return a += i.move(
    r.safe(r.associationId(e), { after: "]", before: a })
  ), n(), o(), a += i.move("]"), a;
}
function gy() {
  return {
    enter: {
      gfmFootnoteCallString: ay,
      gfmFootnoteCall: cy,
      gfmFootnoteDefinitionLabelString: uy,
      gfmFootnoteDefinition: ly
    },
    exit: {
      gfmFootnoteCallString: py,
      gfmFootnoteCall: dy,
      gfmFootnoteDefinitionLabelString: hy,
      gfmFootnoteDefinition: fy
    }
  };
}
function my(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: r, footnoteReference: Cf },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function r(s, i, a, o) {
    const n = a.createTracker(o);
    let c = n.move("[^");
    const u = a.enter("footnoteDefinition"), l = a.enter("label");
    return c += n.move(
      a.safe(a.associationId(s), { before: c, after: "]" })
    ), l(), c += n.move("]:"), s.children && s.children.length > 0 && (n.shift(4), c += n.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(s, n.current()),
        t ? Rf : yy
      )
    )), u(), c;
  }
}
function yy(e, t, r) {
  return t === 0 ? e : Rf(e, t, r);
}
function Rf(e, t, r) {
  return (r ? "" : "    ") + e;
}
const Sy = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Pf.peek = wy;
function Cy() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Py },
    exit: { strikethrough: by }
  };
}
function Ry() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Sy
      }
    ],
    handlers: { delete: Pf }
  };
}
function Py(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function by(e) {
  this.exit(e);
}
function Pf(e, t, r, s) {
  const i = r.createTracker(s), a = r.enter("strikethrough");
  let o = i.move("~~");
  return o += r.containerPhrasing(e, {
    ...i.current(),
    before: o,
    after: "~"
  }), o += i.move("~~"), a(), o;
}
function wy() {
  return "~";
}
function Ey(e) {
  return e.length;
}
function Iy(e, t) {
  const r = t || {}, s = (r.align || []).concat(), i = r.stringLength || Ey, a = [], o = [], n = [], c = [];
  let u = 0, l = -1;
  for (; ++l < e.length; ) {
    const g = [], m = [];
    let v = -1;
    for (e[l].length > u && (u = e[l].length); ++v < e[l].length; ) {
      const y = Ay(e[l][v]);
      if (r.alignDelimiters !== !1) {
        const S = i(y);
        m[v] = S, (c[v] === void 0 || S > c[v]) && (c[v] = S);
      }
      g.push(y);
    }
    o[l] = g, n[l] = m;
  }
  let p = -1;
  if (typeof s == "object" && "length" in s)
    for (; ++p < u; )
      a[p] = Sc(s[p]);
  else {
    const g = Sc(s);
    for (; ++p < u; )
      a[p] = g;
  }
  p = -1;
  const d = [], h = [];
  for (; ++p < u; ) {
    const g = a[p];
    let m = "", v = "";
    g === 99 ? (m = ":", v = ":") : g === 108 ? m = ":" : g === 114 && (v = ":");
    let y = r.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[p] - m.length - v.length
    );
    const S = m + "-".repeat(y) + v;
    r.alignDelimiters !== !1 && (y = m.length + y + v.length, y > c[p] && (c[p] = y), h[p] = y), d[p] = S;
  }
  o.splice(1, 0, d), n.splice(1, 0, h), l = -1;
  const f = [];
  for (; ++l < o.length; ) {
    const g = o[l], m = n[l];
    p = -1;
    const v = [];
    for (; ++p < u; ) {
      const y = g[p] || "";
      let S = "", C = "";
      if (r.alignDelimiters !== !1) {
        const R = c[p] - (m[p] || 0), w = a[p];
        w === 114 ? S = " ".repeat(R) : w === 99 ? R % 2 ? (S = " ".repeat(R / 2 + 0.5), C = " ".repeat(R / 2 - 0.5)) : (S = " ".repeat(R / 2), C = S) : C = " ".repeat(R);
      }
      r.delimiterStart !== !1 && !p && v.push("|"), r.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(r.alignDelimiters === !1 && y === "") && (r.delimiterStart !== !1 || p) && v.push(" "), r.alignDelimiters !== !1 && v.push(S), v.push(y), r.alignDelimiters !== !1 && v.push(C), r.padding !== !1 && v.push(" "), (r.delimiterEnd !== !1 || p !== u - 1) && v.push("|");
    }
    f.push(
      r.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join("")
    );
  }
  return f.join(`
`);
}
function Ay(e) {
  return e == null ? "" : String(e);
}
function Sc(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function Ty(e, t, r, s) {
  const i = r.enter("blockquote"), a = r.createTracker(s);
  a.move("> "), a.shift(2);
  const o = r.indentLines(
    r.containerFlow(e, a.current()),
    _y
  );
  return i(), o;
}
function _y(e, t, r) {
  return ">" + (r ? "" : " ") + e;
}
function ky(e, t) {
  return Cc(e, t.inConstruct, !0) && !Cc(e, t.notInConstruct, !1);
}
function Cc(e, t, r) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return r;
  let s = -1;
  for (; ++s < t.length; )
    if (e.includes(t[s]))
      return !0;
  return !1;
}
function Rc(e, t, r, s) {
  let i = -1;
  for (; ++i < r.unsafe.length; )
    if (r.unsafe[i].character === `
` && ky(r.stack, r.unsafe[i]))
      return /[ \t]/.test(s.before) ? "" : " ";
  return `\\
`;
}
function Oy(e, t) {
  const r = String(e);
  let s = r.indexOf(t), i = s, a = 0, o = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; s !== -1; )
    s === i ? ++a > o && (o = a) : a = 1, i = s + t.length, s = r.indexOf(t, i);
  return o;
}
function My(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function Dy(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Ny(e, t, r, s) {
  const i = Dy(r), a = e.value || "", o = i === "`" ? "GraveAccent" : "Tilde";
  if (My(e, r)) {
    const p = r.enter("codeIndented"), d = r.indentLines(a, xy);
    return p(), d;
  }
  const n = r.createTracker(s), c = i.repeat(Math.max(Oy(a, i) + 1, 3)), u = r.enter("codeFenced");
  let l = n.move(c);
  if (e.lang) {
    const p = r.enter(`codeFencedLang${o}`);
    l += n.move(
      r.safe(e.lang, {
        before: l,
        after: " ",
        encode: ["`"],
        ...n.current()
      })
    ), p();
  }
  if (e.lang && e.meta) {
    const p = r.enter(`codeFencedMeta${o}`);
    l += n.move(" "), l += n.move(
      r.safe(e.meta, {
        before: l,
        after: `
`,
        encode: ["`"],
        ...n.current()
      })
    ), p();
  }
  return l += n.move(`
`), a && (l += n.move(a + `
`)), l += n.move(c), u(), l;
}
function xy(e, t, r) {
  return (r ? "" : "    ") + e;
}
function Za(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function zy(e, t, r, s) {
  const i = Za(r), a = i === '"' ? "Quote" : "Apostrophe", o = r.enter("definition");
  let n = r.enter("label");
  const c = r.createTracker(s);
  let u = c.move("[");
  return u += c.move(
    r.safe(r.associationId(e), {
      before: u,
      after: "]",
      ...c.current()
    })
  ), u += c.move("]: "), n(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (n = r.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    r.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (n = r.enter("destinationRaw"), u += c.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), n(), e.title && (n = r.enter(`title${a}`), u += c.move(" " + i), u += c.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), n()), o(), u;
}
function Ly(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function hs(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Ms(e) {
  if (e === null || de(e) || Ot(e))
    return 1;
  if (Bs(e))
    return 2;
}
function Ds(e, t, r) {
  const s = Ms(e), i = Ms(t);
  return s === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    r === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : s === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
bf.peek = jy;
function bf(e, t, r, s) {
  const i = Ly(r), a = r.enter("emphasis"), o = r.createTracker(s), n = o.move(i);
  let c = o.move(
    r.containerPhrasing(e, {
      after: i,
      before: n,
      ...o.current()
    })
  );
  const u = c.charCodeAt(0), l = Ds(
    s.before.charCodeAt(s.before.length - 1),
    u,
    i
  );
  l.inside && (c = hs(u) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), d = Ds(s.after.charCodeAt(0), p, i);
  d.inside && (c = c.slice(0, -1) + hs(p));
  const h = o.move(i);
  return a(), r.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: l.outside
  }, n + c + h;
}
function jy(e, t, r) {
  return r.options.emphasis || "*";
}
function qy(e, t, r, s) {
  let i, a, o;
  typeof t == "function" && typeof r != "function" ? (a = void 0, o = t, i = r) : (a = t, o = r, i = s), yf(e, a, n, i);
  function n(c, u) {
    const l = u[u.length - 1], p = l ? l.children.indexOf(c) : void 0;
    return o(c, p, l);
  }
}
const Fy = {};
function wf(e, t) {
  const r = Fy, s = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, i = typeof r.includeHtml == "boolean" ? r.includeHtml : !0;
  return Ef(e, s, i);
}
function Ef(e, t, r) {
  if (By(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Pc(e.children, t, r);
  }
  return Array.isArray(e) ? Pc(e, t, r) : "";
}
function Pc(e, t, r) {
  const s = [];
  let i = -1;
  for (; ++i < e.length; )
    s[i] = Ef(e[i], t, r);
  return s.join("");
}
function By(e) {
  return !!(e && typeof e == "object");
}
function Uy(e, t) {
  let r = !1;
  return qy(e, function(s) {
    if ("value" in s && /\r?\n|\r/.test(s.value) || s.type === "break")
      return r = !0, Da;
  }), !!((!e.depth || e.depth < 3) && wf(e) && (t.options.setext || r));
}
function $y(e, t, r, s) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = r.createTracker(s);
  if (Uy(e, r)) {
    const l = r.enter("headingSetext"), p = r.enter("phrasing"), d = r.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return p(), l(), d + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      d.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1)
    );
  }
  const o = "#".repeat(i), n = r.enter("headingAtx"), c = r.enter("phrasing");
  a.move(o + " ");
  let u = r.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(u) && (u = hs(u.charCodeAt(0)) + u.slice(1)), u = u ? o + " " + u : o, r.options.closeAtx && (u += " " + o), c(), n(), u;
}
If.peek = Vy;
function If(e) {
  return e.value || "";
}
function Vy() {
  return "<";
}
Af.peek = Wy;
function Af(e, t, r, s) {
  const i = Za(r), a = i === '"' ? "Quote" : "Apostrophe", o = r.enter("image");
  let n = r.enter("label");
  const c = r.createTracker(s);
  let u = c.move("![");
  return u += c.move(
    r.safe(e.alt, { before: u, after: "]", ...c.current() })
  ), u += c.move("]("), n(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (n = r.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    r.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (n = r.enter("destinationRaw"), u += c.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), n(), e.title && (n = r.enter(`title${a}`), u += c.move(" " + i), u += c.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), n()), u += c.move(")"), o(), u;
}
function Wy() {
  return "!";
}
Tf.peek = Hy;
function Tf(e, t, r, s) {
  const i = e.referenceType, a = r.enter("imageReference");
  let o = r.enter("label");
  const n = r.createTracker(s);
  let c = n.move("![");
  const u = r.safe(e.alt, {
    before: c,
    after: "]",
    ...n.current()
  });
  c += n.move(u + "]["), o();
  const l = r.stack;
  r.stack = [], o = r.enter("reference");
  const p = r.safe(r.associationId(e), {
    before: c,
    after: "]",
    ...n.current()
  });
  return o(), r.stack = l, a(), i === "full" || !u || u !== p ? c += n.move(p + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += n.move("]"), c;
}
function Hy() {
  return "!";
}
_f.peek = Ky;
function _f(e, t, r) {
  let s = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(s); )
    i += "`";
  for (/[^ \r\n]/.test(s) && (/^[ \r\n]/.test(s) && /[ \r\n]$/.test(s) || /^`|`$/.test(s)) && (s = " " + s + " "); ++a < r.unsafe.length; ) {
    const o = r.unsafe[a], n = r.compilePattern(o);
    let c;
    if (o.atBreak)
      for (; c = n.exec(s); ) {
        let u = c.index;
        s.charCodeAt(u) === 10 && s.charCodeAt(u - 1) === 13 && u--, s = s.slice(0, u) + " " + s.slice(c.index + 1);
      }
  }
  return i + s + i;
}
function Ky() {
  return "`";
}
function kf(e, t) {
  const r = wf(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (r === e.url || "mailto:" + r === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
Of.peek = Jy;
function Of(e, t, r, s) {
  const i = Za(r), a = i === '"' ? "Quote" : "Apostrophe", o = r.createTracker(s);
  let n, c;
  if (kf(e, r)) {
    const l = r.stack;
    r.stack = [], n = r.enter("autolink");
    let p = o.move("<");
    return p += o.move(
      r.containerPhrasing(e, {
        before: p,
        after: ">",
        ...o.current()
      })
    ), p += o.move(">"), n(), r.stack = l, p;
  }
  n = r.enter("link"), c = r.enter("label");
  let u = o.move("[");
  return u += o.move(
    r.containerPhrasing(e, {
      before: u,
      after: "](",
      ...o.current()
    })
  ), u += o.move("]("), c(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = r.enter("destinationLiteral"), u += o.move("<"), u += o.move(
    r.safe(e.url, { before: u, after: ">", ...o.current() })
  ), u += o.move(">")) : (c = r.enter("destinationRaw"), u += o.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...o.current()
    })
  )), c(), e.title && (c = r.enter(`title${a}`), u += o.move(" " + i), u += o.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...o.current()
    })
  ), u += o.move(i), c()), u += o.move(")"), n(), u;
}
function Jy(e, t, r) {
  return kf(e, r) ? "<" : "[";
}
Mf.peek = Gy;
function Mf(e, t, r, s) {
  const i = e.referenceType, a = r.enter("linkReference");
  let o = r.enter("label");
  const n = r.createTracker(s);
  let c = n.move("[");
  const u = r.containerPhrasing(e, {
    before: c,
    after: "]",
    ...n.current()
  });
  c += n.move(u + "]["), o();
  const l = r.stack;
  r.stack = [], o = r.enter("reference");
  const p = r.safe(r.associationId(e), {
    before: c,
    after: "]",
    ...n.current()
  });
  return o(), r.stack = l, a(), i === "full" || !u || u !== p ? c += n.move(p + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += n.move("]"), c;
}
function Gy() {
  return "[";
}
function Xa(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function Qy(e) {
  const t = Xa(e), r = e.options.bulletOther;
  if (!r)
    return t === "*" ? "-" : "*";
  if (r !== "*" && r !== "+" && r !== "-")
    throw new Error(
      "Cannot serialize items with `" + r + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (r === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + r + "`) to be different"
    );
  return r;
}
function Yy(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function Df(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function Zy(e, t, r, s) {
  const i = r.enter("list"), a = r.bulletCurrent;
  let o = e.ordered ? Yy(r) : Xa(r);
  const n = e.ordered ? o === "." ? ")" : "." : Qy(r);
  let c = t && r.bulletLastUsed ? o === r.bulletLastUsed : !1;
  if (!e.ordered) {
    const l = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (o === "*" || o === "-") && // Empty first list item:
      l && (!l.children || !l.children[0]) && // Directly in two other list items:
      r.stack[r.stack.length - 1] === "list" && r.stack[r.stack.length - 2] === "listItem" && r.stack[r.stack.length - 3] === "list" && r.stack[r.stack.length - 4] === "listItem" && // That are each the first child.
      r.indexStack[r.indexStack.length - 1] === 0 && r.indexStack[r.indexStack.length - 2] === 0 && r.indexStack[r.indexStack.length - 3] === 0 && (c = !0), Df(r) === o && l
    ) {
      let p = -1;
      for (; ++p < e.children.length; ) {
        const d = e.children[p];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (o = n), r.bulletCurrent = o;
  const u = r.containerFlow(e, s);
  return r.bulletLastUsed = o, r.bulletCurrent = a, i(), u;
}
function Xy(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function eS(e, t, r, s) {
  const i = Xy(r);
  let a = r.bulletCurrent || Xa(r);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (r.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let o = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (o = Math.ceil(o / 4) * 4);
  const n = r.createTracker(s);
  n.move(a + " ".repeat(o - a.length)), n.shift(o);
  const c = r.enter("listItem"), u = r.indentLines(
    r.containerFlow(e, n.current()),
    l
  );
  return c(), u;
  function l(p, d, h) {
    return d ? (h ? "" : " ".repeat(o)) + p : (h ? a : a + " ".repeat(o - a.length)) + p;
  }
}
function tS(e, t, r, s) {
  const i = r.enter("paragraph"), a = r.enter("phrasing"), o = r.containerPhrasing(e, s);
  return a(), i(), o;
}
const rS = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  $s([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function nS(e, t, r, s) {
  return (e.children.some(function(o) {
    return rS(o);
  }) ? r.containerPhrasing : r.containerFlow).call(r, e, s);
}
function iS(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Nf.peek = sS;
function Nf(e, t, r, s) {
  const i = iS(r), a = r.enter("strong"), o = r.createTracker(s), n = o.move(i + i);
  let c = o.move(
    r.containerPhrasing(e, {
      after: i,
      before: n,
      ...o.current()
    })
  );
  const u = c.charCodeAt(0), l = Ds(
    s.before.charCodeAt(s.before.length - 1),
    u,
    i
  );
  l.inside && (c = hs(u) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), d = Ds(s.after.charCodeAt(0), p, i);
  d.inside && (c = c.slice(0, -1) + hs(p));
  const h = o.move(i + i);
  return a(), r.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: l.outside
  }, n + c + h;
}
function sS(e, t, r) {
  return r.options.strong || "*";
}
function oS(e, t, r, s) {
  return r.safe(e.value, s);
}
function aS(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function cS(e, t, r) {
  const s = (Df(r) + (r.options.ruleSpaces ? " " : "")).repeat(aS(r));
  return r.options.ruleSpaces ? s.slice(0, -1) : s;
}
const xf = {
  blockquote: Ty,
  break: Rc,
  code: Ny,
  definition: zy,
  emphasis: bf,
  hardBreak: Rc,
  heading: $y,
  html: If,
  image: Af,
  imageReference: Tf,
  inlineCode: _f,
  link: Of,
  linkReference: Mf,
  list: Zy,
  listItem: eS,
  paragraph: tS,
  root: nS,
  strong: Nf,
  text: oS,
  thematicBreak: cS
};
function uS() {
  return {
    enter: {
      table: lS,
      tableData: bc,
      tableHeader: bc,
      tableRow: dS
    },
    exit: {
      codeText: hS,
      table: pS,
      tableData: uo,
      tableHeader: uo,
      tableRow: uo
    }
  };
}
function lS(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(r) {
        return r === "none" ? null : r;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function pS(e) {
  this.exit(e), this.data.inTable = void 0;
}
function dS(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function uo(e) {
  this.exit(e);
}
function bc(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function hS(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, fS));
  const r = this.stack[this.stack.length - 1];
  r.type, r.value = t, this.exit(e);
}
function fS(e, t) {
  return t === "|" ? t : e;
}
function vS(e) {
  const t = e || {}, r = t.tableCellPadding, s = t.tablePipeAlign, i = t.stringLength, a = r ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: d,
      table: o,
      tableCell: c,
      tableRow: n
    }
  };
  function o(h, f, g, m) {
    return u(l(h, g, m), h.align);
  }
  function n(h, f, g, m) {
    const v = p(h, g, m), y = u([v]);
    return y.slice(0, y.indexOf(`
`));
  }
  function c(h, f, g, m) {
    const v = g.enter("tableCell"), y = g.enter("phrasing"), S = g.containerPhrasing(h, {
      ...m,
      before: a,
      after: a
    });
    return y(), v(), S;
  }
  function u(h, f) {
    return Iy(h, {
      align: f,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: s,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function l(h, f, g) {
    const m = h.children;
    let v = -1;
    const y = [], S = f.enter("table");
    for (; ++v < m.length; )
      y[v] = p(m[v], f, g);
    return S(), y;
  }
  function p(h, f, g) {
    const m = h.children;
    let v = -1;
    const y = [], S = f.enter("tableRow");
    for (; ++v < m.length; )
      y[v] = c(m[v], h, f, g);
    return S(), y;
  }
  function d(h, f, g) {
    let m = xf.inlineCode(h, f, g);
    return g.stack.includes("tableCell") && (m = m.replace(/\|/g, "\\$&")), m;
  }
}
function gS() {
  return {
    exit: {
      taskListCheckValueChecked: wc,
      taskListCheckValueUnchecked: wc,
      paragraph: yS
    }
  };
}
function mS() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: SS }
  };
}
function wc(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function yS(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const r = this.stack[this.stack.length - 1];
    r.type;
    const s = r.children[0];
    if (s && s.type === "text") {
      const i = t.children;
      let a = -1, o;
      for (; ++a < i.length; ) {
        const n = i[a];
        if (n.type === "paragraph") {
          o = n;
          break;
        }
      }
      o === r && (s.value = s.value.slice(1), s.value.length === 0 ? r.children.shift() : r.position && s.position && typeof s.position.start.offset == "number" && (s.position.start.column++, s.position.start.offset++, r.position.start = Object.assign({}, s.position.start)));
    }
  }
  this.exit(e);
}
function SS(e, t, r, s) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", o = "[" + (e.checked ? "x" : " ") + "] ", n = r.createTracker(s);
  a && n.move(o);
  let c = xf.listItem(e, t, r, {
    ...s,
    ...n.current()
  });
  return a && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
  function u(l) {
    return l + o;
  }
}
function CS() {
  return [
    Gm(),
    gy(),
    Cy(),
    uS(),
    gS()
  ];
}
function RS(e) {
  return {
    extensions: [
      Qm(),
      my(e),
      Ry(),
      vS(e),
      mS()
    ]
  };
}
function _s(e, t, r, s) {
  const i = e.length;
  let a = 0, o;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, r = r > 0 ? r : 0, s.length < 1e4)
    o = Array.from(s), o.unshift(t, r), e.splice(...o);
  else
    for (r && e.splice(t, r); a < s.length; )
      o = s.slice(a, a + 1e4), o.unshift(t, 0), e.splice(...o), a += 1e4, t += 1e4;
}
const Ec = {}.hasOwnProperty;
function PS(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    bS(t, e[r]);
  return t;
}
function bS(e, t) {
  let r;
  for (r in t) {
    const i = (Ec.call(e, r) ? e[r] : void 0) || (e[r] = {}), a = t[r];
    let o;
    if (a)
      for (o in a) {
        Ec.call(i, o) || (i[o] = []);
        const n = a[o];
        wS(
          // @ts-expect-error Looks like a list.
          i[o],
          Array.isArray(n) ? n : n ? [n] : []
        );
      }
  }
}
function wS(e, t) {
  let r = -1;
  const s = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : s).push(t[r]);
  _s(e, 0, 0, s);
}
const ES = {
  tokenize: OS,
  partial: !0
}, zf = {
  tokenize: MS,
  partial: !0
}, Lf = {
  tokenize: DS,
  partial: !0
}, jf = {
  tokenize: NS,
  partial: !0
}, IS = {
  tokenize: xS,
  partial: !0
}, qf = {
  name: "wwwAutolink",
  tokenize: _S,
  previous: Bf
}, Ff = {
  name: "protocolAutolink",
  tokenize: kS,
  previous: Uf
}, Ue = {
  name: "emailAutolink",
  tokenize: TS,
  previous: $f
}, ke = {};
function AS() {
  return {
    text: ke
  };
}
let it = 48;
for (; it < 123; )
  ke[it] = Ue, it++, it === 58 ? it = 65 : it === 91 && (it = 97);
ke[43] = Ue;
ke[45] = Ue;
ke[46] = Ue;
ke[95] = Ue;
ke[72] = [Ue, Ff];
ke[104] = [Ue, Ff];
ke[87] = [Ue, qf];
ke[119] = [Ue, qf];
function TS(e, t, r) {
  const s = this;
  let i, a;
  return o;
  function o(p) {
    return !Na(p) || !$f.call(s, s.previous) || ec(s.events) ? r(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), n(p));
  }
  function n(p) {
    return Na(p) ? (e.consume(p), n) : p === 64 ? (e.consume(p), c) : r(p);
  }
  function c(p) {
    return p === 46 ? e.check(IS, l, u)(p) : p === 45 || p === 95 || Ya(p) ? (a = !0, e.consume(p), c) : l(p);
  }
  function u(p) {
    return e.consume(p), i = !0, c;
  }
  function l(p) {
    return a && i && ds(s.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : r(p);
  }
}
function _S(e, t, r) {
  const s = this;
  return i;
  function i(o) {
    return o !== 87 && o !== 119 || !Bf.call(s, s.previous) || ec(s.events) ? r(o) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(ES, e.attempt(zf, e.attempt(Lf, a), r), r)(o));
  }
  function a(o) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(o);
  }
}
function kS(e, t, r) {
  const s = this;
  let i = "", a = !1;
  return o;
  function o(p) {
    return (p === 72 || p === 104) && Uf.call(s, s.previous) && !ec(s.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(p), e.consume(p), n) : r(p);
  }
  function n(p) {
    if (ds(p) && i.length < 5)
      return i += String.fromCodePoint(p), e.consume(p), n;
    if (p === 58) {
      const d = i.toLowerCase();
      if (d === "http" || d === "https")
        return e.consume(p), c;
    }
    return r(p);
  }
  function c(p) {
    return p === 47 ? (e.consume(p), a ? u : (a = !0, c)) : r(p);
  }
  function u(p) {
    return p === null || xm(p) || de(p) || Ot(p) || Bs(p) ? r(p) : e.attempt(zf, e.attempt(Lf, l), r)(p);
  }
  function l(p) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
  }
}
function OS(e, t, r) {
  let s = 0;
  return i;
  function i(o) {
    return (o === 87 || o === 119) && s < 3 ? (s++, e.consume(o), i) : o === 46 && s === 3 ? (e.consume(o), a) : r(o);
  }
  function a(o) {
    return o === null ? r(o) : t(o);
  }
}
function MS(e, t, r) {
  let s, i, a;
  return o;
  function o(u) {
    return u === 46 || u === 95 ? e.check(jf, c, n)(u) : u === null || de(u) || Ot(u) || u !== 45 && Bs(u) ? c(u) : (a = !0, e.consume(u), o);
  }
  function n(u) {
    return u === 95 ? s = !0 : (i = s, s = void 0), e.consume(u), o;
  }
  function c(u) {
    return i || s || !a ? r(u) : t(u);
  }
}
function DS(e, t) {
  let r = 0, s = 0;
  return i;
  function i(o) {
    return o === 40 ? (r++, e.consume(o), i) : o === 41 && s < r ? a(o) : o === 33 || o === 34 || o === 38 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 60 || o === 63 || o === 93 || o === 95 || o === 126 ? e.check(jf, t, a)(o) : o === null || de(o) || Ot(o) ? t(o) : (e.consume(o), i);
  }
  function a(o) {
    return o === 41 && s++, e.consume(o), i;
  }
}
function NS(e, t, r) {
  return s;
  function s(n) {
    return n === 33 || n === 34 || n === 39 || n === 41 || n === 42 || n === 44 || n === 46 || n === 58 || n === 59 || n === 63 || n === 95 || n === 126 ? (e.consume(n), s) : n === 38 ? (e.consume(n), a) : n === 93 ? (e.consume(n), i) : (
      // `<` is an end.
      n === 60 || // So is whitespace.
      n === null || de(n) || Ot(n) ? t(n) : r(n)
    );
  }
  function i(n) {
    return n === null || n === 40 || n === 91 || de(n) || Ot(n) ? t(n) : s(n);
  }
  function a(n) {
    return ds(n) ? o(n) : r(n);
  }
  function o(n) {
    return n === 59 ? (e.consume(n), s) : ds(n) ? (e.consume(n), o) : r(n);
  }
}
function xS(e, t, r) {
  return s;
  function s(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return Ya(a) ? r(a) : t(a);
  }
}
function Bf(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || de(e);
}
function Uf(e) {
  return !ds(e);
}
function $f(e) {
  return !(e === 47 || Na(e));
}
function Na(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || Ya(e);
}
function ec(e) {
  let t = e.length, r = !1;
  for (; t--; ) {
    const s = e[t][1];
    if ((s.type === "labelLink" || s.type === "labelImage") && !s._balanced) {
      r = !0;
      break;
    }
    if (s._gfmAutolinkLiteralWalkedInto) {
      r = !1;
      break;
    }
  }
  return e.length > 0 && !r && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), r;
}
function zS(e, t, r) {
  const s = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !s.includes(a) && (t = a(t, r), s.push(a));
  }
  return t;
}
function Fe(e, t, r, s) {
  const i = s ? s - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return o;
  function o(c) {
    return qe(c) ? (e.enter(r), n(c)) : t(c);
  }
  function n(c) {
    return qe(c) && a++ < i ? (e.consume(c), n) : (e.exit(r), t(c));
  }
}
const LS = {
  partial: !0,
  tokenize: jS
};
function jS(e, t, r) {
  return s;
  function s(a) {
    return qe(a) ? Fe(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || Ut(a) ? t(a) : r(a);
  }
}
const qS = {
  tokenize: KS,
  partial: !0
};
function FS() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: VS,
        continuation: {
          tokenize: WS
        },
        exit: HS
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: $S
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: BS,
        resolveTo: US
      }
    }
  };
}
function BS(e, t, r) {
  const s = this;
  let i = s.events.length;
  const a = s.parser.gfmFootnotes || (s.parser.gfmFootnotes = []);
  let o;
  for (; i--; ) {
    const c = s.events[i][1];
    if (c.type === "labelImage") {
      o = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return n;
  function n(c) {
    if (!o || !o._balanced)
      return r(c);
    const u = ys(s.sliceSerialize({
      start: o.end,
      end: s.now()
    }));
    return u.codePointAt(0) !== 94 || !a.includes(u.slice(1)) ? r(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function US(e, t) {
  let r = e.length;
  for (; r--; )
    if (e[r][1].type === "labelImage" && e[r][0] === "enter") {
      e[r][1];
      break;
    }
  e[r + 1][1].type = "data", e[r + 3][1].type = "gfmFootnoteCallLabelMarker";
  const s = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[r + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[r + 3][1].end),
    end: Object.assign({}, e[r + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, o = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, n = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[r + 1],
    e[r + 2],
    ["enter", s, t],
    // The `[`
    e[r + 3],
    e[r + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", o, t],
    ["exit", o, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", s, t]
  ];
  return e.splice(r, e.length - r + 1, ...n), e;
}
function $S(e, t, r) {
  const s = this, i = s.parser.gfmFootnotes || (s.parser.gfmFootnotes = []);
  let a = 0, o;
  return n;
  function n(p) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(p) {
    return p !== 94 ? r(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(p) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      p === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || de(p)
    )
      return r(p);
    if (p === 93) {
      e.exit("chunkString");
      const d = e.exit("gfmFootnoteCallString");
      return i.includes(ys(s.sliceSerialize(d))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : r(p);
    }
    return de(p) || (o = !0), a++, e.consume(p), p === 92 ? l : u;
  }
  function l(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, u) : u(p);
  }
}
function VS(e, t, r) {
  const s = this, i = s.parser.gfmFootnotes || (s.parser.gfmFootnotes = []);
  let a, o = 0, n;
  return c;
  function c(f) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(f) {
    return f === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", l) : r(f);
  }
  function l(f) {
    if (
      // Too long.
      o > 999 || // Closing brace with nothing.
      f === 93 && !n || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || de(f)
    )
      return r(f);
    if (f === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteDefinitionLabelString");
      return a = ys(s.sliceSerialize(g)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), d;
    }
    return de(f) || (n = !0), o++, e.consume(f), f === 92 ? p : l;
  }
  function p(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), o++, l) : l(f);
  }
  function d(f) {
    return f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), i.includes(a) || i.push(a), Fe(e, h, "gfmFootnoteDefinitionWhitespace")) : r(f);
  }
  function h(f) {
    return t(f);
  }
}
function WS(e, t, r) {
  return e.check(LS, t, e.attempt(qS, t, r));
}
function HS(e) {
  e.exit("gfmFootnoteDefinition");
}
function KS(e, t, r) {
  const s = this;
  return Fe(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const o = s.events[s.events.length - 1];
    return o && o[1].type === "gfmFootnoteDefinitionIndent" && o[2].sliceSerialize(o[1], !0).length === 4 ? t(a) : r(a);
  }
}
function JS(e) {
  let r = (e || {}).singleTilde;
  const s = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return r == null && (r = !0), {
    text: {
      126: s
    },
    insideSpan: {
      null: [s]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(o, n) {
    let c = -1;
    for (; ++c < o.length; )
      if (o[c][0] === "enter" && o[c][1].type === "strikethroughSequenceTemporary" && o[c][1]._close) {
        let u = c;
        for (; u--; )
          if (o[u][0] === "exit" && o[u][1].type === "strikethroughSequenceTemporary" && o[u][1]._open && // If the sizes are the same:
          o[c][1].end.offset - o[c][1].start.offset === o[u][1].end.offset - o[u][1].start.offset) {
            o[c][1].type = "strikethroughSequence", o[u][1].type = "strikethroughSequence";
            const l = {
              type: "strikethrough",
              start: Object.assign({}, o[u][1].start),
              end: Object.assign({}, o[c][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, o[u][1].end),
              end: Object.assign({}, o[c][1].start)
            }, d = [["enter", l, n], ["enter", o[u][1], n], ["exit", o[u][1], n], ["enter", p, n]], h = n.parser.constructs.insideSpan.null;
            h && _s(d, d.length, 0, zS(h, o.slice(u + 1, c), n)), _s(d, d.length, 0, [["exit", p, n], ["enter", o[c][1], n], ["exit", o[c][1], n], ["exit", l, n]]), _s(o, u - 1, c - u + 3, d), c = u + d.length - 2;
            break;
          }
      }
    for (c = -1; ++c < o.length; )
      o[c][1].type === "strikethroughSequenceTemporary" && (o[c][1].type = "data");
    return o;
  }
  function a(o, n, c) {
    const u = this.previous, l = this.events;
    let p = 0;
    return d;
    function d(f) {
      return u === 126 && l[l.length - 1][1].type !== "characterEscape" ? c(f) : (o.enter("strikethroughSequenceTemporary"), h(f));
    }
    function h(f) {
      const g = Ms(u);
      if (f === 126)
        return p > 1 ? c(f) : (o.consume(f), p++, h);
      if (p < 2 && !r) return c(f);
      const m = o.exit("strikethroughSequenceTemporary"), v = Ms(f);
      return m._open = !v || v === 2 && !!g, m._close = !g || g === 2 && !!v, n(f);
    }
  }
}
class GS {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, r, s) {
    QS(this, t, r, s);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, o) {
      return a[0] - o[0];
    }), this.map.length === 0)
      return;
    let r = this.map.length;
    const s = [];
    for (; r > 0; )
      r -= 1, s.push(t.slice(this.map[r][0] + this.map[r][1]), this.map[r][2]), t.length = this.map[r][0];
    s.push(t.slice()), t.length = 0;
    let i = s.pop();
    for (; i; ) {
      for (const a of i)
        t.push(a);
      i = s.pop();
    }
    this.map.length = 0;
  }
}
function QS(e, t, r, s) {
  let i = 0;
  if (!(r === 0 && s.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += r, e.map[i][2].push(...s);
        return;
      }
      i += 1;
    }
    e.map.push([t, r, s]);
  }
}
function YS(e, t) {
  let r = !1;
  const s = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (r) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && s.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = s.length - 1;
          s[a] = s[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (r = !0);
    t += 1;
  }
  return s;
}
function ZS() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: XS,
        resolveAll: eC
      }
    }
  };
}
function XS(e, t, r) {
  const s = this;
  let i = 0, a = 0, o;
  return n;
  function n(b) {
    let _ = s.events.length - 1;
    for (; _ > -1; ) {
      const V = s.events[_][1].type;
      if (V === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      V === "linePrefix") _--;
      else break;
    }
    const k = _ > -1 ? s.events[_][1].type : null, B = k === "tableHead" || k === "tableRow" ? w : c;
    return B === w && s.parser.lazy[s.now().line] ? r(b) : B(b);
  }
  function c(b) {
    return e.enter("tableHead"), e.enter("tableRow"), u(b);
  }
  function u(b) {
    return b === 124 || (o = !0, a += 1), l(b);
  }
  function l(b) {
    return b === null ? r(b) : Ut(b) ? a > 1 ? (a = 0, s.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), h) : r(b) : qe(b) ? Fe(e, l, "whitespace")(b) : (a += 1, o && (o = !1, i += 1), b === 124 ? (e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), o = !0, l) : (e.enter("data"), p(b)));
  }
  function p(b) {
    return b === null || b === 124 || de(b) ? (e.exit("data"), l(b)) : (e.consume(b), b === 92 ? d : p);
  }
  function d(b) {
    return b === 92 || b === 124 ? (e.consume(b), p) : p(b);
  }
  function h(b) {
    return s.interrupt = !1, s.parser.lazy[s.now().line] ? r(b) : (e.enter("tableDelimiterRow"), o = !1, qe(b) ? Fe(e, f, "linePrefix", s.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(b) : f(b));
  }
  function f(b) {
    return b === 45 || b === 58 ? m(b) : b === 124 ? (o = !0, e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), g) : R(b);
  }
  function g(b) {
    return qe(b) ? Fe(e, m, "whitespace")(b) : m(b);
  }
  function m(b) {
    return b === 58 ? (a += 1, o = !0, e.enter("tableDelimiterMarker"), e.consume(b), e.exit("tableDelimiterMarker"), v) : b === 45 ? (a += 1, v(b)) : b === null || Ut(b) ? C(b) : R(b);
  }
  function v(b) {
    return b === 45 ? (e.enter("tableDelimiterFiller"), y(b)) : R(b);
  }
  function y(b) {
    return b === 45 ? (e.consume(b), y) : b === 58 ? (o = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(b), e.exit("tableDelimiterMarker"), S) : (e.exit("tableDelimiterFiller"), S(b));
  }
  function S(b) {
    return qe(b) ? Fe(e, C, "whitespace")(b) : C(b);
  }
  function C(b) {
    return b === 124 ? f(b) : b === null || Ut(b) ? !o || i !== a ? R(b) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(b)) : R(b);
  }
  function R(b) {
    return r(b);
  }
  function w(b) {
    return e.enter("tableRow"), I(b);
  }
  function I(b) {
    return b === 124 ? (e.enter("tableCellDivider"), e.consume(b), e.exit("tableCellDivider"), I) : b === null || Ut(b) ? (e.exit("tableRow"), t(b)) : qe(b) ? Fe(e, I, "whitespace")(b) : (e.enter("data"), E(b));
  }
  function E(b) {
    return b === null || b === 124 || de(b) ? (e.exit("data"), I(b)) : (e.consume(b), b === 92 ? T : E);
  }
  function T(b) {
    return b === 92 || b === 124 ? (e.consume(b), E) : E(b);
  }
}
function eC(e, t) {
  let r = -1, s = !0, i = 0, a = [0, 0, 0, 0], o = [0, 0, 0, 0], n = !1, c = 0, u, l, p;
  const d = new GS();
  for (; ++r < e.length; ) {
    const h = e[r], f = h[1];
    h[0] === "enter" ? f.type === "tableHead" ? (n = !1, c !== 0 && (Ic(d, t, c, u, l), l = void 0, c = 0), u = {
      type: "table",
      start: Object.assign({}, f.start),
      // Note: correct end is set later.
      end: Object.assign({}, f.end)
    }, d.add(r, 0, [["enter", u, t]])) : f.type === "tableRow" || f.type === "tableDelimiterRow" ? (s = !0, p = void 0, a = [0, 0, 0, 0], o = [0, r + 1, 0, 0], n && (n = !1, l = {
      type: "tableBody",
      start: Object.assign({}, f.start),
      // Note: correct end is set later.
      end: Object.assign({}, f.end)
    }, d.add(r, 0, [["enter", l, t]])), i = f.type === "tableDelimiterRow" ? 2 : l ? 3 : 1) : i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") ? (s = !1, o[2] === 0 && (a[1] !== 0 && (o[0] = o[1], p = Es(d, t, a, i, void 0, p), a = [0, 0, 0, 0]), o[2] = r)) : f.type === "tableCellDivider" && (s ? s = !1 : (a[1] !== 0 && (o[0] = o[1], p = Es(d, t, a, i, void 0, p)), a = o, o = [a[1], r, 0, 0])) : f.type === "tableHead" ? (n = !0, c = r) : f.type === "tableRow" || f.type === "tableDelimiterRow" ? (c = r, a[1] !== 0 ? (o[0] = o[1], p = Es(d, t, a, i, r, p)) : o[1] !== 0 && (p = Es(d, t, o, i, r, p)), i = 0) : i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") && (o[3] = r);
  }
  for (c !== 0 && Ic(d, t, c, u, l), d.consume(t.events), r = -1; ++r < t.events.length; ) {
    const h = t.events[r];
    h[0] === "enter" && h[1].type === "table" && (h[1]._align = YS(t.events, r));
  }
  return e;
}
function Es(e, t, r, s, i, a) {
  const o = s === 1 ? "tableHeader" : s === 2 ? "tableDelimiter" : "tableData", n = "tableContent";
  r[0] !== 0 && (a.end = Object.assign({}, Bt(t.events, r[0])), e.add(r[0], 0, [["exit", a, t]]));
  const c = Bt(t.events, r[1]);
  if (a = {
    type: o,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(r[1], 0, [["enter", a, t]]), r[2] !== 0) {
    const u = Bt(t.events, r[2]), l = Bt(t.events, r[3]), p = {
      type: n,
      start: Object.assign({}, u),
      end: Object.assign({}, l)
    };
    if (e.add(r[2], 0, [["enter", p, t]]), s !== 2) {
      const d = t.events[r[2]], h = t.events[r[3]];
      if (d[1].end = Object.assign({}, h[1].end), d[1].type = "chunkText", d[1].contentType = "text", r[3] > r[2] + 1) {
        const f = r[2] + 1, g = r[3] - r[2] - 1;
        e.add(f, g, []);
      }
    }
    e.add(r[3] + 1, 0, [["exit", p, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Bt(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function Ic(e, t, r, s, i) {
  const a = [], o = Bt(t.events, r);
  i && (i.end = Object.assign({}, o), a.push(["exit", i, t])), s.end = Object.assign({}, o), a.push(["exit", s, t]), e.add(r + 1, 0, a);
}
function Bt(e, t) {
  const r = e[t], s = r[0] === "enter" ? "start" : "end";
  return r[1][s];
}
const tC = {
  name: "tasklistCheck",
  tokenize: nC
};
function rC() {
  return {
    text: {
      91: tC
    }
  };
}
function nC(e, t, r) {
  const s = this;
  return i;
  function i(c) {
    return (
      // Exit if there’s stuff before.
      s.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !s._gfmTasklistFirstContentOfListItem ? r(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(c) {
    return de(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), o) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), o) : r(c);
  }
  function o(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), n) : r(c);
  }
  function n(c) {
    return Ut(c) ? t(c) : qe(c) ? e.check({
      tokenize: iC
    }, t, r)(c) : r(c);
  }
}
function iC(e, t, r) {
  return Fe(e, s, "whitespace");
  function s(i) {
    return i === null ? r(i) : t(i);
  }
}
function sC(e) {
  return PS([
    AS(),
    FS(),
    JS(e),
    ZS(),
    rC()
  ]);
}
const oC = {};
function xa(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), r = e || oC, s = t.data(), i = s.micromarkExtensions || (s.micromarkExtensions = []), a = s.fromMarkdownExtensions || (s.fromMarkdownExtensions = []), o = s.toMarkdownExtensions || (s.toMarkdownExtensions = []);
  i.push(sC(r)), a.push(CS()), o.push(RS(r));
}
const Ws = async (e, t, r = "en", s, i, a) => {
  try {
    const o = await fetch(
      `${i}&from=${r}&to=${t}`,
      {
        method: "POST",
        headers: {
          "Ocp-Apim-Subscription-Key": s,
          "Ocp-Apim-Subscription-Region": a,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(e.map((c) => ({ Text: c })))
      }
    );
    if (!o.ok)
      throw new Error(`Translation failed: ${o.statusText}`);
    return (await o.json()).map((c) => c.translations?.[0]?.text || "");
  } catch (o) {
    return console.error("Batch translation error:", o), e;
  }
};
function aC({
  messages: e,
  onSendMessage: t,
  className: r = "",
  isLoading: s = !1,
  rightElement: i,
  suggestedPrompts: a,
  renderMessage: o,
  showRetryButton: n = !1,
  handleRetry: c,
  setInterruptReplica: u,
  language: l,
  config: p
}) {
  const [d, h] = L(""), f = Be(null), [g, m] = L(!0), v = Be(null), y = Be(null), [S, C] = L({ insufficientCredits: "Insufficient Credits", insufficientCreditsDescription: "Please purchase more credits to continue.", placeholder: "Type your message...", suggestedPrompts: "Suggested Prompts", thinking: "Thinking...", retry: "Retry", welcomeMessage: "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload the report." });
  H(() => {
    if (f.current) {
      const T = f.current.closest("[data-radix-scroll-area-viewport]") || v.current;
      T && (T.scrollTop = T.scrollHeight);
    }
  }, [e, s]), H(() => {
    (async () => {
      if (l !== "en" && y.current !== l) {
        const [b, _, k, B, V, Q, K] = await Ws(["Insufficient Credits", "Please purchase more credits to continue.", "Type your message...", "Suggested Prompts", "Thinking...", "Retry", "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload your report."], l, "en", p?.azureTranslatorKey || "", p?.azureTranslatorEndpoint || "", p?.azureTranslatorRegion || "");
        C({ insufficientCredits: b, insufficientCreditsDescription: _, placeholder: k, suggestedPrompts: B, thinking: V, retry: Q, welcomeMessage: K }), y.current = l;
      }
      l === "en" && y.current !== "en" && (C({ insufficientCredits: "Insufficient Credits", insufficientCreditsDescription: "Please purchase more credits to continue.", placeholder: "Type your message...", suggestedPrompts: "Suggested Prompts", thinking: "Thinking...", retry: "Retry", welcomeMessage: "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload your report." }), y.current = "en");
    })();
  }, [l, p]);
  const R = () => {
    d.trim() === "" || s || (t(d), h(""));
  }, w = (T) => {
    T.key === "Enter" && !T.shiftKey && (T.preventDefault(), R());
  }, I = (T) => {
    h(T);
  }, E = () => {
    m(!g);
  };
  return /* @__PURE__ */ M(
    "div",
    {
      className: `flex flex-col h-full bg-white rounded-lg border border-primary/20 overflow-hidden ${r}`,
      children: [
        /* @__PURE__ */ P("div", { ref: v, className: "flex-1 overflow-y-auto p-3 bg-white/80", children: /* @__PURE__ */ M("div", { className: "space-y-3", children: [
          e?.length === 0 ? /* @__PURE__ */ M("div", { className: "flex items-start", children: [
            /* @__PURE__ */ P("div", { className: "w-8 h-8 rounded-full bg-primary flex items-center justify-center text-white flex-shrink-0", children: /* @__PURE__ */ P(dc, { size: 14 }) }),
            /* @__PURE__ */ P("div", { className: "ml-2 px-3 py-2 rounded-lg bg-secondary/10", children: /* @__PURE__ */ P("div", { className: "text-sm text-secondary", children: S.welcomeMessage }) })
          ] }) : e?.map((T, b) => {
            const k = b === e.length - 1 && T.sender === "ai", B = n && k && c && T.sender === "ai";
            return /* @__PURE__ */ P(
              "div",
              {
                className: ls(
                  "flex",
                  T.sender === "user" ? "justify-end" : "justify-start",
                  "mb-4"
                ),
                children: /* @__PURE__ */ M(
                  "div",
                  {
                    className: ls(
                      "max-w-[80%] rounded-lg p-3",
                      T.sender === "user" ? "bg-primary text-white" : "bg-light text-secondary"
                    ),
                    children: [
                      o ? o(T, b) : T.sender === "user" ? /* @__PURE__ */ P("div", { className: "text-sm", children: T.text }) : /* @__PURE__ */ P("div", { className: "text-sm", children: /* @__PURE__ */ P(Oa, { remarkPlugins: [xa], children: T.text }) }),
                      B && /* @__PURE__ */ P("div", { className: "mt-2 flex justify-end", children: /* @__PURE__ */ M(
                        Te,
                        {
                          variant: "ghost",
                          size: "sm",
                          onClick: c,
                          className: "h-6 px-2 text-xs hover:bg-secondary/20",
                          children: [
                            /* @__PURE__ */ P(Rg, { className: "h-3 w-3 mr-1" }),
                            S.retry
                          ]
                        }
                      ) })
                    ]
                  }
                )
              },
              T.id
            );
          }),
          s && /* @__PURE__ */ M("div", { className: "flex items-start", children: [
            /* @__PURE__ */ P("div", { className: "w-8 h-8 rounded-full bg-primary flex items-center justify-center text-white flex-shrink-0", children: /* @__PURE__ */ P(dc, { size: 14 }) }),
            /* @__PURE__ */ M("div", { className: "ml-2 px-3 py-2 rounded-lg bg-secondary/10 flex items-center", children: [
              /* @__PURE__ */ P(ka, { className: "h-4 w-4 animate-spin mr-2 text-primary" }),
              /* @__PURE__ */ P("span", { className: "text-sm text-secondary", children: S.thinking })
            ] })
          ] }),
          /* @__PURE__ */ P("div", { ref: f })
        ] }) }),
        /* @__PURE__ */ M("div", { className: "p-3 border-t border-light bg-white flex-shrink-0", children: [
          a && a?.length > 0 && /* @__PURE__ */ M("div", { className: "bg-white border-b border-light flex-shrink-0", children: [
            /* @__PURE__ */ M(
              "button",
              {
                onClick: E,
                className: "w-full p-2 flex items-center justify-center hover:bg-secondary/10 transition-colors",
                children: [
                  /* @__PURE__ */ P("span", { className: "text-sm font-medium text-secondary", children: S.suggestedPrompts }),
                  g ? /* @__PURE__ */ P(Pg, { className: "h-4 w-4 text-secondary" }) : /* @__PURE__ */ P(bg, { className: "h-4 w-4 text-secondary" })
                ]
              }
            ),
            !g && /* @__PURE__ */ P("div", { className: "p-3 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2", children: a.map(({ id: T, text: b, icon: _ }) => /* @__PURE__ */ M(
              Te,
              {
                variant: "outline",
                className: ls(
                  "w-full justify-start text-left text-sm h-auto min-h-[40px] py-2 px-3",
                  "whitespace-normal break-words"
                ),
                onClick: () => I(b),
                children: [
                  /* @__PURE__ */ P(_, { className: "h-4 w-4 mr-2 text-primary flex-shrink-0" }),
                  /* @__PURE__ */ P("span", { className: "text-left", children: b })
                ]
              },
              T
            )) })
          ] }),
          /* @__PURE__ */ M("div", { className: "flex items-end", children: [
            /* @__PURE__ */ P(
              "textarea",
              {
                value: d,
                onChange: (T) => {
                  h(T.target.value), u(!0), T.target.style.height = "auto", T.target.style.height = Math.min(T.target.scrollHeight, 120) + "px";
                },
                onKeyDown: w,
                placeholder: S.placeholder,
                className: "flex-1 rounded-l-lg rounded-r-none focus-visible:ring-0 focus-visible:ring-offset-0 border-r-0 resize-none min-h-[40px] max-h-[120px] p-3 text-sm border border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
                disabled: s || !1,
                rows: 1
              }
            ),
            /* @__PURE__ */ P(
              Te,
              {
                onClick: R,
                className: "rounded-l-none bg-primary hover:bg-secondary h-[40px]",
                disabled: d.trim() === "" || s,
                children: s ? /* @__PURE__ */ P(ka, { className: "h-5 w-5 animate-spin" }) : /* @__PURE__ */ P(wg, { size: 18 })
              }
            ),
            i && /* @__PURE__ */ P("div", { className: "ml-2", children: i })
          ] })
        ] })
      ]
    }
  );
}
function cC(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function s() {
      var i = !1;
      try {
        i = this instanceof s;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(s) {
    var i = Object.getOwnPropertyDescriptor(e, s);
    Object.defineProperty(r, s, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[s];
      }
    });
  }), r;
}
var st = {}, ot = {}, tr = {}, at = {}, Z = {}, lo = {}, ct = {}, po = {}, rr = {}, Is = {}, Ac;
function Vf() {
  if (Ac) return Is;
  Ac = 1, Object.defineProperty(Is, "__esModule", {
    value: !0
  }), Is.default = r;
  let e;
  const t = new Uint8Array(16);
  function r() {
    if (!e && (e = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !e))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return e(t);
  }
  return Is;
}
var jt = {}, nr = {}, ir = {}, Tc;
function uC() {
  if (Tc) return ir;
  Tc = 1, Object.defineProperty(ir, "__esModule", {
    value: !0
  }), ir.default = void 0;
  var e = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  return ir.default = e, ir;
}
var _c;
function Hs() {
  if (_c) return nr;
  _c = 1, Object.defineProperty(nr, "__esModule", {
    value: !0
  }), nr.default = void 0;
  var e = t(/* @__PURE__ */ uC());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    return typeof i == "string" && e.default.test(i);
  }
  var s = r;
  return nr.default = s, nr;
}
var kc;
function Ks() {
  if (kc) return jt;
  kc = 1, Object.defineProperty(jt, "__esModule", {
    value: !0
  }), jt.default = void 0, jt.unsafeStringify = s;
  var e = t(/* @__PURE__ */ Hs());
  function t(o) {
    return o && o.__esModule ? o : { default: o };
  }
  const r = [];
  for (let o = 0; o < 256; ++o)
    r.push((o + 256).toString(16).slice(1));
  function s(o, n = 0) {
    return r[o[n + 0]] + r[o[n + 1]] + r[o[n + 2]] + r[o[n + 3]] + "-" + r[o[n + 4]] + r[o[n + 5]] + "-" + r[o[n + 6]] + r[o[n + 7]] + "-" + r[o[n + 8]] + r[o[n + 9]] + "-" + r[o[n + 10]] + r[o[n + 11]] + r[o[n + 12]] + r[o[n + 13]] + r[o[n + 14]] + r[o[n + 15]];
  }
  function i(o, n = 0) {
    const c = s(o, n);
    if (!(0, e.default)(c))
      throw TypeError("Stringified UUID is invalid");
    return c;
  }
  var a = i;
  return jt.default = a, jt;
}
var Oc;
function lC() {
  if (Oc) return rr;
  Oc = 1, Object.defineProperty(rr, "__esModule", {
    value: !0
  }), rr.default = void 0;
  var e = r(/* @__PURE__ */ Vf()), t = /* @__PURE__ */ Ks();
  function r(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let s, i, a = 0, o = 0;
  function n(u, l, p) {
    let d = l && p || 0;
    const h = l || new Array(16);
    u = u || {};
    let f = u.node || s, g = u.clockseq !== void 0 ? u.clockseq : i;
    if (f == null || g == null) {
      const R = u.random || (u.rng || e.default)();
      f == null && (f = s = [R[0] | 1, R[1], R[2], R[3], R[4], R[5]]), g == null && (g = i = (R[6] << 8 | R[7]) & 16383);
    }
    let m = u.msecs !== void 0 ? u.msecs : Date.now(), v = u.nsecs !== void 0 ? u.nsecs : o + 1;
    const y = m - a + (v - o) / 1e4;
    if (y < 0 && u.clockseq === void 0 && (g = g + 1 & 16383), (y < 0 || m > a) && u.nsecs === void 0 && (v = 0), v >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    a = m, o = v, i = g, m += 122192928e5;
    const S = ((m & 268435455) * 1e4 + v) % 4294967296;
    h[d++] = S >>> 24 & 255, h[d++] = S >>> 16 & 255, h[d++] = S >>> 8 & 255, h[d++] = S & 255;
    const C = m / 4294967296 * 1e4 & 268435455;
    h[d++] = C >>> 8 & 255, h[d++] = C & 255, h[d++] = C >>> 24 & 15 | 16, h[d++] = C >>> 16 & 255, h[d++] = g >>> 8 | 128, h[d++] = g & 255;
    for (let R = 0; R < 6; ++R)
      h[d + R] = f[R];
    return l || (0, t.unsafeStringify)(h);
  }
  var c = n;
  return rr.default = c, rr;
}
var sr = {}, Qe = {}, or = {}, Mc;
function Wf() {
  if (Mc) return or;
  Mc = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.default = void 0;
  var e = t(/* @__PURE__ */ Hs());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    if (!(0, e.default)(i))
      throw TypeError("Invalid UUID");
    let a;
    const o = new Uint8Array(16);
    return o[0] = (a = parseInt(i.slice(0, 8), 16)) >>> 24, o[1] = a >>> 16 & 255, o[2] = a >>> 8 & 255, o[3] = a & 255, o[4] = (a = parseInt(i.slice(9, 13), 16)) >>> 8, o[5] = a & 255, o[6] = (a = parseInt(i.slice(14, 18), 16)) >>> 8, o[7] = a & 255, o[8] = (a = parseInt(i.slice(19, 23), 16)) >>> 8, o[9] = a & 255, o[10] = (a = parseInt(i.slice(24, 36), 16)) / 1099511627776 & 255, o[11] = a / 4294967296 & 255, o[12] = a >>> 24 & 255, o[13] = a >>> 16 & 255, o[14] = a >>> 8 & 255, o[15] = a & 255, o;
  }
  var s = r;
  return or.default = s, or;
}
var Dc;
function Hf() {
  if (Dc) return Qe;
  Dc = 1, Object.defineProperty(Qe, "__esModule", {
    value: !0
  }), Qe.URL = Qe.DNS = void 0, Qe.default = o;
  var e = /* @__PURE__ */ Ks(), t = r(/* @__PURE__ */ Wf());
  function r(n) {
    return n && n.__esModule ? n : { default: n };
  }
  function s(n) {
    n = unescape(encodeURIComponent(n));
    const c = [];
    for (let u = 0; u < n.length; ++u)
      c.push(n.charCodeAt(u));
    return c;
  }
  const i = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  Qe.DNS = i;
  const a = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  Qe.URL = a;
  function o(n, c, u) {
    function l(p, d, h, f) {
      var g;
      if (typeof p == "string" && (p = s(p)), typeof d == "string" && (d = (0, t.default)(d)), ((g = d) === null || g === void 0 ? void 0 : g.length) !== 16)
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let m = new Uint8Array(16 + p.length);
      if (m.set(d), m.set(p, d.length), m = u(m), m[6] = m[6] & 15 | c, m[8] = m[8] & 63 | 128, h) {
        f = f || 0;
        for (let v = 0; v < 16; ++v)
          h[f + v] = m[v];
        return h;
      }
      return (0, e.unsafeStringify)(m);
    }
    try {
      l.name = n;
    } catch {
    }
    return l.DNS = i, l.URL = a, l;
  }
  return Qe;
}
var ar = {}, Nc;
function pC() {
  if (Nc) return ar;
  Nc = 1, Object.defineProperty(ar, "__esModule", {
    value: !0
  }), ar.default = void 0;
  function e(h) {
    if (typeof h == "string") {
      const f = unescape(encodeURIComponent(h));
      h = new Uint8Array(f.length);
      for (let g = 0; g < f.length; ++g)
        h[g] = f.charCodeAt(g);
    }
    return t(s(i(h), h.length * 8));
  }
  function t(h) {
    const f = [], g = h.length * 32, m = "0123456789abcdef";
    for (let v = 0; v < g; v += 8) {
      const y = h[v >> 5] >>> v % 32 & 255, S = parseInt(m.charAt(y >>> 4 & 15) + m.charAt(y & 15), 16);
      f.push(S);
    }
    return f;
  }
  function r(h) {
    return (h + 64 >>> 9 << 4) + 14 + 1;
  }
  function s(h, f) {
    h[f >> 5] |= 128 << f % 32, h[r(f) - 1] = f;
    let g = 1732584193, m = -271733879, v = -1732584194, y = 271733878;
    for (let S = 0; S < h.length; S += 16) {
      const C = g, R = m, w = v, I = y;
      g = c(g, m, v, y, h[S], 7, -680876936), y = c(y, g, m, v, h[S + 1], 12, -389564586), v = c(v, y, g, m, h[S + 2], 17, 606105819), m = c(m, v, y, g, h[S + 3], 22, -1044525330), g = c(g, m, v, y, h[S + 4], 7, -176418897), y = c(y, g, m, v, h[S + 5], 12, 1200080426), v = c(v, y, g, m, h[S + 6], 17, -1473231341), m = c(m, v, y, g, h[S + 7], 22, -45705983), g = c(g, m, v, y, h[S + 8], 7, 1770035416), y = c(y, g, m, v, h[S + 9], 12, -1958414417), v = c(v, y, g, m, h[S + 10], 17, -42063), m = c(m, v, y, g, h[S + 11], 22, -1990404162), g = c(g, m, v, y, h[S + 12], 7, 1804603682), y = c(y, g, m, v, h[S + 13], 12, -40341101), v = c(v, y, g, m, h[S + 14], 17, -1502002290), m = c(m, v, y, g, h[S + 15], 22, 1236535329), g = u(g, m, v, y, h[S + 1], 5, -165796510), y = u(y, g, m, v, h[S + 6], 9, -1069501632), v = u(v, y, g, m, h[S + 11], 14, 643717713), m = u(m, v, y, g, h[S], 20, -373897302), g = u(g, m, v, y, h[S + 5], 5, -701558691), y = u(y, g, m, v, h[S + 10], 9, 38016083), v = u(v, y, g, m, h[S + 15], 14, -660478335), m = u(m, v, y, g, h[S + 4], 20, -405537848), g = u(g, m, v, y, h[S + 9], 5, 568446438), y = u(y, g, m, v, h[S + 14], 9, -1019803690), v = u(v, y, g, m, h[S + 3], 14, -187363961), m = u(m, v, y, g, h[S + 8], 20, 1163531501), g = u(g, m, v, y, h[S + 13], 5, -1444681467), y = u(y, g, m, v, h[S + 2], 9, -51403784), v = u(v, y, g, m, h[S + 7], 14, 1735328473), m = u(m, v, y, g, h[S + 12], 20, -1926607734), g = l(g, m, v, y, h[S + 5], 4, -378558), y = l(y, g, m, v, h[S + 8], 11, -2022574463), v = l(v, y, g, m, h[S + 11], 16, 1839030562), m = l(m, v, y, g, h[S + 14], 23, -35309556), g = l(g, m, v, y, h[S + 1], 4, -1530992060), y = l(y, g, m, v, h[S + 4], 11, 1272893353), v = l(v, y, g, m, h[S + 7], 16, -155497632), m = l(m, v, y, g, h[S + 10], 23, -1094730640), g = l(g, m, v, y, h[S + 13], 4, 681279174), y = l(y, g, m, v, h[S], 11, -358537222), v = l(v, y, g, m, h[S + 3], 16, -722521979), m = l(m, v, y, g, h[S + 6], 23, 76029189), g = l(g, m, v, y, h[S + 9], 4, -640364487), y = l(y, g, m, v, h[S + 12], 11, -421815835), v = l(v, y, g, m, h[S + 15], 16, 530742520), m = l(m, v, y, g, h[S + 2], 23, -995338651), g = p(g, m, v, y, h[S], 6, -198630844), y = p(y, g, m, v, h[S + 7], 10, 1126891415), v = p(v, y, g, m, h[S + 14], 15, -1416354905), m = p(m, v, y, g, h[S + 5], 21, -57434055), g = p(g, m, v, y, h[S + 12], 6, 1700485571), y = p(y, g, m, v, h[S + 3], 10, -1894986606), v = p(v, y, g, m, h[S + 10], 15, -1051523), m = p(m, v, y, g, h[S + 1], 21, -2054922799), g = p(g, m, v, y, h[S + 8], 6, 1873313359), y = p(y, g, m, v, h[S + 15], 10, -30611744), v = p(v, y, g, m, h[S + 6], 15, -1560198380), m = p(m, v, y, g, h[S + 13], 21, 1309151649), g = p(g, m, v, y, h[S + 4], 6, -145523070), y = p(y, g, m, v, h[S + 11], 10, -1120210379), v = p(v, y, g, m, h[S + 2], 15, 718787259), m = p(m, v, y, g, h[S + 9], 21, -343485551), g = a(g, C), m = a(m, R), v = a(v, w), y = a(y, I);
    }
    return [g, m, v, y];
  }
  function i(h) {
    if (h.length === 0)
      return [];
    const f = h.length * 8, g = new Uint32Array(r(f));
    for (let m = 0; m < f; m += 8)
      g[m >> 5] |= (h[m / 8] & 255) << m % 32;
    return g;
  }
  function a(h, f) {
    const g = (h & 65535) + (f & 65535);
    return (h >> 16) + (f >> 16) + (g >> 16) << 16 | g & 65535;
  }
  function o(h, f) {
    return h << f | h >>> 32 - f;
  }
  function n(h, f, g, m, v, y) {
    return a(o(a(a(f, h), a(m, y)), v), g);
  }
  function c(h, f, g, m, v, y, S) {
    return n(f & g | ~f & m, h, f, v, y, S);
  }
  function u(h, f, g, m, v, y, S) {
    return n(f & m | g & ~m, h, f, v, y, S);
  }
  function l(h, f, g, m, v, y, S) {
    return n(f ^ g ^ m, h, f, v, y, S);
  }
  function p(h, f, g, m, v, y, S) {
    return n(g ^ (f | ~m), h, f, v, y, S);
  }
  var d = e;
  return ar.default = d, ar;
}
var xc;
function dC() {
  if (xc) return sr;
  xc = 1, Object.defineProperty(sr, "__esModule", {
    value: !0
  }), sr.default = void 0;
  var e = r(/* @__PURE__ */ Hf()), t = r(/* @__PURE__ */ pC());
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = (0, e.default)("v3", 48, t.default);
  return sr.default = i, sr;
}
var cr = {}, ur = {}, zc;
function hC() {
  if (zc) return ur;
  zc = 1, Object.defineProperty(ur, "__esModule", {
    value: !0
  }), ur.default = void 0;
  var t = {
    randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  };
  return ur.default = t, ur;
}
var Lc;
function fC() {
  if (Lc) return cr;
  Lc = 1, Object.defineProperty(cr, "__esModule", {
    value: !0
  }), cr.default = void 0;
  var e = s(/* @__PURE__ */ hC()), t = s(/* @__PURE__ */ Vf()), r = /* @__PURE__ */ Ks();
  function s(o) {
    return o && o.__esModule ? o : { default: o };
  }
  function i(o, n, c) {
    if (e.default.randomUUID && !n && !o)
      return e.default.randomUUID();
    o = o || {};
    const u = o.random || (o.rng || t.default)();
    if (u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, n) {
      c = c || 0;
      for (let l = 0; l < 16; ++l)
        n[c + l] = u[l];
      return n;
    }
    return (0, r.unsafeStringify)(u);
  }
  var a = i;
  return cr.default = a, cr;
}
var lr = {}, pr = {}, jc;
function vC() {
  if (jc) return pr;
  jc = 1, Object.defineProperty(pr, "__esModule", {
    value: !0
  }), pr.default = void 0;
  function e(i, a, o, n) {
    switch (i) {
      case 0:
        return a & o ^ ~a & n;
      case 1:
        return a ^ o ^ n;
      case 2:
        return a & o ^ a & n ^ o & n;
      case 3:
        return a ^ o ^ n;
    }
  }
  function t(i, a) {
    return i << a | i >>> 32 - a;
  }
  function r(i) {
    const a = [1518500249, 1859775393, 2400959708, 3395469782], o = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof i == "string") {
      const l = unescape(encodeURIComponent(i));
      i = [];
      for (let p = 0; p < l.length; ++p)
        i.push(l.charCodeAt(p));
    } else Array.isArray(i) || (i = Array.prototype.slice.call(i));
    i.push(128);
    const n = i.length / 4 + 2, c = Math.ceil(n / 16), u = new Array(c);
    for (let l = 0; l < c; ++l) {
      const p = new Uint32Array(16);
      for (let d = 0; d < 16; ++d)
        p[d] = i[l * 64 + d * 4] << 24 | i[l * 64 + d * 4 + 1] << 16 | i[l * 64 + d * 4 + 2] << 8 | i[l * 64 + d * 4 + 3];
      u[l] = p;
    }
    u[c - 1][14] = (i.length - 1) * 8 / Math.pow(2, 32), u[c - 1][14] = Math.floor(u[c - 1][14]), u[c - 1][15] = (i.length - 1) * 8 & 4294967295;
    for (let l = 0; l < c; ++l) {
      const p = new Uint32Array(80);
      for (let v = 0; v < 16; ++v)
        p[v] = u[l][v];
      for (let v = 16; v < 80; ++v)
        p[v] = t(p[v - 3] ^ p[v - 8] ^ p[v - 14] ^ p[v - 16], 1);
      let d = o[0], h = o[1], f = o[2], g = o[3], m = o[4];
      for (let v = 0; v < 80; ++v) {
        const y = Math.floor(v / 20), S = t(d, 5) + e(y, h, f, g) + m + a[y] + p[v] >>> 0;
        m = g, g = f, f = t(h, 30) >>> 0, h = d, d = S;
      }
      o[0] = o[0] + d >>> 0, o[1] = o[1] + h >>> 0, o[2] = o[2] + f >>> 0, o[3] = o[3] + g >>> 0, o[4] = o[4] + m >>> 0;
    }
    return [o[0] >> 24 & 255, o[0] >> 16 & 255, o[0] >> 8 & 255, o[0] & 255, o[1] >> 24 & 255, o[1] >> 16 & 255, o[1] >> 8 & 255, o[1] & 255, o[2] >> 24 & 255, o[2] >> 16 & 255, o[2] >> 8 & 255, o[2] & 255, o[3] >> 24 & 255, o[3] >> 16 & 255, o[3] >> 8 & 255, o[3] & 255, o[4] >> 24 & 255, o[4] >> 16 & 255, o[4] >> 8 & 255, o[4] & 255];
  }
  var s = r;
  return pr.default = s, pr;
}
var qc;
function gC() {
  if (qc) return lr;
  qc = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.default = void 0;
  var e = r(/* @__PURE__ */ Hf()), t = r(/* @__PURE__ */ vC());
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = (0, e.default)("v5", 80, t.default);
  return lr.default = i, lr;
}
var dr = {}, Fc;
function mC() {
  if (Fc) return dr;
  Fc = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.default = void 0;
  var e = "00000000-0000-0000-0000-000000000000";
  return dr.default = e, dr;
}
var hr = {}, Bc;
function yC() {
  if (Bc) return hr;
  Bc = 1, Object.defineProperty(hr, "__esModule", {
    value: !0
  }), hr.default = void 0;
  var e = t(/* @__PURE__ */ Hs());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    if (!(0, e.default)(i))
      throw TypeError("Invalid UUID");
    return parseInt(i.slice(14, 15), 16);
  }
  var s = r;
  return hr.default = s, hr;
}
var Uc;
function SC() {
  return Uc || (Uc = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "NIL", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(e, "v1", {
      enumerable: !0,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(e, "v3", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "v4", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    }), Object.defineProperty(e, "v5", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    });
    var t = l(/* @__PURE__ */ lC()), r = l(/* @__PURE__ */ dC()), s = l(/* @__PURE__ */ fC()), i = l(/* @__PURE__ */ gC()), a = l(/* @__PURE__ */ mC()), o = l(/* @__PURE__ */ yC()), n = l(/* @__PURE__ */ Hs()), c = l(/* @__PURE__ */ Ks()), u = l(/* @__PURE__ */ Wf());
    function l(p) {
      return p && p.__esModule ? p : { default: p };
    }
  }(po)), po;
}
var $c;
function Mt() {
  if ($c) return ct;
  $c = 1, Object.defineProperty(ct, "__esModule", { value: !0 }), ct.createNoDashGuid = ct.createGuid = void 0;
  const e = /* @__PURE__ */ SC(), t = () => (0, e.v4)();
  ct.createGuid = t;
  const r = () => t().replace(new RegExp("-", "g"), "").toUpperCase();
  return ct.createNoDashGuid = r, ct;
}
var Vc;
function Ss() {
  return Vc || (Vc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PlatformEvent = e.EventType = void 0;
    const t = /* @__PURE__ */ Mt();
    (function(s) {
      s[s.Debug = 0] = "Debug", s[s.Info = 1] = "Info", s[s.Warning = 2] = "Warning", s[s.Error = 3] = "Error", s[s.None = 4] = "None";
    })(e.EventType || (e.EventType = {}));
    class r {
      constructor(i, a) {
        this.privName = i, this.privEventId = (0, t.createNoDashGuid)(), this.privEventTime = (/* @__PURE__ */ new Date()).toISOString(), this.privEventType = a, this.privMetadata = {};
      }
      get name() {
        return this.privName;
      }
      get eventId() {
        return this.privEventId;
      }
      get eventTime() {
        return this.privEventTime;
      }
      get eventType() {
        return this.privEventType;
      }
      get metadata() {
        return this.privMetadata;
      }
    }
    e.PlatformEvent = r;
  }(lo)), lo;
}
var Wc;
function CC() {
  if (Wc) return Z;
  Wc = 1, Object.defineProperty(Z, "__esModule", { value: !0 }), Z.AudioStreamNodeErrorEvent = Z.AudioStreamNodeDetachedEvent = Z.AudioStreamNodeAttachedEvent = Z.AudioStreamNodeAttachingEvent = Z.AudioStreamNodeEvent = Z.AudioSourceErrorEvent = Z.AudioSourceOffEvent = Z.AudioSourceReadyEvent = Z.AudioSourceInitializingEvent = Z.AudioSourceEvent = void 0;
  const e = /* @__PURE__ */ Ss();
  class t extends e.PlatformEvent {
    constructor(d, h, f = e.EventType.Info) {
      super(d, f), this.privAudioSourceId = h;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
  }
  Z.AudioSourceEvent = t;
  class r extends t {
    constructor(d) {
      super("AudioSourceInitializingEvent", d);
    }
  }
  Z.AudioSourceInitializingEvent = r;
  class s extends t {
    constructor(d) {
      super("AudioSourceReadyEvent", d);
    }
  }
  Z.AudioSourceReadyEvent = s;
  class i extends t {
    constructor(d) {
      super("AudioSourceOffEvent", d);
    }
  }
  Z.AudioSourceOffEvent = i;
  class a extends t {
    constructor(d, h) {
      super("AudioSourceErrorEvent", d, e.EventType.Error), this.privError = h;
    }
    get error() {
      return this.privError;
    }
  }
  Z.AudioSourceErrorEvent = a;
  class o extends t {
    constructor(d, h, f) {
      super(d, h), this.privAudioNodeId = f;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  Z.AudioStreamNodeEvent = o;
  class n extends o {
    constructor(d, h) {
      super("AudioStreamNodeAttachingEvent", d, h);
    }
  }
  Z.AudioStreamNodeAttachingEvent = n;
  class c extends o {
    constructor(d, h) {
      super("AudioStreamNodeAttachedEvent", d, h);
    }
  }
  Z.AudioStreamNodeAttachedEvent = c;
  class u extends o {
    constructor(d, h) {
      super("AudioStreamNodeDetachedEvent", d, h);
    }
  }
  Z.AudioStreamNodeDetachedEvent = u;
  class l extends o {
    constructor(d, h, f) {
      super("AudioStreamNodeErrorEvent", d, h), this.privError = f;
    }
    get error() {
      return this.privError;
    }
  }
  return Z.AudioStreamNodeErrorEvent = l, Z;
}
var X = {}, Hc;
function RC() {
  if (Hc) return X;
  Hc = 1, Object.defineProperty(X, "__esModule", { value: !0 }), X.ConnectionRedirectEvent = X.ConnectionMessageSentEvent = X.ConnectionMessageReceivedEvent = X.ConnectionEstablishErrorEvent = X.ConnectionErrorEvent = X.ConnectionClosedEvent = X.ConnectionEstablishedEvent = X.ConnectionStartEvent = X.ConnectionEvent = X.ServiceEvent = void 0;
  const e = /* @__PURE__ */ Ss();
  class t extends e.PlatformEvent {
    constructor(d, h, f = e.EventType.Info) {
      super(d, f), this.privJsonResult = h;
    }
    get jsonString() {
      return this.privJsonResult;
    }
  }
  X.ServiceEvent = t;
  class r extends e.PlatformEvent {
    constructor(d, h, f = e.EventType.Info) {
      super(d, f), this.privConnectionId = h;
    }
    get connectionId() {
      return this.privConnectionId;
    }
  }
  X.ConnectionEvent = r;
  class s extends r {
    constructor(d, h, f) {
      super("ConnectionStartEvent", d), this.privUri = h, this.privHeaders = f;
    }
    get uri() {
      return this.privUri;
    }
    get headers() {
      return this.privHeaders;
    }
  }
  X.ConnectionStartEvent = s;
  class i extends r {
    constructor(d) {
      super("ConnectionEstablishedEvent", d);
    }
  }
  X.ConnectionEstablishedEvent = i;
  class a extends r {
    constructor(d, h, f) {
      super("ConnectionClosedEvent", d, e.EventType.Debug), this.privReason = f, this.privStatusCode = h;
    }
    get reason() {
      return this.privReason;
    }
    get statusCode() {
      return this.privStatusCode;
    }
  }
  X.ConnectionClosedEvent = a;
  class o extends r {
    constructor(d, h, f) {
      super("ConnectionErrorEvent", d, e.EventType.Debug), this.privMessage = h, this.privType = f;
    }
    get message() {
      return this.privMessage;
    }
    get type() {
      return this.privType;
    }
  }
  X.ConnectionErrorEvent = o;
  class n extends r {
    constructor(d, h, f) {
      super("ConnectionEstablishErrorEvent", d, e.EventType.Error), this.privStatusCode = h, this.privReason = f;
    }
    get reason() {
      return this.privReason;
    }
    get statusCode() {
      return this.privStatusCode;
    }
  }
  X.ConnectionEstablishErrorEvent = n;
  class c extends r {
    constructor(d, h, f) {
      super("ConnectionMessageReceivedEvent", d), this.privNetworkReceivedTime = h, this.privMessage = f;
    }
    get networkReceivedTime() {
      return this.privNetworkReceivedTime;
    }
    get message() {
      return this.privMessage;
    }
  }
  X.ConnectionMessageReceivedEvent = c;
  class u extends r {
    constructor(d, h, f) {
      super("ConnectionMessageSentEvent", d), this.privNetworkSentTime = h, this.privMessage = f;
    }
    get networkSentTime() {
      return this.privNetworkSentTime;
    }
    get message() {
      return this.privMessage;
    }
  }
  X.ConnectionMessageSentEvent = u;
  class l extends r {
    constructor(d, h, f, g) {
      super("ConnectionRedirectEvent", d, e.EventType.Info), this.privRedirectUrl = h, this.privOriginalUrl = f, this.privContext = g;
    }
    get redirectUrl() {
      return this.privRedirectUrl;
    }
    get originalUrl() {
      return this.privOriginalUrl;
    }
    get context() {
      return this.privContext;
    }
  }
  return X.ConnectionRedirectEvent = l, X;
}
var ho = {}, xe = {}, Kc;
function Oe() {
  if (Kc) return xe;
  Kc = 1, Object.defineProperty(xe, "__esModule", { value: !0 }), xe.ObjectDisposedError = xe.InvalidOperationError = xe.ArgumentNullError = void 0;
  class e extends Error {
    /**
     * Creates an instance of ArgumentNullError.
     *
     * @param {string} argumentName - Name of the argument that is null
     *
     * @memberOf ArgumentNullError
     */
    constructor(i) {
      super(i), this.name = "ArgumentNull", this.message = i;
    }
  }
  xe.ArgumentNullError = e;
  class t extends Error {
    /**
     * Creates an instance of InvalidOperationError.
     *
     * @param {string} error - The error
     *
     * @memberOf InvalidOperationError
     */
    constructor(i) {
      super(i), this.name = "InvalidOperation", this.message = i;
    }
  }
  xe.InvalidOperationError = t;
  class r extends Error {
    /**
     * Creates an instance of ObjectDisposedError.
     *
     * @param {string} objectName - The object that is disposed
     * @param {string} error - The error
     *
     * @memberOf ObjectDisposedError
     */
    constructor(i, a) {
      super(a), this.name = i + "ObjectDisposed", this.message = a;
    }
  }
  return xe.ObjectDisposedError = r, xe;
}
var Jc;
function Kf() {
  return Jc || (Jc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionMessage = e.MessageType = void 0;
    const t = /* @__PURE__ */ Oe(), r = /* @__PURE__ */ Mt();
    var s;
    (function(a) {
      a[a.Text = 0] = "Text", a[a.Binary = 1] = "Binary";
    })(s = e.MessageType || (e.MessageType = {}));
    class i {
      constructor(o, n, c, u) {
        if (this.privBody = null, o === s.Text && n && typeof n != "string")
          throw new t.InvalidOperationError("Payload must be a string");
        if (o === s.Binary && n && !(n instanceof ArrayBuffer))
          throw new t.InvalidOperationError("Payload must be ArrayBuffer");
        switch (this.privMessageType = o, this.privBody = n, this.privHeaders = c || {}, this.privId = u || (0, r.createNoDashGuid)(), this.messageType) {
          case s.Binary:
            this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
            break;
          case s.Text:
            this.privSize = this.textBody.length;
        }
      }
      get messageType() {
        return this.privMessageType;
      }
      get headers() {
        return this.privHeaders;
      }
      get body() {
        return this.privBody;
      }
      get textBody() {
        if (this.privMessageType === s.Binary)
          throw new t.InvalidOperationError("Not supported for binary message");
        return this.privBody;
      }
      get binaryBody() {
        if (this.privMessageType === s.Text)
          throw new t.InvalidOperationError("Not supported for text message");
        return this.privBody;
      }
      get id() {
        return this.privId;
      }
    }
    e.ConnectionMessage = i;
  }(ho)), ho;
}
var fr = {}, Gc;
function PC() {
  if (Gc) return fr;
  Gc = 1, Object.defineProperty(fr, "__esModule", { value: !0 }), fr.ConnectionOpenResponse = void 0;
  let e = class {
    constructor(r, s) {
      this.privStatusCode = r, this.privReason = s;
    }
    get statusCode() {
      return this.privStatusCode;
    }
    get reason() {
      return this.privReason;
    }
  };
  return fr.ConnectionOpenResponse = e, fr;
}
var vr = {}, Qc;
function bC() {
  if (Qc) return vr;
  Qc = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.DeferralMap = void 0;
  let e = class {
    constructor() {
      this.privMap = {};
    }
    add(r, s) {
      this.privMap[r] = s;
    }
    getId(r) {
      return this.privMap[r];
    }
    complete(r, s) {
      try {
        this.privMap[r].resolve(s);
      } catch (i) {
        this.privMap[r].reject(i);
      } finally {
        this.privMap[r] = void 0;
      }
    }
  };
  return vr.DeferralMap = e, vr;
}
var ut = {}, Yc;
function Jf() {
  if (Yc) return ut;
  Yc = 1, Object.defineProperty(ut, "__esModule", { value: !0 }), ut.SendingAgentContextMessageEvent = ut.DialogEvent = void 0;
  const e = /* @__PURE__ */ Ss();
  class t extends e.PlatformEvent {
    constructor(i, a = e.EventType.Info) {
      super(i, a);
    }
  }
  ut.DialogEvent = t;
  class r extends t {
    constructor(i) {
      super("SendingAgentContextMessageEvent"), this.privAgentConfig = i;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
  }
  return ut.SendingAgentContextMessageEvent = r, ut;
}
var gr = {}, mr = {}, Zc;
function Gf() {
  if (Zc) return mr;
  Zc = 1, Object.defineProperty(mr, "__esModule", { value: !0 }), mr.EventSource = void 0;
  const e = /* @__PURE__ */ Oe(), t = /* @__PURE__ */ Mt();
  let r = class {
    constructor(i) {
      this.privEventListeners = {}, this.privIsDisposed = !1, this.privConsoleListener = void 0, this.privMetadata = i;
    }
    onEvent(i) {
      if (this.isDisposed())
        throw new e.ObjectDisposedError("EventSource");
      if (this.metadata)
        for (const a in this.metadata)
          a && i.metadata && (i.metadata[a] || (i.metadata[a] = this.metadata[a]));
      for (const a in this.privEventListeners)
        a && this.privEventListeners[a] && this.privEventListeners[a](i);
    }
    attach(i) {
      const a = (0, t.createNoDashGuid)();
      return this.privEventListeners[a] = i, {
        detach: () => (delete this.privEventListeners[a], Promise.resolve())
      };
    }
    attachListener(i) {
      return this.attach((a) => i.onEvent(a));
    }
    attachConsoleListener(i) {
      return this.privConsoleListener && this.privConsoleListener.detach(), this.privConsoleListener = this.attach((a) => i.onEvent(a)), this.privConsoleListener;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.privEventListeners = null, this.privIsDisposed = !0;
    }
    get metadata() {
      return this.privMetadata;
    }
  };
  return mr.EventSource = r, mr;
}
var Xc;
function wC() {
  if (Xc) return gr;
  Xc = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.Events = void 0;
  const e = /* @__PURE__ */ Oe(), t = /* @__PURE__ */ Gf();
  let r = class za {
    static setEventSource(i) {
      if (!i)
        throw new e.ArgumentNullError("eventSource");
      za.privInstance = i;
    }
    static get instance() {
      return za.privInstance;
    }
  };
  return gr.Events = r, r.privInstance = new t.EventSource(), gr;
}
var fo = {}, eu;
function EC() {
  return eu || (eu = 1, Object.defineProperty(fo, "__esModule", { value: !0 })), fo;
}
var vo = {}, tu;
function IC() {
  return tu || (tu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionState = void 0, function(t) {
      t[t.None = 0] = "None", t[t.Connected = 1] = "Connected", t[t.Connecting = 2] = "Connecting", t[t.Disconnected = 3] = "Disconnected";
    }(e.ConnectionState || (e.ConnectionState = {}));
  }(vo)), vo;
}
var go = {}, ru;
function AC() {
  return ru || (ru = 1, Object.defineProperty(go, "__esModule", { value: !0 })), go;
}
var mo = {}, nu;
function TC() {
  return nu || (nu = 1, Object.defineProperty(mo, "__esModule", { value: !0 })), mo;
}
var yo = {}, iu;
function _C() {
  return iu || (iu = 1, Object.defineProperty(yo, "__esModule", { value: !0 })), yo;
}
var So = {}, su;
function kC() {
  return su || (su = 1, Object.defineProperty(So, "__esModule", { value: !0 })), So;
}
var Co = {}, ou;
function OC() {
  return ou || (ou = 1, Object.defineProperty(Co, "__esModule", { value: !0 })), Co;
}
var Ro = {}, au;
function MC() {
  return au || (au = 1, Object.defineProperty(Ro, "__esModule", { value: !0 })), Ro;
}
var Po = {}, cu;
function DC() {
  return cu || (cu = 1, Object.defineProperty(Po, "__esModule", { value: !0 })), Po;
}
var bo = {}, uu;
function NC() {
  return uu || (uu = 1, Object.defineProperty(bo, "__esModule", { value: !0 })), bo;
}
var yr = {}, lu;
function Qf() {
  if (lu) return yr;
  lu = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.List = void 0;
  const e = /* @__PURE__ */ Oe();
  let t = class Tt {
    constructor(s) {
      if (this.privSubscriptionIdCounter = 0, this.privAddSubscriptions = {}, this.privRemoveSubscriptions = {}, this.privDisposedSubscriptions = {}, this.privDisposeReason = null, this.privList = [], s)
        for (const i of s)
          this.privList.push(i);
    }
    get(s) {
      return this.throwIfDisposed(), this.privList[s];
    }
    first() {
      return this.get(0);
    }
    last() {
      return this.get(this.length() - 1);
    }
    add(s) {
      this.throwIfDisposed(), this.insertAt(this.privList.length, s);
    }
    insertAt(s, i) {
      this.throwIfDisposed(), s === 0 ? this.privList.unshift(i) : s === this.privList.length ? this.privList.push(i) : this.privList.splice(s, 0, i), this.triggerSubscriptions(this.privAddSubscriptions);
    }
    removeFirst() {
      return this.throwIfDisposed(), this.removeAt(0);
    }
    removeLast() {
      return this.throwIfDisposed(), this.removeAt(this.length() - 1);
    }
    removeAt(s) {
      return this.throwIfDisposed(), this.remove(s, 1)[0];
    }
    remove(s, i) {
      this.throwIfDisposed();
      const a = this.privList.splice(s, i);
      return this.triggerSubscriptions(this.privRemoveSubscriptions), a;
    }
    clear() {
      this.throwIfDisposed(), this.remove(0, this.length());
    }
    length() {
      return this.throwIfDisposed(), this.privList.length;
    }
    onAdded(s) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privAddSubscriptions[i] = s, {
        detach: () => (delete this.privAddSubscriptions[i], Promise.resolve())
      };
    }
    onRemoved(s) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privRemoveSubscriptions[i] = s, {
        detach: () => (delete this.privRemoveSubscriptions[i], Promise.resolve())
      };
    }
    onDisposed(s) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privDisposedSubscriptions[i] = s, {
        detach: () => (delete this.privDisposedSubscriptions[i], Promise.resolve())
      };
    }
    join(s) {
      return this.throwIfDisposed(), this.privList.join(s);
    }
    toArray() {
      const s = Array();
      return this.privList.forEach((i) => {
        s.push(i);
      }), s;
    }
    any(s) {
      return this.throwIfDisposed(), s ? this.where(s).length() > 0 : this.length() > 0;
    }
    all(s) {
      return this.throwIfDisposed(), this.where(s).length() === this.length();
    }
    forEach(s) {
      this.throwIfDisposed();
      for (let i = 0; i < this.length(); i++)
        s(this.privList[i], i);
    }
    select(s) {
      this.throwIfDisposed();
      const i = [];
      for (let a = 0; a < this.privList.length; a++)
        i.push(s(this.privList[a], a));
      return new Tt(i);
    }
    where(s) {
      this.throwIfDisposed();
      const i = new Tt();
      for (let a = 0; a < this.privList.length; a++)
        s(this.privList[a], a) && i.add(this.privList[a]);
      return i;
    }
    orderBy(s) {
      this.throwIfDisposed();
      const a = this.toArray().sort(s);
      return new Tt(a);
    }
    orderByDesc(s) {
      return this.throwIfDisposed(), this.orderBy((i, a) => s(a, i));
    }
    clone() {
      return this.throwIfDisposed(), new Tt(this.toArray());
    }
    concat(s) {
      return this.throwIfDisposed(), new Tt(this.privList.concat(s.toArray()));
    }
    concatArray(s) {
      return this.throwIfDisposed(), new Tt(this.privList.concat(s));
    }
    isDisposed() {
      return this.privList == null;
    }
    dispose(s) {
      this.isDisposed() || (this.privDisposeReason = s, this.privList = null, this.privAddSubscriptions = null, this.privRemoveSubscriptions = null, this.triggerSubscriptions(this.privDisposedSubscriptions));
    }
    throwIfDisposed() {
      if (this.isDisposed())
        throw new e.ObjectDisposedError("List", this.privDisposeReason);
    }
    triggerSubscriptions(s) {
      if (s)
        for (const i in s)
          i && s[i]();
    }
  };
  return yr.List = t, yr;
}
var wo = {}, pu;
function Yf() {
  return pu || (pu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.marshalPromiseToCallbacks = e.Sink = e.Deferred = e.PromiseResultEventSource = e.PromiseResult = e.PromiseState = void 0;
    var t;
    (function(n) {
      n[n.None = 0] = "None", n[n.Resolved = 1] = "Resolved", n[n.Rejected = 2] = "Rejected";
    })(t = e.PromiseState || (e.PromiseState = {}));
    class r {
      constructor(c) {
        this.throwIfError = () => {
          if (this.isError)
            throw this.error;
        }, c.on((u) => {
          this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !1, this.privResult = u);
        }, (u) => {
          this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !0, this.privError = u);
        });
      }
      get isCompleted() {
        return this.privIsCompleted;
      }
      get isError() {
        return this.privIsError;
      }
      get error() {
        return this.privError;
      }
      get result() {
        return this.privResult;
      }
    }
    e.PromiseResult = r;
    class s {
      constructor() {
        this.setResult = (c) => {
          this.privOnSetResult(c);
        }, this.setError = (c) => {
          this.privOnSetError(c);
        }, this.on = (c, u) => {
          this.privOnSetResult = c, this.privOnSetError = u;
        };
      }
    }
    e.PromiseResultEventSource = s;
    class i {
      constructor() {
        this.resolve = (c) => (this.privResolve(c), this), this.reject = (c) => (this.privReject(c), this), this.privPromise = new Promise((c, u) => {
          this.privResolve = c, this.privReject = u;
        });
      }
      get promise() {
        return this.privPromise;
      }
    }
    e.Deferred = i;
    class a {
      constructor() {
        this.privState = t.None, this.privPromiseResult = null, this.privPromiseResultEvents = null, this.privSuccessHandlers = [], this.privErrorHandlers = [], this.privPromiseResultEvents = new s(), this.privPromiseResult = new r(this.privPromiseResultEvents);
      }
      get state() {
        return this.privState;
      }
      get result() {
        return this.privPromiseResult;
      }
      resolve(c) {
        if (this.privState !== t.None)
          throw new Error("'Cannot resolve a completed promise'");
        this.privState = t.Resolved, this.privPromiseResultEvents.setResult(c);
        for (let u = 0; u < this.privSuccessHandlers.length; u++)
          this.executeSuccessCallback(c, this.privSuccessHandlers[u], this.privErrorHandlers[u]);
        this.detachHandlers();
      }
      reject(c) {
        if (this.privState !== t.None)
          throw new Error("'Cannot reject a completed promise'");
        this.privState = t.Rejected, this.privPromiseResultEvents.setError(c);
        for (const u of this.privErrorHandlers)
          this.executeErrorCallback(c, u);
        this.detachHandlers();
      }
      on(c, u) {
        c == null && (c = () => {
        }), this.privState === t.None ? (this.privSuccessHandlers.push(c), this.privErrorHandlers.push(u)) : (this.privState === t.Resolved ? this.executeSuccessCallback(this.privPromiseResult.result, c, u) : this.privState === t.Rejected && this.executeErrorCallback(this.privPromiseResult.error, u), this.detachHandlers());
      }
      executeSuccessCallback(c, u, l) {
        try {
          u(c);
        } catch (p) {
          this.executeErrorCallback(`'Unhandled callback error: ${p}'`, l);
        }
      }
      executeErrorCallback(c, u) {
        if (u)
          try {
            u(c);
          } catch (l) {
            throw new Error(`'Unhandled callback error: ${l}. InnerError: ${c}'`);
          }
        else
          throw new Error(`'Unhandled error: ${c}'`);
      }
      detachHandlers() {
        this.privErrorHandlers = [], this.privSuccessHandlers = [];
      }
    }
    e.Sink = a;
    function o(n, c, u) {
      n.then((l) => {
        try {
          c && c(l);
        } catch (p) {
          if (u)
            try {
              if (p instanceof Error) {
                const d = p;
                u(d.name + ": " + d.message);
              } else
                u(p);
            } catch {
            }
        }
      }, (l) => {
        if (u)
          try {
            if (l instanceof Error) {
              const p = l;
              u(p.name + ": " + p.message);
            } else
              u(l);
          } catch {
          }
      });
    }
    e.marshalPromiseToCallbacks = o;
  }(wo)), wo;
}
var Sr = {}, du;
function Zf() {
  if (du) return Sr;
  du = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.Queue = void 0;
  const e = /* @__PURE__ */ Oe(), t = /* @__PURE__ */ Qf(), r = /* @__PURE__ */ Yf();
  var s;
  (function(a) {
    a[a.Dequeue = 0] = "Dequeue", a[a.Peek = 1] = "Peek";
  })(s || (s = {}));
  let i = class {
    constructor(o) {
      this.privPromiseStore = new t.List(), this.privIsDrainInProgress = !1, this.privIsDisposing = !1, this.privDisposeReason = null, this.privList = o || new t.List(), this.privDetachables = [], this.privSubscribers = new t.List(), this.privDetachables.push(this.privList.onAdded(() => this.drain()));
    }
    enqueue(o) {
      this.throwIfDispose(), this.enqueueFromPromise(new Promise((n) => n(o)));
    }
    enqueueFromPromise(o) {
      this.throwIfDispose(), o.then((n) => {
        this.privList.add(n);
      }, () => {
      });
    }
    dequeue() {
      this.throwIfDispose();
      const o = new r.Deferred();
      return this.privSubscribers && (this.privSubscribers.add({ deferral: o, type: s.Dequeue }), this.drain()), o.promise;
    }
    peek() {
      this.throwIfDispose();
      const o = new r.Deferred();
      return this.privSubscribers && (this.privSubscribers.add({ deferral: o, type: s.Peek }), this.drain()), o.promise;
    }
    length() {
      return this.throwIfDispose(), this.privList.length();
    }
    isDisposed() {
      return this.privSubscribers == null;
    }
    async drainAndDispose(o, n) {
      if (!this.isDisposed() && !this.privIsDisposing) {
        this.privDisposeReason = n, this.privIsDisposing = !0;
        const c = this.privSubscribers;
        if (c) {
          for (; c.length() > 0; )
            c.removeFirst().deferral.resolve(void 0);
          this.privSubscribers === c && (this.privSubscribers = c);
        }
        for (const u of this.privDetachables)
          await u.detach();
        if (this.privPromiseStore.length() > 0 && o) {
          const u = [];
          return this.privPromiseStore.toArray().forEach((l) => {
            u.push(l);
          }), Promise.all(u).finally(() => {
            this.privSubscribers = null, this.privList.forEach((l) => {
              o(l);
            }), this.privList = null;
          }).then();
        } else
          this.privSubscribers = null, this.privList = null;
      }
    }
    async dispose(o) {
      await this.drainAndDispose(null, o);
    }
    drain() {
      if (!this.privIsDrainInProgress && !this.privIsDisposing) {
        this.privIsDrainInProgress = !0;
        const o = this.privSubscribers, n = this.privList;
        if (o && n) {
          for (; n.length() > 0 && o.length() > 0 && !this.privIsDisposing; ) {
            const c = o.removeFirst();
            if (c.type === s.Peek)
              c.deferral.resolve(n.first());
            else {
              const u = n.removeFirst();
              c.deferral.resolve(u);
            }
          }
          this.privSubscribers === o && (this.privSubscribers = o), this.privList === n && (this.privList = n);
        }
        this.privIsDrainInProgress = !1;
      }
    }
    throwIfDispose() {
      if (this.isDisposed())
        throw this.privDisposeReason ? new e.InvalidOperationError(this.privDisposeReason) : new e.ObjectDisposedError("Queue");
      if (this.privIsDisposing)
        throw new e.InvalidOperationError("Queue disposing");
    }
  };
  return Sr.Queue = i, Sr;
}
var Cr = {}, hu;
function xC() {
  if (hu) return Cr;
  hu = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.RawWebsocketMessage = void 0;
  const e = /* @__PURE__ */ Kf(), t = /* @__PURE__ */ Oe(), r = /* @__PURE__ */ Mt();
  let s = class {
    constructor(a, o, n) {
      if (this.privPayload = null, !o)
        throw new t.ArgumentNullError("payload");
      if (a === e.MessageType.Binary && Object.getPrototypeOf(o).constructor.name !== "ArrayBuffer")
        throw new t.InvalidOperationError("Payload must be ArrayBuffer");
      if (a === e.MessageType.Text && typeof o != "string")
        throw new t.InvalidOperationError("Payload must be a string");
      this.privMessageType = a, this.privPayload = o, this.privId = n || (0, r.createNoDashGuid)();
    }
    get messageType() {
      return this.privMessageType;
    }
    get payload() {
      return this.privPayload;
    }
    get textContent() {
      if (this.privMessageType === e.MessageType.Binary)
        throw new t.InvalidOperationError("Not supported for binary message");
      return this.privPayload;
    }
    get binaryContent() {
      if (this.privMessageType === e.MessageType.Text)
        throw new t.InvalidOperationError("Not supported for text message");
      return this.privPayload;
    }
    get id() {
      return this.privId;
    }
  };
  return Cr.RawWebsocketMessage = s, Cr;
}
var Rr = {}, fu;
function zC() {
  if (fu) return Rr;
  fu = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.RiffPcmEncoder = void 0;
  let e = class {
    constructor(r, s) {
      this.privActualSampleRate = r, this.privDesiredSampleRate = s;
    }
    encode(r) {
      const s = this.downSampleAudioFrame(r, this.privActualSampleRate, this.privDesiredSampleRate);
      if (!s)
        return null;
      const i = s.length * 2, a = new ArrayBuffer(i), o = new DataView(a);
      return this.floatTo16BitPCM(o, 0, s), a;
    }
    setString(r, s, i) {
      for (let a = 0; a < i.length; a++)
        r.setUint8(s + a, i.charCodeAt(a));
    }
    floatTo16BitPCM(r, s, i) {
      for (let a = 0; a < i.length; a++, s += 2) {
        const o = Math.max(-1, Math.min(1, i[a]));
        r.setInt16(s, o < 0 ? o * 32768 : o * 32767, !0);
      }
    }
    downSampleAudioFrame(r, s, i) {
      if (!r)
        return null;
      if (i === s || i > s)
        return r;
      const a = s / i, o = Math.round(r.length / a), n = new Float32Array(o);
      let c = 0, u = 0;
      for (; u < o; ) {
        const l = Math.round((u + 1) * a);
        let p = 0, d = 0;
        for (; c < l && c < r.length; )
          p += r[c++], d++;
        n[u++] = p / d;
      }
      return n;
    }
  };
  return Rr.RiffPcmEncoder = e, Rr;
}
var Pr = {}, vu;
function LC() {
  if (vu) return Pr;
  vu = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.Stream = void 0;
  const e = /* @__PURE__ */ Oe(), t = /* @__PURE__ */ Mt(), r = /* @__PURE__ */ Zf();
  let s = class {
    constructor(a) {
      this.privIsWriteEnded = !1, this.privIsReadEnded = !1, this.privId = a || (0, t.createNoDashGuid)(), this.privReaderQueue = new r.Queue();
    }
    get isClosed() {
      return this.privIsWriteEnded;
    }
    get isReadEnded() {
      return this.privIsReadEnded;
    }
    get id() {
      return this.privId;
    }
    close() {
      this.privIsWriteEnded || (this.writeStreamChunk({
        buffer: null,
        isEnd: !0,
        timeReceived: Date.now()
      }), this.privIsWriteEnded = !0);
    }
    writeStreamChunk(a) {
      if (this.throwIfClosed(), !this.privReaderQueue.isDisposed())
        try {
          this.privReaderQueue.enqueue(a);
        } catch {
        }
    }
    read() {
      if (this.privIsReadEnded)
        throw new e.InvalidOperationError("Stream read has already finished");
      return this.privReaderQueue.dequeue().then(async (a) => ((a === void 0 || a.isEnd) && await this.privReaderQueue.dispose("End of stream reached"), a));
    }
    readEnded() {
      this.privIsReadEnded || (this.privIsReadEnded = !0, this.privReaderQueue = new r.Queue());
    }
    throwIfClosed() {
      if (this.privIsWriteEnded)
        throw new e.InvalidOperationError("Stream closed");
    }
  };
  return Pr.Stream = s, Pr;
}
var Eo = {}, gu;
function tc() {
  return gu || (gu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TranslationStatus = void 0, function(t) {
      t[t.Success = 0] = "Success", t[t.Error = 1] = "Error";
    }(e.TranslationStatus || (e.TranslationStatus = {}));
  }(Eo)), Eo;
}
var br = {}, mu;
function jC() {
  if (mu) return br;
  mu = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.ChunkedArrayBufferStream = void 0;
  const e = /* @__PURE__ */ D();
  let t = class extends e.Stream {
    constructor(s, i) {
      super(i), this.privTargetChunkSize = Math.round(s), this.privNextBufferReadyBytes = 0;
    }
    writeStreamChunk(s) {
      if (s.isEnd || this.privNextBufferReadyBytes === 0 && s.buffer.byteLength === this.privTargetChunkSize) {
        super.writeStreamChunk(s);
        return;
      }
      let i = 0;
      for (; i < s.buffer.byteLength; ) {
        this.privNextBufferToWrite === void 0 && (this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize), this.privNextBufferStartTime = s.timeReceived);
        const a = Math.min(s.buffer.byteLength - i, this.privTargetChunkSize - this.privNextBufferReadyBytes), o = new Uint8Array(this.privNextBufferToWrite), n = new Uint8Array(s.buffer.slice(i, a + i));
        o.set(n, this.privNextBufferReadyBytes), this.privNextBufferReadyBytes += a, i += a, this.privNextBufferReadyBytes === this.privTargetChunkSize && (super.writeStreamChunk({
          buffer: this.privNextBufferToWrite,
          isEnd: !1,
          timeReceived: this.privNextBufferStartTime
        }), this.privNextBufferReadyBytes = 0, this.privNextBufferToWrite = void 0);
      }
    }
    close() {
      this.privNextBufferReadyBytes !== 0 && !this.isClosed && super.writeStreamChunk({
        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
        isEnd: !1,
        timeReceived: this.privNextBufferStartTime
      }), super.close();
    }
  };
  return br.ChunkedArrayBufferStream = t, br;
}
var Io = {}, yu;
function qC() {
  return yu || (yu = 1, Object.defineProperty(Io, "__esModule", { value: !0 })), Io;
}
var wr = {}, Su;
function FC() {
  if (Su) return wr;
  Su = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.Timeout = void 0;
  let e = class Ye {
    static load() {
      const r = /* @__PURE__ */ new Map([[0, () => {
      }]]), s = /* @__PURE__ */ new Map(), a = "data:text/javascript;base64," + btoa(`!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id "'.concat(e,'".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error('The given method "'.concat(e.method,'" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`), o = new Worker(a);
      return o.addEventListener("message", ({ data: u }) => {
        if (Ye.isCallNotification(u)) {
          const { params: { timerId: l } } = u, p = r.get(l);
          if (typeof p == "number") {
            const d = s.get(p);
            if (d === void 0 || d !== l)
              throw new Error("The timer is in an undefined state.");
          } else if (typeof p < "u")
            p(), r.delete(l);
          else
            throw new Error("The timer is in an undefined state.");
        } else if (Ye.isClearResponse(u)) {
          const { id: l } = u, p = s.get(l);
          if (p === void 0)
            throw new Error("The timer is in an undefined state.");
          s.delete(l), r.delete(p);
        } else {
          const { error: { message: l } } = u;
          throw new Error(l);
        }
      }), {
        clearTimeout: (u) => {
          const l = Math.random();
          s.set(l, u), r.set(u, l), o.postMessage({
            id: l,
            method: "clear",
            params: { timerId: u }
          });
        },
        setTimeout: (u, l) => {
          const p = Math.random();
          return r.set(p, u), o.postMessage({
            id: null,
            method: "set",
            params: {
              delay: l,
              now: performance.now(),
              timerId: p
            }
          }), p;
        }
      };
    }
    static loadWorkerTimers() {
      return () => (Ye.workerTimers !== null || (Ye.workerTimers = Ye.load()), Ye.workerTimers);
    }
    static isCallNotification(r) {
      return r.method !== void 0 && r.method === "call";
    }
    static isClearResponse(r) {
      return r.error === null && typeof r.id == "number";
    }
  };
  return wr.Timeout = e, e.workerTimers = null, e.clearTimeout = (t) => e.timers().clearTimeout(t), e.setTimeout = (t, r) => e.timers().setTimeout(t, r), e.timers = e.loadWorkerTimers(), wr;
}
var F = {}, Cu;
function BC() {
  if (Cu) return F;
  Cu = 1, Object.defineProperty(F, "__esModule", { value: !0 }), F.OCSPCacheUpdateErrorEvent = F.OCSPResponseRetrievedEvent = F.OCSPCacheFetchErrorEvent = F.OCSPVerificationFailedEvent = F.OCSPCacheHitEvent = F.OCSPCacheEntryNeedsRefreshEvent = F.OCSPCacheEntryExpiredEvent = F.OCSPWSUpgradeStartedEvent = F.OCSPStapleReceivedEvent = F.OCSPCacheUpdateCompleteEvent = F.OCSPDiskCacheStoreEvent = F.OCSPMemoryCacheStoreEvent = F.OCSPCacheUpdateNeededEvent = F.OCSPDiskCacheHitEvent = F.OCSPCacheMissEvent = F.OCSPMemoryCacheHitEvent = F.OCSPEvent = void 0;
  const e = /* @__PURE__ */ Ss();
  class t extends e.PlatformEvent {
    constructor(S, C, R) {
      super(S, C), this.privSignature = R;
    }
  }
  F.OCSPEvent = t;
  class r extends t {
    constructor(S) {
      super("OCSPMemoryCacheHitEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPMemoryCacheHitEvent = r;
  class s extends t {
    constructor(S) {
      super("OCSPCacheMissEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPCacheMissEvent = s;
  class i extends t {
    constructor(S) {
      super("OCSPDiskCacheHitEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPDiskCacheHitEvent = i;
  class a extends t {
    constructor(S) {
      super("OCSPCacheUpdateNeededEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPCacheUpdateNeededEvent = a;
  class o extends t {
    constructor(S) {
      super("OCSPMemoryCacheStoreEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPMemoryCacheStoreEvent = o;
  class n extends t {
    constructor(S) {
      super("OCSPDiskCacheStoreEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPDiskCacheStoreEvent = n;
  class c extends t {
    constructor(S) {
      super("OCSPCacheUpdateCompleteEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPCacheUpdateCompleteEvent = c;
  class u extends t {
    constructor() {
      super("OCSPStapleReceivedEvent", e.EventType.Debug, "");
    }
  }
  F.OCSPStapleReceivedEvent = u;
  class l extends t {
    constructor(S) {
      super("OCSPWSUpgradeStartedEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPWSUpgradeStartedEvent = l;
  class p extends t {
    constructor(S, C) {
      super("OCSPCacheEntryExpiredEvent", e.EventType.Debug, S), this.privExpireTime = C;
    }
  }
  F.OCSPCacheEntryExpiredEvent = p;
  class d extends t {
    constructor(S, C, R) {
      super("OCSPCacheEntryNeedsRefreshEvent", e.EventType.Debug, S), this.privExpireTime = R, this.privStartTime = C;
    }
  }
  F.OCSPCacheEntryNeedsRefreshEvent = d;
  class h extends t {
    constructor(S, C, R) {
      super("OCSPCacheHitEvent", e.EventType.Debug, S), this.privExpireTime = R, this.privExpireTimeString = new Date(R).toLocaleDateString(), this.privStartTime = C, this.privStartTimeString = new Date(C).toLocaleTimeString();
    }
  }
  F.OCSPCacheHitEvent = h;
  class f extends t {
    constructor(S, C) {
      super("OCSPVerificationFailedEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  F.OCSPVerificationFailedEvent = f;
  class g extends t {
    constructor(S, C) {
      super("OCSPCacheFetchErrorEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  F.OCSPCacheFetchErrorEvent = g;
  class m extends t {
    constructor(S) {
      super("OCSPResponseRetrievedEvent", e.EventType.Debug, S);
    }
  }
  F.OCSPResponseRetrievedEvent = m;
  class v extends t {
    constructor(S, C) {
      super("OCSPCacheUpdateErrorEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  return F.OCSPCacheUpdateErrorEvent = v, F;
}
var Er = {}, Ru;
function UC() {
  if (Ru) return Er;
  Ru = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.BackgroundEvent = void 0;
  const e = /* @__PURE__ */ D();
  class t extends e.PlatformEvent {
    constructor(s) {
      super("BackgroundEvent", e.EventType.Error), this.privError = s;
    }
    get error() {
      return this.privError;
    }
  }
  return Er.BackgroundEvent = t, Er;
}
var Pu;
function D() {
  return Pu || (Pu = 1, function(e) {
    var t = at && at.__createBinding || (Object.create ? function(i, a, o, n) {
      n === void 0 && (n = o), Object.defineProperty(i, n, { enumerable: !0, get: function() {
        return a[o];
      } });
    } : function(i, a, o, n) {
      n === void 0 && (n = o), i[n] = a[o];
    }), r = at && at.__exportStar || function(i, a) {
      for (var o in i) o !== "default" && !Object.prototype.hasOwnProperty.call(a, o) && t(a, i, o);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TranslationStatus = void 0, r(/* @__PURE__ */ CC(), e), r(/* @__PURE__ */ RC(), e), r(/* @__PURE__ */ Kf(), e), r(/* @__PURE__ */ PC(), e), r(/* @__PURE__ */ bC(), e), r(/* @__PURE__ */ Jf(), e), r(/* @__PURE__ */ Oe(), e), r(/* @__PURE__ */ wC(), e), r(/* @__PURE__ */ Gf(), e), r(/* @__PURE__ */ Mt(), e), r(/* @__PURE__ */ EC(), e), r(/* @__PURE__ */ IC(), e), r(/* @__PURE__ */ AC(), e), r(/* @__PURE__ */ TC(), e), r(/* @__PURE__ */ _C(), e), r(/* @__PURE__ */ kC(), e), r(/* @__PURE__ */ OC(), e), r(/* @__PURE__ */ MC(), e), r(/* @__PURE__ */ DC(), e), r(/* @__PURE__ */ NC(), e), r(/* @__PURE__ */ Qf(), e), r(/* @__PURE__ */ Ss(), e), r(/* @__PURE__ */ Yf(), e), r(/* @__PURE__ */ Zf(), e), r(/* @__PURE__ */ xC(), e), r(/* @__PURE__ */ zC(), e), r(/* @__PURE__ */ LC(), e);
    var s = /* @__PURE__ */ tc();
    Object.defineProperty(e, "TranslationStatus", { enumerable: !0, get: function() {
      return s.TranslationStatus;
    } }), r(/* @__PURE__ */ jC(), e), r(/* @__PURE__ */ qC(), e), r(/* @__PURE__ */ FC(), e), r(/* @__PURE__ */ BC(), e), r(/* @__PURE__ */ UC(), e);
  }(at)), at;
}
var Ir = {}, bu;
function ue() {
  if (bu) return Ir;
  bu = 1, Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.HeaderNames = void 0;
  let e = class {
  };
  return Ir.HeaderNames = e, e.AuthKey = "Ocp-Apim-Subscription-Key", e.Authorization = "Authorization", e.SpIDAuthKey = "Apim-Subscription-Id", e.ConnectionId = "X-ConnectionId", e.ContentType = "Content-Type", e.CustomCommandsAppId = "X-CommandsAppId", e.Path = "Path", e.RequestId = "X-RequestId", e.RequestStreamId = "X-StreamId", e.RequestTimestamp = "X-Timestamp", Ir;
}
var Ar = {}, wu;
function rc() {
  if (wu) return Ar;
  wu = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.AuthInfo = void 0;
  class e {
    constructor(r, s) {
      this.privHeaderName = r, this.privToken = s;
    }
    get headerName() {
      return this.privHeaderName;
    }
    get token() {
      return this.privToken;
    }
  }
  return Ar.AuthInfo = e, Ar;
}
var Eu;
function $C() {
  if (Eu) return tr;
  Eu = 1, Object.defineProperty(tr, "__esModule", { value: !0 }), tr.CognitiveSubscriptionKeyAuthentication = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ ue(), r = /* @__PURE__ */ rc();
  let s = class {
    /**
     * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
     * @constructor
     * @param {string} subscriptionKey - The subscription key
     */
    constructor(a) {
      if (!a)
        throw new e.ArgumentNullError("subscriptionKey");
      this.privAuthInfo = new r.AuthInfo(t.HeaderNames.AuthKey, a);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fetch(a) {
      return Promise.resolve(this.privAuthInfo);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fetchOnExpiry(a) {
      return Promise.resolve(this.privAuthInfo);
    }
  };
  return tr.CognitiveSubscriptionKeyAuthentication = s, tr;
}
var Tr = {}, Iu;
function VC() {
  if (Iu) return Tr;
  Iu = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.CognitiveTokenAuthentication = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ rc(), r = /* @__PURE__ */ ue();
  let s = class La {
    constructor(a, o) {
      if (!a)
        throw new e.ArgumentNullError("fetchCallback");
      if (!o)
        throw new e.ArgumentNullError("fetchOnExpiryCallback");
      this.privFetchCallback = a, this.privFetchOnExpiryCallback = o;
    }
    fetch(a) {
      return this.privFetchCallback(a).then((o) => new t.AuthInfo(r.HeaderNames.Authorization, o === void 0 ? void 0 : La.privTokenPrefix + o));
    }
    fetchOnExpiry(a) {
      return this.privFetchOnExpiryCallback(a).then((o) => new t.AuthInfo(r.HeaderNames.Authorization, o === void 0 ? void 0 : La.privTokenPrefix + o));
    }
  };
  return Tr.CognitiveTokenAuthentication = s, s.privTokenPrefix = "Bearer ", Tr;
}
var Ao = {}, Au;
function WC() {
  return Au || (Au = 1, Object.defineProperty(Ao, "__esModule", { value: !0 })), Ao;
}
var To = {}, Tu;
function HC() {
  return Tu || (Tu = 1, Object.defineProperty(To, "__esModule", { value: !0 })), To;
}
var _r = {}, lt = {}, be = {};
const KC = {}, JC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: KC
}, Symbol.toStringTag, { value: "Module" })), kt = /* @__PURE__ */ cC(JC);
var _o = {}, _u;
function Xf() {
  return _u || (_u = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LogLevel = void 0;
    const t = /* @__PURE__ */ D();
    Object.defineProperty(e, "LogLevel", { enumerable: !0, get: function() {
      return t.EventType;
    } });
  }(_o)), _o;
}
var kr = {}, ku;
function z() {
  if (ku) return kr;
  ku = 1, Object.defineProperty(kr, "__esModule", { value: !0 }), kr.Contracts = void 0;
  let e = class _t {
    static throwIfNullOrUndefined(r, s) {
      if (r == null)
        throw new Error("throwIfNullOrUndefined:" + s);
    }
    static throwIfNull(r, s) {
      if (r === null)
        throw new Error("throwIfNull:" + s);
    }
    static throwIfNullOrWhitespace(r, s) {
      if (_t.throwIfNullOrUndefined(r, s), ("" + r).trim().length < 1)
        throw new Error("throwIfNullOrWhitespace:" + s);
    }
    static throwIfNullOrTooLong(r, s, i) {
      if (_t.throwIfNullOrUndefined(r, s), ("" + r).length > i)
        throw new Error("throwIfNullOrTooLong:" + s + " (more than " + i.toString() + " characters)");
    }
    static throwIfNullOrTooShort(r, s, i) {
      if (_t.throwIfNullOrUndefined(r, s), ("" + r).length < i)
        throw new Error("throwIfNullOrTooShort:" + s + " (less than " + i.toString() + " characters)");
    }
    static throwIfDisposed(r) {
      if (r)
        throw new Error("the object is already disposed");
    }
    static throwIfArrayEmptyOrWhitespace(r, s) {
      if (_t.throwIfNullOrUndefined(r, s), r.length === 0)
        throw new Error("throwIfArrayEmptyOrWhitespace:" + s);
      for (const i of r)
        _t.throwIfNullOrWhitespace(i, s);
    }
    static throwIfFileDoesNotExist(r, s) {
      _t.throwIfNullOrWhitespace(r, s);
    }
    static throwIfNotUndefined(r, s) {
      if (r !== void 0)
        throw new Error("throwIfNotUndefined:" + s);
    }
  };
  return kr.Contracts = e, kr;
}
var Ou;
function GC() {
  if (Ou) return be;
  Ou = 1;
  var e = be && be.__createBinding || (Object.create ? function(n, c, u, l) {
    l === void 0 && (l = u), Object.defineProperty(n, l, { enumerable: !0, get: function() {
      return c[u];
    } });
  } : function(n, c, u, l) {
    l === void 0 && (l = u), n[l] = c[u];
  }), t = be && be.__setModuleDefault || (Object.create ? function(n, c) {
    Object.defineProperty(n, "default", { enumerable: !0, value: c });
  } : function(n, c) {
    n.default = c;
  }), r = be && be.__importStar || function(n) {
    if (n && n.__esModule) return n;
    var c = {};
    if (n != null) for (var u in n) u !== "default" && Object.prototype.hasOwnProperty.call(n, u) && e(c, n, u);
    return t(c, n), c;
  };
  Object.defineProperty(be, "__esModule", { value: !0 }), be.ConsoleLoggingListener = void 0;
  const s = r(kt), i = /* @__PURE__ */ Xf(), a = /* @__PURE__ */ z();
  let o = class {
    constructor(c = i.LogLevel.None) {
      this.privLogPath = void 0, this.privEnableConsoleOutput = !0, this.privLogLevelFilter = c;
    }
    set logPath(c) {
      a.Contracts.throwIfNullOrUndefined(s.openSync, `
File System access not available`), this.privLogPath = c;
    }
    set enableConsoleOutput(c) {
      this.privEnableConsoleOutput = c;
    }
    onEvent(c) {
      if (c.eventType >= this.privLogLevelFilter) {
        const u = this.toString(c);
        if (this.logCallback && this.logCallback(u), this.privLogPath && s.writeFileSync(this.privLogPath, u + `
`, { flag: "a+" }), this.privEnableConsoleOutput)
          switch (c.eventType) {
            case i.LogLevel.Debug:
              console.debug(u);
              break;
            case i.LogLevel.Info:
              console.info(u);
              break;
            case i.LogLevel.Warning:
              console.warn(u);
              break;
            case i.LogLevel.Error:
              console.error(u);
              break;
            default:
              console.log(u);
              break;
          }
      }
    }
    toString(c) {
      const u = [
        `${c.eventTime}`,
        `${c.name}`
      ], l = c;
      for (const p in l)
        if (p && c.hasOwnProperty(p) && p !== "eventTime" && p !== "eventType" && p !== "eventId" && p !== "name" && p !== "constructor") {
          const d = l[p];
          let h = "<NULL>";
          d != null && (typeof d == "number" || typeof d == "string" ? h = d.toString() : h = JSON.stringify(d)), u.push(`${p}: ${h}`);
        }
      return u.join(" | ");
    }
  };
  return be.ConsoleLoggingListener = o, be;
}
var ko = {}, Mu;
function QC() {
  return Mu || (Mu = 1, Object.defineProperty(ko, "__esModule", { value: !0 })), ko;
}
var Oo = {}, Mo = {}, Du;
function Dt() {
  return Du || (Du = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AudioStreamFormatImpl = e.AudioStreamFormat = e.AudioFormatTag = void 0;
    var t;
    (function(i) {
      i[i.PCM = 1] = "PCM", i[i.MuLaw = 2] = "MuLaw", i[i.Siren = 3] = "Siren", i[i.MP3 = 4] = "MP3", i[i.SILKSkype = 5] = "SILKSkype", i[i.OGG_OPUS = 6] = "OGG_OPUS", i[i.WEBM_OPUS = 7] = "WEBM_OPUS", i[i.ALaw = 8] = "ALaw", i[i.FLAC = 9] = "FLAC", i[i.OPUS = 10] = "OPUS", i[i.AMR_WB = 11] = "AMR_WB", i[i.G722 = 12] = "G722";
    })(t = e.AudioFormatTag || (e.AudioFormatTag = {}));
    class r {
      /**
       * Creates an audio stream format object representing the default audio stream
       * format (16KHz 16bit mono PCM).
       * @member AudioStreamFormat.getDefaultInputFormat
       * @function
       * @public
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getDefaultInputFormat() {
        return s.getDefaultInputFormat();
      }
      /**
       * Creates an audio stream format object with the specified format characteristics.
       * @member AudioStreamFormat.getWaveFormat
       * @function
       * @public
       * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
       * @param {number} bitsPerSample - Bits per sample, typically 16.
       * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
       * uses one channel and stereo data uses two channels.
       * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getWaveFormat(a, o, n, c) {
        return new s(a, o, n, c);
      }
      /**
       * Creates an audio stream format object with the specified pcm waveformat characteristics.
       * @member AudioStreamFormat.getWaveFormatPCM
       * @function
       * @public
       * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
       * @param {number} bitsPerSample - Bits per sample, typically 16.
       * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
       * uses one channel and stereo data uses two channels.
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getWaveFormatPCM(a, o, n) {
        return new s(a, o, n);
      }
    }
    e.AudioStreamFormat = r;
    class s extends r {
      /**
       * Creates an instance with the given values.
       * @constructor
       * @param {number} samplesPerSec - Samples per second.
       * @param {number} bitsPerSample - Bits per sample.
       * @param {number} channels - Number of channels.
       * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
       */
      constructor(a = 16e3, o = 16, n = 1, c = t.PCM) {
        super();
        let u = !0;
        switch (c) {
          case t.PCM:
            this.formatTag = 1;
            break;
          case t.ALaw:
            this.formatTag = 6;
            break;
          case t.MuLaw:
            this.formatTag = 7;
            break;
          default:
            u = !1;
        }
        if (this.bitsPerSample = o, this.samplesPerSec = a, this.channels = n, this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8), this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8), u) {
          this.privHeader = new ArrayBuffer(44);
          const l = new DataView(this.privHeader);
          this.setString(l, 0, "RIFF"), l.setUint32(4, 0, !0), this.setString(l, 8, "WAVEfmt "), l.setUint32(16, 16, !0), l.setUint16(20, this.formatTag, !0), l.setUint16(22, this.channels, !0), l.setUint32(24, this.samplesPerSec, !0), l.setUint32(28, this.avgBytesPerSec, !0), l.setUint16(32, this.channels * (this.bitsPerSample / 8), !0), l.setUint16(34, this.bitsPerSample, !0), this.setString(l, 36, "data"), l.setUint32(40, 0, !0);
        }
      }
      /**
       * Retrieves the default input format.
       * @member AudioStreamFormatImpl.getDefaultInputFormat
       * @function
       * @public
       * @returns {AudioStreamFormatImpl} The default input format.
       */
      static getDefaultInputFormat() {
        return new s();
      }
      /**
       * Creates an audio context appropriate to current browser
       * @member AudioStreamFormatImpl.getAudioContext
       * @function
       * @public
       * @returns {AudioContext} An audio context instance
       */
      /* eslint-disable */
      static getAudioContext(a) {
        const o = window.AudioContext || window.webkitAudioContext || !1;
        if (o)
          return a !== void 0 && navigator.mediaDevices.getSupportedConstraints().sampleRate ? new o({ sampleRate: a }) : new o();
        throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
      }
      /* eslint-enable */
      /**
       * Closes the configuration object.
       * @member AudioStreamFormatImpl.prototype.close
       * @function
       * @public
       */
      close() {
      }
      get header() {
        return this.privHeader;
      }
      setString(a, o, n) {
        for (let c = 0; c < n.length; c++)
          a.setUint8(o + c, n.charCodeAt(c));
      }
    }
    e.AudioStreamFormatImpl = s;
  }(Mo)), Mo;
}
var Nu;
function YC() {
  return Nu || (Nu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MicAudioSource = e.AudioWorkletSourceURLPropertyName = void 0;
    const t = /* @__PURE__ */ O(), r = /* @__PURE__ */ D(), s = /* @__PURE__ */ Dt();
    e.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
    class i {
      constructor(o, n, c, u) {
        this.privRecorder = o, this.deviceId = n, this.privStreams = {}, this.privOutputChunkSize = i.AUDIOFORMAT.avgBytesPerSec / 10, this.privId = c || (0, r.createNoDashGuid)(), this.privEvents = new r.EventSource(), this.privMediaStream = u || null, this.privIsClosing = !1;
      }
      get format() {
        return Promise.resolve(i.AUDIOFORMAT);
      }
      turnOn() {
        if (this.privInitializeDeferral)
          return this.privInitializeDeferral.promise;
        this.privInitializeDeferral = new r.Deferred();
        try {
          this.createAudioContext();
        } catch (c) {
          if (c instanceof Error) {
            const u = c;
            this.privInitializeDeferral.reject(u.name + ": " + u.message);
          } else
            this.privInitializeDeferral.reject(c);
          return this.privInitializeDeferral.promise;
        }
        const o = window.navigator;
        let n = (
          // eslint-disable-next-line
          o.getUserMedia || o.webkitGetUserMedia || o.mozGetUserMedia || o.msGetUserMedia
        );
        if (o.mediaDevices && (n = (c, u, l) => {
          o.mediaDevices.getUserMedia(c).then(u).catch(l);
        }), n) {
          const c = () => {
            this.onEvent(new r.AudioSourceInitializingEvent(this.privId)), this.privMediaStream && this.privMediaStream.active ? (this.onEvent(new r.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve()) : n({ audio: this.deviceId ? { deviceId: this.deviceId } : !0, video: !1 }, (u) => {
              this.privMediaStream = u, this.onEvent(new r.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve();
            }, (u) => {
              const l = `Error occurred during microphone initialization: ${u}`;
              this.privInitializeDeferral.reject(l), this.onEvent(new r.AudioSourceErrorEvent(this.privId, l));
            });
          };
          this.privContext.state === "suspended" ? this.privContext.resume().then(c).catch((u) => {
            this.privInitializeDeferral.reject(`Failed to initialize audio context: ${u}`);
          }) : c();
        } else {
          const c = "Browser does not support getUserMedia.";
          this.privInitializeDeferral.reject(c), this.onEvent(new r.AudioSourceErrorEvent(c, ""));
        }
        return this.privInitializeDeferral.promise;
      }
      id() {
        return this.privId;
      }
      attach(o) {
        return this.onEvent(new r.AudioStreamNodeAttachingEvent(this.privId, o)), this.listen(o).then((n) => (this.onEvent(new r.AudioStreamNodeAttachedEvent(this.privId, o)), {
          detach: async () => (n.readEnded(), delete this.privStreams[o], this.onEvent(new r.AudioStreamNodeDetachedEvent(this.privId, o)), this.turnOff()),
          id: () => o,
          read: () => n.read()
        }));
      }
      detach(o) {
        o && this.privStreams[o] && (this.privStreams[o].close(), delete this.privStreams[o], this.onEvent(new r.AudioStreamNodeDetachedEvent(this.privId, o)));
      }
      async turnOff() {
        for (const o in this.privStreams)
          if (o) {
            const n = this.privStreams[o];
            n && n.close();
          }
        this.onEvent(new r.AudioSourceOffEvent(this.privId)), this.privInitializeDeferral && (await this.privInitializeDeferral, this.privInitializeDeferral = null), await this.destroyAudioContext();
      }
      get events() {
        return this.privEvents;
      }
      get deviceInfo() {
        return this.getMicrophoneLabel().then((o) => ({
          bitspersample: i.AUDIOFORMAT.bitsPerSample,
          channelcount: i.AUDIOFORMAT.channels,
          connectivity: t.connectivity.Unknown,
          manufacturer: "Speech SDK",
          model: o,
          samplerate: i.AUDIOFORMAT.samplesPerSec,
          type: t.type.Microphones
        }));
      }
      setProperty(o, n) {
        if (o === e.AudioWorkletSourceURLPropertyName)
          this.privRecorder.setWorkletUrl(n);
        else
          throw new Error("Property '" + o + "' is not supported on Microphone.");
      }
      getMicrophoneLabel() {
        const o = "microphone";
        if (this.privMicrophoneLabel !== void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        if (this.privMediaStream === void 0 || !this.privMediaStream.active)
          return Promise.resolve(o);
        this.privMicrophoneLabel = o;
        const n = this.privMediaStream.getTracks()[0].getSettings().deviceId;
        if (n === void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        const c = new r.Deferred();
        return navigator.mediaDevices.enumerateDevices().then((u) => {
          for (const l of u)
            if (l.deviceId === n) {
              this.privMicrophoneLabel = l.label;
              break;
            }
          c.resolve(this.privMicrophoneLabel);
        }, () => c.resolve(this.privMicrophoneLabel)), c.promise;
      }
      async listen(o) {
        await this.turnOn();
        const n = new r.ChunkedArrayBufferStream(this.privOutputChunkSize, o);
        this.privStreams[o] = n;
        try {
          this.privRecorder.record(this.privContext, this.privMediaStream, n);
        } catch (u) {
          throw this.onEvent(new r.AudioStreamNodeErrorEvent(this.privId, o, u)), u;
        }
        return n;
      }
      onEvent(o) {
        this.privEvents.onEvent(o), r.Events.instance.onEvent(o);
      }
      createAudioContext() {
        this.privContext || (this.privContext = s.AudioStreamFormatImpl.getAudioContext(i.AUDIOFORMAT.samplesPerSec));
      }
      async destroyAudioContext() {
        if (!this.privContext)
          return;
        this.privRecorder.releaseMediaResources(this.privContext);
        let o = !1;
        "close" in this.privContext && (o = !0), o ? this.privIsClosing || (this.privIsClosing = !0, await this.privContext.close(), this.privContext = null, this.privIsClosing = !1) : this.privContext !== null && this.privContext.state === "running" && await this.privContext.suspend();
      }
    }
    e.MicAudioSource = i, i.AUDIOFORMAT = s.AudioStreamFormat.getDefaultInputFormat();
  }(Oo)), Oo;
}
var Or = {}, xu;
function ZC() {
  if (xu) return Or;
  xu = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.FileAudioSource = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ Dt();
  let s = class {
    constructor(a, o, n) {
      this.privStreams = {}, this.privHeaderEnd = 44, this.privId = n || (0, t.createNoDashGuid)(), this.privEvents = new t.EventSource(), this.privSource = a, typeof window < "u" && typeof Blob < "u" && this.privSource instanceof Blob ? this.privFilename = a.name : this.privFilename = o || "unknown.wav", this.privAudioFormatPromise = this.readHeader();
    }
    get format() {
      return this.privAudioFormatPromise;
    }
    turnOn() {
      if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
        const a = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
        return this.onEvent(new t.AudioSourceErrorEvent(a, "")), Promise.reject(a);
      }
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    id() {
      return this.privId;
    }
    async attach(a) {
      this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, a));
      const o = await this.upload(a);
      return this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, a)), Promise.resolve({
        detach: async () => {
          o.readEnded(), delete this.privStreams[a], this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, a)), await this.turnOff();
        },
        id: () => a,
        read: () => o.read()
      });
    }
    detach(a) {
      a && this.privStreams[a] && (this.privStreams[a].close(), delete this.privStreams[a], this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, a)));
    }
    turnOff() {
      for (const a in this.privStreams)
        if (a) {
          const o = this.privStreams[a];
          o && !o.isClosed && o.close();
        }
      return this.onEvent(new t.AudioSourceOffEvent(this.privId)), Promise.resolve();
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return this.privAudioFormatPromise.then((a) => Promise.resolve({
        bitspersample: a.bitsPerSample,
        channelcount: a.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "File",
        samplerate: a.samplesPerSec,
        type: e.type.File
      }));
    }
    readHeader() {
      const o = this.privSource.slice(0, 4296), n = new t.Deferred(), c = (u) => {
        const l = new DataView(u), p = (v) => String.fromCharCode(l.getUint8(v), l.getUint8(v + 1), l.getUint8(v + 2), l.getUint8(v + 3));
        if (p(0) !== "RIFF") {
          n.reject("Invalid WAV header in file, RIFF was not found");
          return;
        }
        if (p(8) !== "WAVE" || p(12) !== "fmt ") {
          n.reject("Invalid WAV header in file, WAVEfmt was not found");
          return;
        }
        const d = l.getInt32(16, !0), h = l.getUint16(22, !0), f = l.getUint32(24, !0), g = l.getUint16(34, !0);
        let m = 36 + Math.max(d - 16, 0);
        for (; p(m) !== "data"; m += 2)
          if (m > 4288) {
            n.reject("Invalid WAV header in file, data block was not found");
            return;
          }
        this.privHeaderEnd = m + 8, n.resolve(r.AudioStreamFormat.getWaveFormatPCM(f, g, h));
      };
      if (typeof window < "u" && typeof Blob < "u" && o instanceof Blob) {
        const u = new FileReader();
        u.onload = (l) => {
          const p = l.target.result;
          c(p);
        }, u.readAsArrayBuffer(o);
      } else {
        const u = o;
        c(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
      }
      return n.promise;
    }
    async upload(a) {
      const o = (n) => {
        const c = `Error occurred while processing '${this.privFilename}'. ${n}`;
        throw this.onEvent(new t.AudioStreamNodeErrorEvent(this.privId, a, c)), new Error(c);
      };
      try {
        await this.turnOn();
        const n = await this.privAudioFormatPromise, c = new t.ChunkedArrayBufferStream(n.avgBytesPerSec / 10, a);
        this.privStreams[a] = c;
        const u = this.privSource.slice(this.privHeaderEnd), l = (p) => {
          c.isClosed || (c.writeStreamChunk({
            buffer: p,
            isEnd: !1,
            timeReceived: Date.now()
          }), c.close());
        };
        if (typeof window < "u" && typeof Blob < "u" && u instanceof Blob) {
          const p = new FileReader();
          p.onerror = (d) => o(d.toString()), p.onload = (d) => {
            const h = d.target.result;
            l(h);
          }, p.readAsArrayBuffer(u);
        } else {
          const p = u;
          l(p.buffer.slice(p.byteOffset, p.byteOffset + p.byteLength));
        }
        return c;
      } catch (n) {
        o(n);
      }
    }
    onEvent(a) {
      this.privEvents.onEvent(a), t.Events.instance.onEvent(a);
    }
  };
  return Or.FileAudioSource = s, Or;
}
var Mr = {}, zu;
function XC() {
  if (zu) return Mr;
  zu = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.PcmRecorder = void 0;
  const e = /* @__PURE__ */ D();
  class t {
    constructor(s) {
      this.privStopInputOnRelease = s;
    }
    record(s, i, a) {
      const n = new e.RiffPcmEncoder(s.sampleRate, 16e3), c = s.createMediaStreamSource(i), u = () => {
        const p = (() => {
          let d = 0;
          try {
            return s.createScriptProcessor(d, 1, 1);
          } catch {
            d = 2048;
            let f = s.sampleRate;
            for (; d < 16384 && f >= 32e3; )
              d <<= 1, f >>= 1;
            return s.createScriptProcessor(d, 1, 1);
          }
        })();
        p.onaudioprocess = (d) => {
          const h = d.inputBuffer.getChannelData(0);
          if (a && !a.isClosed) {
            const f = n.encode(h);
            f && a.writeStreamChunk({
              buffer: f,
              isEnd: !1,
              timeReceived: Date.now()
            });
          }
        }, c.connect(p), p.connect(s.destination), this.privMediaResources = {
          scriptProcessorNode: p,
          source: c,
          stream: i
        };
      }, l = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === "ignore";
      if (s.audioWorklet && !l) {
        if (!this.privSpeechProcessorScript) {
          const p = `class SP extends AudioWorkletProcessor {
                    constructor(options) {
                      super(options);
                    }
                    process(inputs, outputs) {
                      const input = inputs[0];
                      const output = [];
                      for (let channel = 0; channel < input.length; channel += 1) {
                        output[channel] = input[channel];
                      }
                      this.port.postMessage(output[0]);
                      return true;
                    }
                  }
                  registerProcessor('speech-processor', SP);`, d = new Blob([p], { type: "application/javascript; charset=utf-8" });
          this.privSpeechProcessorScript = URL.createObjectURL(d);
        }
        s.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {
          const p = new AudioWorkletNode(s, "speech-processor");
          p.port.onmessage = (d) => {
            const h = d.data;
            if (a && !a.isClosed) {
              const f = n.encode(h);
              f && a.writeStreamChunk({
                buffer: f,
                isEnd: !1,
                timeReceived: Date.now()
              });
            }
          }, c.connect(p), p.connect(s.destination), this.privMediaResources = {
            scriptProcessorNode: p,
            source: c,
            stream: i
          };
        }).catch(() => {
          u();
        });
      } else
        try {
          u();
        } catch (p) {
          throw new Error(`Unable to start audio worklet node for PCMRecorder: ${p}`);
        }
    }
    releaseMediaResources(s) {
      this.privMediaResources && (this.privMediaResources.scriptProcessorNode && (this.privMediaResources.scriptProcessorNode.disconnect(s.destination), this.privMediaResources.scriptProcessorNode = null), this.privMediaResources.source && (this.privMediaResources.source.disconnect(), this.privStopInputOnRelease && this.privMediaResources.stream.getTracks().forEach((i) => i.stop()), this.privMediaResources.source = null));
    }
    setWorkletUrl(s) {
      this.privSpeechProcessorScript = s;
    }
  }
  return Mr.PcmRecorder = t, Mr;
}
var Dr = {}, fe = {}, Lu;
function ev() {
  if (Lu) return fe;
  Lu = 1;
  var e = fe && fe.__createBinding || (Object.create ? function(d, h, f, g) {
    g === void 0 && (g = f), Object.defineProperty(d, g, { enumerable: !0, get: function() {
      return h[f];
    } });
  } : function(d, h, f, g) {
    g === void 0 && (g = f), d[g] = h[f];
  }), t = fe && fe.__setModuleDefault || (Object.create ? function(d, h) {
    Object.defineProperty(d, "default", { enumerable: !0, value: h });
  } : function(d, h) {
    d.default = h;
  }), r = fe && fe.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var h = {};
    if (d != null) for (var f in d) f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && e(h, d, f);
    return t(h, d), h;
  }, s = fe && fe.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(fe, "__esModule", { value: !0 }), fe.WebsocketMessageAdapter = void 0;
  const i = r(kt), a = r(kt), o = s(kt), n = s(kt), c = s(kt), u = /* @__PURE__ */ ue(), l = /* @__PURE__ */ D();
  let p = class ja {
    constructor(h, f, g, m, v, y) {
      if (!h)
        throw new l.ArgumentNullError("uri");
      if (!g)
        throw new l.ArgumentNullError("messageFormatter");
      this.proxyInfo = m, this.privConnectionEvents = new l.EventSource(), this.privConnectionId = f, this.privMessageFormatter = g, this.privConnectionState = l.ConnectionState.None, this.privUri = h, this.privHeaders = v, this.privEnableCompression = y, this.privHeaders[u.HeaderNames.ConnectionId] = this.privConnectionId, this.privHeaders.connectionId = this.privConnectionId, this.privLastErrorReceived = "";
    }
    get state() {
      return this.privConnectionState;
    }
    open() {
      if (this.privConnectionState === l.ConnectionState.Disconnected)
        return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
      if (this.privConnectionEstablishDeferral)
        return this.privConnectionEstablishDeferral.promise;
      this.privConnectionEstablishDeferral = new l.Deferred(), this.privCertificateValidatedDeferral = new l.Deferred(), this.privConnectionState = l.ConnectionState.Connecting;
      try {
        if (typeof WebSocket < "u" && !ja.forceNpmWebSocket)
          this.privCertificateValidatedDeferral.resolve(), this.privWebsocketClient = new WebSocket(this.privUri);
        else {
          let f = new URL(this.privUri).protocol;
          f?.toLocaleLowerCase() === "wss:" ? f = "https:" : f?.toLocaleLowerCase() === "ws:" && (f = "http:");
          const g = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression, followRedirects: f.toLocaleLowerCase() === "https:" };
          this.privCertificateValidatedDeferral.resolve(), g.agent = this.getAgent(), g.agent.protocol = f, this.privWebsocketClient = new c.default(this.privUri, g), this.privWebsocketClient.on("redirect", (m) => {
            const v = new l.ConnectionRedirectEvent(this.privConnectionId, m, this.privUri, `Getting redirect URL from endpoint ${this.privUri} with redirect URL '${m}'`);
            l.Events.instance.onEvent(v);
          });
        }
        this.privWebsocketClient.binaryType = "arraybuffer", this.privReceivingMessageQueue = new l.Queue(), this.privDisconnectDeferral = new l.Deferred(), this.privSendMessageQueue = new l.Queue(), this.processSendQueue().catch((h) => {
          l.Events.instance.onEvent(new l.BackgroundEvent(h));
        });
      } catch (h) {
        return this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(500, h)), this.privConnectionEstablishDeferral.promise;
      }
      return this.onEvent(new l.ConnectionStartEvent(this.privConnectionId, this.privUri)), this.privWebsocketClient.onopen = () => {
        this.privCertificateValidatedDeferral.promise.then(() => {
          this.privConnectionState = l.ConnectionState.Connected, this.onEvent(new l.ConnectionEstablishedEvent(this.privConnectionId)), this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(200, ""));
        }, (h) => {
          this.privConnectionEstablishDeferral.reject(h);
        });
      }, this.privWebsocketClient.onerror = (h) => {
        this.onEvent(new l.ConnectionErrorEvent(this.privConnectionId, h.message, h.type)), this.privLastErrorReceived = h.message;
      }, this.privWebsocketClient.onclose = (h) => {
        this.privConnectionState === l.ConnectionState.Connecting ? (this.privConnectionState = l.ConnectionState.Disconnected, this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(h.code, h.reason + " " + this.privLastErrorReceived))) : (this.privConnectionState = l.ConnectionState.Disconnected, this.privWebsocketClient = null, this.onEvent(new l.ConnectionClosedEvent(this.privConnectionId, h.code, h.reason))), this.onClose(h.code, h.reason).catch((f) => {
          l.Events.instance.onEvent(new l.BackgroundEvent(f));
        });
      }, this.privWebsocketClient.onmessage = (h) => {
        const f = (/* @__PURE__ */ new Date()).toISOString();
        if (this.privConnectionState === l.ConnectionState.Connected) {
          const g = new l.Deferred();
          if (this.privReceivingMessageQueue.enqueueFromPromise(g.promise), h.data instanceof ArrayBuffer) {
            const m = new l.RawWebsocketMessage(l.MessageType.Binary, h.data);
            this.privMessageFormatter.toConnectionMessage(m).then((v) => {
              this.onEvent(new l.ConnectionMessageReceivedEvent(this.privConnectionId, f, v)), g.resolve(v);
            }, (v) => {
              g.reject(`Invalid binary message format. Error: ${v}`);
            });
          } else {
            const m = new l.RawWebsocketMessage(l.MessageType.Text, h.data);
            this.privMessageFormatter.toConnectionMessage(m).then((v) => {
              this.onEvent(new l.ConnectionMessageReceivedEvent(this.privConnectionId, f, v)), g.resolve(v);
            }, (v) => {
              g.reject(`Invalid text message format. Error: ${v}`);
            });
          }
        }
      }, this.privConnectionEstablishDeferral.promise;
    }
    send(h) {
      if (this.privConnectionState !== l.ConnectionState.Connected)
        return Promise.reject(`Cannot send on connection that is in ${l.ConnectionState[this.privConnectionState]} state`);
      const f = new l.Deferred(), g = new l.Deferred();
      return this.privSendMessageQueue.enqueueFromPromise(g.promise), this.privMessageFormatter.fromConnectionMessage(h).then((m) => {
        g.resolve({
          Message: h,
          RawWebsocketMessage: m,
          sendStatusDeferral: f
        });
      }, (m) => {
        g.reject(`Error formatting the message. ${m}`);
      }), f.promise;
    }
    read() {
      return this.privConnectionState !== l.ConnectionState.Connected ? Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`) : this.privReceivingMessageQueue.dequeue();
    }
    close(h) {
      if (this.privWebsocketClient)
        this.privConnectionState !== l.ConnectionState.Disconnected && this.privWebsocketClient.close(1e3, h || "Normal closure by client");
      else
        return Promise.resolve();
      return this.privDisconnectDeferral.promise;
    }
    get events() {
      return this.privConnectionEvents;
    }
    sendRawMessage(h) {
      try {
        if (!h)
          return Promise.resolve();
        if (this.onEvent(new l.ConnectionMessageSentEvent(this.privConnectionId, (/* @__PURE__ */ new Date()).toISOString(), h.Message)), this.isWebsocketOpen)
          this.privWebsocketClient.send(h.RawWebsocketMessage.payload);
        else
          return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + h.Message.id + " " + new Error().stack);
        return Promise.resolve();
      } catch (f) {
        return Promise.reject(`websocket send error: ${f}`);
      }
    }
    async onClose(h, f) {
      const g = `Connection closed. ${h}: ${f}`;
      this.privConnectionState = l.ConnectionState.Disconnected, this.privDisconnectDeferral.resolve(), await this.privReceivingMessageQueue.drainAndDispose(() => {
      }, g), await this.privSendMessageQueue.drainAndDispose((m) => {
        m.sendStatusDeferral.reject(g);
      }, g);
    }
    async processSendQueue() {
      for (; ; ) {
        const f = await this.privSendMessageQueue.dequeue();
        if (!f)
          return;
        try {
          await this.sendRawMessage(f), f.sendStatusDeferral.resolve();
        } catch (g) {
          f.sendStatusDeferral.reject(g);
        }
      }
    }
    onEvent(h) {
      this.privConnectionEvents.onEvent(h), l.Events.instance.onEvent(h);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAgent() {
      const h = new o.default.Agent(this.createConnection);
      return this.proxyInfo !== void 0 && this.proxyInfo.HostName !== void 0 && this.proxyInfo.Port > 0 && (h.proxyInfo = this.proxyInfo), h;
    }
    static GetProxyAgent(h) {
      const f = {
        host: h.HostName,
        port: h.Port
      };
      return h.UserName ? f.headers = {
        "Proxy-Authentication": "Basic " + new Buffer(`${h.UserName}:${h.Password === void 0 ? "" : h.Password}`).toString("base64")
      } : f.headers = {}, f.headers.requestOCSP = "true", new n.default(f);
    }
    createConnection(h, f) {
      let g;
      if (f = {
        ...f,
        requestOCSP: !0,
        servername: f.host
      }, this.proxyInfo) {
        const v = ja.GetProxyAgent(this.proxyInfo);
        g = new Promise((y, S) => {
          v.callback(h, f, (C, R) => {
            C ? S(C) : y(R);
          });
        });
      } else
        f.secureEndpoint ? g = Promise.resolve(a.connect(f)) : g = Promise.resolve(i.connect(f));
      return g;
    }
    get isWebsocketOpen() {
      return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
    }
  };
  return fe.WebsocketMessageAdapter = p, p.forceNpmWebSocket = !1, fe;
}
var ju;
function eR() {
  if (ju) return Dr;
  ju = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.WebsocketConnection = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ ev();
  let r = class {
    constructor(i, a, o, n, c, u = !1, l) {
      if (this.privIsDisposed = !1, !i)
        throw new e.ArgumentNullError("uri");
      if (!n)
        throw new e.ArgumentNullError("messageFormatter");
      this.privMessageFormatter = n;
      let p = "", d = 0;
      if (a) {
        for (const h in a)
          if (h) {
            p += d === 0 && i.indexOf("?") === -1 ? "?" : "&";
            const f = encodeURIComponent(h);
            p += f;
            let g = a[h];
            g && (g = encodeURIComponent(g), p += `=${g}`), d++;
          }
      }
      if (o) {
        for (const h in o)
          if (h) {
            p += d === 0 && i.indexOf("?") === -1 ? "?" : "&";
            const f = encodeURIComponent(o[h]);
            p += `${h}=${f}`, d++;
          }
      }
      this.privUri = i + p, this.privId = l || (0, e.createNoDashGuid)(), this.privConnectionMessageAdapter = new t.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, c, o, u);
    }
    async dispose() {
      this.privIsDisposed = !0, this.privConnectionMessageAdapter && await this.privConnectionMessageAdapter.close();
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    get id() {
      return this.privId;
    }
    get uri() {
      return this.privUri;
    }
    state() {
      return this.privConnectionMessageAdapter.state;
    }
    open() {
      return this.privConnectionMessageAdapter.open();
    }
    send(i) {
      return this.privConnectionMessageAdapter.send(i);
    }
    read() {
      return this.privConnectionMessageAdapter.read();
    }
    get events() {
      return this.privConnectionMessageAdapter.events;
    }
  };
  return Dr.WebsocketConnection = r, Dr;
}
var Nr = {}, qu;
function tR() {
  if (qu) return Nr;
  qu = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.ReplayableAudioNode = void 0;
  let e = class {
    constructor(s, i) {
      this.privBuffers = [], this.privReplayOffset = 0, this.privLastShrinkOffset = 0, this.privBufferStartOffset = 0, this.privBufferSerial = 0, this.privBufferedBytes = 0, this.privReplay = !1, this.privLastChunkAcquiredTime = 0, this.privAudioNode = s, this.privBytesPerSecond = i;
    }
    id() {
      return this.privAudioNode.id();
    }
    // Reads and returns the next chunk of audio buffer.
    // If replay of existing buffers are needed, read() will first seek and replay
    // existing content, and upoin completion it will read new content from the underlying
    // audio node, saving that content into the replayable buffers.
    read() {
      if (this.privReplay && this.privBuffers.length !== 0) {
        const s = this.privReplayOffset - this.privBufferStartOffset;
        let i = Math.round(s * this.privBytesPerSecond * 1e-7);
        i % 2 !== 0 && i++;
        let a = 0;
        for (; a < this.privBuffers.length && i >= this.privBuffers[a].chunk.buffer.byteLength; )
          i -= this.privBuffers[a++].chunk.buffer.byteLength;
        if (a < this.privBuffers.length) {
          const o = this.privBuffers[a].chunk.buffer.slice(i);
          return this.privReplayOffset += o.byteLength / this.privBytesPerSecond * 1e7, a === this.privBuffers.length - 1 && (this.privReplay = !1), Promise.resolve({
            buffer: o,
            isEnd: !1,
            timeReceived: this.privBuffers[a].chunk.timeReceived
          });
        }
      }
      return this.privAudioNode.read().then((s) => (s && s.buffer && this.privBuffers && (this.privBuffers.push(new t(s, this.privBufferSerial++, this.privBufferedBytes)), this.privBufferedBytes += s.buffer.byteLength), s));
    }
    detach() {
      return this.privBuffers = void 0, this.privAudioNode.detach();
    }
    replay() {
      this.privBuffers && this.privBuffers.length !== 0 && (this.privReplay = !0, this.privReplayOffset = this.privLastShrinkOffset);
    }
    // Shrinks the existing audio buffers to start at the new offset, or at the
    // beginning of the buffer closest to the requested offset.
    // A replay request will start from the last shrink point.
    shrinkBuffers(s) {
      if (this.privBuffers === void 0 || this.privBuffers.length === 0)
        return;
      this.privLastShrinkOffset = s;
      const i = s - this.privBufferStartOffset;
      let a = Math.round(i * this.privBytesPerSecond * 1e-7), o = 0;
      for (; o < this.privBuffers.length && a >= this.privBuffers[o].chunk.buffer.byteLength; )
        a -= this.privBuffers[o++].chunk.buffer.byteLength;
      this.privBufferStartOffset = Math.round(s - a / this.privBytesPerSecond * 1e7), this.privBuffers = this.privBuffers.slice(o);
    }
    // Finds the time a buffer of audio was first seen by offset.
    findTimeAtOffset(s) {
      if (s < this.privBufferStartOffset || this.privBuffers === void 0)
        return 0;
      for (const i of this.privBuffers) {
        const a = i.byteOffset / this.privBytesPerSecond * 1e7, o = a + i.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
        if (s >= a && s <= o)
          return i.chunk.timeReceived;
      }
      return 0;
    }
  };
  Nr.ReplayableAudioNode = e;
  class t {
    constructor(s, i, a) {
      this.chunk = s, this.serial = i, this.byteOffset = a;
    }
  }
  return Nr;
}
var xr = {}, Do = {}, ze = {}, we = {}, Fu;
function tv() {
  if (Fu) return we;
  Fu = 1;
  var e = we && we.__createBinding || (Object.create ? function(o, n, c, u) {
    u === void 0 && (u = c), Object.defineProperty(o, u, { enumerable: !0, get: function() {
      return n[c];
    } });
  } : function(o, n, c, u) {
    u === void 0 && (u = c), o[u] = n[c];
  }), t = we && we.__setModuleDefault || (Object.create ? function(o, n) {
    Object.defineProperty(o, "default", { enumerable: !0, value: n });
  } : function(o, n) {
    o.default = n;
  }), r = we && we.__importStar || function(o) {
    if (o && o.__esModule) return o;
    var n = {};
    if (o != null) for (var c in o) c !== "default" && Object.prototype.hasOwnProperty.call(o, c) && e(n, o, c);
    return t(n, o), n;
  };
  Object.defineProperty(we, "__esModule", { value: !0 }), we.AudioFileWriter = void 0;
  const s = r(kt), i = /* @__PURE__ */ z();
  let a = class {
    constructor(n) {
      i.Contracts.throwIfNullOrUndefined(s.openSync, `
File System access not available, please use Push or PullAudioOutputStream`), this.privFd = s.openSync(n, "w");
    }
    set format(n) {
      i.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set"), this.privAudioFormat = n;
      let c = 0;
      this.privAudioFormat.hasHeader && (c = this.privAudioFormat.header.byteLength), this.privFd !== void 0 && (this.privWriteStream = s.createWriteStream("", { fd: this.privFd, start: c, autoClose: !1 }));
    }
    write(n) {
      i.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing."), this.privWriteStream !== void 0 && this.privWriteStream.write(new Uint8Array(n.slice(0)));
    }
    close() {
      this.privFd !== void 0 && (this.privWriteStream.on("finish", () => {
        this.privAudioFormat.hasHeader && (this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten), s.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0)), s.closeSync(this.privFd), this.privFd = void 0;
      }), this.privWriteStream.end());
    }
    id() {
      return this.privId;
    }
  };
  return we.AudioFileWriter = a, we;
}
var ve = {}, Bu;
function rv() {
  if (Bu) return ve;
  Bu = 1, Object.defineProperty(ve, "__esModule", { value: !0 }), ve.PullAudioInputStreamImpl = ve.PullAudioInputStream = ve.PushAudioInputStreamImpl = ve.PushAudioInputStream = ve.AudioInputStream = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ Mt(), s = /* @__PURE__ */ A(), i = /* @__PURE__ */ Dt();
  let a = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member AudioInputStream.createPushStream
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The audio input stream being created.
     */
    static createPushStream(p) {
      return o.create(p);
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
     * and close() methods.
     * @member AudioInputStream.createPullStream
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
     * PullAudioInputStreamCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The audio input stream being created.
     */
    static createPullStream(p, d) {
      return c.create(p, d);
    }
  };
  ve.AudioInputStream = a;
  class o extends a {
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member PushAudioInputStream.create
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The push audio input stream being created.
     */
    static create(p) {
      return new n(p);
    }
  }
  ve.PushAudioInputStream = o;
  class n extends o {
    /**
     * Creates and initalizes an instance with the given values.
     * @constructor
     * @param {AudioStreamFormat} format - The audio stream format.
     */
    constructor(p) {
      super(), p === void 0 ? this.privFormat = i.AudioStreamFormatImpl.getDefaultInputFormat() : this.privFormat = p, this.privEvents = new t.EventSource(), this.privId = (0, r.createNoDashGuid)(), this.privStream = new t.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PushAudioInputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(p) {
      this.privStream.writeStreamChunk({
        buffer: p,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PushAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    async attach(p) {
      this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, p)), await this.turnOn();
      const d = this.privStream;
      return this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, p)), {
        detach: async () => (this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p)), this.turnOff()),
        id: () => p,
        read: () => d.read()
      };
    }
    detach(p) {
      this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PushStream",
        samplerate: this.privFormat.samplesPerSec,
        type: e.type.Stream
      });
    }
    onEvent(p) {
      this.privEvents.onEvent(p), t.Events.instance.onEvent(p);
    }
    toBuffer(p) {
      const d = Buffer.alloc(p.byteLength), h = new Uint8Array(p);
      for (let f = 0; f < d.length; ++f)
        d[f] = h[f];
      return d;
    }
  }
  ve.PushAudioInputStreamImpl = n;
  class c extends a {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @member PullAudioInputStream.create
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The push audio input stream being created.
     */
    static create(p, d) {
      return new u(p, d);
    }
  }
  ve.PullAudioInputStream = c;
  class u extends c {
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @constructor
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     */
    constructor(p, d) {
      super(), d === void 0 ? this.privFormat = s.AudioStreamFormat.getDefaultInputFormat() : this.privFormat = d, this.privEvents = new t.EventSource(), this.privId = (0, r.createNoDashGuid)(), this.privCallback = p, this.privIsClosed = !1, this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Closes the stream.
     * @member PullAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privIsClosed = !0, this.privCallback.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    async attach(p) {
      return this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, p)), await this.turnOn(), this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, p)), {
        detach: () => (this.privCallback.close(), this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p)), this.turnOff()),
        id: () => p,
        read: () => {
          let d = 0, h;
          for (; d < this.privBufferSize; ) {
            const f = new ArrayBuffer(this.privBufferSize - d), g = this.privCallback.read(f);
            if (h === void 0 ? h = f : new Int8Array(h).set(new Int8Array(f), d), g === 0)
              break;
            d += g;
          }
          return Promise.resolve({
            buffer: h.slice(0, d),
            isEnd: this.privIsClosed || d === 0,
            timeReceived: Date.now()
          });
        }
      };
    }
    detach(p) {
      this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PullStream",
        samplerate: this.privFormat.samplesPerSec,
        type: e.type.Stream
      });
    }
    onEvent(p) {
      this.privEvents.onEvent(p), t.Events.instance.onEvent(p);
    }
  }
  return ve.PullAudioInputStreamImpl = u, ve;
}
var ge = {}, zr = {}, No = {}, Uu;
function nv() {
  return Uu || (Uu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeechSynthesisOutputFormat = void 0, function(t) {
      t[t.Raw8Khz8BitMonoMULaw = 0] = "Raw8Khz8BitMonoMULaw", t[t.Riff16Khz16KbpsMonoSiren = 1] = "Riff16Khz16KbpsMonoSiren", t[t.Audio16Khz16KbpsMonoSiren = 2] = "Audio16Khz16KbpsMonoSiren", t[t.Audio16Khz32KBitRateMonoMp3 = 3] = "Audio16Khz32KBitRateMonoMp3", t[t.Audio16Khz128KBitRateMonoMp3 = 4] = "Audio16Khz128KBitRateMonoMp3", t[t.Audio16Khz64KBitRateMonoMp3 = 5] = "Audio16Khz64KBitRateMonoMp3", t[t.Audio24Khz48KBitRateMonoMp3 = 6] = "Audio24Khz48KBitRateMonoMp3", t[t.Audio24Khz96KBitRateMonoMp3 = 7] = "Audio24Khz96KBitRateMonoMp3", t[t.Audio24Khz160KBitRateMonoMp3 = 8] = "Audio24Khz160KBitRateMonoMp3", t[t.Raw16Khz16BitMonoTrueSilk = 9] = "Raw16Khz16BitMonoTrueSilk", t[t.Riff16Khz16BitMonoPcm = 10] = "Riff16Khz16BitMonoPcm", t[t.Riff8Khz16BitMonoPcm = 11] = "Riff8Khz16BitMonoPcm", t[t.Riff24Khz16BitMonoPcm = 12] = "Riff24Khz16BitMonoPcm", t[t.Riff8Khz8BitMonoMULaw = 13] = "Riff8Khz8BitMonoMULaw", t[t.Raw16Khz16BitMonoPcm = 14] = "Raw16Khz16BitMonoPcm", t[t.Raw24Khz16BitMonoPcm = 15] = "Raw24Khz16BitMonoPcm", t[t.Raw8Khz16BitMonoPcm = 16] = "Raw8Khz16BitMonoPcm", t[t.Ogg16Khz16BitMonoOpus = 17] = "Ogg16Khz16BitMonoOpus", t[t.Ogg24Khz16BitMonoOpus = 18] = "Ogg24Khz16BitMonoOpus", t[t.Raw48Khz16BitMonoPcm = 19] = "Raw48Khz16BitMonoPcm", t[t.Riff48Khz16BitMonoPcm = 20] = "Riff48Khz16BitMonoPcm", t[t.Audio48Khz96KBitRateMonoMp3 = 21] = "Audio48Khz96KBitRateMonoMp3", t[t.Audio48Khz192KBitRateMonoMp3 = 22] = "Audio48Khz192KBitRateMonoMp3", t[t.Ogg48Khz16BitMonoOpus = 23] = "Ogg48Khz16BitMonoOpus", t[t.Webm16Khz16BitMonoOpus = 24] = "Webm16Khz16BitMonoOpus", t[t.Webm24Khz16BitMonoOpus = 25] = "Webm24Khz16BitMonoOpus", t[t.Raw24Khz16BitMonoTrueSilk = 26] = "Raw24Khz16BitMonoTrueSilk", t[t.Raw8Khz8BitMonoALaw = 27] = "Raw8Khz8BitMonoALaw", t[t.Riff8Khz8BitMonoALaw = 28] = "Riff8Khz8BitMonoALaw", t[t.Webm24Khz16Bit24KbpsMonoOpus = 29] = "Webm24Khz16Bit24KbpsMonoOpus", t[t.Audio16Khz16Bit32KbpsMonoOpus = 30] = "Audio16Khz16Bit32KbpsMonoOpus", t[t.Audio24Khz16Bit48KbpsMonoOpus = 31] = "Audio24Khz16Bit48KbpsMonoOpus", t[t.Audio24Khz16Bit24KbpsMonoOpus = 32] = "Audio24Khz16Bit24KbpsMonoOpus", t[t.Raw22050Hz16BitMonoPcm = 33] = "Raw22050Hz16BitMonoPcm", t[t.Riff22050Hz16BitMonoPcm = 34] = "Riff22050Hz16BitMonoPcm", t[t.Raw44100Hz16BitMonoPcm = 35] = "Raw44100Hz16BitMonoPcm", t[t.Riff44100Hz16BitMonoPcm = 36] = "Riff44100Hz16BitMonoPcm", t[t.AmrWb16000Hz = 37] = "AmrWb16000Hz", t[t.G72216Khz64Kbps = 38] = "G72216Khz64Kbps";
    }(e.SpeechSynthesisOutputFormat || (e.SpeechSynthesisOutputFormat = {}));
  }(No)), No;
}
var $u;
function Cs() {
  if ($u) return zr;
  $u = 1, Object.defineProperty(zr, "__esModule", { value: !0 }), zr.AudioOutputFormatImpl = void 0;
  const e = /* @__PURE__ */ nv(), t = /* @__PURE__ */ Dt();
  class r extends t.AudioStreamFormatImpl {
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param formatTag
     * @param {number} channels - Number of channels.
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} avgBytesPerSec - Average bytes per second.
     * @param {number} blockAlign - Block alignment.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {string} audioFormatString - Audio format string
     * @param {string} requestAudioFormatString - Audio format string sent to service.
     * @param {boolean} hasHeader - If the format has header or not.
     */
    constructor(i, a, o, n, c, u, l, p, d) {
      super(o, u, a, i), this.formatTag = i, this.avgBytesPerSec = n, this.blockAlign = c, this.priAudioFormatString = l, this.priRequestAudioFormatString = p, this.priHasHeader = d;
    }
    static fromSpeechSynthesisOutputFormat(i) {
      return i === void 0 ? r.getDefaultOutputFormat() : r.fromSpeechSynthesisOutputFormatString(r.SpeechSynthesisOutputFormatToString[i]);
    }
    static fromSpeechSynthesisOutputFormatString(i) {
      switch (i) {
        case "raw-8khz-8bit-mono-mulaw":
          return new r(t.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, i, i, !1);
        case "riff-16khz-16kbps-mono-siren":
          return new r(t.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, i, "audio-16khz-16kbps-mono-siren", !0);
        case "audio-16khz-16kbps-mono-siren":
          return new r(t.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, i, i, !1);
        case "audio-16khz-32kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 4096, 2, 16, i, i, !1);
        case "audio-16khz-128kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 16384, 2, 16, i, i, !1);
        case "audio-16khz-64kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 8192, 2, 16, i, i, !1);
        case "audio-24khz-48kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 6144, 2, 16, i, i, !1);
        case "audio-24khz-96kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 12288, 2, 16, i, i, !1);
        case "audio-24khz-160kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 20480, 2, 16, i, i, !1);
        case "raw-16khz-16bit-mono-truesilk":
          return new r(t.AudioFormatTag.SILKSkype, 1, 16e3, 32e3, 2, 16, i, i, !1);
        case "riff-8khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, i, "raw-8khz-16bit-mono-pcm", !0);
        case "riff-24khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, i, "raw-24khz-16bit-mono-pcm", !0);
        case "riff-8khz-8bit-mono-mulaw":
          return new r(t.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, i, "raw-8khz-8bit-mono-mulaw", !0);
        case "raw-16khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, i, "raw-16khz-16bit-mono-pcm", !1);
        case "raw-24khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, i, "raw-24khz-16bit-mono-pcm", !1);
        case "raw-8khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, i, "raw-8khz-16bit-mono-pcm", !1);
        case "ogg-16khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 16e3, 8192, 2, 16, i, i, !1);
        case "ogg-24khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 24e3, 8192, 2, 16, i, i, !1);
        case "raw-48khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, i, "raw-48khz-16bit-mono-pcm", !1);
        case "riff-48khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, i, "raw-48khz-16bit-mono-pcm", !0);
        case "audio-48khz-96kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 48e3, 12288, 2, 16, i, i, !1);
        case "audio-48khz-192kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 48e3, 24576, 2, 16, i, i, !1);
        case "ogg-48khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 48e3, 12e3, 2, 16, i, i, !1);
        case "webm-16khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 16e3, 4e3, 2, 16, i, i, !1);
        case "webm-24khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 24e3, 6e3, 2, 16, i, i, !1);
        case "webm-24khz-16bit-24kbps-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 24e3, 3e3, 2, 16, i, i, !1);
        case "audio-16khz-16bit-32kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 16e3, 4e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-48kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 24e3, 6e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-24kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 24e3, 3e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-mono-flac":
          return new r(t.AudioFormatTag.FLAC, 1, 24e3, 24e3, 2, 16, i, i, !1);
        case "audio-48khz-16bit-mono-flac":
          return new r(t.AudioFormatTag.FLAC, 1, 48e3, 3e4, 2, 16, i, i, !1);
        case "raw-24khz-16bit-mono-truesilk":
          return new r(t.AudioFormatTag.SILKSkype, 1, 24e3, 48e3, 2, 16, i, i, !1);
        case "raw-8khz-8bit-mono-alaw":
          return new r(t.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, i, i, !1);
        case "riff-8khz-8bit-mono-alaw":
          return new r(t.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, i, "raw-8khz-8bit-mono-alaw", !0);
        case "raw-22050hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, i, i, !1);
        case "riff-22050hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, i, "raw-22050hz-16bit-mono-pcm", !0);
        case "raw-44100hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, i, i, !1);
        case "riff-44100hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, i, "raw-44100hz-16bit-mono-pcm", !0);
        case "amr-wb-16000h":
          return new r(t.AudioFormatTag.AMR_WB, 1, 16e3, 3052, 2, 16, i, i, !1);
        case "g722-16khz-64kbps":
          return new r(t.AudioFormatTag.G722, 1, 16e3, 8e3, 2, 16, i, i, !1);
        case "riff-16khz-16bit-mono-pcm":
        default:
          return new r(t.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", !0);
      }
    }
    static getDefaultOutputFormat() {
      return r.fromSpeechSynthesisOutputFormatString(typeof window < "u" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
    }
    /**
     * Specifies if this audio output format has a header
     * @boolean AudioOutputFormatImpl.prototype.hasHeader
     * @function
     * @public
     */
    get hasHeader() {
      return this.priHasHeader;
    }
    /**
     * Specifies the header of this format
     * @ArrayBuffer AudioOutputFormatImpl.prototype.header
     * @function
     * @public
     */
    get header() {
      if (this.hasHeader)
        return this.privHeader;
    }
    /**
     * Updates the header based on the audio length
     * @member AudioOutputFormatImpl.updateHeader
     * @function
     * @public
     * @param {number} audioLength - the audio length
     */
    updateHeader(i) {
      if (this.priHasHeader) {
        const a = new DataView(this.privHeader);
        a.setUint32(4, i + this.privHeader.byteLength - 8, !0), a.setUint32(40, i, !0);
      }
    }
    /**
     * Specifies the audio format string to be sent to the service
     * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
     * @function
     * @public
     */
    get requestAudioFormatString() {
      return this.priRequestAudioFormatString;
    }
    /**
     * Adds audio header
     * @param audio the raw audio without header
     * @returns the audio with header if applicable
     */
    addHeader(i) {
      if (!this.hasHeader)
        return i;
      this.updateHeader(i.byteLength);
      const a = new Uint8Array(i.byteLength + this.header.byteLength);
      return a.set(new Uint8Array(this.header), 0), a.set(new Uint8Array(i), this.header.byteLength), a.buffer;
    }
  }
  return zr.AudioOutputFormatImpl = r, r.SpeechSynthesisOutputFormatToString = {
    [e.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
    [e.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
    [e.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
    [e.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
    [e.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
    [e.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
    [e.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
    [e.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
    [e.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.AmrWb16000Hz]: "amr-wb-16000hz",
    [e.SpeechSynthesisOutputFormat.G72216Khz64Kbps]: "g722-16khz-64kbps"
  }, zr;
}
var Vu;
function Wt() {
  if (Vu) return ge;
  Vu = 1, Object.defineProperty(ge, "__esModule", { value: !0 }), ge.PushAudioOutputStreamImpl = ge.PushAudioOutputStream = ge.PullAudioOutputStreamImpl = ge.PullAudioOutputStream = ge.AudioOutputStream = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ Cs();
  let s = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member AudioOutputStream.createPullStream
     * @function
     * @public
     * @returns {PullAudioOutputStream} The audio output stream being created.
     */
    static createPullStream() {
      return i.create();
    }
  };
  ge.AudioOutputStream = s;
  class i extends s {
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member PullAudioOutputStream.create
     * @function
     * @public
     * @returns {PullAudioOutputStream} The push audio output stream being created.
     */
    static create() {
      return new a();
    }
  }
  ge.PullAudioOutputStream = i;
  class a extends i {
    /**
     * Creates and initializes an instance with the given values.
     * @constructor
     */
    constructor() {
      super(), this.privId = (0, e.createNoDashGuid)(), this.privStream = new e.Stream();
    }
    /**
     * Sets the format information to the stream. For internal use only.
     * @param {AudioStreamFormat} format - the format to be set.
     */
    set format(u) {
      u == null && (this.privFormat = r.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privFormat = u;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privFormat;
    }
    /**
     * Checks if the stream is closed
     * @member PullAudioOutputStreamImpl.prototype.isClosed
     * @property
     * @public
     */
    get isClosed() {
      return this.privStream.isClosed;
    }
    /**
     * Gets the id of the stream
     * @member PullAudioOutputStreamImpl.prototype.id
     * @property
     * @public
     */
    id() {
      return this.privId;
    }
    /**
     * Reads audio data from the internal buffer.
     * @member PullAudioOutputStreamImpl.prototype.read
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
     * @returns {Promise<number>} - Audio buffer length has been read.
     */
    async read(u) {
      const l = new Int8Array(u);
      let p = 0;
      if (this.privLastChunkView !== void 0) {
        if (this.privLastChunkView.length > u.byteLength)
          return l.set(this.privLastChunkView.slice(0, u.byteLength)), this.privLastChunkView = this.privLastChunkView.slice(u.byteLength), Promise.resolve(u.byteLength);
        l.set(this.privLastChunkView), p = this.privLastChunkView.length, this.privLastChunkView = void 0;
      }
      for (; p < u.byteLength && !this.privStream.isReadEnded; ) {
        const d = await this.privStream.read();
        if (d !== void 0 && !d.isEnd) {
          let h;
          d.buffer.byteLength > u.byteLength - p ? (h = d.buffer.slice(0, u.byteLength - p), this.privLastChunkView = new Int8Array(d.buffer.slice(u.byteLength - p))) : h = d.buffer, l.set(new Int8Array(h), p), p += h.byteLength;
        } else
          this.privStream.readEnded();
      }
      return p;
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PullAudioOutputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(u) {
      t.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing"), this.privStream.writeStreamChunk({
        buffer: u,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PullAudioOutputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
  }
  ge.PullAudioOutputStreamImpl = a;
  class o extends s {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * write() and close() methods.
     * @member PushAudioOutputStream.create
     * @function
     * @public
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     * @returns {PushAudioOutputStream} The push audio output stream being created.
     */
    static create(u) {
      return new n(u);
    }
  }
  ge.PushAudioOutputStream = o;
  class n extends o {
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * read() and close() methods.
     * @constructor
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     */
    constructor(u) {
      super(), this.privId = (0, e.createNoDashGuid)(), this.privCallback = u;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set format(u) {
    }
    write(u) {
      this.privCallback.write && this.privCallback.write(u);
    }
    close() {
      this.privCallback.close && this.privCallback.close();
    }
    id() {
      return this.privId;
    }
  }
  return ge.PushAudioOutputStreamImpl = n, ge;
}
var Wu;
function sv() {
  if (Wu) return ze;
  Wu = 1, Object.defineProperty(ze, "__esModule", { value: !0 }), ze.AudioOutputConfigImpl = ze.AudioConfigImpl = ze.AudioConfig = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ tv(), i = /* @__PURE__ */ rv(), a = /* @__PURE__ */ Wt();
  let o = class iv {
    /**
     * Creates an AudioConfig object representing the default microphone on the system.
     * @member AudioConfig.fromDefaultMicrophoneInput
     * @function
     * @public
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromDefaultMicrophoneInput() {
      const l = new e.PcmRecorder(!0);
      return new n(new e.MicAudioSource(l));
    }
    /**
     * Creates an AudioConfig object representing a microphone with the specified device ID.
     * @member AudioConfig.fromMicrophoneInput
     * @function
     * @public
     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
     * Default microphone is used the value is omitted.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromMicrophoneInput(l) {
      const p = new e.PcmRecorder(!0);
      return new n(new e.MicAudioSource(p, l));
    }
    /**
     * Creates an AudioConfig object representing the specified file.
     * @member AudioConfig.fromWavFileInput
     * @function
     * @public
     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromWavFileInput(l, p = "unnamedBuffer.wav") {
      return new n(new e.FileAudioSource(l, p));
    }
    /**
     * Creates an AudioConfig object representing the specified stream.
     * @member AudioConfig.fromStreamInput
     * @function
     * @public
     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
     * stream. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromStreamInput(l) {
      if (l instanceof r.PullAudioInputStreamCallback)
        return new n(new i.PullAudioInputStreamImpl(l));
      if (l instanceof r.AudioInputStream)
        return new n(l);
      if (typeof MediaStream < "u" && l instanceof MediaStream) {
        const p = new e.PcmRecorder(!1);
        return new n(new e.MicAudioSource(p, null, null, l));
      }
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing the default speaker.
     * @member AudioConfig.fromDefaultSpeakerOutput
     * @function
     * @public
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromDefaultSpeakerOutput() {
      return new c(new r.SpeakerAudioDestination());
    }
    /**
     * Creates an AudioConfig object representing the custom IPlayer object.
     * You can use the IPlayer object to control pause, resume, etc.
     * @member AudioConfig.fromSpeakerOutput
     * @function
     * @public
     * @param {IPlayer} player - the IPlayer object for playback.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.12.0
     */
    static fromSpeakerOutput(l) {
      if (l === void 0)
        return iv.fromDefaultSpeakerOutput();
      if (l instanceof r.SpeakerAudioDestination)
        return new c(l);
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing a specified output audio file
     * @member AudioConfig.fromAudioFileOutput
     * @function
     * @public
     * @param {PathLike} filename - the filename of the output audio file
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromAudioFileOutput(l) {
      return new c(new s.AudioFileWriter(l));
    }
    /**
     * Creates an AudioConfig object representing a specified audio output stream
     * @member AudioConfig.fromStreamOutput
     * @function
     * @public
     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
     * stream.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromStreamOutput(l) {
      if (l instanceof r.PushAudioOutputStreamCallback)
        return new c(new a.PushAudioOutputStreamImpl(l));
      if (l instanceof r.PushAudioOutputStream)
        return new c(l);
      if (l instanceof r.PullAudioOutputStream)
        return new c(l);
      throw new Error("Not Supported Type");
    }
  };
  ze.AudioConfig = o;
  class n extends o {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioSource} source - An audio source.
     */
    constructor(l) {
      super(), this.privSource = l;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privSource.format;
    }
    /**
     * @member AudioConfigImpl.prototype.close
     * @function
     * @public
     */
    close(l, p) {
      this.privSource.turnOff().then(() => {
        l && l();
      }, (d) => {
        p && p(d);
      });
    }
    /**
     * @member AudioConfigImpl.prototype.id
     * @function
     * @public
     */
    id() {
      return this.privSource.id();
    }
    /**
     * @member AudioConfigImpl.prototype.turnOn
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOn() {
      return this.privSource.turnOn();
    }
    /**
     * @member AudioConfigImpl.prototype.attach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     * @returns {Promise<IAudioStreamNode>} A promise.
     */
    attach(l) {
      return this.privSource.attach(l);
    }
    /**
     * @member AudioConfigImpl.prototype.detach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     */
    detach(l) {
      return this.privSource.detach(l);
    }
    /**
     * @member AudioConfigImpl.prototype.turnOff
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOff() {
      return this.privSource.turnOff();
    }
    /**
     * @member AudioConfigImpl.prototype.events
     * @function
     * @public
     * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
     */
    get events() {
      return this.privSource.events;
    }
    setProperty(l, p) {
      if (t.Contracts.throwIfNull(p, "value"), this.privSource.setProperty !== void 0)
        this.privSource.setProperty(l, p);
      else
        throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty(l, p) {
      if (this.privSource.getProperty !== void 0)
        return this.privSource.getProperty(l, p);
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
    get deviceInfo() {
      return this.privSource.deviceInfo;
    }
  }
  ze.AudioConfigImpl = n;
  class c extends o {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioDestination} destination - An audio destination.
     */
    constructor(l) {
      super(), this.privDestination = l;
    }
    set format(l) {
      this.privDestination.format = l;
    }
    write(l) {
      this.privDestination.write(l);
    }
    close() {
      this.privDestination.close();
    }
    id() {
      return this.privDestination.id();
    }
    setProperty() {
      throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty() {
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
  }
  return ze.AudioOutputConfigImpl = c, ze;
}
var xo = {}, Hu;
function rR() {
  return Hu || (Hu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationReason = void 0, function(t) {
      t[t.Error = 0] = "Error", t[t.EndOfStream = 1] = "EndOfStream";
    }(e.CancellationReason || (e.CancellationReason = {}));
  }(xo)), xo;
}
var Lr = {}, Ku;
function nR() {
  if (Ku) return Lr;
  Ku = 1, Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.PullAudioInputStreamCallback = void 0;
  let e = class {
  };
  return Lr.PullAudioInputStreamCallback = e, Lr;
}
var jr = {}, Ju;
function iR() {
  if (Ju) return jr;
  Ju = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.PushAudioOutputStreamCallback = void 0;
  let e = class {
  };
  return jr.PushAudioOutputStreamCallback = e, jr;
}
var qr = {}, Gu;
function sR() {
  if (Gu) return qr;
  Gu = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.KeywordRecognitionModel = void 0;
  const e = /* @__PURE__ */ z();
  let t = class {
    /**
     * Create and initializes a new instance.
     * @constructor
     */
    constructor() {
      this.privDisposed = !1;
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromFile
     * @function
     * @public
     * @param {string} fileName - A string that represents file name for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model
     * will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */
    static fromFile(s) {
      throw e.Contracts.throwIfFileDoesNotExist(s, "fileName"), new Error("Not yet implemented.");
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromStream
     * @function
     * @public
     * @param {string} file - A File that represents file for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */
    static fromStream(s) {
      throw e.Contracts.throwIfNull(s, "file"), new Error("Not yet implemented.");
    }
    /**
     * Dispose of associated resources.
     * @member KeywordRecognitionModel.prototype.close
     * @function
     * @public
     */
    close() {
      this.privDisposed || (this.privDisposed = !0);
    }
  };
  return qr.KeywordRecognitionModel = t, qr;
}
var Fr = {}, Qu;
function oR() {
  if (Qu) return Fr;
  Qu = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.SessionEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionId - The session id.
     */
    constructor(r) {
      this.privSessionId = r;
    }
    /**
     * Represents the session identifier.
     * @member SessionEventArgs.prototype.sessionId
     * @function
     * @public
     * @returns {string} Represents the session identifier.
     */
    get sessionId() {
      return this.privSessionId;
    }
  };
  return Fr.SessionEventArgs = e, Fr;
}
var Br = {}, Yu;
function aR() {
  if (Yu) return Br;
  Yu = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.RecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(s, i) {
      super(i), this.privOffset = s;
    }
    /**
     * Represents the message offset
     * @member RecognitionEventArgs.prototype.offset
     * @function
     * @public
     */
    get offset() {
      return this.privOffset;
    }
  };
  return Br.RecognitionEventArgs = t, Br;
}
var zo = {}, Zu;
function cR() {
  return Zu || (Zu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OutputFormat = void 0, function(t) {
      t[t.Simple = 0] = "Simple", t[t.Detailed = 1] = "Detailed";
    }(e.OutputFormat || (e.OutputFormat = {}));
  }(zo)), zo;
}
var Ur = {}, Xu;
function uR() {
  if (Xu) return Ur;
  Xu = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.IntentRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param result - The result of the intent recognition.
     * @param offset - The offset.
     * @param sessionId - The session id.
     */
    constructor(s, i, a) {
      super(i, a), this.privResult = s;
    }
    /**
     * Represents the intent recognition result.
     * @member IntentRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {IntentRecognitionResult} Represents the intent recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Ur.IntentRecognitionEventArgs = t, Ur;
}
var $r = {}, el;
function lR() {
  if (el) return $r;
  el = 1, Object.defineProperty($r, "__esModule", { value: !0 }), $r.RecognitionResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, i, a, o, n, c, u, l, p) {
      this.privResultId = r, this.privReason = s, this.privText = i, this.privDuration = a, this.privOffset = o, this.privLanguage = n, this.privLanguageDetectionConfidence = c, this.privErrorDetails = u, this.privJson = l, this.privProperties = p;
    }
    /**
     * Specifies the result identifier.
     * @member RecognitionResult.prototype.resultId
     * @function
     * @public
     * @returns {string} Specifies the result identifier.
     */
    get resultId() {
      return this.privResultId;
    }
    /**
     * Specifies status of the result.
     * @member RecognitionResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} Specifies status of the result.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * Presents the recognized text in the result.
     * @member RecognitionResult.prototype.text
     * @function
     * @public
     * @returns {string} Presents the recognized text in the result.
     */
    get text() {
      return this.privText;
    }
    /**
     * Duration of recognized speech in 100 nano second increments.
     * @member RecognitionResult.prototype.duration
     * @function
     * @public
     * @returns {number} Duration of recognized speech in 100 nano second increments.
     */
    get duration() {
      return this.privDuration;
    }
    /**
     * Offset of recognized speech in 100 nano second increments.
     * @member RecognitionResult.prototype.offset
     * @function
     * @public
     * @returns {number} Offset of recognized speech in 100 nano second increments.
     */
    get offset() {
      return this.privOffset;
    }
    /**
     * Primary Language detected.
     * @member RecognitionResult.prototype.language
     * @function
     * @public
     * @returns {string} language detected.
     */
    get language() {
      return this.privLanguage;
    }
    /**
     * Primary Language detection confidence (Unknown, Low, Medium, High).
     * @member RecognitionResult.prototype.languageDetectionConfidence
     * @function
     * @public
     * @returns {string} detection confidence strength.
     */
    get languageDetectionConfidence() {
      return this.privLanguageDetectionConfidence;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member RecognitionResult.prototype.errorDetails
     * @function
     * @public
     * @returns {string} a brief description of an error.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * A string containing Json serialized recognition result as it was received from the service.
     * @member RecognitionResult.prototype.json
     * @function
     * @private
     * @returns {string} Json serialized representation of the result.
     */
    get json() {
      return this.privJson;
    }
    /**
     * The set of properties exposed in the result.
     * @member RecognitionResult.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The set of properties exposed in the result.
     */
    get properties() {
      return this.privProperties;
    }
  };
  return $r.RecognitionResult = e, $r;
}
var Vr = {}, tl;
function pR() {
  if (tl) return Vr;
  tl = 1, Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.SpeechRecognitionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription, if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(s, i, a, o, n, c, u, l, p, d, h) {
      super(s, i, a, o, n, c, u, p, d, h), this.privSpeakerId = l;
    }
    /**
     * speaker id from conversation transcription/id scenarios
     * @member SpeechRecognitionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return Vr.SpeechRecognitionResult = t, Vr;
}
var Wr = {}, rl;
function dR() {
  if (rl) return Wr;
  rl = 1, Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.IntentRecognitionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param intentId - The intent id.
     * @param resultId - The result id.
     * @param reason - The reason.
     * @param text - The recognized text.
     * @param duration - The duration.
     * @param offset - The offset into the stream.
     * @param language - Primary Language detected, if provided.
     * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param errorDetails - Error details, if provided.
     * @param json - Additional Json, if provided.
     * @param properties - Additional properties, if provided.
     */
    constructor(s, i, a, o, n, c, u, l, p, d, h) {
      super(i, a, o, n, c, u, l, void 0, p, d, h), this.privIntentId = s;
    }
    /**
     * A String that represents the intent identifier being recognized.
     * @member IntentRecognitionResult.prototype.intentId
     * @function
     * @public
     * @returns {string} A String that represents the intent identifier being recognized.
     */
    get intentId() {
      return this.privIntentId;
    }
  };
  return Wr.IntentRecognitionResult = t, Wr;
}
var pt = {}, nl;
function hR() {
  if (nl) return pt;
  nl = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.LanguageUnderstandingModelImpl = pt.LanguageUnderstandingModel = void 0;
  const e = /* @__PURE__ */ z();
  let t = class {
    /**
     * Creates and initializes a new instance
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates an language understanding model using the specified endpoint.
     * @member LanguageUnderstandingModel.fromEndpoint
     * @function
     * @public
     * @param {URL} uri - A String that represents the endpoint of the language understanding model.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromEndpoint(i) {
      e.Contracts.throwIfNull(i, "uri"), e.Contracts.throwIfNullOrWhitespace(i.hostname, "uri");
      const a = new r(), o = i.host.indexOf(".");
      if (o === -1)
        throw new Error("Could not determine region from endpoint");
      a.region = i.host.substr(0, o);
      const n = i.pathname.lastIndexOf("/") + 1;
      if (n === -1)
        throw new Error("Could not determine appId from endpoint");
      if (a.appId = i.pathname.substr(n), a.subscriptionKey = i.searchParams.get("subscription-key"), a.subscriptionKey === void 0)
        throw new Error("Could not determine subscription key from endpoint");
      return a;
    }
    /**
     * Creates an language understanding model using the application id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromAppId
     * @function
     * @public
     * @param {string} appId - A String that represents the application id of Language Understanding service.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromAppId(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "appId");
      const a = new r();
      return a.appId = i, a;
    }
    /**
     * Creates a language understanding model using hostname, subscription key and application
     * id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - A String that represents the subscription key of
     * Language Understanding service.
     * @param {string} appId - A String that represents the application id of Language
     * Understanding service.
     * @param {LanguageUnderstandingModel} region - A String that represents the region
     * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromSubscription(i, a, o) {
      e.Contracts.throwIfNullOrWhitespace(i, "subscriptionKey"), e.Contracts.throwIfNullOrWhitespace(a, "appId"), e.Contracts.throwIfNullOrWhitespace(o, "region");
      const n = new r();
      return n.appId = a, n.region = o, n.subscriptionKey = i, n;
    }
  };
  pt.LanguageUnderstandingModel = t;
  class r extends t {
  }
  return pt.LanguageUnderstandingModelImpl = r, pt;
}
var Le = {}, il;
function fR() {
  if (il) return Le;
  il = 1, Object.defineProperty(Le, "__esModule", { value: !0 }), Le.MeetingTranscriptionEventArgs = Le.ConversationTranscriptionEventArgs = Le.SpeechRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechRecognitionResult} result - The speech recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(a, o, n) {
      super(o, n), this.privResult = a;
    }
    /**
     * Specifies the recognition result.
     * @member SpeechRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  Le.SpeechRecognitionEventArgs = t;
  class r extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranscriptionResult} result - The conversation transcription result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(a, o, n) {
      super(o, n), this.privResult = a;
    }
    /**
     * Specifies the transcription result.
     * @member ConversationTranscription1EventArgs.prototype.result
     * @function
     * @public
     * @returns {ConversationTranscriptionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  }
  Le.ConversationTranscriptionEventArgs = r;
  class s extends t {
  }
  return Le.MeetingTranscriptionEventArgs = s, Le;
}
var Hr = {}, Kr = {}, sl;
function Rs() {
  if (sl) return Kr;
  sl = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.CancellationEventArgsBase = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(s, i, a, o, n) {
      super(o, n), this.privReason = s, this.privErrorDetails = i, this.privErrorCode = a;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationEventArgsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful operation.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful operation, provides details of the occurred error.
     * @member CancellationEventArgsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return Kr.CancellationEventArgsBase = t, Kr;
}
var ol;
function vR() {
  if (ol) return Hr;
  ol = 1, Object.defineProperty(Hr, "__esModule", { value: !0 }), Hr.SpeechRecognitionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Rs();
  let t = class extends e.CancellationEventArgsBase {
  };
  return Hr.SpeechRecognitionCanceledEventArgs = t, Hr;
}
var Jr = {}, al;
function gR() {
  if (al) return Jr;
  al = 1, Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.TranslationRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationRecognitionResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(s, i, a) {
      super(i, a), this.privResult = s;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Jr.TranslationRecognitionEventArgs = t, Jr;
}
var Gr = {}, cl;
function mR() {
  if (cl) return Gr;
  cl = 1, Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.TranslationSynthesisEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationSynthesisResult} result - The translation synthesis result.
     * @param {string} sessionId - The session id.
     */
    constructor(s, i) {
      super(i), this.privResult = s;
    }
    /**
     * Specifies the translation synthesis result.
     * @member TranslationSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Gr.TranslationSynthesisEventArgs = t, Gr;
}
var Qr = {}, ul;
function av() {
  if (ul) return Qr;
  ul = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.TranslationRecognitionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class ov extends e.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {Translations} translations - The translations.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(s, i, a, o, n, c, u, l, p, d, h) {
      super(i, a, o, n, c, u, l, void 0, p, d, h), this.privTranslations = s;
    }
    static fromSpeechRecognitionResult(s) {
      return new ov(void 0, s.resultId, s.reason, s.text, s.duration, s.offset, s.language, s.languageDetectionConfidence, s.errorDetails, s.json, s.properties);
    }
    /**
     * Presents the translation results. Each item in the dictionary represents
     * a translation result in one of target languages, where the key is the name
     * of the target language, in BCP-47 format, and the value is the translation
     * text in the specified language.
     * @member TranslationRecognitionResult.prototype.translations
     * @function
     * @public
     * @returns {Translations} the current translation map that holds all translations requested.
     */
    get translations() {
      return this.privTranslations;
    }
  };
  return Qr.TranslationRecognitionResult = t, Qr;
}
var Yr = {}, ll;
function yR() {
  if (ll) return Yr;
  ll = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.TranslationSynthesisResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ResultReason} reason - The synthesis reason.
     * @param {ArrayBuffer} audio - The audio data.
     */
    constructor(r, s) {
      this.privReason = r, this.privAudio = s;
    }
    /**
     * Translated text in the target language.
     * @member TranslationSynthesisResult.prototype.audio
     * @function
     * @public
     * @returns {ArrayBuffer} Translated audio in the target language.
     */
    get audio() {
      return this.privAudio;
    }
    /**
     * The synthesis status.
     * @member TranslationSynthesisResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} The synthesis status.
     */
    get reason() {
      return this.privReason;
    }
  };
  return Yr.TranslationSynthesisResult = e, Yr;
}
var Lo = {}, pl;
function SR() {
  return pl || (pl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ResultReason = void 0, function(t) {
      t[t.NoMatch = 0] = "NoMatch", t[t.Canceled = 1] = "Canceled", t[t.RecognizingSpeech = 2] = "RecognizingSpeech", t[t.RecognizedSpeech = 3] = "RecognizedSpeech", t[t.RecognizedKeyword = 4] = "RecognizedKeyword", t[t.RecognizingIntent = 5] = "RecognizingIntent", t[t.RecognizedIntent = 6] = "RecognizedIntent", t[t.TranslatingSpeech = 7] = "TranslatingSpeech", t[t.TranslatedSpeech = 8] = "TranslatedSpeech", t[t.SynthesizingAudio = 9] = "SynthesizingAudio", t[t.SynthesizingAudioCompleted = 10] = "SynthesizingAudioCompleted", t[t.SynthesizingAudioStarted = 11] = "SynthesizingAudioStarted", t[t.EnrollingVoiceProfile = 12] = "EnrollingVoiceProfile", t[t.EnrolledVoiceProfile = 13] = "EnrolledVoiceProfile", t[t.RecognizedSpeakers = 14] = "RecognizedSpeakers", t[t.RecognizedSpeaker = 15] = "RecognizedSpeaker", t[t.ResetVoiceProfile = 16] = "ResetVoiceProfile", t[t.DeletedVoiceProfile = 17] = "DeletedVoiceProfile", t[t.VoicesListRetrieved = 18] = "VoicesListRetrieved", t[t.TranslatingParticipantSpeech = 19] = "TranslatingParticipantSpeech", t[t.TranslatedParticipantSpeech = 20] = "TranslatedParticipantSpeech", t[t.TranslatedInstantMessage = 21] = "TranslatedInstantMessage", t[t.TranslatedParticipantInstantMessage = 22] = "TranslatedParticipantInstantMessage";
    }(e.ResultReason || (e.ResultReason = {}));
  }(Lo)), Lo;
}
var dt = {}, dl;
function CR() {
  if (dl) return dt;
  dl = 1, Object.defineProperty(dt, "__esModule", { value: !0 }), dt.SpeechConfigImpl = dt.SpeechConfig = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A();
  let s = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * @member SpeechConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} The speech factory
     */
    static fromSubscription(o, n) {
      t.Contracts.throwIfNullOrWhitespace(o, "subscriptionKey"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c.setProperty(r.PropertyId.SpeechServiceConnection_IntentRegion, n), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, o), c;
    }
    /**
     * Internal implementation of fromEndpoint() overloads. Accepts either a subscription key or a TokenCredential.
     * @private
     */
    static fromEndpoint(o, n) {
      t.Contracts.throwIfNull(o, "endpoint");
      const c = typeof n == "string" && n.trim().length > 0, u = typeof n == "object" && n !== null && typeof n.getToken == "function";
      if (n !== void 0 && !c && !u)
        throw new Error("Invalid 'auth' parameter: must be a non-empty key string or a valid TokenCredential object.");
      const l = typeof n == "object" ? new i(n) : new i();
      return l.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, o.href), typeof n == "string" && n.trim().length > 0 && l.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), l;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(o, n) {
      t.Contracts.throwIfNull(o, "hostName");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Host, o.protocol + "//" + o.hostname + (o.port === "" ? "" : ":" + o.port)), c.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), n !== void 0 && c.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), c;
    }
    /**
     * Creates an instance of the speech factory with specified initial authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
     * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
     * the new token value will not apply to recognizers that have already been created. For recognizers
     * that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The initial authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromAuthorizationToken(o, n) {
      t.Contracts.throwIfNull(o, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c.setProperty(r.PropertyId.SpeechServiceConnection_IntentRegion, n), c.authorizationToken = o, c;
    }
    /**
     * Closes the configuration.
     * @member SpeechConfig.prototype.close
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    close() {
    }
  };
  dt.SpeechConfig = s;
  class i extends s {
    constructor(o) {
      super(), this.privProperties = new r.PropertyCollection(), this.speechRecognitionLanguage = "en-US", this.outputFormat = r.OutputFormat.Simple, this.privTokenCredential = o;
    }
    get properties() {
      return this.privProperties;
    }
    get endPoint() {
      return new URL(this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint));
    }
    get subscriptionKey() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Key);
    }
    get region() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Region);
    }
    get authorizationToken() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(o) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, o);
    }
    get speechRecognitionLanguage() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    set speechRecognitionLanguage(o) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, o);
    }
    get autoDetectSourceLanguages() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
    }
    set autoDetectSourceLanguages(o) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, o);
    }
    get outputFormat() {
      return r.OutputFormat[this.privProperties.getProperty(e.OutputFormatPropertyName, void 0)];
    }
    set outputFormat(o) {
      this.privProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[o]);
    }
    get endpointId() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId);
    }
    set endpointId(o) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_EndpointId, o);
    }
    get tokenCredential() {
      return this.privTokenCredential;
    }
    setProperty(o, n) {
      t.Contracts.throwIfNull(n, "value"), this.privProperties.setProperty(o, n);
    }
    getProperty(o, n) {
      return this.privProperties.getProperty(o, n);
    }
    setProxy(o, n, c, u) {
      this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyHostName], o), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPort], n), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    setServiceProperty(o, n) {
      const c = JSON.parse(this.privProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
      c[o] = n, this.privProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(o) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_ProfanityOption, r.ProfanityOption[o]);
    }
    enableAudioLogging() {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true"), this.privProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Detailed]);
    }
    enableDictation() {
      this.privProperties.setProperty(e.ForceDictationPropertyName, "true");
    }
    clone() {
      const o = new i(this.tokenCredential);
      return o.privProperties = this.privProperties.clone(), o;
    }
    get speechSynthesisLanguage() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(o) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, o);
    }
    get speechSynthesisVoiceName() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(o) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, o);
    }
    get speechSynthesisOutputFormat() {
      return r.SpeechSynthesisOutputFormat[this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(o) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, r.SpeechSynthesisOutputFormat[o]);
    }
  }
  return dt.SpeechConfigImpl = i, dt;
}
var ht = {}, hl;
function RR() {
  if (hl) return ht;
  hl = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.SpeechTranslationConfigImpl = ht.SpeechTranslationConfig = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A();
  let s = class extends r.SpeechConfig {
    /**
     * Creates an instance of recognizer config.
     */
    constructor() {
      super();
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
     * @member SpeechTranslationConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromSubscription(o, n) {
      t.Contracts.throwIfNullOrWhitespace(o, "subscriptionKey"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Key, o), c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by setting the property authorizationToken with a new
     * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
     * will encounter errors during recognition.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply
     * to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechTranslationConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromAuthorizationToken(o, n) {
      t.Contracts.throwIfNullOrWhitespace(o, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, o), c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(o, n) {
      t.Contracts.throwIfNull(o, "hostName");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Host, o.protocol + "//" + o.hostname + (o.port === "" ? "" : ":" + o.port)), n !== void 0 && c.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), c;
    }
    /**
     * Internal implementation of fromEndpoint() overloads. Accepts either a subscription key or a TokenCredential.
     * @private
     */
    static fromEndpoint(o, n) {
      t.Contracts.throwIfNull(o, "endpoint");
      const c = typeof n == "string" && n.trim().length > 0, u = typeof n == "object" && n !== null && typeof n.getToken == "function";
      if (n !== void 0 && !c && !u)
        throw new Error("Invalid 'auth' parameter: must be a non-empty key string or a valid TokenCredential object.");
      const l = typeof n == "object" ? new i(n) : new i();
      return l.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, o.href), typeof n == "string" && n.trim().length > 0 && l.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), l;
    }
  };
  ht.SpeechTranslationConfig = s;
  class i extends s {
    constructor(o) {
      super(), this.privSpeechProperties = new r.PropertyCollection(), this.outputFormat = r.OutputFormat.Simple, this.privTokenCredential = o;
    }
    /**
     * Gets/Sets the authorization token.
     * If this is set, subscription key is ignored.
     * User needs to make sure the provided authorization token is valid and not expired.
     * @member SpeechTranslationConfigImpl.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set authorizationToken(o) {
      t.Contracts.throwIfNullOrWhitespace(o, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, o);
    }
    /**
     * Sets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set speechRecognitionLanguage(o) {
      t.Contracts.throwIfNullOrWhitespace(o, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, o);
    }
    /**
     * Gets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @return {string} The speechRecognitionLanguage.
     */
    get speechRecognitionLanguage() {
      return this.privSpeechProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
     * @function
     * @public
     */
    get subscriptionKey() {
      return this.privSpeechProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_Key]);
    }
    /**
     * Gets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    get outputFormat() {
      return r.OutputFormat[this.privSpeechProperties.getProperty(e.OutputFormatPropertyName, void 0)];
    }
    /**
     * Gets/Sets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    set outputFormat(o) {
      this.privSpeechProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[o]);
    }
    /**
     * Gets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    get endpointId() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId);
    }
    /**
     * Gets/Sets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    set endpointId(o) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_EndpointId, o);
    }
    /**
     * Add a (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    addTargetLanguage(o) {
      t.Contracts.throwIfNullOrWhitespace(o, "value");
      const n = this.targetLanguages;
      n.includes(o) || (n.push(o), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, n.join(",")));
    }
    /**
     * Gets the (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.targetLanguages
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    get targetLanguages() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",") : [];
    }
    /**
     * Gets the voice name.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     */
    get voiceName() {
      return this.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_TranslationVoice]);
    }
    /**
     * Gets/Sets the voice of the translated language, enable voice synthesis output.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     * @param {string} value - The name of the voice.
     */
    set voiceName(o) {
      t.Contracts.throwIfNullOrWhitespace(o, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, o);
    }
    /**
     * Provides the region.
     * @member SpeechTranslationConfigImpl.prototype.region
     * @function
     * @public
     * @returns {string} The region.
     */
    get region() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_Region);
    }
    get tokenCredential() {
      return this.privTokenCredential;
    }
    setProxy(o, n, c, u) {
      this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyHostName], o), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPort], n), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    /**
     * Gets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {string} name - The name of the property.
     * @param {string} def - The default value of the property in case it is not set.
     * @returns {string} The value of the property.
     */
    getProperty(o, n) {
      return this.privSpeechProperties.getProperty(o, n);
    }
    /**
     * Gets/Sets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {string | PropertyId} name - The name of the property to set.
     * @param {string} value - The value of the property.
     */
    setProperty(o, n) {
      this.privSpeechProperties.setProperty(o, n);
    }
    /**
     * Provides access to custom properties.
     * @member SpeechTranslationConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechProperties;
    }
    /**
     * Dispose of associated resources.
     * @member SpeechTranslationConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
    setServiceProperty(o, n) {
      const c = JSON.parse(this.privSpeechProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
      c[o] = n, this.privSpeechProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(o) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceResponse_ProfanityOption, r.ProfanityOption[o]);
    }
    enableAudioLogging() {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    }
    enableDictation() {
      this.privSpeechProperties.setProperty(e.ForceDictationPropertyName, "true");
    }
    get speechSynthesisLanguage() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(o) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, o);
    }
    get speechSynthesisVoiceName() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(o) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, o);
    }
    get speechSynthesisOutputFormat() {
      return r.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(o) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, r.SpeechSynthesisOutputFormat[o]);
    }
  }
  return ht.SpeechTranslationConfigImpl = i, ht;
}
var Zr = {}, fl;
function uv() {
  if (fl) return Zr;
  fl = 1, Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.PropertyCollection = void 0;
  const e = /* @__PURE__ */ A();
  let t = class cv {
    constructor() {
      this.privKeys = [], this.privValues = [];
    }
    /**
     * Returns the property value in type String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member PropertyCollection.prototype.getProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string | number | boolean} def - The default value which is returned if the parameter
     * is not available in the collection.
     * @returns {string} value of the parameter.
     */
    getProperty(s, i) {
      let a;
      typeof s == "string" ? a = s : a = e.PropertyId[s];
      for (let o = 0; o < this.privKeys.length; o++)
        if (this.privKeys[o] === a)
          return this.privValues[o];
      if (i !== void 0)
        return String(i);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member PropertyCollection.prototype.setProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    setProperty(s, i) {
      let a;
      typeof s == "string" ? a = s : a = e.PropertyId[s];
      for (let o = 0; o < this.privKeys.length; o++)
        if (this.privKeys[o] === a) {
          this.privValues[o] = i;
          return;
        }
      this.privKeys.push(a), this.privValues.push(i);
    }
    /**
     * Clones the collection.
     * @member PropertyCollection.prototype.clone
     * @function
     * @public
     * @returns {PropertyCollection} A copy of the collection.
     */
    clone() {
      const s = new cv();
      for (let i = 0; i < this.privKeys.length; i++)
        s.privKeys.push(this.privKeys[i]), s.privValues.push(this.privValues[i]);
      return s;
    }
    /**
     * Merges this set of properties into another, no overwrites.
     * @member PropertyCollection.prototype.mergeTo
     * @function
     * @public
     * @param {PropertyCollection}  destinationCollection - The collection to merge into.
     */
    mergeTo(s) {
      this.privKeys.forEach((i) => {
        if (s.getProperty(i, void 0) === void 0) {
          const a = this.getProperty(i);
          s.setProperty(i, a);
        }
      });
    }
    /**
     * Get the keys in Property Collection.
     * @member PropertyCollection.prototype.keys
     * @function
     * @public
     * @returns {string []} Keys in the collection.
     */
    get keys() {
      return this.privKeys;
    }
  };
  return Zr.PropertyCollection = t, Zr;
}
var jo = {}, vl;
function nc() {
  return vl || (vl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PropertyId = void 0, function(t) {
      t[t.SpeechServiceConnection_Key = 0] = "SpeechServiceConnection_Key", t[t.SpeechServiceConnection_Endpoint = 1] = "SpeechServiceConnection_Endpoint", t[t.SpeechServiceConnection_Region = 2] = "SpeechServiceConnection_Region", t[t.SpeechServiceAuthorization_Token = 3] = "SpeechServiceAuthorization_Token", t[t.SpeechServiceAuthorization_Type = 4] = "SpeechServiceAuthorization_Type", t[t.SpeechServiceConnection_EndpointId = 5] = "SpeechServiceConnection_EndpointId", t[t.SpeechServiceConnection_TranslationToLanguages = 6] = "SpeechServiceConnection_TranslationToLanguages", t[t.SpeechServiceConnection_TranslationVoice = 7] = "SpeechServiceConnection_TranslationVoice", t[t.SpeechServiceConnection_TranslationFeatures = 8] = "SpeechServiceConnection_TranslationFeatures", t[t.SpeechServiceConnection_TranslationCategoryId = 9] = "SpeechServiceConnection_TranslationCategoryId", t[t.SpeechServiceConnection_IntentRegion = 10] = "SpeechServiceConnection_IntentRegion", t[t.SpeechServiceConnection_ProxyHostName = 11] = "SpeechServiceConnection_ProxyHostName", t[t.SpeechServiceConnection_ProxyPort = 12] = "SpeechServiceConnection_ProxyPort", t[t.SpeechServiceConnection_ProxyUserName = 13] = "SpeechServiceConnection_ProxyUserName", t[t.SpeechServiceConnection_ProxyPassword = 14] = "SpeechServiceConnection_ProxyPassword", t[t.SpeechServiceConnection_RecoMode = 15] = "SpeechServiceConnection_RecoMode", t[t.SpeechServiceConnection_RecoLanguage = 16] = "SpeechServiceConnection_RecoLanguage", t[t.Speech_SessionId = 17] = "Speech_SessionId", t[t.SpeechServiceConnection_SynthLanguage = 18] = "SpeechServiceConnection_SynthLanguage", t[t.SpeechServiceConnection_SynthVoice = 19] = "SpeechServiceConnection_SynthVoice", t[t.SpeechServiceConnection_SynthOutputFormat = 20] = "SpeechServiceConnection_SynthOutputFormat", t[t.SpeechServiceConnection_AutoDetectSourceLanguages = 21] = "SpeechServiceConnection_AutoDetectSourceLanguages", t[t.SpeechServiceResponse_RequestDetailedResultTrueFalse = 22] = "SpeechServiceResponse_RequestDetailedResultTrueFalse", t[t.SpeechServiceResponse_RequestProfanityFilterTrueFalse = 23] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse", t[t.SpeechServiceResponse_JsonResult = 24] = "SpeechServiceResponse_JsonResult", t[t.SpeechServiceResponse_JsonErrorDetails = 25] = "SpeechServiceResponse_JsonErrorDetails", t[t.CancellationDetails_Reason = 26] = "CancellationDetails_Reason", t[t.CancellationDetails_ReasonText = 27] = "CancellationDetails_ReasonText", t[t.CancellationDetails_ReasonDetailedText = 28] = "CancellationDetails_ReasonDetailedText", t[t.LanguageUnderstandingServiceResponse_JsonResult = 29] = "LanguageUnderstandingServiceResponse_JsonResult", t[t.SpeechServiceConnection_Url = 30] = "SpeechServiceConnection_Url", t[t.SpeechServiceConnection_InitialSilenceTimeoutMs = 31] = "SpeechServiceConnection_InitialSilenceTimeoutMs", t[t.SpeechServiceConnection_EndSilenceTimeoutMs = 32] = "SpeechServiceConnection_EndSilenceTimeoutMs", t[t.Speech_SegmentationSilenceTimeoutMs = 33] = "Speech_SegmentationSilenceTimeoutMs", t[t.Speech_SegmentationMaximumTimeMs = 34] = "Speech_SegmentationMaximumTimeMs", t[t.Speech_SegmentationStrategy = 35] = "Speech_SegmentationStrategy", t[t.SpeechServiceConnection_EnableAudioLogging = 36] = "SpeechServiceConnection_EnableAudioLogging", t[t.SpeechServiceConnection_LanguageIdMode = 37] = "SpeechServiceConnection_LanguageIdMode", t[t.SpeechServiceConnection_RecognitionEndpointVersion = 38] = "SpeechServiceConnection_RecognitionEndpointVersion", t[t.SpeechServiceConnection_SpeakerIdMode = 39] = "SpeechServiceConnection_SpeakerIdMode", t[t.SpeechServiceResponse_ProfanityOption = 40] = "SpeechServiceResponse_ProfanityOption", t[t.SpeechServiceResponse_PostProcessingOption = 41] = "SpeechServiceResponse_PostProcessingOption", t[t.SpeechServiceResponse_RequestWordLevelTimestamps = 42] = "SpeechServiceResponse_RequestWordLevelTimestamps", t[t.SpeechServiceResponse_StablePartialResultThreshold = 43] = "SpeechServiceResponse_StablePartialResultThreshold", t[t.SpeechServiceResponse_OutputFormatOption = 44] = "SpeechServiceResponse_OutputFormatOption", t[t.SpeechServiceResponse_TranslationRequestStablePartialResult = 45] = "SpeechServiceResponse_TranslationRequestStablePartialResult", t[t.SpeechServiceResponse_RequestWordBoundary = 46] = "SpeechServiceResponse_RequestWordBoundary", t[t.SpeechServiceResponse_RequestPunctuationBoundary = 47] = "SpeechServiceResponse_RequestPunctuationBoundary", t[t.SpeechServiceResponse_RequestSentenceBoundary = 48] = "SpeechServiceResponse_RequestSentenceBoundary", t[t.SpeechServiceResponse_DiarizeIntermediateResults = 49] = "SpeechServiceResponse_DiarizeIntermediateResults", t[t.Conversation_ApplicationId = 50] = "Conversation_ApplicationId", t[t.Conversation_DialogType = 51] = "Conversation_DialogType", t[t.Conversation_Initial_Silence_Timeout = 52] = "Conversation_Initial_Silence_Timeout", t[t.Conversation_From_Id = 53] = "Conversation_From_Id", t[t.Conversation_Conversation_Id = 54] = "Conversation_Conversation_Id", t[t.Conversation_Custom_Voice_Deployment_Ids = 55] = "Conversation_Custom_Voice_Deployment_Ids", t[t.Conversation_Speech_Activity_Template = 56] = "Conversation_Speech_Activity_Template", t[t.Conversation_Request_Bot_Status_Messages = 57] = "Conversation_Request_Bot_Status_Messages", t[t.Conversation_Agent_Connection_Id = 58] = "Conversation_Agent_Connection_Id", t[t.SpeechServiceConnection_Host = 59] = "SpeechServiceConnection_Host", t[t.ConversationTranslator_Host = 60] = "ConversationTranslator_Host", t[t.ConversationTranslator_Name = 61] = "ConversationTranslator_Name", t[t.ConversationTranslator_CorrelationId = 62] = "ConversationTranslator_CorrelationId", t[t.ConversationTranslator_Token = 63] = "ConversationTranslator_Token", t[t.PronunciationAssessment_ReferenceText = 64] = "PronunciationAssessment_ReferenceText", t[t.PronunciationAssessment_GradingSystem = 65] = "PronunciationAssessment_GradingSystem", t[t.PronunciationAssessment_Granularity = 66] = "PronunciationAssessment_Granularity", t[t.PronunciationAssessment_EnableMiscue = 67] = "PronunciationAssessment_EnableMiscue", t[t.PronunciationAssessment_Json = 68] = "PronunciationAssessment_Json", t[t.PronunciationAssessment_Params = 69] = "PronunciationAssessment_Params", t[t.SpeakerRecognition_Api_Version = 70] = "SpeakerRecognition_Api_Version", t[t.WebWorkerLoadType = 71] = "WebWorkerLoadType", t[t.TalkingAvatarService_WebRTC_SDP = 72] = "TalkingAvatarService_WebRTC_SDP";
    }(e.PropertyId || (e.PropertyId = {}));
  }(jo)), jo;
}
var Xr = {}, gl;
function PR() {
  if (gl) return Xr;
  gl = 1, Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.Recognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A();
  let i = class lv {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     * @param {PropertyCollection} properties - A set of properties to set on the recognizer
     * @param {IConnectionFactory} connectionFactory - The factory class used to create a custom IConnection for the recognizer
     */
    constructor(o, n, c, u) {
      this.audioConfig = o !== void 0 ? o : s.AudioConfig.fromDefaultMicrophoneInput(), this.privDisposed = !1, this.privProperties = n.clone(), this.privConnectionFactory = c, this.tokenCredential = u, this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */
    close(o, n) {
      r.Contracts.throwIfDisposed(this.privDisposed), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), o, n);
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privReco;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(o) {
      this.privDisposed || (this.privDisposed = !0, o && this.privReco && (await this.privReco.audioSource.turnOff(), await this.privReco.dispose()));
    }
    /**
     * This method returns the current state of the telemetry setting.
     * @member Recognizer.prototype.telemetryEnabled
     * @function
     * @public
     * @returns true if the telemetry is enabled, false otherwise.
     */
    static get telemetryEnabled() {
      return e.ServiceRecognizerBase.telemetryDataEnabled;
    }
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */
    static enableTelemetry(o) {
      e.ServiceRecognizerBase.telemetryDataEnabled = o;
    }
    // Does the generic recognizer setup that is common across all recognizer types.
    implCommonRecognizerSetup() {
      let o = typeof window < "u" ? "Browser" : "Node", n = "unknown", c = "unknown";
      typeof navigator < "u" && (o = o + "/" + navigator.platform, n = navigator.userAgent, c = navigator.appVersion);
      const u = this.createRecognizerConfig(new e.SpeechServiceConfig(new e.Context(new e.OS(o, n, c))));
      this.privReco = this.createServiceRecognizer(lv.getAuth(this.privProperties, this.tokenCredential), this.privConnectionFactory, this.audioConfig, u);
    }
    async recognizeOnceAsyncImpl(o) {
      r.Contracts.throwIfDisposed(this.privDisposed);
      const n = new t.Deferred();
      await this.implRecognizerStop(), await this.privReco.recognize(o, n.resolve, n.reject);
      const c = await n.promise;
      return await this.implRecognizerStop(), c;
    }
    async startContinuousRecognitionAsyncImpl(o) {
      r.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop(), await this.privReco.recognize(o, void 0, void 0);
    }
    async stopContinuousRecognitionAsyncImpl() {
      r.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop();
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    static getAuth(o, n) {
      const c = o.getProperty(s.PropertyId.SpeechServiceConnection_Key, void 0);
      return c && c !== "" ? new e.CognitiveSubscriptionKeyAuthentication(c) : n ? new e.CognitiveTokenAuthentication(async () => {
        try {
          return (await n.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (u) {
          throw u;
        }
      }, async () => {
        try {
          return (await n.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (u) {
          throw u;
        }
      }) : new e.CognitiveTokenAuthentication(() => {
        const u = o.getProperty(s.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      }, () => {
        const u = o.getProperty(s.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      });
    }
  };
  return Xr.Recognizer = i, Xr;
}
var en = {}, qo = {}, ml;
function Se() {
  return ml || (ml = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionMode = void 0, function(t) {
      t.Interactive = "Interactive", t.Dictation = "Dictation", t.Conversation = "Conversation", t.None = "None";
    }(e.RecognitionMode || (e.RecognitionMode = {}));
  }(qo)), qo;
}
var yl;
function bR() {
  if (yl) return en;
  yl = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.SpeechRecognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ Se(), r = /* @__PURE__ */ D(), s = /* @__PURE__ */ z(), i = /* @__PURE__ */ A();
  let a = class pv extends i.Recognizer {
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      s.Contracts.throwIfNull(u, "speechConfig"), s.Contracts.throwIfNullOrWhitespace(u.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new e.SpeechConnectionFactory(), n.tokenCredential), this.privDisposedRecognizer = !1;
    }
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(n, c, u) {
      const l = n;
      return c.properties.mergeTo(l.properties), new pv(n, u);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for speech recognition.
     * @member SpeechRecognizer.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return s.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      s.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * Gets the spoken language of recognition.
     * @member SpeechRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return s.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of recognition.
     * @member SpeechRecognizer.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of recognition.
     */
    get outputFormat() {
      return s.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(e.OutputFormatPropertyName, i.OutputFormat[i.OutputFormat.Simple]) === i.OutputFormat[i.OutputFormat.Simple] ? i.OutputFormat.Simple : i.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this SpeechRecognizer.
     * @member SpeechRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts speech recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition
     * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member SpeechRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the SpeechRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), n, c);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(this.properties.getProperty(e.ForceDictationPropertyName, void 0) === void 0 ? t.RecognitionMode.Conversation : t.RecognitionMode.Dictation), n, c);
    }
    /**
     * Stops continuous speech recognition.
     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * Starts speech recognition with keyword spotting, until
     * stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model The keyword recognition model that
     * specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(n, c, u) {
      s.Contracts.throwIfNull(n, "model"), u && u("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(n) {
      n && n();
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member SpeechRecognizer.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      s.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new e.SpeechServiceRecognizer(n, c, p, l, this);
    }
  };
  return en.SpeechRecognizer = a, en;
}
var tn = {}, Sl;
function wR() {
  if (Sl) return tn;
  Sl = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.IntentRecognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ Se(), r = /* @__PURE__ */ D(), s = /* @__PURE__ */ z(), i = /* @__PURE__ */ A();
  let a = class extends i.Recognizer {
    /**
     * Initializes an instance of the IntentRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(n, c) {
      s.Contracts.throwIfNullOrUndefined(n, "speechConfig");
      const u = n;
      s.Contracts.throwIfNullOrUndefined(u, "speechConfig"), super(c, u.properties, new e.IntentConnectionFactory()), this.privAddedIntents = [], this.privAddedLmIntents = {}, this.privDisposedIntentRecognizer = !1, this.privProperties = u.properties, s.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * Gets the spoken language of recognition.
     * @member IntentRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} the spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return s.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(n) {
      this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * The collection of properties and their values defined for this IntentRecognizer.
     * @member IntentRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their
     * values defined for this IntentRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts intent recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text and intent as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition like command or query.
     * For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member IntentRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(n, c) {
      if (s.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const u = this.buildSpeechContext();
        this.privReco.speechContext.getContext().intent = u.Intent, this.privReco.dynamicGrammar.addReferenceGrammar(u.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), n, c);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(n, c) {
      if (Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const u = this.buildSpeechContext();
        this.privReco.speechContext.getContext().intent = u.Intent, this.privReco.dynamicGrammar.addReferenceGrammar(u.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), n, c);
    }
    /**
     * Stops continuous intent recognition.
     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(n, c, u) {
      s.Contracts.throwIfNull(n, "model"), u && u("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(n, c) {
      if (n)
        try {
          n();
        } catch (u) {
          c && c(u);
        }
    }
    /**
     * Adds a phrase that should be recognized as intent.
     * @member IntentRecognizer.prototype.addIntent
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
     * @param {string} phrase - A String that specifies the phrase representing the intent.
     */
    addIntent(n, c) {
      s.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), s.Contracts.throwIfNullOrWhitespace(c, "intentId"), s.Contracts.throwIfNullOrWhitespace(n, "simplePhrase"), this.privAddedIntents.push([c, n]);
    }
    /**
     * Adds an intent from Language Understanding service for recognition.
     * @member IntentRecognizer.prototype.addIntentWithLanguageModel
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent
     * to be recognized. Ignored if intentName is empty.
     * @param {string} model - The intent model from Language Understanding service.
     * @param {string} intentName - The intent name defined in the intent model. If it
     * is empty, all intent names defined in the model will be added.
     */
    addIntentWithLanguageModel(n, c, u) {
      s.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), s.Contracts.throwIfNullOrWhitespace(n, "intentId"), s.Contracts.throwIfNull(c, "model");
      const l = c;
      s.Contracts.throwIfNullOrWhitespace(l.appId, "model.appId"), this.privAddedLmIntents[n] = new e.AddedLmIntent(l, u);
    }
    /**
     * @summary Adds all intents from the specified Language Understanding Model.
     * @member IntentRecognizer.prototype.addAllIntents
     * @function
     * @public
     * @function
     * @public
     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
     */
    addAllIntents(n, c) {
      s.Contracts.throwIfNull(n, "model");
      const u = n;
      s.Contracts.throwIfNullOrWhitespace(u.appId, "model.appId"), this.privUmbrellaIntent = new e.AddedLmIntent(u, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member IntentRecognizer.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      s.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new e.IntentServiceRecognizer(n, c, p, l, this);
    }
    async dispose(n) {
      this.privDisposedIntentRecognizer || n && (this.privDisposedIntentRecognizer = !0, await super.dispose(n));
    }
    buildSpeechContext() {
      let n, c, u;
      const l = [];
      this.privUmbrellaIntent !== void 0 && (n = this.privUmbrellaIntent.modelImpl.appId, c = this.privUmbrellaIntent.modelImpl.region, u = this.privUmbrellaIntent.modelImpl.subscriptionKey);
      for (const p of Object.keys(this.privAddedLmIntents)) {
        const d = this.privAddedLmIntents[p];
        if (n === void 0)
          n = d.modelImpl.appId;
        else if (n !== d.modelImpl.appId)
          throw new Error("Intents must all be from the same LUIS model");
        if (c === void 0)
          c = d.modelImpl.region;
        else if (c !== d.modelImpl.region)
          throw new Error("Intents must all be from the same LUIS model in a single region");
        if (u === void 0)
          u = d.modelImpl.subscriptionKey;
        else if (u !== d.modelImpl.subscriptionKey)
          throw new Error("Intents must all use the same subscription key");
        const h = "luis/" + n + "-PRODUCTION#" + p;
        l.push(h);
      }
      return {
        Intent: {
          id: n,
          key: u === void 0 ? this.privProperties.getProperty(i.PropertyId[i.PropertyId.SpeechServiceConnection_Key]) : u,
          provider: "LUIS"
        },
        ReferenceGrammars: this.privUmbrellaIntent === void 0 ? l : ["luis/" + n + "-PRODUCTION"]
      };
    }
  };
  return tn.IntentRecognizer = a, tn;
}
var Fo = {}, Cl;
function ER() {
  return Cl || (Cl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.VoiceProfileType = void 0, function(t) {
      t[t.TextIndependentIdentification = 0] = "TextIndependentIdentification", t[t.TextDependentVerification = 1] = "TextDependentVerification", t[t.TextIndependentVerification = 2] = "TextIndependentVerification";
    }(e.VoiceProfileType || (e.VoiceProfileType = {}));
  }(Fo)), Fo;
}
var rn = {}, nn = {}, ft = {}, Rl;
function dv() {
  if (Rl) return ft;
  Rl = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.ConnectionMessageImpl = ft.ConnectionMessage = void 0;
  const e = /* @__PURE__ */ ue(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ uv(), s = /* @__PURE__ */ nc();
  let i = class {
  };
  ft.ConnectionMessage = i;
  class a {
    constructor(n) {
      this.privConnectionMessage = n, this.privProperties = new r.PropertyCollection(), this.privConnectionMessage.headers[e.HeaderNames.ConnectionId] && this.privProperties.setProperty(s.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[e.HeaderNames.ConnectionId]), Object.keys(this.privConnectionMessage.headers).forEach((c) => {
        this.privProperties.setProperty(c, this.privConnectionMessage.headers[c]);
      });
    }
    /**
     * The message path.
     */
    get path() {
      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((n) => n.toLowerCase() === "path".toLowerCase())];
    }
    /**
     * Checks to see if the ConnectionMessage is a text message.
     * See also IsBinaryMessage().
     */
    get isTextMessage() {
      return this.privConnectionMessage.messageType === t.MessageType.Text;
    }
    /**
     * Checks to see if the ConnectionMessage is a binary message.
     * See also GetBinaryMessage().
     */
    get isBinaryMessage() {
      return this.privConnectionMessage.messageType === t.MessageType.Binary;
    }
    /**
     * Gets the text message payload. Typically the text message content-type is
     * application/json. To determine other content-types use
     * Properties.GetProperty("Content-Type").
     */
    get TextMessage() {
      return this.privConnectionMessage.textBody;
    }
    /**
     * Gets the binary message payload.
     */
    get binaryMessage() {
      return this.privConnectionMessage.binaryBody;
    }
    /**
     * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
     * Message headers can be accessed via this collection (e.g. "Content-Type").
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Returns a string that represents the connection message.
     */
    toString() {
      return "";
    }
  }
  return ft.ConnectionMessageImpl = a, ft;
}
var Pl;
function hv() {
  if (Pl) return nn;
  Pl = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.Connection = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ dv(), s = /* @__PURE__ */ z(), i = /* @__PURE__ */ A();
  let a = class qa {
    /**
     * Gets the Connection instance from the specified recognizer.
     * @param recognizer The recognizer associated with the connection.
     * @return The Connection instance of the recognizer.
     */
    static fromRecognizer(n) {
      const c = n.internalData, u = new qa();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Gets the Connection instance from the specified synthesizer.
     * @param synthesizer The synthesizer associated with the connection.
     * @return The Connection instance of the synthesizer.
     */
    static fromSynthesizer(n) {
      const c = n.internalData, u = new qa();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Starts to set up connection to the service.
     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     */
    openConnection(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.connect(), n, c);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
     *
     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
     */
    closeConnection(n, c) {
      if (this.privInternalData instanceof e.SynthesisAdapterBase)
        throw new Error("Disconnecting a synthesizer's connection is currently not supported");
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.disconnect(), n, c);
    }
    /**
     * Appends a parameter in a message to service.
     * Added in version 1.12.1.
     * @param path The path of the network message.
     * @param propertyName Name of the property
     * @param propertyValue Value of the property. This is a json string.
     */
    setMessageProperty(n, c, u) {
      if (s.Contracts.throwIfNullOrWhitespace(c, "propertyName"), this.privInternalData instanceof e.ServiceRecognizerBase) {
        if (n.toLowerCase() !== "speech.context")
          throw new Error("Only speech.context message property sets are currently supported for recognizer");
        {
          const l = this.privInternalData.speechContext.getContext();
          l[c] = u;
        }
      } else if (this.privInternalData instanceof e.SynthesisAdapterBase) {
        if (n.toLowerCase() !== "synthesis.context")
          throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
        this.privInternalData.synthesisContext.setSection(c, u);
      }
    }
    /**
     * Sends a message to the speech service.
     * Added in version 1.13.0.
     * @param path The WebSocket path of the message
     * @param payload The payload of the message. This is a json string or a ArrayBuffer.
     * @param success A callback to indicate success.
     * @param error A callback to indicate an error.
     */
    sendMessageAsync(n, c, u, l) {
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.sendNetworkMessage(n, c), u, l);
    }
    /**
     * Dispose of associated resources.
     */
    close() {
    }
    setupEvents() {
      this.privEventListener = this.privInternalData.connectionEvents.attach((n) => {
        n.name === "ConnectionEstablishedEvent" ? this.connected && this.connected(new i.ConnectionEventArgs(n.connectionId)) : n.name === "ConnectionClosedEvent" ? this.disconnected && this.disconnected(new i.ConnectionEventArgs(n.connectionId)) : n.name === "ConnectionMessageSentEvent" ? this.messageSent && this.messageSent(new i.ConnectionMessageEventArgs(new r.ConnectionMessageImpl(n.message))) : n.name === "ConnectionMessageReceivedEvent" && this.messageReceived && this.messageReceived(new i.ConnectionMessageEventArgs(new r.ConnectionMessageImpl(n.message)));
      }), this.privServiceEventListener = this.privInternalData.serviceEvents.attach((n) => {
        this.receivedServiceMessage && this.receivedServiceMessage(new i.ServiceEventArgs(n.jsonString, n.name));
      });
    }
  };
  return nn.Connection = a, nn;
}
var bl;
function IR() {
  if (bl) return rn;
  bl = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.TranslationRecognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ Se(), r = /* @__PURE__ */ D(), s = /* @__PURE__ */ hv(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ A();
  let o = class fv extends a.Recognizer {
    /**
     * Initializes an instance of the TranslationRecognizer.
     * @constructor
     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
     */
    constructor(c, u, l) {
      const p = c;
      i.Contracts.throwIfNull(p, "speechConfig"), super(u, p.properties, l || new e.TranslationConnectionFactory(), c.tokenCredential), this.privDisposedTranslationRecognizer = !1, this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice), a.PropertyId[a.PropertyId.SpeechServiceConnection_TranslationVoice]), i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages), a.PropertyId[a.PropertyId.SpeechServiceConnection_TranslationToLanguages]), i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage), a.PropertyId[a.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * TranslationRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(c, u, l) {
      const p = c;
      return u.properties.mergeTo(p.properties), u.properties.getProperty(a.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0) === e.AutoDetectSourceLanguagesOpenRangeOptionName && p.properties.setProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), new fv(c, l);
    }
    /**
     * Gets the language name that was set when the recognizer was created.
     * @member TranslationRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} Gets the language name that was set when the recognizer was created.
     */
    get speechRecognitionLanguage() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets target languages for translation that were set when the recognizer was created.
     * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
     * @member TranslationRecognizer.prototype.targetLanguages
     * @function
     * @public
     * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
     */
    get targetLanguages() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
    }
    /**
     * Gets the name of output voice.
     * @member TranslationRecognizer.prototype.voiceName
     * @function
     * @public
     * @returns {string} the name of output voice.
     */
    get voiceName() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
    }
    /**
     * The collection of properties and their values defined for this TranslationRecognizer.
     * @member TranslationRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(a.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(c) {
      this.properties.setProperty(a.PropertyId.SpeechServiceAuthorization_Token, c);
    }
    /**
     * Starts recognition and translation, and stops after the first utterance is recognized.
     * The task returns the translation text as result.
     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
     * for single shot recognition like command or query. For long-running recognition,
     * use startContinuousRecognitionAsync() instead.
     * @member TranslationRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the translation has completed.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(c, u) {
      i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), c, u);
    }
    /**
     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive translation results.
     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(c, u) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), c, u);
    }
    /**
     * Stops continuous recognition and translation.
     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(c, u) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), c, u);
    }
    /**
     * dynamically remove a language from list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.removeTargetLanguage
     * @function
     * @param lang - language to be removed
     * @public
     */
    removeTargetLanguage(c) {
      if (i.Contracts.throwIfNullOrUndefined(c, "language to be removed"), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        const u = this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), l = u.indexOf(c);
        l > -1 && (u.splice(l, 1), this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, u.join(",")), this.updateLanguages(u));
      }
    }
    /**
     * dynamically add a language to list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.addTargetLanguage
     * @function
     * @param lang - language to be added
     * @public
     */
    addTargetLanguage(c) {
      i.Contracts.throwIfNullOrUndefined(c, "language to be added");
      let u = [];
      this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? (u = this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), u.includes(c) || (u.push(c), this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, u.join(",")))) : (this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, c), u = [c]), this.updateLanguages(u);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member TranslationRecognizer.prototype.close
     * @function
     * @public
     */
    close(c, u) {
      i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), c, u);
    }
    /**
     * handles ConnectionEstablishedEvent for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onConnection
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onConnection() {
    }
    async dispose(c) {
      this.privDisposedTranslationRecognizer || (this.privDisposedTranslationRecognizer = !0, c && (await this.implRecognizerStop(), await super.dispose(c)));
    }
    createRecognizerConfig(c) {
      return new e.RecognizerConfig(c, this.privProperties);
    }
    createServiceRecognizer(c, u, l, p) {
      const d = l;
      return new e.TranslationServiceRecognizer(c, u, d, p, this);
    }
    updateLanguages(c) {
      const u = s.Connection.fromRecognizer(this);
      u && (u.setMessageProperty("speech.context", "translationcontext", { to: c }), u.sendMessageAsync("event", JSON.stringify({
        id: "translation",
        name: "updateLanguage",
        to: c
      })));
    }
  };
  return rn.TranslationRecognizer = o, rn;
}
var sn = {}, wl;
function AR() {
  if (wl) return sn;
  wl = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.Translations = void 0;
  const e = /* @__PURE__ */ A();
  let t = class {
    constructor() {
      this.privMap = new e.PropertyCollection();
    }
    /**
     * Get the languages in the object in a String array.
     * @member Translations.prototype.languages
     * @function
     * @public
     * @returns {string[]} languages in translations object.
     */
    get languages() {
      return this.privMap.keys;
    }
    /**
     * Returns the parameter value in type String. The parameter must have the same type as String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member Translations.prototype.get
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} def - The default value which is returned if the parameter is not available in the collection.
     * @returns {string} value of the parameter.
     */
    get(s, i) {
      return this.privMap.getProperty(s, i);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member Translations.prototype.set
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    set(s, i) {
      this.privMap.setProperty(s, i);
    }
  };
  return sn.Translations = t, sn;
}
var Bo = {}, El;
function TR() {
  return El || (El = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NoMatchReason = void 0, function(t) {
      t[t.NotRecognized = 0] = "NotRecognized", t[t.InitialSilenceTimeout = 1] = "InitialSilenceTimeout", t[t.InitialBabbleTimeout = 2] = "InitialBabbleTimeout";
    }(e.NoMatchReason || (e.NoMatchReason = {}));
  }(Bo)), Bo;
}
var on = {}, Il;
function _R() {
  if (Il) return on;
  Il = 1, Object.defineProperty(on, "__esModule", { value: !0 }), on.NoMatchDetails = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ A();
  let r = class vv {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {NoMatchReason} reason - The no-match reason.
     */
    constructor(i) {
      this.privReason = i;
    }
    /**
     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
     * @member NoMatchDetails.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
     * result - The recognition result that was not recognized.
     * @returns {NoMatchDetails} The no match details object being created.
     */
    static fromResult(i) {
      const a = e.SimpleSpeechPhrase.fromJSON(i.json, 0);
      let o = t.NoMatchReason.NotRecognized;
      switch (a.RecognitionStatus) {
        case e.RecognitionStatus.BabbleTimeout:
          o = t.NoMatchReason.InitialBabbleTimeout;
          break;
        case e.RecognitionStatus.InitialSilenceTimeout:
          o = t.NoMatchReason.InitialSilenceTimeout;
          break;
        default:
          o = t.NoMatchReason.NotRecognized;
          break;
      }
      return new vv(o);
    }
    /**
     * The reason the recognition was canceled.
     * @member NoMatchDetails.prototype.reason
     * @function
     * @public
     * @returns {NoMatchReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
  };
  return on.NoMatchDetails = r, on;
}
var an = {}, Al;
function kR() {
  if (Al) return an;
  Al = 1, Object.defineProperty(an, "__esModule", { value: !0 }), an.TranslationRecognitionCanceledEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionid - The session id.
     * @param {CancellationReason} cancellationReason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {TranslationRecognitionResult} result - The result.
     */
    constructor(r, s, i, a, o) {
      this.privCancelReason = s, this.privErrorDetails = i, this.privResult = o, this.privSessionId = r, this.privErrorCode = a;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionCanceledEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
    /**
     * Specifies the session identifier.
     * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
     * @function
     * @public
     * @returns {string} the session identifier.
     */
    get sessionId() {
      return this.privSessionId;
    }
    /**
     * The reason the recognition was canceled.
     * @member TranslationRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privCancelReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return an.TranslationRecognitionCanceledEventArgs = e, an;
}
var cn = {}, Tl;
function OR() {
  if (Tl) return cn;
  Tl = 1, Object.defineProperty(cn, "__esModule", { value: !0 }), cn.IntentRecognitionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.IntentRecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} result - The result of the intent recognition.
     * @param {string} offset - The offset.
     * @param {IntentRecognitionResult} sessionId - The session id.
     */
    constructor(s, i, a, o, n, c) {
      super(o, n, c), this.privReason = s, this.privErrorDetails = i, this.privErrorCode = a;
    }
    /**
     * The reason the recognition was canceled.
     * @member IntentRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return cn.IntentRecognitionCanceledEventArgs = t, cn;
}
var un = {}, _l;
function gv() {
  if (_l) return un;
  _l = 1, Object.defineProperty(un, "__esModule", { value: !0 }), un.CancellationDetailsBase = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - The error details, if provided.
     */
    constructor(r, s, i) {
      this.privReason = r, this.privErrorDetails = s, this.privErrorCode = i;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationDetailsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member CancellationDetailsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get ErrorCode() {
      return this.privErrorCode;
    }
  };
  return un.CancellationDetailsBase = e, un;
}
var ln = {}, kl;
function MR() {
  if (kl) return ln;
  kl = 1, Object.defineProperty(ln, "__esModule", { value: !0 }), ln.CancellationDetails = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ gv(), r = /* @__PURE__ */ A();
  let s = class mv extends t.CancellationDetailsBase {
    constructor(a, o, n) {
      super(a, o, n);
    }
    /**
     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
     * @member CancellationDetails.fromResult
     * @function
     * @public
     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
     * @returns {CancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      let o = r.CancellationReason.Error, n = r.CancellationErrorCode.NoError;
      if (a instanceof r.RecognitionResult && a.json) {
        const c = e.SimpleSpeechPhrase.fromJSON(a.json, 0);
        o = e.EnumTranslation.implTranslateCancelResult(c.RecognitionStatus);
      }
      return a.properties && (n = r.CancellationErrorCode[a.properties.getProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new mv(o, a.errorDetails || e.EnumTranslation.implTranslateErrorDetails(n), n);
    }
  };
  return ln.CancellationDetails = s, ln;
}
var Uo = {}, Ol;
function DR() {
  return Ol || (Ol = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationErrorCode = void 0, function(t) {
      t[t.NoError = 0] = "NoError", t[t.AuthenticationFailure = 1] = "AuthenticationFailure", t[t.BadRequestParameters = 2] = "BadRequestParameters", t[t.TooManyRequests = 3] = "TooManyRequests", t[t.ConnectionFailure = 4] = "ConnectionFailure", t[t.ServiceTimeout = 5] = "ServiceTimeout", t[t.ServiceError = 6] = "ServiceError", t[t.RuntimeError = 7] = "RuntimeError", t[t.Forbidden = 8] = "Forbidden";
    }(e.CancellationErrorCode || (e.CancellationErrorCode = {}));
  }(Uo)), Uo;
}
var pn = {}, Ml;
function NR() {
  if (Ml) return pn;
  Ml = 1, Object.defineProperty(pn, "__esModule", { value: !0 }), pn.ConnectionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
  };
  return pn.ConnectionEventArgs = t, pn;
}
var dn = {}, Dl;
function xR() {
  if (Dl) return dn;
  Dl = 1, Object.defineProperty(dn, "__esModule", { value: !0 }), dn.ServiceEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} json - json payload of the USP message.
     */
    constructor(s, i, a) {
      super(a), this.privJsonResult = s, this.privEventName = i;
    }
    get jsonString() {
      return this.privJsonResult;
    }
    get eventName() {
      return this.privEventName;
    }
  };
  return dn.ServiceEventArgs = t, dn;
}
var hn = {}, Nl;
function zR() {
  if (Nl) return hn;
  Nl = 1, Object.defineProperty(hn, "__esModule", { value: !0 }), hn.PhraseListGrammar = void 0;
  let e = class yv {
    constructor(r) {
      this.privGrammerBuilder = r.dynamicGrammar;
    }
    /**
     * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
     * @param recognizer The recognizer to add phrase lists to.
     */
    static fromRecognizer(r) {
      const s = r.internalData;
      return new yv(s);
    }
    /**
     * Adds a single phrase to the current recognizer.
     * @param phrase Phrase to add.
     */
    addPhrase(r) {
      this.privGrammerBuilder.addPhrase(r);
    }
    /**
     * Adds multiple phrases to the current recognizer.
     * @param phrases Array of phrases to add.
     */
    addPhrases(r) {
      this.privGrammerBuilder.addPhrase(r);
    }
    /**
     * Clears all phrases added to the current recognizer.
     */
    clear() {
      this.privGrammerBuilder.clearPhrases();
    }
  };
  return hn.PhraseListGrammar = e, hn;
}
var vt = {}, xl;
function ic() {
  if (xl) return vt;
  xl = 1, Object.defineProperty(vt, "__esModule", { value: !0 }), vt.DialogServiceConfigImpl = vt.DialogServiceConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class {
    /**
     * Creates an instance of DialogService config.
     * @constructor
     */
    constructor() {
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member DialogServiceConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set applicationId(a) {
    }
    static get DialogTypes() {
      return {
        BotFramework: "bot_framework",
        CustomCommands: "custom_commands"
      };
    }
  };
  vt.DialogServiceConfig = r;
  class s extends r {
    /**
     * Creates an instance of dialogService config.
     */
    constructor() {
      super(), this.privSpeechConfig = new t.SpeechConfigImpl();
    }
    /**
     * Provides access to custom properties.
     * @member DialogServiceConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechConfig.properties;
    }
    /**
     * Gets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     */
    get speechRecognitionLanguage() {
      return this.privSpeechConfig.speechRecognitionLanguage;
    }
    /**
     * Sets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The language to set.
     */
    set speechRecognitionLanguage(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechConfig.speechRecognitionLanguage = a;
    }
    get outputFormat() {
      return this.privSpeechConfig.outputFormat;
    }
    set outputFormat(a) {
      this.privSpeechConfig.outputFormat = a;
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to set.
     * @param {string} value - The value.
     */
    setProperty(a, o) {
      this.privSpeechConfig.setProperty(a, o);
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to get.
     * @param {string} def - The default value to return in case the property is not known.
     * @returns {string} The current value, or provided default, of the given property.
     */
    getProperty(a, o) {
      return this.privSpeechConfig.getProperty(a);
    }
    /**
     * Sets the proxy configuration.
     * Only relevant in Node.js environments.
     * Added in version 1.4.0.
     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
     * @param proxyPort The port number of the proxy server.
     * @param proxyUserName The user name of the proxy server.
     * @param proxyPassword The password of the proxy server.
     */
    setProxy(a, o, n, c) {
      this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyHostName, a), this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyPort, `${o}`), n && this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyUserName, n), c && this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyPassword, c);
    }
    setServiceProperty(a, o, n) {
      this.privSpeechConfig.setServiceProperty(a, o);
    }
    /**
     * Dispose of associated resources.
     * @member DialogServiceConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
  }
  return vt.DialogServiceConfigImpl = s, vt;
}
var fn = {}, zl;
function LR() {
  if (zl) return fn;
  zl = 1, Object.defineProperty(fn, "__esModule", { value: !0 }), fn.BotFrameworkConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ ic(), r = /* @__PURE__ */ A();
  let s = class extends t.DialogServiceConfigImpl {
    /**
     * Creates an instance of BotFrameworkConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates a bot framework configuration instance with the provided subscription information.
     * @member BotFrameworkConfig.fromSubscription
     * @function
     * @public
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromSubscription(a, o, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "subscription"), e.Contracts.throwIfNullOrWhitespace(o, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, o), n && c.setProperty(r.PropertyId.Conversation_ApplicationId, n), c;
    }
    /**
     * Creates a bot framework configuration instance for the specified authorization token and region.
     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
     * caller must refresh it by setting the authorizationToken property on the corresponding
     * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
     * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
     * original configuration's authorization token. Create a new configuration instance or set the
     * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
     * further DialogServiceConnectors.
     * @member BotFrameworkConfig.fromAuthorizationToken
     * @function
     * @public
     * @param authorizationToken The authorization token associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromAuthorizationToken(a, o, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(o, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, o), n && c.setProperty(r.PropertyId.Conversation_ApplicationId, n), c;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-default service host. The standard resource path will be
     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
     * property on the created BotFrameworkConfig instance.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromHost
     * @function
     * @public
     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
     * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
     * wss://{host}.convai.speech.azure.us.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromHost(a, o, n) {
      e.Contracts.throwIfNullOrUndefined(a, "host");
      const c = a instanceof URL ? a : new URL(`wss://${a}.convai.speech.azure.us`);
      e.Contracts.throwIfNullOrUndefined(c, "resolvedHost");
      const u = new t.DialogServiceConfigImpl();
      return u.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), u.setProperty(r.PropertyId.SpeechServiceConnection_Host, c.toString()), o !== void 0 && u.setProperty(r.PropertyId.SpeechServiceConnection_Key, o), u;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
     * use the authorization token.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
     */
    static fromEndpoint(a, o) {
      e.Contracts.throwIfNull(a, "endpoint");
      const n = new t.DialogServiceConfigImpl();
      return n.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), n.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, a.toString()), o !== void 0 && n.setProperty(r.PropertyId.SpeechServiceConnection_Key, o), n;
    }
  };
  return fn.BotFrameworkConfig = s, fn;
}
var vn = {}, Ll;
function jR() {
  if (Ll) return vn;
  Ll = 1, Object.defineProperty(vn, "__esModule", { value: !0 }), vn.CustomCommandsConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ ic(), r = /* @__PURE__ */ A();
  let s = class extends t.DialogServiceConfigImpl {
    /**
     * Creates an instance of CustomCommandsConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates an instance of the bot framework config with the specified subscription and region.
     * @member CustomCommandsConfig.fromSubscription
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new bot framework config.
     */
    static fromSubscription(a, o, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "applicationId"), e.Contracts.throwIfNullOrWhitespace(o, "subscription"), e.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(r.PropertyId.Conversation_ApplicationId, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, o), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member CustomCommandsConfig.fromAuthorizationToken
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param authorizationToken The authorization token associated with the application.
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new speech commands config.
     */
    static fromAuthorizationToken(a, o, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "applicationId"), e.Contracts.throwIfNullOrWhitespace(o, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(r.PropertyId.Conversation_ApplicationId, a), c.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, o), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    set applicationId(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.setProperty(r.PropertyId.Conversation_ApplicationId, a);
    }
    /**
     * Gets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to get.
     */
    get applicationId() {
      return this.getProperty(r.PropertyId.Conversation_ApplicationId);
    }
  };
  return vn.CustomCommandsConfig = s, vn;
}
var gn = {}, mn = {}, yn = {}, Sn = {}, jl;
function Xe() {
  if (jl) return Sn;
  jl = 1, Object.defineProperty(Sn, "__esModule", { value: !0 }), Sn.QueryParameterNames = void 0;
  let e = class {
  };
  return Sn.QueryParameterNames = e, e.BotId = "botid", e.CustomSpeechDeploymentId = "cid", e.CustomVoiceDeploymentId = "deploymentId", e.EnableAudioLogging = "storeAudio", e.EnableLanguageId = "lidEnabled", e.EnableWordLevelTimestamps = "wordLevelTimestamps", e.EndSilenceTimeoutMs = "endSilenceTimeoutMs", e.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs", e.SegmentationMaximumTimeMs = "segmentationMaximumTimeMs", e.SegmentationStrategy = "segmentationStrategy", e.Format = "format", e.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs", e.Language = "language", e.Profanity = "profanity", e.RequestBotStatusMessages = "enableBotMessageStatus", e.StableIntermediateThreshold = "stableIntermediateThreshold", e.StableTranslation = "stableTranslation", e.TestHooks = "testhooks", e.Postprocessing = "postprocessing", e.CtsMeetingId = "meetingId", e.CtsDeviceId = "deviceId", e.CtsIsParticipant = "isParticipant", e.EnableAvatar = "enableTalkingAvatar", Sn;
}
var ql;
function Ae() {
  if (ql) return yn;
  ql = 1, Object.defineProperty(yn, "__esModule", { value: !0 }), yn.ConnectionFactoryBase = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ Xe();
  let i = class {
    static getHostSuffix(o) {
      if (o) {
        if (o.toLowerCase().startsWith("china"))
          return ".azure.cn";
        if (o.toLowerCase().startsWith("usgov"))
          return ".azure.us";
      }
      return ".microsoft.com";
    }
    setCommonUrlParams(o, n, c) {
      (/* @__PURE__ */ new Map([
        [r.PropertyId.Speech_SegmentationSilenceTimeoutMs, s.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceConnection_EnableAudioLogging, s.QueryParameterNames.EnableAudioLogging],
        [r.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, s.QueryParameterNames.EndSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, s.QueryParameterNames.InitialSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceResponse_PostProcessingOption, s.QueryParameterNames.Postprocessing],
        [r.PropertyId.SpeechServiceResponse_ProfanityOption, s.QueryParameterNames.Profanity],
        [r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, s.QueryParameterNames.EnableWordLevelTimestamps],
        [r.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, s.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((p, d) => {
        this.setUrlParameter(d, p, o, n, c);
      });
      const l = JSON.parse(o.parameters.getProperty(e.ServicePropertiesPropertyName, "{}"));
      Object.keys(l).forEach((p) => {
        n[p] = l[p];
      });
    }
    setUrlParameter(o, n, c, u, l) {
      const p = c.parameters.getProperty(o, void 0);
      p && (!l || l.search(n) === -1) && (u[n] = p.toLocaleLowerCase());
    }
    static async getRedirectUrlFromEndpoint(o) {
      let n;
      if (typeof window < "u" && typeof window.fetch < "u") {
        const c = new URL(o);
        c.protocol = "https:", c.port = "443", c.searchParams.append("GenerateRedirectResponse", "true");
        const l = c.toString();
        t.Events.instance.onEvent(new t.ConnectionRedirectEvent("", l, void 0, "ConnectionFactoryBase: redirectUrl request"));
        const p = await fetch(l);
        if (p.status !== 200)
          return o;
        n = await p.text();
      } else
        n = o;
      t.Events.instance.onEvent(new t.ConnectionRedirectEvent("", n, o, "ConnectionFactoryBase: redirectUrlString"));
      try {
        return new URL(n.trim()).toString();
      } catch {
        return o;
      }
    }
  };
  return yn.ConnectionFactoryBase = i, yn;
}
var Fl;
function qR() {
  if (Fl) return mn;
  Fl = 1, Object.defineProperty(mn, "__esModule", { value: !0 }), mn.DialogConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ Ae(), i = /* @__PURE__ */ O(), a = /* @__PURE__ */ ue(), o = /* @__PURE__ */ Xe();
  class n extends s.ConnectionFactoryBase {
    create(u, l, p) {
      const d = u.parameters.getProperty(r.PropertyId.Conversation_ApplicationId, ""), h = u.parameters.getProperty(r.PropertyId.Conversation_DialogType), f = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region), g = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), m = u.parameters.getProperty(r.PropertyId.Conversation_Request_Bot_Status_Messages, "true"), v = {};
      v[a.HeaderNames.ConnectionId] = p, v[o.QueryParameterNames.Format] = u.parameters.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase(), v[o.QueryParameterNames.Language] = g, v[o.QueryParameterNames.RequestBotStatusMessages] = m, d && (v[o.QueryParameterNames.BotId] = d, h === r.DialogServiceConfig.DialogTypes.CustomCommands && (v[a.HeaderNames.CustomCommandsAppId] = d));
      const y = h === r.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "", S = h === r.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : h === r.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0", C = {};
      l.token != null && l.token !== "" && (C[l.headerName] = l.token);
      let R = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, "");
      if (!R) {
        const I = s.ConnectionFactoryBase.getHostSuffix(f), E = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, `wss://${f}.${n.BaseUrl}${I}`);
        R = `${E.endsWith("/") ? E : E + "/"}${y}${n.ApiKey}/${S}`;
      }
      this.setCommonUrlParams(u, v, R);
      const w = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(R, v, C, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), w, p));
    }
  }
  return mn.DialogConnectionFactory = n, n.ApiKey = "api", n.BaseUrl = "convai.speech", mn;
}
var Bl;
function FR() {
  if (Bl) return gn;
  Bl = 1, Object.defineProperty(gn, "__esModule", { value: !0 }), gn.DialogServiceConnector = void 0;
  const e = /* @__PURE__ */ qR(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ Se(), s = /* @__PURE__ */ D(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ A(), o = /* @__PURE__ */ nc();
  let n = class extends a.Recognizer {
    /**
     * Initializes an instance of the DialogServiceConnector.
     * @constructor
     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     */
    constructor(u, l) {
      const p = u;
      i.Contracts.throwIfNull(u, "dialogConfig"), super(l, p.properties, new e.DialogConnectionFactory()), this.isTurnComplete = !0, this.privIsDisposed = !1, this.privProperties = p.properties.clone();
      const d = this.buildAgentConfig();
      this.privReco.agentConfig.set(d);
    }
    /**
     * Starts a connection to the service.
     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     * @member DialogServiceConnector.prototype.connect
     * @function
     * @public
     */
    connect(u, l) {
      (0, s.marshalPromiseToCallbacks)(this.privReco.connect(), u, l);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
     *
     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
     */
    disconnect(u, l) {
      (0, s.marshalPromiseToCallbacks)(this.privReco.disconnect(), u, l);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Sets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(u) {
      i.Contracts.throwIfNullOrWhitespace(u, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, u);
    }
    /**
     * The collection of properties and their values defined for this DialogServiceConnector.
     * @member DialogServiceConnector.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
     */
    get properties() {
      return this.privProperties;
    }
    /** Gets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be empty
     */
    get speechActivityTemplate() {
      return this.properties.getProperty(o.PropertyId.Conversation_Speech_Activity_Template);
    }
    /** Sets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be null or empty.
     * Note: it has to be a valid Json object.
     */
    set speechActivityTemplate(u) {
      this.properties.setProperty(o.PropertyId.Conversation_Speech_Activity_Template, u);
    }
    /**
     * Starts recognition and stops after the first utterance is recognized.
     * @member DialogServiceConnector.prototype.listenOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the reco has completed.
     * @param err - Callback invoked in case of an error.
     */
    listenOnceAsync(u, l) {
      if (this.isTurnComplete) {
        i.Contracts.throwIfDisposed(this.privIsDisposed);
        const d = (async () => {
          await this.privReco.connect(), await this.implRecognizerStop(), this.isTurnComplete = !1;
          const h = new s.Deferred();
          await this.privReco.recognize(r.RecognitionMode.Conversation, h.resolve, h.reject);
          const f = await h.promise;
          return await this.implRecognizerStop(), f;
        })();
        d.catch(() => {
          this.dispose(!0).catch(() => {
          });
        }), (0, s.marshalPromiseToCallbacks)(d.finally(() => {
          this.isTurnComplete = !0;
        }), u, l);
      }
    }
    sendActivityAsync(u, l, p) {
      (0, s.marshalPromiseToCallbacks)(this.privReco.sendMessage(u), l, p);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member DialogServiceConnector.prototype.close
     * @function
     * @public
     */
    close(u, l) {
      i.Contracts.throwIfDisposed(this.privIsDisposed), (0, s.marshalPromiseToCallbacks)(this.dispose(!0), u, l);
    }
    async dispose(u) {
      this.privIsDisposed || u && (this.privIsDisposed = !0, await this.implRecognizerStop(), await super.dispose(u));
    }
    createRecognizerConfig(u) {
      return new t.RecognizerConfig(u, this.privProperties);
    }
    createServiceRecognizer(u, l, p, d) {
      const h = p;
      return new t.DialogServiceAdapter(u, l, h, d, this);
    }
    buildAgentConfig() {
      return {
        botInfo: {
          commType: this.properties.getProperty("Conversation_Communication_Type", "Default"),
          commandsCulture: void 0,
          connectionId: this.properties.getProperty(o.PropertyId.Conversation_Agent_Connection_Id),
          conversationId: this.properties.getProperty(o.PropertyId.Conversation_Conversation_Id, void 0),
          fromId: this.properties.getProperty(o.PropertyId.Conversation_From_Id, void 0),
          ttsAudioFormat: this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)
        },
        version: 0.2
      };
    }
  };
  return gn.DialogServiceConnector = n, gn;
}
var Cn = {}, Ul;
function BR() {
  if (Ul) return Cn;
  Ul = 1, Object.defineProperty(Cn, "__esModule", { value: !0 }), Cn.ActivityReceivedEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {any} activity - The activity..
     */
    constructor(r, s) {
      this.privActivity = r, this.privAudioStream = s;
    }
    /**
     * Gets the received activity
     * @member ActivityReceivedEventArgs.prototype.activity
     * @function
     * @public
     * @returns {any} the received activity.
     */
    get activity() {
      return this.privActivity;
    }
    get audioStream() {
      return this.privAudioStream;
    }
  };
  return Cn.ActivityReceivedEventArgs = e, Cn;
}
var Rn = {}, Pn = {}, $l;
function UR() {
  if ($l) return Pn;
  $l = 1, Object.defineProperty(Pn, "__esModule", { value: !0 }), Pn.TurnStatusResponsePayload = void 0;
  class e {
    constructor(r) {
      this.privMessageStatusResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new e(r);
    }
    get interactionId() {
      return this.privMessageStatusResponse.interactionId;
    }
    get conversationId() {
      return this.privMessageStatusResponse.conversationId;
    }
    get statusCode() {
      switch (this.privMessageStatusResponse.statusCode) {
        case "Success":
          return 200;
        case "Failed":
          return 400;
        case "TimedOut":
          return 429;
        default:
          return this.privMessageStatusResponse.statusCode;
      }
    }
  }
  return Pn.TurnStatusResponsePayload = e, Pn;
}
var Vl;
function $R() {
  if (Vl) return Rn;
  Vl = 1, Object.defineProperty(Rn, "__esModule", { value: !0 }), Rn.TurnStatusReceivedEventArgs = void 0;
  const e = /* @__PURE__ */ UR();
  let t = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} turnStatus - The JSON-encoded turn status message.
     */
    constructor(s) {
      this.privTurnStatus = e.TurnStatusResponsePayload.fromJSON(s);
    }
    /**
     * Gets the interaction identifier associated with this turn status event.
     * @member TurnStatusReceivedEventArgs.prototype.interactionId
     * @function
     * @public
     * @returns {any} the received interaction id.
     */
    get interactionId() {
      return this.privTurnStatus.interactionId;
    }
    /**
     * Gets the conversation identifier associated with this turn status event.
     * @member TurnStatusReceivedEventArgs.prototype.conversationId
     * @function
     * @public
     * @returns {any} the received conversation id.
     */
    get conversationId() {
      return this.privTurnStatus.conversationId;
    }
    /**
     * Gets the received turn status code.
     * @member TurnStatusReceivedEventArgs.prototype.statusCode
     * @function
     * @public
     * @returns {number} the received turn status.
     */
    get statusCode() {
      return this.privTurnStatus.statusCode;
    }
  };
  return Rn.TurnStatusReceivedEventArgs = t, Rn;
}
var $o = {}, Wl;
function VR() {
  return Wl || (Wl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ServicePropertyChannel = void 0, function(t) {
      t[t.UriQueryParameter = 0] = "UriQueryParameter";
    }(e.ServicePropertyChannel || (e.ServicePropertyChannel = {}));
  }($o)), $o;
}
var Vo = {}, Hl;
function WR() {
  return Hl || (Hl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ProfanityOption = void 0, function(t) {
      t[t.Masked = 0] = "Masked", t[t.Removed = 1] = "Removed", t[t.Raw = 2] = "Raw";
    }(e.ProfanityOption || (e.ProfanityOption = {}));
  }(Vo)), Vo;
}
var bn = {}, Kl;
function HR() {
  if (Kl) return bn;
  Kl = 1, Object.defineProperty(bn, "__esModule", { value: !0 }), bn.BaseAudioPlayer = void 0;
  const e = /* @__PURE__ */ Oe(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Dt();
  let s = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
     */
    constructor(a) {
      this.audioContext = null, this.gainNode = null, this.autoUpdateBufferTimer = 0, a === void 0 && (a = t.AudioStreamFormat.getDefaultInputFormat()), this.init(a);
    }
    /**
     * play Audio sample
     * @param newAudioData audio data to be played.
     */
    playAudioSample(a, o, n) {
      try {
        this.ensureInitializedContext();
        const c = this.formatAudioData(a), u = new Float32Array(this.samples.length + c.length);
        u.set(this.samples, 0), u.set(c, this.samples.length), this.samples = u, o && o();
      } catch (c) {
        n && n(c);
      }
    }
    /**
     * stops audio and clears the buffers
     */
    stopAudio(a, o) {
      this.audioContext !== null && (this.samples = new Float32Array(), clearInterval(this.autoUpdateBufferTimer), this.audioContext.close().then(() => {
        a && a();
      }, (n) => {
        o && o(n);
      }), this.audioContext = null);
    }
    init(a) {
      this.audioFormat = a, this.samples = new Float32Array();
    }
    ensureInitializedContext() {
      if (this.audioContext === null) {
        this.createAudioContext();
        const a = 200;
        this.autoUpdateBufferTimer = setInterval(() => {
          this.updateAudioBuffer();
        }, a);
      }
    }
    createAudioContext() {
      this.audioContext = r.AudioStreamFormatImpl.getAudioContext(), this.gainNode = this.audioContext.createGain(), this.gainNode.gain.value = 1, this.gainNode.connect(this.audioContext.destination), this.startTime = this.audioContext.currentTime;
    }
    formatAudioData(a) {
      switch (this.audioFormat.bitsPerSample) {
        case 8:
          return this.formatArrayBuffer(new Int8Array(a), 128);
        case 16:
          return this.formatArrayBuffer(new Int16Array(a), 32768);
        case 32:
          return this.formatArrayBuffer(new Int32Array(a), 2147483648);
        default:
          throw new e.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
      }
    }
    formatArrayBuffer(a, o) {
      const n = new Float32Array(a.length);
      for (let c = 0; c < a.length; c++)
        n[c] = a[c] / o;
      return n;
    }
    updateAudioBuffer() {
      if (this.samples.length === 0)
        return;
      const a = this.audioFormat.channels, o = this.audioContext.createBufferSource(), n = this.samples.length / a, c = this.audioContext.createBuffer(a, n, this.audioFormat.samplesPerSec);
      for (let u = 0; u < a; u++) {
        let l = u;
        const p = c.getChannelData(u);
        for (let d = 0; d < this.samples.length; d++, l += a)
          p[d] = this.samples[l];
      }
      this.startTime < this.audioContext.currentTime && (this.startTime = this.audioContext.currentTime), o.buffer = c, o.connect(this.gainNode), o.start(this.startTime), this.startTime += c.duration, this.samples = new Float32Array();
    }
    async playAudio(a) {
      this.audioContext === null && this.createAudioContext();
      const o = this.audioContext.createBufferSource(), n = this.audioContext.destination;
      await this.audioContext.decodeAudioData(a, (c) => {
        o.buffer = c, o.connect(n), o.start(0);
      });
    }
  };
  return bn.BaseAudioPlayer = s, bn;
}
var wn = {}, Jl;
function KR() {
  if (Jl) return wn;
  Jl = 1, Object.defineProperty(wn, "__esModule", { value: !0 }), wn.ConnectionMessageEventArgs = void 0;
  let e = class {
    constructor(r) {
      this.privConnectionMessage = r;
    }
    /**
     * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
     */
    get message() {
      return this.privConnectionMessage;
    }
    /**
     * Returns a string that represents the connection message event.
     */
    toString() {
      return "Message: " + this.privConnectionMessage.toString();
    }
  };
  return wn.ConnectionMessageEventArgs = e, wn;
}
var En = {}, Gl;
function JR() {
  if (Gl) return En;
  Gl = 1, Object.defineProperty(En, "__esModule", { value: !0 }), En.VoiceProfile = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} profileId - profileId of this Voice Profile.
     * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
     */
    constructor(r, s) {
      this.privId = r, this.privProfileType = s;
    }
    /**
     * profileId of this Voice Profile instance
     * @member VoiceProfile.prototype.profileId
     * @function
     * @public
     * @returns {string} profileId of this Voice Profile instance.
     */
    get profileId() {
      return this.privId;
    }
    /**
     * profileType of this Voice Profile instance
     * @member VoiceProfile.prototype.profileType
     * @function
     * @public
     * @returns {VoiceProfileType} profile type of this Voice Profile instance.
     */
    get profileType() {
      return this.privProfileType;
    }
  };
  return En.VoiceProfile = e, En;
}
var gt = {}, Ql;
function GR() {
  if (Ql) return gt;
  Ql = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.VoiceProfileEnrollmentCancellationDetails = gt.VoiceProfileEnrollmentResult = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ A();
  let r = class Fa {
    constructor(a, o, n) {
      this.privReason = a, this.privProperties = new t.PropertyCollection(), this.privReason !== t.ResultReason.Canceled ? o && (this.privDetails = JSON.parse(o), this.privDetails.enrollmentStatus.toLowerCase() === "enrolling" && (this.privReason = t.ResultReason.EnrollingVoiceProfile)) : (this.privErrorDetails = n, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[t.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get enrollmentsCount() {
      return this.privDetails.enrollmentsCount;
    }
    get enrollmentsLength() {
      return this.privDetails.enrollmentsLength;
    }
    get properties() {
      return this.privProperties;
    }
    get enrollmentResultDetails() {
      return this.privDetails;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
    static FromIdentificationProfileList(a) {
      const o = [];
      for (const n of a.value) {
        const c = n.enrollmentStatus.toLowerCase() === "enrolling" ? t.ResultReason.EnrollingVoiceProfile : n.enrollmentStatus.toLowerCase() === "enrolled" ? t.ResultReason.EnrolledVoiceProfile : t.ResultReason.Canceled, u = new Fa(c, null, null);
        u.privDetails = this.getIdentificationDetails(n), o.push(u);
      }
      return o;
    }
    static FromVerificationProfileList(a) {
      const o = [];
      for (const n of a.value) {
        const c = n.enrollmentStatus.toLowerCase() === "enrolling" ? t.ResultReason.EnrollingVoiceProfile : n.enrollmentStatus.toLowerCase() === "enrolled" ? t.ResultReason.EnrolledVoiceProfile : t.ResultReason.Canceled, u = new Fa(c, null, null);
        u.privDetails = this.getVerificationDetails(n), o.push(u);
      }
      return o;
    }
    static getIdentificationDetails(a) {
      return {
        audioLength: a.audioLength ? parseFloat(a.audioLength) : 0,
        audioSpeechLength: a.audioSpeechLength ? parseFloat(a.audioSpeechLength) : 0,
        enrollmentStatus: a.enrollmentStatus,
        enrollmentsCount: a.enrollmentsCount || 0,
        enrollmentsLength: a.enrollmentsLength ? parseFloat(a.enrollmentsLength) : 0,
        enrollmentsSpeechLength: a.enrollmentsSpeechLength ? parseFloat(a.enrollmentsSpeechLength) : 0,
        profileId: a.profileId || a.identificationProfileId,
        remainingEnrollmentsSpeechLength: a.remainingEnrollmentsSpeechLength ? parseFloat(a.remainingEnrollmentsSpeechLength) : 0
      };
    }
    static getVerificationDetails(a) {
      return {
        audioLength: a.audioLength ? parseFloat(a.audioLength) : 0,
        audioSpeechLength: a.audioSpeechLength ? parseFloat(a.audioSpeechLength) : 0,
        enrollmentStatus: a.enrollmentStatus,
        enrollmentsCount: a.enrollmentsCount,
        enrollmentsLength: a.enrollmentsLength ? parseFloat(a.enrollmentsLength) : 0,
        enrollmentsSpeechLength: a.enrollmentsSpeechLength ? parseFloat(a.enrollmentsSpeechLength) : 0,
        profileId: a.profileId || a.verificationProfileId,
        remainingEnrollmentsCount: a.remainingEnrollments || a.remainingEnrollmentsCount,
        remainingEnrollmentsSpeechLength: a.remainingEnrollmentsSpeechLength ? parseFloat(a.remainingEnrollmentsSpeechLength) : 0
      };
    }
  };
  gt.VoiceProfileEnrollmentResult = r;
  class s extends t.CancellationDetailsBase {
    constructor(a, o, n) {
      super(a, o, n);
    }
    /**
     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
     * @member VoiceProfileEnrollmentCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      const o = t.CancellationReason.Error;
      let n = t.CancellationErrorCode.NoError;
      return a.properties && (n = t.CancellationErrorCode[a.properties.getProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[t.CancellationErrorCode.NoError])]), new s(o, a.errorDetails, n);
    }
  }
  return gt.VoiceProfileEnrollmentCancellationDetails = s, gt;
}
var mt = {}, Yl;
function QR() {
  if (Yl) return mt;
  Yl = 1, Object.defineProperty(mt, "__esModule", { value: !0 }), mt.VoiceProfileCancellationDetails = mt.VoiceProfileResult = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A();
  let s = class {
    constructor(o, n) {
      this.privReason = o, this.privProperties = new r.PropertyCollection(), o === r.ResultReason.Canceled && (t.Contracts.throwIfNullOrUndefined(n, "statusText"), this.privErrorDetails = n, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get properties() {
      return this.privProperties;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  mt.VoiceProfileResult = s;
  class i extends r.CancellationDetailsBase {
    constructor(o, n, c) {
      super(o, n, c);
    }
    /**
     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
     * @member VoiceProfileCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileResult} result - The result that was canceled.
     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
     */
    static fromResult(o) {
      const n = r.CancellationReason.Error;
      let c = r.CancellationErrorCode.NoError;
      return o.properties && (c = r.CancellationErrorCode[o.properties.getProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new i(n, o.errorDetails, c);
    }
  }
  return mt.VoiceProfileCancellationDetails = i, mt;
}
var In = {}, Zl;
function YR() {
  if (Zl) return In;
  Zl = 1, Object.defineProperty(In, "__esModule", { value: !0 }), In.VoiceProfilePhraseResult = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class extends t.VoiceProfileResult {
    constructor(i, a, o, n) {
      super(i, a), this.privPhrases = [], e.Contracts.throwIfNullOrUndefined(n, "phrase array"), this.privType = o, n && n[0] && (this.privPhrases = n);
    }
    get phrases() {
      return this.privPhrases;
    }
    get type() {
      return this.privType;
    }
  };
  return In.VoiceProfilePhraseResult = r, In;
}
var An = {}, Xl;
function ZR() {
  if (Xl) return An;
  Xl = 1, Object.defineProperty(An, "__esModule", { value: !0 }), An.VoiceProfileClient = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ sv(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A();
  let i = class extends s.Recognizer {
    /**
     * VoiceProfileClient constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
     */
    constructor(o) {
      r.Contracts.throwIfNullOrUndefined(o, "speechConfig");
      const n = o;
      r.Contracts.throwIfNull(n, "speechConfig"), super(t.AudioConfig.fromStreamInput(s.AudioInputStream.createPushStream()), n.properties, new e.VoiceProfileConnectionFactory()), this.privProperties = n.properties.clone(), this.privVoiceAdapter = this.privReco, this.privDisposedVoiceAdapter = !1;
    }
    /**
     * The collection of properties and their values defined for this VoiceProfileClient.
     * @member VoiceProfileClient.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(o) {
      r.Contracts.throwIfNullOrWhitespace(o, "token"), this.properties.setProperty(s.PropertyId.SpeechServiceAuthorization_Token, o);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.createProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Type of Voice Profile to be created
     * @param {string} lang Language string (locale) for Voice Profile
     * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
     */
    async createProfileAsync(o, n) {
      const c = await this.privVoiceAdapter.createProfile(o, n);
      return new s.VoiceProfile(c[0], o);
    }
    /**
     * Get current information of a voice profile
     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to retrieve info for
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async retrieveEnrollmentResultAsync(o) {
      return this.privVoiceAdapter.retrieveEnrollmentResult(o);
    }
    /**
     * Get all voice profiles on account with given voice profile type
     * @member VoiceProfileClient.prototype.getAllProfilesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
     * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
     */
    async getAllProfilesAsync(o) {
      return this.privVoiceAdapter.getAllProfiles(o);
    }
    /**
     * Get valid authorization phrases for voice profile enrollment
     * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
     * @param {string} lang Language string (locale) for Voice Profile
     */
    async getActivationPhrasesAsync(o, n) {
      return this.privVoiceAdapter.getActivationPhrases(o, n);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.enrollProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to create enrollment for
     * @param {AudioConfig} audioConfig source info from which to create enrollment
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async enrollProfileAsync(o, n) {
      const c = n;
      return r.Contracts.throwIfNullOrUndefined(c, "audioConfig"), this.audioConfig = n, this.privVoiceAdapter.SpeakerAudioSource = c, this.privVoiceAdapter.enrollProfile(o);
    }
    /**
     * Delete a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.deleteProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be deleted
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async deleteProfileAsync(o) {
      return this.privVoiceAdapter.deleteProfile(o);
    }
    /**
     * Remove all enrollments for a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.resetProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be reset
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async resetProfileAsync(o) {
      return this.privVoiceAdapter.resetProfile(o);
    }
    /**
     * Clean up object and close underlying connection
     * @member VoiceProfileClient.prototype.close
     * @function
     * @async
     * @public
     */
    async close() {
      await this.dispose(!0);
    }
    createServiceRecognizer(o, n, c, u) {
      const l = c;
      return new e.VoiceServiceRecognizer(o, n, l, u, this);
    }
    async dispose(o) {
      this.privDisposedVoiceAdapter || (this.privDisposedVoiceAdapter = !0, o && await super.dispose(o));
    }
    createRecognizerConfig(o) {
      return new e.RecognizerConfig(o, this.properties);
    }
    getResult(o, n) {
      return new s.VoiceProfileResult(o.ok ? n : s.ResultReason.Canceled, o.statusText);
    }
  };
  return An.VoiceProfileClient = i, An;
}
var Tn = {}, ep;
function XR() {
  if (ep) return Tn;
  ep = 1, Object.defineProperty(Tn, "__esModule", { value: !0 }), Tn.SpeakerRecognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A();
  let s = class extends r.Recognizer {
    /**
     * Initializes an instance of the SpeakerRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(a, o) {
      t.Contracts.throwIfNullOrUndefined(a, "speechConfig");
      const n = a;
      t.Contracts.throwIfNullOrUndefined(n, "speechConfig"), super(o, n.properties, new e.SpeakerRecognitionConnectionFactory()), this.privAudioConfigImpl = o, t.Contracts.throwIfNull(this.privAudioConfigImpl, "audioConfig"), this.privDisposedSpeakerRecognizer = !1, this.privProperties = n.properties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      t.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * The collection of properties and their values defined for this SpeakerRecognizer.
     * @member SpeakerRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Get recognition result for model using given audio
     * @member SpeakerRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @async
     * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
     * @param cb - Callback invoked once result is returned.
     * @param err - Callback invoked in case of an error.
     */
    async recognizeOnceAsync(a) {
      return t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), this.recognizeSpeakerOnceAsyncImpl(a);
    }
    /**
     * Included for compatibility
     * @member SpeakerRecognizer.prototype.close
     * @function
     * @public
     * @async
     */
    async close() {
      t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.dispose(!0);
    }
    async recognizeSpeakerOnceAsyncImpl(a) {
      t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.implRecognizerStop();
      const o = await this.privReco.recognizeSpeaker(a);
      return await this.implRecognizerStop(), o;
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    createRecognizerConfig(a) {
      return new e.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, o, n, c) {
      const u = n;
      return new e.SpeakerServiceRecognizer(a, o, u, c, this);
    }
    async dispose(a) {
      this.privDisposedSpeakerRecognizer || a && (this.privDisposedSpeakerRecognizer = !0, await super.dispose(a));
    }
  };
  return Tn.SpeakerRecognizer = s, Tn;
}
var _n = {}, tp;
function eP() {
  if (tp) return _n;
  tp = 1, Object.defineProperty(_n, "__esModule", { value: !0 }), _n.SpeakerIdentificationModel = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class Sv {
    constructor(i) {
      if (this.privVoiceProfiles = [], this.privProfileIds = [], e.Contracts.throwIfNullOrUndefined(i, "VoiceProfiles"), i.length === 0)
        throw new Error("Empty Voice Profiles array");
      for (const a of i) {
        if (a.profileType !== t.VoiceProfileType.TextIndependentIdentification)
          throw new Error("Identification model can only be created from Identification profile: " + a.profileId);
        this.privVoiceProfiles.push(a), this.privProfileIds.push(a.profileId);
      }
    }
    static fromProfiles(i) {
      return new Sv(i);
    }
    get voiceProfileIds() {
      return this.privProfileIds.join(",");
    }
    get profileIds() {
      return this.privProfileIds;
    }
    get scenario() {
      return "TextIndependentIdentification";
    }
  };
  return _n.SpeakerIdentificationModel = r, _n;
}
var kn = {}, rp;
function tP() {
  if (rp) return kn;
  rp = 1, Object.defineProperty(kn, "__esModule", { value: !0 }), kn.SpeakerVerificationModel = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class Cv {
    constructor(i) {
      if (e.Contracts.throwIfNullOrUndefined(i, "VoiceProfile"), i.profileType === t.VoiceProfileType.TextIndependentIdentification)
        throw new Error("Verification model cannot be created from Identification profile");
      this.privVoiceProfile = i;
    }
    static fromProfile(i) {
      return new Cv(i);
    }
    get voiceProfile() {
      return this.privVoiceProfile;
    }
    get profileIds() {
      return [this.voiceProfile.profileId];
    }
    get scenario() {
      return this.voiceProfile.profileType === t.VoiceProfileType.TextDependentVerification ? "TextDependentVerification" : "TextIndependentVerification";
    }
  };
  return kn.SpeakerVerificationModel = r, kn;
}
var On = {}, Wo = {}, np;
function Rv() {
  return np || (np = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LanguageIdMode = void 0, function(t) {
      t[t.AtStart = 0] = "AtStart", t[t.Continuous = 1] = "Continuous";
    }(e.LanguageIdMode || (e.LanguageIdMode = {}));
  }(Wo)), Wo;
}
var ip;
function rP() {
  if (ip) return On;
  ip = 1, Object.defineProperty(On, "__esModule", { value: !0 }), On.AutoDetectSourceLanguageConfig = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ Rv();
  let i = class ks {
    constructor() {
      this.privProperties = new r.PropertyCollection(), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart"), this.privLanguageIdMode = s.LanguageIdMode.AtStart;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromOpenRange
     * @function
     * @public
     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
     */
    static fromOpenRange() {
      const o = new ks();
      return o.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, e.AutoDetectSourceLanguagesOpenRangeOptionName), o.properties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), o;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromLanguages
     * @function
     * @public
     * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
     */
    static fromLanguages(o) {
      t.Contracts.throwIfArrayEmptyOrWhitespace(o, "languages");
      const n = new ks();
      return n.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, o.join()), n;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
     * @function
     * @public
     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
     */
    static fromSourceLanguageConfigs(o) {
      if (o.length < 1)
        throw new Error("Expected non-empty SourceLanguageConfig array.");
      const n = new ks(), c = [];
      return o.forEach((u) => {
        if (c.push(u.language), u.endpointId !== void 0 && u.endpointId !== "") {
          const l = u.language + r.PropertyId.SpeechServiceConnection_EndpointId.toString();
          n.properties.setProperty(l, u.endpointId);
        }
      }), n.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, c.join()), n;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets an auto detected language config properties
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.mode
     * @function
     * @public
     * @param {LanguageIdMode} mode LID mode desired.
     * @summary Sets LID operation to desired mode
     */
    set mode(o) {
      o === s.LanguageIdMode.Continuous ? (this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous")) : (this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart")), this.privLanguageIdMode = o;
    }
  };
  return On.AutoDetectSourceLanguageConfig = i, On;
}
var Mn = {}, sp;
function nP() {
  if (sp) return Mn;
  sp = 1, Object.defineProperty(Mn, "__esModule", { value: !0 }), Mn.AutoDetectSourceLanguageResult = void 0;
  const e = /* @__PURE__ */ z();
  let t = class Ba {
    constructor(s, i) {
      e.Contracts.throwIfNullOrUndefined(s, "language"), e.Contracts.throwIfNullOrUndefined(i, "languageDetectionConfidence"), this.privLanguage = s, this.privLanguageDetectionConfidence = i;
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
     * @member AutoDetectSourceLanguageResult.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult} result - The recognition result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */
    static fromResult(s) {
      return new Ba(s.language, s.languageDetectionConfidence);
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
     * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
     * @function
     * @public
     * @param {ConversationTranscriptionResult} result - The transcription result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */
    static fromConversationTranscriptionResult(s) {
      return new Ba(s.language, s.languageDetectionConfidence);
    }
    get language() {
      return this.privLanguage;
    }
    get languageDetectionConfidence() {
      return this.privLanguageDetectionConfidence;
    }
  };
  return Mn.AutoDetectSourceLanguageResult = t, Mn;
}
var Dn = {}, op;
function iP() {
  if (op) return Dn;
  op = 1, Object.defineProperty(Dn, "__esModule", { value: !0 }), Dn.SourceLanguageConfig = void 0;
  const e = /* @__PURE__ */ z();
  let t = class Pv {
    constructor(s, i) {
      e.Contracts.throwIfNullOrUndefined(s, "language"), this.privLanguage = s, this.privEndpointId = i;
    }
    /**
     * @member SourceLanguageConfig.fromLanguage
     * @function
     * @public
     * @param {string} language language (eg. "en-US") value of config.
     * @param {string?} endpointId endpointId of model bound to given language of config.
     * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
     * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
     * Added in version 1.13.0.
     */
    static fromLanguage(s, i) {
      return new Pv(s, i);
    }
    get language() {
      return this.privLanguage;
    }
    get endpointId() {
      return this.privEndpointId;
    }
  };
  return Dn.SourceLanguageConfig = t, Dn;
}
var Ho = {}, ap;
function sP() {
  return ap || (ap = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeakerRecognitionCancellationDetails = e.SpeakerRecognitionResult = e.SpeakerRecognitionResultType = void 0;
    const t = /* @__PURE__ */ O(), r = /* @__PURE__ */ A();
    var s;
    (function(o) {
      o[o.Verify = 0] = "Verify", o[o.Identify = 1] = "Identify";
    })(s = e.SpeakerRecognitionResultType || (e.SpeakerRecognitionResultType = {}));
    class i {
      constructor(n, c = r.ResultReason.RecognizedSpeaker, u = r.CancellationErrorCode.NoError, l = "") {
        this.privProperties = new r.PropertyCollection();
        const p = n.scenario === "TextIndependentIdentification" ? s.Identify : s.Verify;
        this.privReason = c, this.privReason !== r.ResultReason.Canceled ? p === s.Identify ? (this.privProfileId = n.identificationResult.identifiedProfile.profileId, this.privScore = n.identificationResult.identifiedProfile.score, this.privReason = r.ResultReason.RecognizedSpeakers) : (this.privScore = n.verificationResult.score, n.verificationResult.recognitionResult.toLowerCase() !== "accept" && (this.privReason = r.ResultReason.NoMatch), n.verificationResult.profileId !== void 0 && n.verificationResult.profileId !== "" && (this.privProfileId = n.verificationResult.profileId)) : (this.privErrorDetails = l, this.privProperties.setProperty(t.CancellationErrorCodePropertyName, r.CancellationErrorCode[u])), this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(n));
      }
      get properties() {
        return this.privProperties;
      }
      get reason() {
        return this.privReason;
      }
      get profileId() {
        return this.privProfileId;
      }
      get errorDetails() {
        return this.privErrorDetails;
      }
      get score() {
        return this.privScore;
      }
    }
    e.SpeakerRecognitionResult = i;
    class a extends r.CancellationDetailsBase {
      constructor(n, c, u) {
        super(n, c, u);
      }
      /**
       * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
       * @member SpeakerRecognitionCancellationDetails.fromResult
       * @function
       * @public
       * @param {SpeakerRecognitionResult} result - The result that was canceled.
       * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
       */
      static fromResult(n) {
        const c = r.CancellationReason.Error;
        let u = r.CancellationErrorCode.NoError;
        return n.properties && (u = r.CancellationErrorCode[n.properties.getProperty(t.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new a(c, n.errorDetails, u);
      }
    }
    e.SpeakerRecognitionCancellationDetails = a;
  }(Ho)), Ho;
}
var Ko = {}, yt = {}, cp;
function bv() {
  if (cp) return yt;
  cp = 1, Object.defineProperty(yt, "__esModule", { value: !0 }), yt.ConversationImpl = yt.Conversation = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A();
  let i = class {
    constructor() {
    }
    /**
     * Create a conversation
     * @param speechConfig
     * @param cb
     * @param err
     */
    static createConversationAsync(n, c, u, l) {
      r.Contracts.throwIfNullOrUndefined(n, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), r.Contracts.throwIfNullOrUndefined(n.region, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), !n.subscriptionKey && !n.getProperty(s.PropertyId[s.PropertyId.SpeechServiceAuthorization_Token]) && r.Contracts.throwIfNullOrUndefined(n.subscriptionKey, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      let p, d, h;
      return typeof c == "string" ? (p = new a(n, c), (0, t.marshalPromiseToCallbacks)((async () => {
      })(), u, l)) : (p = new a(n), d = c, h = u, p.createConversationAsync(() => {
        d && d();
      }, (f) => {
        h && h(f);
      })), p;
    }
  };
  yt.Conversation = i;
  class a extends i {
    /**
     * Create a conversation impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(n, c) {
      if (super(), this.privErrors = e.ConversationConnectionConfig.restErrors, this.onConnected = (p) => {
        this.privIsConnected = !0;
        try {
          this.privConversationTranslator?.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, p);
        } catch {
        }
      }, this.onDisconnected = (p) => {
        try {
          this.privConversationTranslator?.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, p);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (p, d) => {
        try {
          this.privConversationTranslator?.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, d);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.getParticipant(d.id);
          if (h !== void 0) {
            switch (d.key) {
              case e.ConversationTranslatorCommandTypes.changeNickname:
                h.displayName = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setUseTTS:
                h.isUsingTts = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setProfanityFiltering:
                h.profanity = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setMute:
                h.isMuted = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                h.translateToLanguages = d.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(h), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.Updated, [this.toParticipant(h)], d.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (p, d) => {
        try {
          this.privParticipants.participants.forEach((h) => h.isMuted = h.isHost ? !1 : d.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.Updated, this.toParticipants(!1), d.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.addOrUpdateParticipant(d.participant);
          h !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.JoinedConversation, [this.toParticipant(h)], d.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.getParticipant(d.participant.id);
          h !== void 0 && (this.privParticipants.deleteParticipant(d.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.LeftConversation, [this.toParticipant(h)], d.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (p, d) => {
        try {
          switch (d.command) {
            case e.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new s.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new s.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new s.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (p, d) => {
        try {
          if (d.sessionToken !== void 0 && d.sessionToken !== null && (this.privRoom.token = d.sessionToken), this.privParticipants.participants = [...d.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), d.sessionId)), this.me.isHost) {
            const h = this.privConversationTranslator?.properties.getProperty(s.PropertyId.ConversationTranslator_Name);
            h !== void 0 && h.length > 0 && h !== this.me.displayName && this.changeNicknameAsync(h);
          }
        } catch {
        }
      }, this.onConversationExpiration = (p, d) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, d);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new s.PropertyCollection(), this.privManager = new e.ConversationManager(), n.getProperty(s.PropertyId[s.PropertyId.SpeechServiceConnection_RecoLanguage]) || n.setProperty(s.PropertyId[s.PropertyId.SpeechServiceConnection_RecoLanguage], e.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = n.getProperty(s.PropertyId[s.PropertyId.SpeechServiceConnection_RecoLanguage]), c)
        this.privConversationId = c;
      else {
        n.targetLanguages.length === 0 && n.addTargetLanguage(this.privLanguage), n.getProperty(s.PropertyId[s.PropertyId.SpeechServiceResponse_ProfanityOption]) || n.setProfanity(s.ProfanityOption.Masked);
        let d = n.getProperty(s.PropertyId[s.PropertyId.ConversationTranslator_Name]);
        d == null && (d = "Host"), r.Contracts.throwIfNullOrTooLong(d, "nickname", 50), r.Contracts.throwIfNullOrTooShort(d, "nickname", 2), n.setProperty(s.PropertyId[s.PropertyId.ConversationTranslator_Name], d);
      }
      this.privConfig = n;
      const l = n;
      r.Contracts.throwIfNull(l, "speechConfig"), this.privProperties = l.properties.clone(), this.privIsConnected = !1, this.privParticipants = new e.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the conversation Id
    get conversationId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      return this.privParticipants.me?.isHost ? !1 : this.privParticipants.me?.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get conversationInfo() {
      const n = this.conversationId, c = this.participants.map((p) => ({
        id: p.id,
        preferredLanguage: p.preferredLanguage,
        voice: p.voice
      })), u = {};
      for (const p of e.ConversationConnectionConfig.transcriptionEventKeys) {
        const d = this.properties.getProperty(p, "");
        d !== "" && (u[p] = d);
      }
      return { id: n, participants: c, conversationProperties: u };
    }
    get canSend() {
      return this.privIsConnected && !this.privParticipants.me?.isMuted;
    }
    get canSendAsHost() {
      return this.privIsConnected && this.privParticipants.me?.isHost;
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "authorizationToken"), this.privToken = n;
    }
    set conversationTranslator(n) {
      this.privConversationTranslator = n;
    }
    onToken(n) {
      this.privConversationTranslator.onToken(n);
    }
    /**
     * Create a new conversation as Host
     * @param cb
     * @param err
     */
    createConversationAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new conversation as host.
     * @param cb
     * @param err
     */
    startConversationAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer = e.ConversationRecognizerFactory.fromConfig(this, this.privConfig), this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a conversation as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(n, c, u) {
      r.Contracts.throwIfNullOrUndefined(n, "Participant"), (0, t.marshalPromiseToCallbacks)(this.addParticipantImplAsync(n), c, u);
    }
    /**
     * Join a conversation as a participant.
     * @param conversation
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinConversationAsync(n, c, u, l, p) {
      try {
        r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), r.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, n, (d) => {
          r.Contracts.throwIfNullOrUndefined(d, this.privErrors.permissionDeniedConnect), this.privRoom = d, this.privConfig.authorizationToken = d.cognitiveSpeechAuthToken, l && l(d.cognitiveSpeechAuthToken);
        }, (d) => {
          this.handleError(d, p);
        });
      } catch (d) {
        this.handleError(d, p);
      }
    }
    /**
     * Deletes a conversation
     * @param cb
     * @param err
     */
    deleteConversationAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.deleteConversationImplAsync(), n, c);
    }
    async deleteConversationImplAsync() {
      r.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), r.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endConversationAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.endConversationImplAsync(), n, c);
    }
    endConversationImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockConversationAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the conversation
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !0), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(n, c, u) {
      try {
        if (r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && n.hasOwnProperty("id"))
          (0, t.marshalPromiseToCallbacks)(this.removeParticipantImplAsync(n), c, u);
        else {
          r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let l = "";
          typeof n == "string" ? l = n : n.hasOwnProperty("id") ? l = n.id : n.hasOwnProperty("userId") && (l = n.userId), r.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((d) => d.id === l) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(l), () => {
            this.handleCallback(c, u);
          }, (d) => {
            this.handleError(d, u);
          });
        }
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to unlock the conversation
     * @param cb
     * @param err
     */
    unlockConversationAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the conversation
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !1), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "message")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), n.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfArrayEmptyOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "languages")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(n) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await n.enforceAudioGating(), this.privTranscriberRecognizer = n, this.privTranscriberRecognizer.conversation = this;
    }
    getKeepAlive() {
      const n = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: n,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(n) {
      if (this.privParticipants.addOrUpdateParticipant(n) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.conversationInfo;
        return u.participants = [n], this.privTranscriberRecognizer.pushConversationEvent(u, "join");
      }
    }
    removeParticipantImplAsync(n) {
      this.privParticipants.deleteParticipant(n.id);
      const c = this.conversationInfo;
      return c.participants = [n], this.privTranscriberRecognizer.pushConversationEvent(c, "leave");
    }
    async close(n) {
      try {
        this.privIsConnected = !1, await this.privConversationRecognizer?.close(), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (c) {
        throw c;
      }
      n && this.dispose();
    }
    /** Helpers */
    handleCallback(n, c) {
      if (n) {
        try {
          n();
        } catch (u) {
          c && c(u);
        }
        n = void 0;
      }
    }
    handleError(n, c) {
      if (c)
        if (n instanceof Error) {
          const u = n;
          c(u.name + ": " + u.message);
        } else
          c(n);
    }
    /** Participant Helpers */
    toParticipants(n) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return n ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(n) {
      return new s.Participant(n.id, n.avatar, n.displayName, n.isHost, n.isMuted, n.isUsingTts, n.preferredLanguage, n.voice);
    }
    getMuteAllCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMuteCommand(n, c) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getEjectCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getChangeNicknameCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "nickname"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.changeNickname,
        nickname: n,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMessageCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), r.Contracts.throwIfNullOrWhitespace(n, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: n,
        type: e.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return yt.ConversationImpl = a, yt;
}
var Nn = {}, up;
function oP() {
  if (up) return Nn;
  up = 1, Object.defineProperty(Nn, "__esModule", { value: !0 }), Nn.ConversationCommon = void 0;
  let e = class {
    constructor(r) {
      this.privAudioConfig = r;
    }
    handleCallback(r, s) {
      if (r) {
        try {
          r();
        } catch (i) {
          s && s(i);
        }
        r = void 0;
      }
    }
    handleError(r, s) {
      if (s)
        if (r instanceof Error) {
          const i = r;
          s(i.name + ": " + i.message);
        } else
          s(r);
    }
  };
  return Nn.ConversationCommon = e, Nn;
}
var xn = {}, lp;
function aP() {
  if (lp) return xn;
  lp = 1, Object.defineProperty(xn, "__esModule", { value: !0 }), xn.ConversationExpirationEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    constructor(s, i) {
      super(i), this.privExpirationTime = s;
    }
    /** How much longer until the conversation expires (in minutes). */
    get expirationTime() {
      return this.privExpirationTime;
    }
  };
  return xn.ConversationExpirationEventArgs = t, xn;
}
var zn = {}, pp;
function cP() {
  if (pp) return zn;
  pp = 1, Object.defineProperty(zn, "__esModule", { value: !0 }), zn.ConversationParticipantsChangedEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    constructor(s, i, a) {
      super(a), this.privReason = s, this.privParticipant = i;
    }
    get reason() {
      return this.privReason;
    }
    get participants() {
      return this.privParticipant;
    }
  };
  return zn.ConversationParticipantsChangedEventArgs = t, zn;
}
var Ln = {}, dp;
function uP() {
  if (dp) return Ln;
  dp = 1, Object.defineProperty(Ln, "__esModule", { value: !0 }), Ln.ConversationTranslationCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Rs();
  let t = class extends e.CancellationEventArgsBase {
  };
  return Ln.ConversationTranslationCanceledEventArgs = t, Ln;
}
var jn = {}, hp;
function lP() {
  if (hp) return jn;
  hp = 1, Object.defineProperty(jn, "__esModule", { value: !0 }), jn.ConversationTranslationEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranslationResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(s, i, a) {
      super(i, a), this.privResult = s;
    }
    /**
     * Specifies the recognition result.
     * @returns {ConversationTranslationResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return jn.ConversationTranslationEventArgs = t, jn;
}
var qn = {}, fp;
function pP() {
  if (fp) return qn;
  fp = 1, Object.defineProperty(qn, "__esModule", { value: !0 }), qn.ConversationTranslationResult = void 0;
  const e = /* @__PURE__ */ av();
  let t = class extends e.TranslationRecognitionResult {
    constructor(s, i, a, o, n, c, u, l, p, d, h) {
      super(i, o, n, c, u, l, void 0, void 0, p, d, h), this.privId = s, this.privOrigLang = a;
    }
    /**
     * The unique identifier for the participant this result is for.
     */
    get participantId() {
      return this.privId;
    }
    /**
     * The original language this result was in.
     */
    get originalLang() {
      return this.privOrigLang;
    }
  };
  return qn.ConversationTranslationResult = t, qn;
}
var Jo = {}, Fn = {}, Bn = {}, vp;
function wv() {
  if (vp) return Bn;
  vp = 1, Object.defineProperty(Bn, "__esModule", { value: !0 }), Bn.StringUtils = void 0;
  let e = class {
    /**
     * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
     * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
     * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
     * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
     * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
     */
    static formatString(r, s) {
      if (!r)
        return "";
      if (!s)
        return r;
      let i = "", a = "";
      const o = (u) => {
        i += u;
      }, n = (u) => {
        a += u;
      };
      let c = o;
      for (let u = 0; u < r.length; u++) {
        const l = r[u], p = u + 1 < r.length ? r[u + 1] : "";
        switch (l) {
          case "{":
            p === "{" ? (c("{"), u++) : c = n;
            break;
          case "}":
            p === "}" ? (c("}"), u++) : (s.hasOwnProperty(a) && (i += s[a]), c = o, a = "");
            break;
          default:
            c(l);
            break;
        }
      }
      return i;
    }
  };
  return Bn.StringUtils = e, Bn;
}
var gp;
function dP() {
  if (gp) return Fn;
  gp = 1, Object.defineProperty(Fn, "__esModule", { value: !0 }), Fn.ConversationTranslatorConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ wv(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A(), i = /* @__PURE__ */ ue(), a = /* @__PURE__ */ Xe(), o = /* @__PURE__ */ Ae(), n = /* @__PURE__ */ O();
  let c = class Ev extends o.ConnectionFactoryBase {
    constructor(l) {
      super(), r.Contracts.throwIfNullOrUndefined(l, "convGetter"), this.privConvGetter = l;
    }
    create(l, p, d) {
      const h = l.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE", f = this.privConvGetter().room, g = f.cognitiveSpeechRegion || l.parameters.getProperty(s.PropertyId.SpeechServiceConnection_Region, ""), m = {
        hostSuffix: o.ConnectionFactoryBase.getHostSuffix(g),
        path: Ev.CTS_VIRT_MIC_PATH,
        region: encodeURIComponent(g)
      };
      m[a.QueryParameterNames.Language] = encodeURIComponent(l.parameters.getProperty(s.PropertyId.SpeechServiceConnection_RecoLanguage, "")), m[a.QueryParameterNames.CtsMeetingId] = encodeURIComponent(f.roomId), m[a.QueryParameterNames.CtsDeviceId] = encodeURIComponent(f.participantId), m[a.QueryParameterNames.CtsIsParticipant] = f.isHost ? "" : "&" + a.QueryParameterNames.CtsIsParticipant;
      let v = "";
      const y = {}, S = {};
      if (h) {
        v = l.parameters.getProperty(s.PropertyId.SpeechServiceConnection_Endpoint), v || (v = "wss://" + l.parameters.getProperty(s.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}") + "{path}"), v = t.StringUtils.formatString(v, m);
        const R = new URL(v);
        R.searchParams.forEach((I, E) => {
          y[E] = I;
        }), new n.TranscriberConnectionFactory().setQueryParams(y, l, v), y[a.QueryParameterNames.CtsMeetingId] = m[a.QueryParameterNames.CtsMeetingId], y[a.QueryParameterNames.CtsDeviceId] = m[a.QueryParameterNames.CtsDeviceId], f.isHost || (y[a.QueryParameterNames.CtsIsParticipant] = ""), a.QueryParameterNames.Format in y || (y[a.QueryParameterNames.Format] = "simple"), R.searchParams.forEach((I, E) => {
          R.searchParams.set(E, y[E]), delete y[E];
        }), v = R.toString();
      } else {
        const R = new n.TranslationConnectionFactory();
        v = R.getEndpointUrl(l, !0), v = t.StringUtils.formatString(v, m), R.setQueryParams(y, l, v);
      }
      S[i.HeaderNames.ConnectionId] = d, S[e.RestConfigBase.configParams.token] = f.token, p.token && (S[p.headerName] = p.token);
      const C = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
      return Promise.resolve(new e.WebsocketConnection(v, y, S, new n.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), C, d));
    }
  };
  return Fn.ConversationTranslatorConnectionFactory = c, c.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio", Fn;
}
var mp;
function hP() {
  return mp || (mp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConversationTranslator = e.SpeechState = void 0;
    const t = /* @__PURE__ */ O(), r = /* @__PURE__ */ dP(), s = /* @__PURE__ */ D(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ A(), o = /* @__PURE__ */ bv(), n = /* @__PURE__ */ sc();
    var c;
    (function(p) {
      p[p.Inactive = 0] = "Inactive", p[p.Connecting = 1] = "Connecting", p[p.Connected = 2] = "Connected";
    })(c = e.SpeechState || (e.SpeechState = {}));
    class u extends a.TranslationRecognizer {
      constructor(d, h, f, g) {
        super(d, h, new r.ConversationTranslatorConnectionFactory(g)), this.privSpeechState = c.Inactive, f && (this.privTranslator = f, this.sessionStarted = () => {
          this.privSpeechState = c.Connected;
        }, this.sessionStopped = () => {
          this.privSpeechState = c.Inactive;
        }, this.recognizing = (m, v) => {
          this.privTranslator.recognizing && this.privTranslator.recognizing(this.privTranslator, v);
        }, this.recognized = async (m, v) => {
          v.result?.errorDetails ? (await this.cancelSpeech(), this.fireCancelEvent(v.result.errorDetails)) : this.privTranslator.recognized && this.privTranslator.recognized(this.privTranslator, v);
        }, this.canceled = async () => {
          if (this.privSpeechState !== c.Inactive)
            try {
              await this.cancelSpeech();
            } catch {
              this.privSpeechState = c.Inactive;
            }
        });
      }
      get state() {
        return this.privSpeechState;
      }
      set state(d) {
        this.privSpeechState = d;
      }
      set authentication(d) {
        this.privReco.authentication = d;
      }
      onConnection() {
        this.privSpeechState = c.Connected;
      }
      async onCancelSpeech() {
        this.privSpeechState = c.Inactive, await this.cancelSpeech();
      }
      /**
       * Fire a cancel event
       * @param error
       */
      fireCancelEvent(d) {
        try {
          if (this.privTranslator.canceled) {
            const h = new n.ConversationTranslationCanceledEventArgs(a.CancellationReason.Error, d, a.CancellationErrorCode.RuntimeError);
            this.privTranslator.canceled(this.privTranslator, h);
          }
        } catch {
        }
      }
      async cancelSpeech() {
        try {
          this.stopContinuousRecognitionAsync(), await this.privReco?.disconnect(), this.privSpeechState = c.Inactive;
        } catch {
        }
      }
    }
    class l extends n.ConversationCommon {
      constructor(d) {
        super(d), this.privErrors = t.ConversationConnectionConfig.restErrors, this.privIsDisposed = !1, this.privIsSpeaking = !1, this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345", this.privPlaceholderRegion = "westus", this.privProperties = new a.PropertyCollection();
      }
      get properties() {
        return this.privProperties;
      }
      get speechRecognitionLanguage() {
        return this.privSpeechRecognitionLanguage;
      }
      get participants() {
        return this.privConversation?.participants;
      }
      get canSpeak() {
        return !(!this.privConversation.isConnected || !this.privCTRecognizer || this.privIsSpeaking || this.privCTRecognizer.state === c.Connected || this.privCTRecognizer.state === c.Connecting || this.privConversation.isMutedByHost);
      }
      onToken(d) {
        this.privCTRecognizer.authentication = d;
      }
      setServiceProperty(d, h) {
        const f = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
        f[d] = h, this.privProperties.setProperty(t.ServicePropertiesPropertyName, JSON.stringify(f));
      }
      joinConversationAsync(d, h, f, g, m) {
        try {
          if (typeof d == "string") {
            i.Contracts.throwIfNullOrUndefined(d, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), i.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privConversation && this.handleError(new Error(this.privErrors.permissionDeniedStart), m);
            let v = f;
            (v == null || v === "") && (v = t.ConversationConnectionConfig.defaultLanguageCode), this.privSpeechTranslationConfig = a.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion), this.privSpeechTranslationConfig.setProfanity(a.ProfanityOption.Masked), this.privSpeechTranslationConfig.addTargetLanguage(v), this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_RecoLanguage], v), this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.ConversationTranslator_Name], h);
            const y = [
              a.PropertyId.SpeechServiceConnection_Host,
              a.PropertyId.ConversationTranslator_Host,
              a.PropertyId.SpeechServiceConnection_Endpoint,
              a.PropertyId.SpeechServiceConnection_ProxyHostName,
              a.PropertyId.SpeechServiceConnection_ProxyPassword,
              a.PropertyId.SpeechServiceConnection_ProxyPort,
              a.PropertyId.SpeechServiceConnection_ProxyUserName,
              "ConversationTranslator_MultiChannelAudio",
              "ConversationTranslator_Region"
            ];
            for (const C of y) {
              const R = this.privProperties.getProperty(C);
              if (R) {
                const w = typeof C == "string" ? C : a.PropertyId[C];
                this.privSpeechTranslationConfig.setProperty(w, R);
              }
            }
            const S = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
            for (const C of Object.keys(S))
              this.privSpeechTranslationConfig.setServiceProperty(C, S[C], a.ServicePropertyChannel.UriQueryParameter);
            this.privConversation = new o.ConversationImpl(this.privSpeechTranslationConfig), this.privConversation.conversationTranslator = this, this.privConversation.joinConversationAsync(d, h, v, (C) => {
              C || this.handleError(new Error(this.privErrors.permissionDeniedConnect), m), this.privSpeechTranslationConfig.authorizationToken = C, this.privConversation.room.isHost = !1, this.privConversation.startConversationAsync(() => {
                this.handleCallback(g, m);
              }, (R) => {
                this.handleError(R, m);
              });
            }, (C) => {
              this.handleError(C, m);
            });
          } else typeof d == "object" ? (i.Contracts.throwIfNullOrUndefined(d, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), i.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privProperties.setProperty(a.PropertyId.ConversationTranslator_Name, h), this.privConversation = d, this.privConversation.conversationTranslator = this, this.privConversation.room.isHost = !0, i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect), i.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privSpeechTranslationConfig = d.config, this.handleCallback(f, g)) : this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), g);
        } catch (v) {
          this.handleError(v, typeof f == "string" ? m : g);
        }
      }
      /**
       * Leave the conversation
       * @param cb
       * @param err
       */
      leaveConversationAsync(d, h) {
        (0, s.marshalPromiseToCallbacks)((async () => {
          await this.cancelSpeech(), await this.privConversation.endConversationImplAsync(), await this.privConversation.deleteConversationImplAsync(), this.dispose();
        })(), d, h);
      }
      /**
       * Send a text message
       * @param message
       * @param cb
       * @param err
       */
      sendTextMessageAsync(d, h, f) {
        try {
          i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), i.Contracts.throwIfNullOrWhitespace(d, this.privErrors.invalidArgs.replace("{arg}", d)), this.privConversation.sendTextMessageAsync(d, h, f);
        } catch (g) {
          this.handleError(g, f);
        }
      }
      /**
       * Start speaking
       * @param cb
       * @param err
       */
      startTranscribingAsync(d, h) {
        (0, s.marshalPromiseToCallbacks)((async () => {
          try {
            i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), i.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privCTRecognizer === void 0 && await this.connectTranslatorRecognizer(), i.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend), this.canSpeak || this.handleError(new Error(this.privErrors.permissionDeniedSend), h), await this.startContinuousRecognition(), this.privIsSpeaking = !0;
          } catch (f) {
            throw this.privIsSpeaking = !1, await this.cancelSpeech(), f;
          }
        })(), d, h);
      }
      /**
       * Stop speaking
       * @param cb
       * @param err
       */
      stopTranscribingAsync(d, h) {
        (0, s.marshalPromiseToCallbacks)((async () => {
          try {
            if (!this.privIsSpeaking) {
              await this.cancelSpeech();
              return;
            }
            this.privIsSpeaking = !1, await new Promise((f, g) => {
              this.privCTRecognizer.stopContinuousRecognitionAsync(f, g);
            });
          } catch {
            await this.cancelSpeech();
          }
        })(), d, h);
      }
      isDisposed() {
        return this.privIsDisposed;
      }
      dispose(d, h, f) {
        (0, s.marshalPromiseToCallbacks)((async () => {
          this.isDisposed && !this.privIsSpeaking || (await this.cancelSpeech(), this.privIsDisposed = !0, this.privSpeechTranslationConfig.close(), this.privSpeechRecognitionLanguage = void 0, this.privProperties = void 0, this.privAudioConfig = void 0, this.privSpeechTranslationConfig = void 0, this.privConversation.dispose(), this.privConversation = void 0);
        })(), h, f);
      }
      /**
       * Cancel the speech websocket
       */
      async cancelSpeech() {
        try {
          this.privIsSpeaking = !1, await this.privCTRecognizer?.onCancelSpeech(), this.privCTRecognizer = void 0;
        } catch {
        }
      }
      /**
       * Connect to the speech translation recognizer.
       * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
       * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
       * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
       */
      async connectTranslatorRecognizer() {
        try {
          this.privAudioConfig === void 0 && (this.privAudioConfig = a.AudioConfig.fromDefaultMicrophoneInput()), this.privSpeechTranslationConfig.getProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey && this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_Key], "");
          const d = () => this.privConversation;
          this.privCTRecognizer = new u(this.privSpeechTranslationConfig, this.privAudioConfig, this, d);
        } catch (d) {
          throw await this.cancelSpeech(), d;
        }
      }
      /**
       * Handle the start speaking request
       */
      startContinuousRecognition() {
        return new Promise((d, h) => {
          this.privCTRecognizer.startContinuousRecognitionAsync(d, h);
        });
      }
    }
    e.ConversationTranslator = l;
  }(Jo)), Jo;
}
var Un = {}, yp;
function fP() {
  if (yp) return Un;
  yp = 1, Object.defineProperty(Un, "__esModule", { value: !0 }), Un.ConversationTranscriber = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ Se(), r = /* @__PURE__ */ D(), s = /* @__PURE__ */ z(), i = /* @__PURE__ */ A();
  let a = class Iv extends i.Recognizer {
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      s.Contracts.throwIfNull(u, "speechConfig"), s.Contracts.throwIfNullOrWhitespace(u.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new e.ConversationTranscriberConnectionFactory(), n.tokenCredential), this.privProperties.setProperty(i.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privDisposedRecognizer = !1;
    }
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(n, c, u) {
      const l = n;
      return c.properties.mergeTo(l.properties), new Iv(n, u);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for transcription.
     * @member ConversationTranscriber.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return s.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      s.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * Gets the spoken language of transcription.
     * @member ConversationTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of transcription.
     */
    get speechRecognitionLanguage() {
      return s.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of transcription.
     * @member ConversationTranscriber.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of transcription.
     */
    get outputFormat() {
      return s.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(e.OutputFormatPropertyName, i.OutputFormat[i.OutputFormat.Simple]) === i.OutputFormat[i.OutputFormat.Simple] ? i.OutputFormat.Simple : i.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this conversation transcriber.
     * @member ConversationTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts conversation transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member ConversationTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), n, c);
    }
    /**
     * Stops conversation transcription.
     * @member ConversationTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member ConversationTranscriber.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      s.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return l.isSpeakerDiarizationEnabled = !0, new e.ConversationTranscriptionServiceRecognizer(n, c, p, l, this);
    }
  };
  return Un.ConversationTranscriber = a, Un;
}
var St = {}, Sp;
function vP() {
  if (Sp) return St;
  Sp = 1, Object.defineProperty(St, "__esModule", { value: !0 }), St.Participant = St.User = void 0;
  const e = /* @__PURE__ */ A();
  class t {
    constructor(i) {
      this.privUserId = i;
    }
    get userId() {
      return this.privUserId;
    }
  }
  St.User = t;
  class r {
    constructor(i, a, o, n, c, u, l, p) {
      this.privId = i, this.privAvatar = a, this.privDisplayName = o, this.privIsHost = n, this.privIsMuted = c, this.privIsUsingTts = u, this.privPreferredLanguage = l, this.privVoice = p, this.privProperties = new e.PropertyCollection();
    }
    get avatar() {
      return this.privAvatar;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get id() {
      return this.privId;
    }
    get preferredLanguage() {
      return this.privPreferredLanguage;
    }
    get isHost() {
      return this.privIsHost;
    }
    get isMuted() {
      return this.privIsMuted;
    }
    get isUsingTts() {
      return this.privIsUsingTts;
    }
    get voice() {
      return this.privVoice;
    }
    get properties() {
      return this.privProperties;
    }
    static From(i, a, o) {
      return new r(i, "", i, !1, !1, !1, a, o);
    }
  }
  return St.Participant = r, St;
}
var Go = {}, Cp;
function gP() {
  return Cp || (Cp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ParticipantChangedReason = void 0, function(t) {
      t[t.JoinedConversation = 0] = "JoinedConversation", t[t.LeftConversation = 1] = "LeftConversation", t[t.Updated = 2] = "Updated";
    }(e.ParticipantChangedReason || (e.ParticipantChangedReason = {}));
  }(Go)), Go;
}
var Ct = {}, Rp;
function mP() {
  if (Rp) return Ct;
  Rp = 1, Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.MeetingImpl = Ct.Meeting = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A();
  let i = class {
    constructor() {
    }
    /**
     * Create a meeting
     * @param speechConfig
     * @param meetingId
     * @param cb
     * @param err
     */
    static createMeetingAsync(n, c, u, l) {
      if (r.Contracts.throwIfNullOrUndefined(n, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), r.Contracts.throwIfNullOrUndefined(n.region, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), r.Contracts.throwIfNull(c, "meetingId"), c.length === 0)
        throw new Error("meetingId cannot be empty");
      !n.subscriptionKey && !n.getProperty(s.PropertyId[s.PropertyId.SpeechServiceAuthorization_Token]) && r.Contracts.throwIfNullOrUndefined(n.subscriptionKey, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      const p = new a(n, c);
      return (0, t.marshalPromiseToCallbacks)((async () => {
      })(), u, l), p;
    }
  };
  Ct.Meeting = i;
  class a extends i {
    /**
     * Create a Meeting impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(n, c) {
      super(), this.privErrors = e.ConversationConnectionConfig.restErrors, this.onConnected = (p) => {
        this.privIsConnected = !0;
        try {
          this.privConversationTranslator?.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, p);
        } catch {
        }
      }, this.onDisconnected = (p) => {
        try {
          this.privConversationTranslator?.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, p);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (p, d) => {
        try {
          this.privConversationTranslator?.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, d);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.getParticipant(d.id);
          if (h !== void 0) {
            switch (d.key) {
              case e.ConversationTranslatorCommandTypes.changeNickname:
                h.displayName = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setUseTTS:
                h.isUsingTts = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setProfanityFiltering:
                h.profanity = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setMute:
                h.isMuted = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                h.translateToLanguages = d.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(h), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.Updated, [this.toParticipant(h)], d.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (p, d) => {
        try {
          this.privParticipants.participants.forEach((h) => h.isMuted = h.isHost ? !1 : d.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.Updated, this.toParticipants(!1), d.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.addOrUpdateParticipant(d.participant);
          h !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.JoinedConversation, [this.toParticipant(h)], d.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.getParticipant(d.participant.id);
          h !== void 0 && (this.privParticipants.deleteParticipant(d.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.LeftConversation, [this.toParticipant(h)], d.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (p, d) => {
        try {
          switch (d.command) {
            case e.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new s.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new s.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new s.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (p, d) => {
        try {
          if (d.sessionToken !== void 0 && d.sessionToken !== null && (this.privRoom.token = d.sessionToken), this.privParticipants.participants = [...d.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new s.ConversationParticipantsChangedEventArgs(s.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), d.sessionId)), this.me.isHost) {
            const h = this.privConversationTranslator?.properties.getProperty(s.PropertyId.ConversationTranslator_Name);
            h !== void 0 && h.length > 0 && h !== this.me.displayName && this.changeNicknameAsync(h);
          }
        } catch {
        }
      }, this.onConversationExpiration = (p, d) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, d);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new s.PropertyCollection(), this.privManager = new e.ConversationManager(), n.getProperty(s.PropertyId[s.PropertyId.SpeechServiceConnection_RecoLanguage]) || n.setProperty(s.PropertyId[s.PropertyId.SpeechServiceConnection_RecoLanguage], e.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = n.getProperty(s.PropertyId[s.PropertyId.SpeechServiceConnection_RecoLanguage]), this.privConversationId = c, this.privConfig = n;
      const l = n;
      r.Contracts.throwIfNull(l, "speechConfig"), this.privProperties = l.properties.clone(), this.privIsConnected = !1, this.privParticipants = new e.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the meeting Id
    get meetingId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      return this.privParticipants.me?.isHost ? !1 : this.privParticipants.me?.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get meetingInfo() {
      const n = this.meetingId, c = this.participants.map((p) => ({
        id: p.id,
        preferredLanguage: p.preferredLanguage,
        voice: p.voice
      })), u = {};
      for (const p of e.ConversationConnectionConfig.transcriptionEventKeys) {
        const d = this.properties.getProperty(p, "");
        d !== "" && (u[p] = d);
      }
      return { id: n, participants: c, meetingProperties: u };
    }
    get canSend() {
      return this.privIsConnected && !this.privParticipants.me?.isMuted;
    }
    get canSendAsHost() {
      return this.privIsConnected && this.privParticipants.me?.isHost;
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "authorizationToken"), this.privToken = n;
    }
    /**
     * Create a new meeting as Host
     * @param cb
     * @param err
     */
    createMeetingAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new meeting as host.
     * @param cb
     * @param err
     */
    startMeetingAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a meeting as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(n, c, u) {
      r.Contracts.throwIfNullOrUndefined(n, "Participant"), (0, t.marshalPromiseToCallbacks)(this.addParticipantImplAsync(n), c, u);
    }
    /**
     * Join a meeting as a participant.
     * @param meeting
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinMeetingAsync(n, c, u, l, p) {
      try {
        r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), r.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, n, (d) => {
          r.Contracts.throwIfNullOrUndefined(d, this.privErrors.permissionDeniedConnect), this.privRoom = d, this.privConfig.authorizationToken = d.cognitiveSpeechAuthToken, l && l(d.cognitiveSpeechAuthToken);
        }, (d) => {
          this.handleError(d, p);
        });
      } catch (d) {
        this.handleError(d, p);
      }
    }
    /**
     * Deletes a meeting
     * @param cb
     * @param err
     */
    deleteMeetingAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.deleteMeetingImplAsync(), n, c);
    }
    async deleteMeetingImplAsync() {
      r.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), r.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endMeetingAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.endMeetingImplAsync(), n, c);
    }
    endMeetingImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockMeetingAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the meeting
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !0), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(n, c, u) {
      try {
        if (r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && n.hasOwnProperty("id"))
          (0, t.marshalPromiseToCallbacks)(this.removeParticipantImplAsync(n), c, u);
        else {
          r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let l = "";
          typeof n == "string" ? l = n : n.hasOwnProperty("id") ? l = n.id : n.hasOwnProperty("userId") && (l = n.userId), r.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((d) => d.id === l) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(l), () => {
            this.handleCallback(c, u);
          }, (d) => {
            this.handleError(d, u);
          });
        }
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to unlock the meeting
     * @param cb
     * @param err
     */
    unlockMeetingAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the meeting
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !1), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "message")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), n.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfArrayEmptyOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "languages")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(n) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await n.enforceAudioGating(), this.privTranscriberRecognizer = n, this.privTranscriberRecognizer.meeting = this;
    }
    getKeepAlive() {
      const n = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: n,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(n) {
      if (this.privParticipants.addOrUpdateParticipant(n) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.meetingInfo;
        return u.participants = [n], this.privTranscriberRecognizer.pushMeetingEvent(u, "join");
      }
    }
    removeParticipantImplAsync(n) {
      this.privParticipants.deleteParticipant(n.id);
      const c = this.meetingInfo;
      return c.participants = [n], this.privTranscriberRecognizer.pushMeetingEvent(c, "leave");
    }
    async close(n) {
      try {
        this.privIsConnected = !1, await this.privConversationRecognizer?.close(), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (c) {
        throw c;
      }
      n && this.dispose();
    }
    /** Helpers */
    handleCallback(n, c) {
      if (n) {
        try {
          n();
        } catch (u) {
          c && c(u);
        }
        n = void 0;
      }
    }
    handleError(n, c) {
      if (c)
        if (n instanceof Error) {
          const u = n;
          c(u.name + ": " + u.message);
        } else
          c(n);
    }
    /** Participant Helpers */
    toParticipants(n) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return n ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(n) {
      return new s.Participant(n.id, n.avatar, n.displayName, n.isHost, n.isMuted, n.isUsingTts, n.preferredLanguage, n.voice);
    }
    getMuteAllCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMuteCommand(n, c) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getEjectCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getChangeNicknameCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(n, "nickname"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.changeNickname,
        nickname: n,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMessageCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), r.Contracts.throwIfNullOrWhitespace(n, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: n,
        type: e.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return Ct.MeetingImpl = a, Ct;
}
var $n = {}, Pp;
function yP() {
  if (Pp) return $n;
  Pp = 1, Object.defineProperty($n, "__esModule", { value: !0 }), $n.MeetingTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Rs();
  class t extends e.CancellationEventArgsBase {
  }
  return $n.MeetingTranscriptionCanceledEventArgs = t, $n;
}
var Vn = {}, bp;
function SP() {
  if (bp) return Vn;
  bp = 1, Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.MeetingTranscriber = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A(), i = /* @__PURE__ */ sc();
  let a = class {
    /**
     * MeetingTranscriber constructor.
     * @constructor
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n) {
      this.privAudioConfig = n, this.privProperties = new s.PropertyCollection(), this.privRecognizer = void 0, this.privDisposedRecognizer = !1;
    }
    /**
     * Gets the spoken language of recognition.
     * @member MeetingTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return r.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(s.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * The collection of properties and their values defined for this MeetingTranscriber.
     * @member MeetingTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privRecognizer.internalData;
    }
    /**
     * @Deprecated
     * @Obsolete
     * Please use the Connection.fromRecognizer pattern to obtain a connection object
     */
    get connection() {
      return s.Connection.fromRecognizer(this.privRecognizer);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(s.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * @param {Meeting} meeting - meeting to be recognized
     */
    joinMeetingAsync(n, c, u) {
      const l = n;
      r.Contracts.throwIfNullOrUndefined(i.MeetingImpl, "Meeting"), this.privRecognizer = new e.TranscriberRecognizer(n.config, this.privAudioConfig), r.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer"), this.privRecognizer.connectMeetingCallbacks(this), (0, t.marshalPromiseToCallbacks)(l.connectTranscriberRecognizer(this.privRecognizer), c, u);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(n, c) {
      this.privRecognizer.startContinuousRecognitionAsync(n, c);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(n, c) {
      this.privRecognizer.stopContinuousRecognitionAsync(n, c);
    }
    /**
     * Leave the current meeting. After this is called, you will no longer receive any events.
     */
    leaveMeetingAsync(n, c) {
      this.privRecognizer.disconnectCallbacks(), (0, t.marshalPromiseToCallbacks)((async () => {
      })(), n, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member MeetingTranscriber.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      r.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member MeetingTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (this.privRecognizer && (await this.privRecognizer.close(), this.privRecognizer = void 0), n && (this.privDisposedRecognizer = !0));
    }
  };
  return Vn.MeetingTranscriber = a, Vn;
}
var Wn = {}, wp;
function CP() {
  if (wp) return Wn;
  wp = 1, Object.defineProperty(Wn, "__esModule", { value: !0 }), Wn.ConversationTranscriptionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(s, i, a, o, n, c, u, l, p, d, h) {
      super(s, i, a, o, n, c, u, p, d, h), this.privSpeakerId = l;
    }
    /**
     * speaker id
     * @member ConversationTranscriptionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return Wn.ConversationTranscriptionResult = t, Wn;
}
var Ep;
function sc() {
  return Ep || (Ep = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConversationTranscriptionResult = e.MeetingTranscriber = e.MeetingTranscriptionCanceledEventArgs = e.MeetingImpl = e.Meeting = e.ParticipantChangedReason = e.User = e.Participant = e.ConversationTranscriber = e.ConversationTranslator = e.ConversationTranslationResult = e.ConversationTranslationEventArgs = e.ConversationTranslationCanceledEventArgs = e.ConversationParticipantsChangedEventArgs = e.ConversationExpirationEventArgs = e.ConversationCommon = e.ConversationImpl = e.Conversation = void 0;
    var t = /* @__PURE__ */ bv();
    Object.defineProperty(e, "Conversation", { enumerable: !0, get: function() {
      return t.Conversation;
    } }), Object.defineProperty(e, "ConversationImpl", { enumerable: !0, get: function() {
      return t.ConversationImpl;
    } });
    var r = /* @__PURE__ */ oP();
    Object.defineProperty(e, "ConversationCommon", { enumerable: !0, get: function() {
      return r.ConversationCommon;
    } });
    var s = /* @__PURE__ */ aP();
    Object.defineProperty(e, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return s.ConversationExpirationEventArgs;
    } });
    var i = /* @__PURE__ */ cP();
    Object.defineProperty(e, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return i.ConversationParticipantsChangedEventArgs;
    } });
    var a = /* @__PURE__ */ uP();
    Object.defineProperty(e, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return a.ConversationTranslationCanceledEventArgs;
    } });
    var o = /* @__PURE__ */ lP();
    Object.defineProperty(e, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return o.ConversationTranslationEventArgs;
    } });
    var n = /* @__PURE__ */ pP();
    Object.defineProperty(e, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return n.ConversationTranslationResult;
    } });
    var c = /* @__PURE__ */ hP();
    Object.defineProperty(e, "ConversationTranslator", { enumerable: !0, get: function() {
      return c.ConversationTranslator;
    } });
    var u = /* @__PURE__ */ fP();
    Object.defineProperty(e, "ConversationTranscriber", { enumerable: !0, get: function() {
      return u.ConversationTranscriber;
    } });
    var l = /* @__PURE__ */ vP();
    Object.defineProperty(e, "Participant", { enumerable: !0, get: function() {
      return l.Participant;
    } }), Object.defineProperty(e, "User", { enumerable: !0, get: function() {
      return l.User;
    } });
    var p = /* @__PURE__ */ gP();
    Object.defineProperty(e, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return p.ParticipantChangedReason;
    } });
    var d = /* @__PURE__ */ mP();
    Object.defineProperty(e, "Meeting", { enumerable: !0, get: function() {
      return d.Meeting;
    } }), Object.defineProperty(e, "MeetingImpl", { enumerable: !0, get: function() {
      return d.MeetingImpl;
    } });
    var h = /* @__PURE__ */ yP();
    Object.defineProperty(e, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return h.MeetingTranscriptionCanceledEventArgs;
    } });
    var f = /* @__PURE__ */ SP();
    Object.defineProperty(e, "MeetingTranscriber", { enumerable: !0, get: function() {
      return f.MeetingTranscriber;
    } });
    var g = /* @__PURE__ */ CP();
    Object.defineProperty(e, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return g.ConversationTranscriptionResult;
    } });
  }(Ko)), Ko;
}
var Rt = {}, Ip;
function oc() {
  if (Ip) return Rt;
  Ip = 1, Object.defineProperty(Rt, "__esModule", { value: !0 }), Rt.SynthesisRequest = Rt.Synthesizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A();
  let i = class Av {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config to initialize the synthesizer.
     */
    constructor(n) {
      const c = n;
      r.Contracts.throwIfNull(c, "speechConfig"), this.privProperties = c.properties.clone(), this.privDisposed = !1, this.privSynthesizing = !1, this.synthesisRequestQueue = new t.Queue(), this.tokenCredential = n.tokenCredential;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(s.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * The collection of properties and their values defined for this Synthesizer.
     * @member Synthesizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Indicates if auto detect source language is enabled
     * @member Synthesizer.prototype.autoDetectSourceLanguage
     * @function
     * @public
     * @returns {boolean} if auto detect source language is enabled
     */
    get autoDetectSourceLanguage() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === e.AutoDetectSourceLanguagesOpenRangeOptionName;
    }
    buildSsml(n) {
      const c = {
        "af-ZA": "af-ZA-AdriNeural",
        "am-ET": "am-ET-AmehaNeural",
        "ar-AE": "ar-AE-FatimaNeural",
        "ar-BH": "ar-BH-AliNeural",
        "ar-DZ": "ar-DZ-AminaNeural",
        "ar-EG": "ar-EG-SalmaNeural",
        "ar-IQ": "ar-IQ-BasselNeural",
        "ar-JO": "ar-JO-SanaNeural",
        "ar-KW": "ar-KW-FahedNeural",
        "ar-LY": "ar-LY-ImanNeural",
        "ar-MA": "ar-MA-JamalNeural",
        "ar-QA": "ar-QA-AmalNeural",
        "ar-SA": "ar-SA-HamedNeural",
        "ar-SY": "ar-SY-AmanyNeural",
        "ar-TN": "ar-TN-HediNeural",
        "ar-YE": "ar-YE-MaryamNeural",
        "bg-BG": "bg-BG-BorislavNeural",
        "bn-BD": "bn-BD-NabanitaNeural",
        "bn-IN": "bn-IN-BashkarNeural",
        "ca-ES": "ca-ES-JoanaNeural",
        "cs-CZ": "cs-CZ-AntoninNeural",
        "cy-GB": "cy-GB-AledNeural",
        "da-DK": "da-DK-ChristelNeural",
        "de-AT": "de-AT-IngridNeural",
        "de-CH": "de-CH-JanNeural",
        "de-DE": "de-DE-KatjaNeural",
        "el-GR": "el-GR-AthinaNeural",
        "en-AU": "en-AU-NatashaNeural",
        "en-CA": "en-CA-ClaraNeural",
        "en-GB": "en-GB-LibbyNeural",
        "en-HK": "en-HK-SamNeural",
        "en-IE": "en-IE-ConnorNeural",
        "en-IN": "en-IN-NeerjaNeural",
        "en-KE": "en-KE-AsiliaNeural",
        "en-NG": "en-NG-AbeoNeural",
        "en-NZ": "en-NZ-MitchellNeural",
        "en-PH": "en-PH-JamesNeural",
        "en-SG": "en-SG-LunaNeural",
        "en-TZ": "en-TZ-ElimuNeural",
        "en-US": "en-US-AvaMultilingualNeural",
        "en-ZA": "en-ZA-LeahNeural",
        "es-AR": "es-AR-ElenaNeural",
        "es-BO": "es-BO-MarceloNeural",
        "es-CL": "es-CL-CatalinaNeural",
        "es-CO": "es-CO-GonzaloNeural",
        "es-CR": "es-CR-JuanNeural",
        "es-CU": "es-CU-BelkysNeural",
        "es-DO": "es-DO-EmilioNeural",
        "es-EC": "es-EC-AndreaNeural",
        "es-ES": "es-ES-AlvaroNeural",
        "es-GQ": "es-GQ-JavierNeural",
        "es-GT": "es-GT-AndresNeural",
        "es-HN": "es-HN-CarlosNeural",
        "es-MX": "es-MX-DaliaNeural",
        "es-NI": "es-NI-FedericoNeural",
        "es-PA": "es-PA-MargaritaNeural",
        "es-PE": "es-PE-AlexNeural",
        "es-PR": "es-PR-KarinaNeural",
        "es-PY": "es-PY-MarioNeural",
        "es-SV": "es-SV-LorenaNeural",
        "es-US": "es-US-AlonsoNeural",
        "es-UY": "es-UY-MateoNeural",
        "es-VE": "es-VE-PaolaNeural",
        "et-EE": "et-EE-AnuNeural",
        "fa-IR": "fa-IR-DilaraNeural",
        "fi-FI": "fi-FI-SelmaNeural",
        "fil-PH": "fil-PH-AngeloNeural",
        "fr-BE": "fr-BE-CharlineNeural",
        "fr-CA": "fr-CA-SylvieNeural",
        "fr-CH": "fr-CH-ArianeNeural",
        "fr-FR": "fr-FR-DeniseNeural",
        "ga-IE": "ga-IE-ColmNeural",
        "gl-ES": "gl-ES-RoiNeural",
        "gu-IN": "gu-IN-DhwaniNeural",
        "he-IL": "he-IL-AvriNeural",
        "hi-IN": "hi-IN-MadhurNeural",
        "hr-HR": "hr-HR-GabrijelaNeural",
        "hu-HU": "hu-HU-NoemiNeural",
        "id-ID": "id-ID-ArdiNeural",
        "is-IS": "is-IS-GudrunNeural",
        "it-IT": "it-IT-IsabellaNeural",
        "ja-JP": "ja-JP-NanamiNeural",
        "jv-ID": "jv-ID-DimasNeural",
        "kk-KZ": "kk-KZ-AigulNeural",
        "km-KH": "km-KH-PisethNeural",
        "kn-IN": "kn-IN-GaganNeural",
        "ko-KR": "ko-KR-SunHiNeural",
        "lo-LA": "lo-LA-ChanthavongNeural",
        "lt-LT": "lt-LT-LeonasNeural",
        "lv-LV": "lv-LV-EveritaNeural",
        "mk-MK": "mk-MK-AleksandarNeural",
        "ml-IN": "ml-IN-MidhunNeural",
        "mr-IN": "mr-IN-AarohiNeural",
        "ms-MY": "ms-MY-OsmanNeural",
        "mt-MT": "mt-MT-GraceNeural",
        "my-MM": "my-MM-NilarNeural",
        "nb-NO": "nb-NO-PernilleNeural",
        "nl-BE": "nl-BE-ArnaudNeural",
        "nl-NL": "nl-NL-ColetteNeural",
        "pl-PL": "pl-PL-AgnieszkaNeural",
        "ps-AF": "ps-AF-GulNawazNeural",
        "pt-BR": "pt-BR-FranciscaNeural",
        "pt-PT": "pt-PT-DuarteNeural",
        "ro-RO": "ro-RO-AlinaNeural",
        "ru-RU": "ru-RU-SvetlanaNeural",
        "si-LK": "si-LK-SameeraNeural",
        "sk-SK": "sk-SK-LukasNeural",
        "sl-SI": "sl-SI-PetraNeural",
        "so-SO": "so-SO-MuuseNeural",
        "sr-RS": "sr-RS-NicholasNeural",
        "su-ID": "su-ID-JajangNeural",
        "sv-SE": "sv-SE-SofieNeural",
        "sw-KE": "sw-KE-RafikiNeural",
        "sw-TZ": "sw-TZ-DaudiNeural",
        "ta-IN": "ta-IN-PallaviNeural",
        "ta-LK": "ta-LK-KumarNeural",
        "ta-SG": "ta-SG-AnbuNeural",
        "te-IN": "te-IN-MohanNeural",
        "th-TH": "th-TH-PremwadeeNeural",
        "tr-TR": "tr-TR-AhmetNeural",
        "uk-UA": "uk-UA-OstapNeural",
        "ur-IN": "ur-IN-GulNeural",
        "ur-PK": "ur-PK-AsadNeural",
        "uz-UZ": "uz-UZ-MadinaNeural",
        "vi-VN": "vi-VN-HoaiMyNeural",
        "zh-CN": "zh-CN-XiaoxiaoNeural",
        "zh-HK": "zh-HK-HiuMaanNeural",
        "zh-TW": "zh-TW-HsiaoChenNeural",
        "zu-ZA": "zu-ZA-ThandoNeural"
      };
      let u = this.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US"), l = this.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthVoice, ""), p = Av.XMLEncode(n);
      return this.autoDetectSourceLanguage ? u = "en-US" : l = l || c[u], l && (p = `<voice name='${l}'>${p}</voice>`), p = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${u}'>${p}</speak>`, p;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Synthesizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(n) {
      this.privDisposed || (n && this.privAdapter && await this.privAdapter.dispose(), this.privDisposed = !0);
    }
    async adapterSpeak() {
      if (!this.privDisposed && !this.privSynthesizing) {
        this.privSynthesizing = !0;
        const n = await this.synthesisRequestQueue.dequeue();
        return this.privAdapter.Speak(n.text, n.isSSML, n.requestId, n.cb, n.err, n.dataStream);
      }
    }
    createSynthesizerConfig(n) {
      return new e.SynthesizerConfig(n, this.privProperties);
    }
    // Does the generic synthesizer setup that is common across all synthesizer types.
    implCommonSynthesizeSetup() {
      let n = typeof window < "u" ? "Browser" : "Node", c = "unknown", u = "unknown";
      typeof navigator < "u" && (n = n + "/" + navigator.platform, c = navigator.userAgent, u = navigator.appVersion);
      const l = this.createSynthesizerConfig(new e.SpeechServiceConfig(new e.Context(new e.OS(n, c, u)))), p = this.privProperties.getProperty(s.PropertyId.SpeechServiceConnection_Key, void 0), d = p && p !== "" ? new e.CognitiveSubscriptionKeyAuthentication(p) : this.tokenCredential ? new e.CognitiveTokenAuthentication(async () => {
        try {
          return (await this.tokenCredential.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (h) {
          throw h;
        }
      }, async () => {
        try {
          return (await this.tokenCredential.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (h) {
          throw h;
        }
      }) : new e.CognitiveTokenAuthentication(() => {
        const h = this.privProperties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(h);
      }, () => {
        const h = this.privProperties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(h);
      });
      this.privAdapter = this.createSynthesisAdapter(d, this.privConnectionFactory, l), this.privRestAdapter = this.createRestSynthesisAdapter(d, l);
    }
    static XMLEncode(n) {
      return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
  };
  Rt.Synthesizer = i;
  class a {
    constructor(n, c, u, l, p, d) {
      this.requestId = n, this.text = c, this.isSSML = u, this.cb = l, this.err = p, this.dataStream = d;
    }
  }
  return Rt.SynthesisRequest = a, Rt;
}
var Hn = {}, Ap;
function RP() {
  if (Ap) return Hn;
  Ap = 1, Object.defineProperty(Hn, "__esModule", { value: !0 }), Hn.SpeechSynthesizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ tv(), s = /* @__PURE__ */ Cs(), i = /* @__PURE__ */ Wt(), a = /* @__PURE__ */ z(), o = /* @__PURE__ */ A(), n = /* @__PURE__ */ oc();
  let c = class Tv extends o.Synthesizer {
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
     */
    constructor(l, p) {
      super(l), p !== null && (p === void 0 ? this.audioConfig = typeof window > "u" ? void 0 : o.AudioConfig.fromDefaultSpeakerOutput() : this.audioConfig = p), this.privConnectionFactory = new e.SpeechSynthesisConnectionFactory(), this.implCommonSynthesizeSetup();
    }
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
     */
    static FromConfig(l, p, d) {
      const h = l;
      return p.properties.mergeTo(h.properties), new Tv(l, d);
    }
    /**
     * Executes speech synthesis on plain text.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param text - Text to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakTextAsync(l, p, d, h) {
      this.speakImpl(l, !1, p, d, h);
    }
    /**
     * Executes speech synthesis on SSML.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param ssml - SSML to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakSsmlAsync(l, p, d, h) {
      this.speakImpl(l, !0, p, d, h);
    }
    /**
     * Get list of synthesis voices available.
     * The task returns the synthesis voice result.
     * @member SpeechSynthesizer.prototype.getVoicesAsync
     * @function
     * @async
     * @public
     * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
     * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
     */
    async getVoicesAsync(l = "") {
      return this.getVoices(l);
    }
    /**
     * Dispose of associated resources.
     * @member SpeechSynthesizer.prototype.close
     * @function
     * @public
     */
    close(l, p) {
      a.Contracts.throwIfDisposed(this.privDisposed), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), l, p);
    }
    /**
     * @Internal
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privAdapter;
    }
    //
    // ################################################################################################################
    // IMPLEMENTATION.
    // ################################################################################################################
    //
    // Creates the synthesis adapter
    createSynthesisAdapter(l, p, d) {
      return new e.SpeechSynthesisAdapter(l, p, d, this, this.audioConfig);
    }
    createRestSynthesisAdapter(l, p) {
      return new e.SynthesisRestAdapter(p, l);
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = s.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(o.SpeechSynthesisOutputFormat[this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)]);
    }
    speakImpl(l, p, d, h, f) {
      try {
        a.Contracts.throwIfDisposed(this.privDisposed);
        const g = (0, t.createNoDashGuid)();
        let m;
        f instanceof o.PushAudioOutputStreamCallback ? m = new i.PushAudioOutputStreamImpl(f) : f instanceof o.PullAudioOutputStream ? m = f : f !== void 0 ? m = new r.AudioFileWriter(f) : m = void 0, this.synthesisRequestQueue.enqueue(new n.SynthesisRequest(g, l, p, (v) => {
          if (this.privSynthesizing = !1, d)
            try {
              d(v);
            } catch (y) {
              h && h(y);
            }
          d = void 0, this.adapterSpeak().catch(() => {
          });
        }, (v) => {
          h && h(v);
        }, m)), this.adapterSpeak().catch(() => {
        });
      } catch (g) {
        if (h)
          if (g instanceof Error) {
            const m = g;
            h(m.name + ": " + m.message);
          } else
            h(g);
        this.dispose(!0).catch(() => {
        });
      }
    }
    async getVoices(l) {
      const p = (0, t.createNoDashGuid)(), d = await this.privRestAdapter.getVoicesList(p);
      if (d.ok && Array.isArray(d.json)) {
        let h = d.json;
        return l && l.length > 0 && (h = h.filter((f) => !!f.Locale && f.Locale.toLowerCase() === l.toLowerCase())), new o.SynthesisVoicesResult(p, h, void 0);
      } else
        return new o.SynthesisVoicesResult(p, void 0, `Error: ${d.status}: ${d.statusText}`);
    }
  };
  return Hn.SpeechSynthesizer = c, Hn;
}
var Kn = {}, Tp;
function PP() {
  if (Tp) return Kn;
  Tp = 1, Object.defineProperty(Kn, "__esModule", { value: !0 }), Kn.SynthesisResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, s, i, a) {
      this.privResultId = r, this.privReason = s, this.privErrorDetails = i, this.privProperties = a;
    }
    /**
     * Specifies the result identifier.
     * @member SynthesisResult.prototype.resultId
     * @function
     * @public
     * @returns {string} Specifies the result identifier.
     */
    get resultId() {
      return this.privResultId;
    }
    /**
     * Specifies status of the result.
     * @member SynthesisResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} Specifies status of the result.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * In case of an unsuccessful synthesis, provides details of the occurred error.
     * @member SynthesisResult.prototype.errorDetails
     * @function
     * @public
     * @returns {string} a brief description of an error.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * The set of properties exposed in the result.
     * @member SynthesisResult.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The set of properties exposed in the result.
     */
    get properties() {
      return this.privProperties;
    }
  };
  return Kn.SynthesisResult = e, Kn;
}
var Jn = {}, _p;
function bP() {
  if (_p) return Jn;
  _p = 1, Object.defineProperty(Jn, "__esModule", { value: !0 }), Jn.SpeechSynthesisResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {ArrayBuffer} audioData - The synthesized audio binary.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     * @param {number} audioDuration - The audio duration.
     */
    constructor(s, i, a, o, n, c) {
      super(s, i, o, n), this.privAudioData = a, this.privAudioDuration = c;
    }
    /**
     * The synthesized audio data
     * @member SpeechSynthesisResult.prototype.audioData
     * @function
     * @public
     * @returns {ArrayBuffer} The synthesized audio data.
     */
    get audioData() {
      return this.privAudioData;
    }
    /**
     * The time duration of synthesized audio, in ticks (100 nanoseconds).
     * @member SpeechSynthesisResult.prototype.audioDuration
     * @function
     * @public
     * @returns {number} The time duration of synthesized audio.
     */
    get audioDuration() {
      return this.privAudioDuration;
    }
  };
  return Jn.SpeechSynthesisResult = t, Jn;
}
var Gn = {}, kp;
function wP() {
  if (kp) return Gn;
  kp = 1, Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.SpeechSynthesisEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechSynthesisResult} result - The speech synthesis result.
     */
    constructor(r) {
      this.privResult = r;
    }
    /**
     * Specifies the synthesis result.
     * @member SpeechSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechSynthesisResult} the synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Gn.SpeechSynthesisEventArgs = e, Gn;
}
var Qn = {}, Op;
function EP() {
  if (Op) return Qn;
  Op = 1, Object.defineProperty(Qn, "__esModule", { value: !0 }), Qn.SpeechSynthesisWordBoundaryEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} duration - The audio duration.
     * @param {string} text - The text.
     * @param {number} wordLength - The length of the word.
     * @param {number} textOffset - The text offset.
     * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
     */
    constructor(r, s, i, a, o, n) {
      this.privAudioOffset = r, this.privDuration = s, this.privText = i, this.privWordLength = a, this.privTextOffset = o, this.privBoundaryType = n;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the duration, in ticks (100 nanoseconds).
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
     * @function
     * @public
     * @returns {number} Duration in 100 nanosecond increments.
     */
    get duration() {
      return this.privDuration;
    }
    /**
     * Specifies the text of the word boundary event.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
     * @function
     * @public
     * @returns {string} the text.
     */
    get text() {
      return this.privText;
    }
    /**
     * Specifies the word length
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
     * @function
     * @public
     * @returns {number} the word length
     */
    get wordLength() {
      return this.privWordLength;
    }
    /**
     * Specifies the text offset.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
     * @function
     * @public
     * @returns {number} the text offset.
     */
    get textOffset() {
      return this.privTextOffset;
    }
    /**
     * Specifies the boundary type.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
     * @function
     * @public
     * @returns {SpeechSynthesisBoundaryType} the boundary type.
     */
    get boundaryType() {
      return this.privBoundaryType;
    }
  };
  return Qn.SpeechSynthesisWordBoundaryEventArgs = e, Qn;
}
var Yn = {}, Mp;
function IP() {
  if (Mp) return Yn;
  Mp = 1, Object.defineProperty(Yn, "__esModule", { value: !0 }), Yn.SpeechSynthesisBookmarkEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {string} text - The bookmark text.
     */
    constructor(r, s) {
      this.privAudioOffset = r, this.privText = s;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the bookmark.
     * @member SpeechSynthesisBookmarkEventArgs.prototype.text
     * @function
     * @public
     * @returns {string} the bookmark text.
     */
    get text() {
      return this.privText;
    }
  };
  return Yn.SpeechSynthesisBookmarkEventArgs = e, Yn;
}
var Zn = {}, Dp;
function AP() {
  if (Dp) return Zn;
  Dp = 1, Object.defineProperty(Zn, "__esModule", { value: !0 }), Zn.SpeechSynthesisVisemeEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} visemeId - The viseme ID.
     * @param {string} animation - The animation, could be in svg or other format.
     */
    constructor(r, s, i) {
      this.privAudioOffset = r, this.privVisemeId = s, this.privAnimation = i;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the viseme ID.
     * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
     * @function
     * @public
     * @returns {number} the viseme ID.
     */
    get visemeId() {
      return this.privVisemeId;
    }
    /**
     * Specifies the animation.
     * @member SpeechSynthesisVisemeEventArgs.prototype.animation
     * @function
     * @public
     * @returns {string} the animation, could be in svg or other format.
     */
    get animation() {
      return this.privAnimation;
    }
  };
  return Zn.SpeechSynthesisVisemeEventArgs = e, Zn;
}
var Qo = {}, Np;
function TP() {
  return Np || (Np = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeechSynthesisBoundaryType = void 0, function(t) {
      t.Word = "WordBoundary", t.Punctuation = "PunctuationBoundary", t.Sentence = "SentenceBoundary";
    }(e.SpeechSynthesisBoundaryType || (e.SpeechSynthesisBoundaryType = {}));
  }(Qo)), Qo;
}
var Xn = {}, xp;
function _P() {
  if (xp) return Xn;
  xp = 1, Object.defineProperty(Xn, "__esModule", { value: !0 }), Xn.SynthesisVoicesResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param requestId - result id for request.
     * @param json - json payload from endpoint.
     */
    constructor(s, i, a) {
      if (Array.isArray(i)) {
        super(s, e.ResultReason.VoicesListRetrieved, void 0, new e.PropertyCollection()), this.privVoices = [];
        for (const o of i)
          this.privVoices.push(new e.VoiceInfo(o));
      } else
        super(s, e.ResultReason.Canceled, a || "Error information unavailable", new e.PropertyCollection());
    }
    /**
     * The list of voices
     * @member SynthesisVoicesResult.prototype.voices
     * @function
     * @public
     * @returns {VoiceInfo[]} List of synthesized voices.
     */
    get voices() {
      return this.privVoices;
    }
  };
  return Xn.SynthesisVoicesResult = t, Xn;
}
var Yo = {}, zp;
function kP() {
  return zp || (zp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.VoiceInfo = e.SynthesisVoiceType = e.SynthesisVoiceGender = void 0;
    var t;
    (function(o) {
      o[o.Unknown = 0] = "Unknown", o[o.Female = 1] = "Female", o[o.Male = 2] = "Male", o[o.Neutral = 3] = "Neutral";
    })(t = e.SynthesisVoiceGender || (e.SynthesisVoiceGender = {}));
    var r;
    (function(o) {
      o[o.Unknown = 0] = "Unknown", o[o.OnlineNeural = 1] = "OnlineNeural", o[o.OnlineStandard = 2] = "OnlineStandard", o[o.OfflineNeural = 3] = "OfflineNeural", o[o.OfflineStandard = 4] = "OfflineStandard", o[o.OnlineNeuralHD = 5] = "OnlineNeuralHD";
    })(r = e.SynthesisVoiceType || (e.SynthesisVoiceType = {}));
    const s = {
      [t[t.Neutral]]: t.Neutral,
      [t[t.Male]]: t.Male,
      [t[t.Female]]: t.Female
    }, i = {
      Neural: r.OnlineNeural,
      NeuralHD: r.OnlineNeuralHD
    };
    class a {
      constructor(n) {
        if (this.privStyleList = [], n) {
          if (this.privName = n.Name, this.privLocale = n.Locale, this.privShortName = n.ShortName, this.privLocaleName = n.LocaleName, this.privDisplayName = n.DisplayName, this.privLocalName = n.LocalName, this.privVoiceType = i[n.VoiceType] || r.Unknown, this.privGender = s[n.Gender] || t.Unknown, n.StyleList && Array.isArray(n.StyleList))
            for (const c of n.StyleList)
              this.privStyleList.push(c);
          this.privSampleRateHertz = n.SampleRateHertz, this.privStatus = n.Status, n.ExtendedPropertyMap && (this.privExtendedPropertyMap = n.ExtendedPropertyMap), this.privWordsPerMinute = n.WordsPerMinute, Array.isArray(n.SecondaryLocaleList) && (this.privSecondaryLocaleList = [...n.SecondaryLocaleList]), Array.isArray(n.RolePlayList) && (this.privRolePlayList = [...n.RolePlayList]), n.VoiceTag && (this.privVoiceTag = n.VoiceTag);
        }
      }
      get name() {
        return this.privName;
      }
      get locale() {
        return this.privLocale;
      }
      get shortName() {
        return this.privShortName;
      }
      get displayName() {
        return this.privDisplayName;
      }
      get localName() {
        return this.privLocalName;
      }
      get localeName() {
        return this.privLocaleName;
      }
      get gender() {
        return this.privGender;
      }
      get voiceType() {
        return this.privVoiceType;
      }
      get styleList() {
        return this.privStyleList;
      }
      get sampleRateHertz() {
        return this.privSampleRateHertz;
      }
      get status() {
        return this.privStatus;
      }
      get extendedPropertyMap() {
        return this.privExtendedPropertyMap;
      }
      get wordsPerMinute() {
        return this.privWordsPerMinute;
      }
      get secondaryLocaleList() {
        return this.privSecondaryLocaleList;
      }
      get rolePlayList() {
        return this.privRolePlayList;
      }
      get voiceTag() {
        return this.privVoiceTag;
      }
    }
    e.VoiceInfo = a;
  }(Yo)), Yo;
}
var ei = {}, Lp;
function OP() {
  if (Lp) return ei;
  Lp = 1, Object.defineProperty(ei, "__esModule", { value: !0 }), ei.SpeakerAudioDestination = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ Wt(), r = /* @__PURE__ */ Dt(), s = 60 * 30, i = {
    [r.AudioFormatTag.PCM]: "audio/wav",
    [r.AudioFormatTag.MuLaw]: "audio/x-wav",
    [r.AudioFormatTag.MP3]: "audio/mpeg",
    [r.AudioFormatTag.OGG_OPUS]: "audio/ogg",
    [r.AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
    [r.AudioFormatTag.ALaw]: "audio/x-wav",
    [r.AudioFormatTag.FLAC]: "audio/flac",
    [r.AudioFormatTag.AMR_WB]: "audio/amr-wb",
    [r.AudioFormatTag.G722]: "audio/G722"
  };
  let a = class {
    constructor(n) {
      this.privPlaybackStarted = !1, this.privAppendingToBuffer = !1, this.privMediaSourceOpened = !1, this.privBytesReceived = 0, this.privId = n || (0, e.createNoDashGuid)(), this.privIsPaused = !1, this.privIsClosed = !1;
    }
    id() {
      return this.privId;
    }
    write(n, c, u) {
      this.privAudioBuffer !== void 0 ? (this.privAudioBuffer.push(n), this.updateSourceBuffer().then(() => {
        c && c();
      }, (l) => {
        u && u(l);
      })) : this.privAudioOutputStream !== void 0 && (this.privAudioOutputStream.write(n), this.privBytesReceived += n.byteLength);
    }
    close(n, c) {
      if (this.privIsClosed = !0, this.privSourceBuffer !== void 0)
        this.handleSourceBufferUpdateEnd().then(() => {
          n && n();
        }, (u) => {
          c && c(u);
        });
      else if (this.privAudioOutputStream !== void 0 && typeof window < "u")
        if ((this.privFormat.formatTag === r.AudioFormatTag.PCM || this.privFormat.formatTag === r.AudioFormatTag.MuLaw || this.privFormat.formatTag === r.AudioFormatTag.ALaw) && this.privFormat.hasHeader === !1)
          console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header."), this.onAudioEnd && this.onAudioEnd(this);
        else {
          let u = new ArrayBuffer(this.privBytesReceived);
          this.privAudioOutputStream.read(u).then(() => {
            u = this.privFormat.addHeader(u);
            const l = new Blob([u], { type: i[this.privFormat.formatTag] });
            this.privAudio.src = window.URL.createObjectURL(l), this.notifyPlayback().then(() => {
              n && n();
            }, (p) => {
              c && c(p);
            });
          }, (l) => {
            c && c(l);
          });
        }
      else
        this.onAudioEnd && this.onAudioEnd(this);
    }
    set format(n) {
      if (typeof AudioContext < "u" || typeof window < "u" && typeof window.webkitAudioContext < "u") {
        this.privFormat = n;
        const c = i[this.privFormat.formatTag];
        c === void 0 ? console.warn(`Unknown mimeType for format ${r.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`) : typeof MediaSource < "u" && MediaSource.isTypeSupported(c) ? (this.privAudio = new Audio(), this.privAudioBuffer = [], this.privMediaSource = new MediaSource(), this.privAudio.src = URL.createObjectURL(this.privMediaSource), this.privAudio.load(), this.privMediaSource.onsourceopen = () => {
          this.privMediaSourceOpened = !0, this.privMediaSource.duration = s, this.privSourceBuffer = this.privMediaSource.addSourceBuffer(c), this.privSourceBuffer.onupdate = () => {
            this.updateSourceBuffer().catch((u) => {
              e.Events.instance.onEvent(new e.BackgroundEvent(u));
            });
          }, this.privSourceBuffer.onupdateend = () => {
            this.handleSourceBufferUpdateEnd().catch((u) => {
              e.Events.instance.onEvent(new e.BackgroundEvent(u));
            });
          }, this.privSourceBuffer.onupdatestart = () => {
            this.privAppendingToBuffer = !1;
          };
        }, this.updateSourceBuffer().catch((u) => {
          e.Events.instance.onEvent(new e.BackgroundEvent(u));
        })) : (console.warn(`Format ${r.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`), this.privAudioOutputStream = new t.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privFormat, this.privAudio = new Audio());
      }
    }
    get volume() {
      return this.privAudio?.volume ?? -1;
    }
    set volume(n) {
      this.privAudio && (this.privAudio.volume = n);
    }
    mute() {
      this.privAudio && (this.privAudio.muted = !0);
    }
    unmute() {
      this.privAudio && (this.privAudio.muted = !1);
    }
    get isClosed() {
      return this.privIsClosed;
    }
    get currentTime() {
      return this.privAudio !== void 0 ? this.privAudio.currentTime : -1;
    }
    pause() {
      !this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.pause(), this.privIsPaused = !0);
    }
    resume(n, c) {
      this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.play().then(() => {
        n && n();
      }, (u) => {
        c && c(u);
      }), this.privIsPaused = !1);
    }
    get internalAudio() {
      return this.privAudio;
    }
    async updateSourceBuffer() {
      if (this.privAudioBuffer !== void 0 && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
        this.privAppendingToBuffer = !0;
        const n = this.privAudioBuffer.shift();
        try {
          this.privSourceBuffer.appendBuffer(n);
        } catch {
          this.privAudioBuffer.unshift(n), console.log("buffer filled, pausing addition of binaries until space is made");
          return;
        }
        await this.notifyPlayback();
      } else this.canEndStream() && await this.handleSourceBufferUpdateEnd();
    }
    async handleSourceBufferUpdateEnd() {
      this.canEndStream() && this.sourceBufferAvailable() && (this.privMediaSource.endOfStream(), await this.notifyPlayback());
    }
    async notifyPlayback() {
      !this.privPlaybackStarted && this.privAudio !== void 0 && (this.privPlaybackStarted = !0, this.onAudioStart && this.onAudioStart(this), this.privAudio.onended = () => {
        this.onAudioEnd && this.onAudioEnd(this);
      }, this.privIsPaused || await this.privAudio.play());
    }
    canEndStream() {
      return this.isClosed && this.privSourceBuffer !== void 0 && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
    }
    sourceBufferAvailable() {
      return this.privSourceBuffer !== void 0 && !this.privSourceBuffer.updating;
    }
  };
  return ei.SpeakerAudioDestination = a, ei;
}
var ti = {}, jp;
function MP() {
  if (jp) return ti;
  jp = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.ConversationTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Rs();
  let t = class extends e.CancellationEventArgsBase {
  };
  return ti.ConversationTranscriptionCanceledEventArgs = t, ti;
}
var ri = {}, qp;
function DP() {
  if (qp) return ri;
  qp = 1, Object.defineProperty(ri, "__esModule", { value: !0 }), ri.MeetingTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Rs();
  let t = class extends e.CancellationEventArgsBase {
  };
  return ri.MeetingTranscriptionCanceledEventArgs = t, ri;
}
var Zo = {}, Fp;
function NP() {
  return Fp || (Fp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PronunciationAssessmentGradingSystem = void 0, function(t) {
      t[t.FivePoint = 1] = "FivePoint", t[t.HundredMark = 2] = "HundredMark";
    }(e.PronunciationAssessmentGradingSystem || (e.PronunciationAssessmentGradingSystem = {}));
  }(Zo)), Zo;
}
var Xo = {}, Bp;
function xP() {
  return Bp || (Bp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PronunciationAssessmentGranularity = void 0, function(t) {
      t[t.Phoneme = 1] = "Phoneme", t[t.Word = 2] = "Word", t[t.FullText = 3] = "FullText";
    }(e.PronunciationAssessmentGranularity || (e.PronunciationAssessmentGranularity = {}));
  }(Xo)), Xo;
}
var ni = {}, Up;
function zP() {
  if (Up) return ni;
  Up = 1, Object.defineProperty(ni, "__esModule", { value: !0 }), ni.PronunciationAssessmentConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class _v {
    /**
     * PronunciationAssessmentConfig constructor.
     * @constructor
     * @param {string} referenceText
     * @param gradingSystem
     * @param granularity
     * @param enableMiscue
     */
    constructor(i, a = t.PronunciationAssessmentGradingSystem.FivePoint, o = t.PronunciationAssessmentGranularity.Phoneme, n = !1) {
      e.Contracts.throwIfNullOrUndefined(i, "referenceText"), this.privProperties = new t.PropertyCollection(), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_ReferenceText, i), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_GradingSystem, t.PronunciationAssessmentGradingSystem[a]), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_Granularity, t.PronunciationAssessmentGranularity[o]), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, String(n));
    }
    /**
     * @member PronunciationAssessmentConfig.fromJSON
     * @function
     * @public
     * @param {string} json The json string containing the pronunciation assessment parameters.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentConfig from json.
     * This method is designed to support the pronunciation assessment parameters still in preview.
     * Under normal circumstances, use the constructor instead.
     */
    static fromJSON(i) {
      e.Contracts.throwIfNullOrUndefined(i, "json");
      const a = new _v("");
      return a.privProperties = new t.PropertyCollection(), a.properties.setProperty(t.PropertyId.PronunciationAssessment_Json, i), a;
    }
    toJSON() {
      return this.updateJson(), this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Params);
    }
    applyTo(i) {
      this.updateJson();
      const a = i.internalData;
      a.expectContentAssessmentResponse = !!this.privContentAssessmentTopic, a.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(t.PropertyId.PronunciationAssessment_Params), this.privContentAssessmentTopic, a.isSpeakerDiarizationEnabled);
    }
    /**
     * Gets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @returns {string} Reference text.
     */
    get referenceText() {
      return this.properties.getProperty(t.PropertyId.PronunciationAssessment_ReferenceText);
    }
    /**
     * Gets/Sets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @param {string} referenceText - Reference text.
     */
    set referenceText(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "referenceText"), this.properties.setProperty(t.PropertyId.PronunciationAssessment_ReferenceText, i);
    }
    /**
     * Sets the phoneme alphabet.
     * The valid values are "SAPI" (default) and "IPA".
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
     * @function
     * @public
     * @param {string} phonemeAlphabet - Phoneme alphabet.
     */
    set phonemeAlphabet(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "phonemeAlphabet"), this.privPhonemeAlphabet = i;
    }
    /**
     * Sets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @param {boolean} enableMiscue - enable miscue.
     */
    set enableMiscue(i) {
      const a = i ? "true" : "false";
      this.properties.setProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, a);
    }
    /**
     * Gets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @return {boolean} enableMiscue - enable miscue.
     */
    get enableMiscue() {
      return this.properties.getProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, "false").toLowerCase() === "true";
    }
    /**
     * Sets the nbest phoneme count
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
     * @function
     * @public
     * @param {number} nbestPhonemeCount - NBest phoneme count.
     */
    set nbestPhonemeCount(i) {
      this.privNBestPhonemeCount = i;
    }
    /**
     * Enables the prosody assessment.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableProsodyAssessment
     * @function
     * @public
     * @param {boolean} enableProsodyAssessment - enable prosody assessment.
     */
    set enableProsodyAssessment(i) {
      this.privEnableProsodyAssessment = i;
    }
    /**
     * Enables content assessment and sets the topic.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableContentAssessmentWithTopic
     * @function
     * @public
     * @param {string} topic - Topic for content assessment.
     */
    enableContentAssessmentWithTopic(i) {
      this.privContentAssessmentTopic = i;
    }
    /**
     * @member PronunciationAssessmentConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets a pronunciation assessment config properties
     */
    get properties() {
      return this.privProperties;
    }
    updateJson() {
      const i = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Json, "{}"), a = JSON.parse(i), o = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_ReferenceText);
      o && (a.referenceText = o);
      const n = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_GradingSystem);
      n && (a.gradingSystem = n);
      const c = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Granularity);
      c && (a.granularity = c), this.privPhonemeAlphabet && (a.phonemeAlphabet = this.privPhonemeAlphabet), this.privNBestPhonemeCount && (a.nbestPhonemeCount = this.privNBestPhonemeCount), a.enableProsodyAssessment = this.privEnableProsodyAssessment, a.dimension = "Comprehensive", this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_EnableMiscue) && (a.enableMiscue = this.enableMiscue), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_Params, JSON.stringify(a));
    }
  };
  return ni.PronunciationAssessmentConfig = r, ni;
}
var Pt = {}, $p;
function LP() {
  if ($p) return Pt;
  $p = 1, Object.defineProperty(Pt, "__esModule", { value: !0 }), Pt.PronunciationAssessmentResult = Pt.ContentAssessmentResult = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  class r {
    /**
     * @Internal
     * Do not use externally.
     */
    constructor(a) {
      this.privPronJson = a;
    }
    /**
     * Correctness in using grammar and variety of sentence patterns.
     * Grammatical errors are jointly evaluated by lexical accuracy,
     * grammatical accuracy and diversity of sentence structures.
     * @member ContentAssessmentResult.prototype.grammarScore
     * @function
     * @public
     * @returns {number} Grammar score.
     */
    get grammarScore() {
      return this.privPronJson.ContentAssessment.GrammarScore;
    }
    /**
     * Proficiency in lexical usage. It evaluates the speaker's effective usage
     * of words and their appropriateness within the given context to express
     * ideas accurately, as well as level of lexical complexity.
     * @member ContentAssessmentResult.prototype.vocabularyScore
     * @function
     * @public
     * @returns {number} Vocabulary score.
     */
    get vocabularyScore() {
      return this.privPronJson.ContentAssessment.VocabularyScore;
    }
    /**
     * Level of understanding and engagement with the topic, which provides
     * insights into the speaker’s ability to express their thoughts and ideas
     * effectively and the ability to engage with the topic.
     * @member ContentAssessmentResult.prototype.topicScore
     * @function
     * @public
     * @returns {number} Topic score.
     */
    get topicScore() {
      return this.privPronJson.ContentAssessment.TopicScore;
    }
  }
  Pt.ContentAssessmentResult = r;
  let s = class kv {
    constructor(a) {
      const o = JSON.parse(a);
      e.Contracts.throwIfNullOrUndefined(o.NBest[0], "NBest"), this.privPronJson = o.NBest[0];
    }
    /**
     * @member PronunciationAssessmentResult.fromResult
     * @function
     * @public
     * @param {RecognitionResult} result The recognition result.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
     */
    static fromResult(a) {
      e.Contracts.throwIfNullOrUndefined(a, "result");
      const o = a.properties.getProperty(t.PropertyId.SpeechServiceResponse_JsonResult);
      return e.Contracts.throwIfNullOrUndefined(o, "json"), new kv(o);
    }
    /**
     * Gets the detail result of pronunciation assessment.
     * @member PronunciationAssessmentConfig.prototype.detailResult
     * @function
     * @public
     * @returns {DetailResult} detail result.
     */
    get detailResult() {
      return this.privPronJson;
    }
    /**
     * The score indicating the pronunciation accuracy of the given speech, which indicates
     * how closely the phonemes match a native speaker's pronunciation.
     * @member PronunciationAssessmentResult.prototype.accuracyScore
     * @function
     * @public
     * @returns {number} Accuracy score.
     */
    get accuracyScore() {
      return this.detailResult.PronunciationAssessment?.AccuracyScore;
    }
    /**
     * The overall score indicating the pronunciation quality of the given speech.
     * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
     * @member PronunciationAssessmentResult.prototype.pronunciationScore
     * @function
     * @public
     * @returns {number} Pronunciation score.
     */
    get pronunciationScore() {
      return this.detailResult.PronunciationAssessment?.PronScore;
    }
    /**
     * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
     * @member PronunciationAssessmentResult.prototype.completenessScore
     * @function
     * @public
     * @returns {number} Completeness score.
     */
    get completenessScore() {
      return this.detailResult.PronunciationAssessment?.CompletenessScore;
    }
    /**
     * The score indicating the fluency of the given speech.
     * @member PronunciationAssessmentResult.prototype.fluencyScore
     * @function
     * @public
     * @returns {number} Fluency score.
     */
    get fluencyScore() {
      return this.detailResult.PronunciationAssessment?.FluencyScore;
    }
    /**
     * The prosody score, which indicates how nature of the given speech, including stress, intonation, speaking speed and rhythm.
     * @member PronunciationAssessmentResult.prototype.prosodyScore
     * @function
     * @public
     * @returns {number} Prosody score.
     */
    get prosodyScore() {
      return this.detailResult.PronunciationAssessment?.ProsodyScore;
    }
    /**
     * The concent assessment result.
     * Only available when content assessment is enabled.
     * @member PronunciationAssessmentResult.prototype.contentAssessmentResult
     * @function
     * @public
     * @returns {ContentAssessmentResult} Content assessment result.
     */
    get contentAssessmentResult() {
      if (this.detailResult.ContentAssessment !== void 0)
        return new r(this.detailResult);
    }
  };
  return Pt.PronunciationAssessmentResult = s, Pt;
}
var ii = {}, Vp;
function jP() {
  if (Vp) return ii;
  Vp = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.AvatarConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} character - The avatar character.
     * @param {string} style - The avatar style.
     * @param {AvatarVideoFormat} videoFormat - The talking avatar output video format.
     */
    constructor(i, a, o) {
      this.privCustomized = !1, this.privUseBuiltInVoice = !1, e.Contracts.throwIfNullOrWhitespace(i, "character"), this.character = i, this.style = a, o === void 0 && (o = new t.AvatarVideoFormat()), this.videoFormat = o;
    }
    /**
     * Indicates if the talking avatar is customized.
     */
    get customized() {
      return this.privCustomized;
    }
    /**
     * Sets if the talking avatar is customized.
     */
    set customized(i) {
      this.privCustomized = i;
    }
    /**
     * Indicates whether to use built-in voice for custom avatar.
     */
    get useBuiltInVoice() {
      return this.privUseBuiltInVoice;
    }
    /**
     * Sets whether to use built-in voice for custom avatar.
     */
    set useBuiltInVoice(i) {
      this.privUseBuiltInVoice = i;
    }
    /**
     * Gets the background color.
     */
    get backgroundColor() {
      return this.privBackgroundColor;
    }
    /**
     * Sets the background color.
     */
    set backgroundColor(i) {
      this.privBackgroundColor = i;
    }
    /**
     * Gets the background image.
     */
    get backgroundImage() {
      return this.privBackgroundImage;
    }
    /**
     * Sets the background image.
     * @param {URL} value - The background image.
     */
    set backgroundImage(i) {
      this.privBackgroundImage = i;
    }
    /**
     * Gets the remote ICE servers.
     * @remarks This method is designed to be used internally in the SDK.
     * @returns {RTCIceServer[]} The remote ICE servers.
     */
    get remoteIceServers() {
      return this.privRemoteIceServers;
    }
    /**
     * Sets the remote ICE servers.
     * @remarks Normally, the ICE servers are gathered from the PeerConnection,
     * set this property to override the ICE servers. E.g., the ICE servers are
     * different in client and server side.
     * @param {RTCIceServer[]} value - The remote ICE servers.
     */
    set remoteIceServers(i) {
      this.privRemoteIceServers = i;
    }
  };
  return ii.AvatarConfig = r, ii;
}
var ea = {}, Wp;
function qP() {
  return Wp || (Wp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AvatarEventArgs = e.AvatarEventTypes = void 0, function(r) {
      r.SwitchedToSpeaking = "SwitchedToSpeaking", r.SwitchedToIdle = "SwitchedToIdle", r.SessionClosed = "SessionClosed";
    }(e.AvatarEventTypes || (e.AvatarEventTypes = {}));
    class t {
      /**
       * Creates and initializes an instance of this class.
       * @constructor
       * @param {number} audioOffset - The audio offset.
       * @param {string} description - The description of the event.
       */
      constructor(s, i) {
        this.privOffset = s, this.privDescription = i;
      }
      /**
       * The type of the event.
       * @public
       * @returns {AvatarEventTypes} The type of the event.
       */
      get type() {
        return this.privType;
      }
      /**
       * The time offset associated with this event.
       * @public
       * @returns {number} The time offset associated with this event.
       */
      get offset() {
        return this.privOffset;
      }
      /**
       * The description of the event.
       * @public
       * @returns {string} The description of the event.
       */
      get description() {
        return this.privDescription;
      }
    }
    e.AvatarEventArgs = t;
  }(ea)), ea;
}
var si = {}, oi = {}, Hp;
function Ov() {
  if (Hp) return oi;
  Hp = 1, Object.defineProperty(oi, "__esModule", { value: !0 }), oi.SpeechSynthesisConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Ae(), s = /* @__PURE__ */ O(), i = /* @__PURE__ */ ue(), a = /* @__PURE__ */ Xe();
  let o = class {
    constructor() {
      this.synthesisUri = "/tts/cognitiveservices/websocket/v1";
    }
    async create(c, u, l) {
      let p = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const d = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, void 0), h = r.ConnectionFactoryBase.getHostSuffix(d), f = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), g = f === void 0 ? "tts" : "voice", m = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + d + "." + g + ".speech" + h), v = {}, y = {};
      if (u.token !== void 0 && u.token !== "" && (y[u.headerName] = u.token), y[i.HeaderNames.ConnectionId] = l, f !== void 0 && f !== "" && (!p || p.search(a.QueryParameterNames.CustomVoiceDeploymentId) === -1) && (v[a.QueryParameterNames.CustomVoiceDeploymentId] = f), c.avatarEnabled && (!p || p.search(a.QueryParameterNames.EnableAvatar) === -1) && (v[a.QueryParameterNames.EnableAvatar] = "true"), p) {
        const C = new URL(p), R = C.pathname;
        (R === "" || R === "/") && (C.pathname = this.synthesisUri, p = await r.ConnectionFactoryBase.getRedirectUrlFromEndpoint(C.toString()));
      }
      p || (p = m + this.synthesisUri), c.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, p);
      const S = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new e.WebsocketConnection(p, v, y, new s.WebsocketMessageFormatter(), e.ProxyInfo.fromParameters(c.parameters), S, l);
    }
  };
  return oi.SpeechSynthesisConnectionFactory = o, oi;
}
var Kp;
function FP() {
  if (Kp) return si;
  Kp = 1, Object.defineProperty(si, "__esModule", { value: !0 }), si.AvatarSynthesizer = void 0;
  const e = /* @__PURE__ */ Ov(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ D(), s = /* @__PURE__ */ Cs(), i = /* @__PURE__ */ A(), a = /* @__PURE__ */ z(), o = /* @__PURE__ */ oc();
  let n = class extends i.Synthesizer {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config.
     * @param {AvatarConfig} avatarConfig - The talking avatar config.
     */
    constructor(u, l) {
      super(u), a.Contracts.throwIfNullOrUndefined(l, "avatarConfig"), this.privConnectionFactory = new e.SpeechSynthesisConnectionFactory(), this.privAvatarConfig = l, this.implCommonSynthesizeSetup();
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = s.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(i.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);
    }
    /**
     * Starts the talking avatar session and establishes the WebRTC connection.
     * @member AvatarSynthesizer.prototype.startAvatarAsync
     * @function
     * @public
     * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.
     * @returns {Promise<SynthesisResult>} The promise of the connection result.
     */
    async startAvatarAsync(u) {
      a.Contracts.throwIfNullOrUndefined(u, "peerConnection"), this.privIceServers = u.getConfiguration().iceServers, a.Contracts.throwIfNullOrUndefined(this.privIceServers, "Ice servers must be set.");
      const l = new r.Deferred();
      u.onicegatheringstatechange = () => {
        r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering state: " + u.iceGatheringState, r.EventType.Debug)), u.iceGatheringState === "complete" && (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering complete.", r.EventType.Info)), l.resolve());
      }, u.onicecandidate = (g) => {
        g.candidate ? r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice candidate: " + g.candidate.candidate, r.EventType.Debug)) : (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice candidate: complete", r.EventType.Debug)), l.resolve());
      }, setTimeout(() => {
        u.iceGatheringState !== "complete" && (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering timeout.", r.EventType.Warning)), l.resolve());
      }, 2e3);
      const p = await u.createOffer();
      await u.setLocalDescription(p), await l.promise, r.Events.instance.onEvent(new r.PlatformEvent("peer connection: got local SDP.", r.EventType.Info)), this.privProperties.setProperty(i.PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(u.localDescription));
      const d = await this.speak("", !1);
      if (d.reason !== i.ResultReason.SynthesizingAudioCompleted)
        return new i.SynthesisResult(d.resultId, d.reason, d.errorDetails, d.properties);
      const h = atob(d.properties.getProperty(i.PropertyId.TalkingAvatarService_WebRTC_SDP)), f = new RTCSessionDescription(JSON.parse(h));
      return await u.setRemoteDescription(f), new i.SynthesisResult(d.resultId, d.reason, void 0, d.properties);
    }
    /**
     * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param {string} text - The plain text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakTextAsync(u) {
      const l = await this.speak(u, !1);
      return new i.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
    }
    /**
     * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param {string} ssml - The SSML text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakSsmlAsync(u) {
      const l = await this.speak(u, !0);
      return new i.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
    }
    /**
     * Speaks text asynchronously. The avatar will switch to idle state.
     * @member AvatarSynthesizer.prototype.stopSpeakingAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopSpeakingAsync() {
      for (; this.synthesisRequestQueue.length() > 0; )
        (await this.synthesisRequestQueue.dequeue()).err("Synthesis is canceled by user.");
      return this.privAdapter.stopSpeaking();
    }
    /**
     * Stops the talking avatar session and closes the WebRTC connection.
     * For now, this is the same as close().
     * You need to create a new AvatarSynthesizer instance to start a new session.
     * @member AvatarSynthesizer.prototype.stopAvatarAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopAvatarAsync() {
      return a.Contracts.throwIfDisposed(this.privDisposed), this.dispose(!0);
    }
    /**
     * Dispose of associated resources.
     * @member AvatarSynthesizer.prototype.close
     * @function
     * @public
     */
    async close() {
      if (!this.privDisposed)
        return this.dispose(!0);
    }
    /**
     * Gets the ICE servers. Internal use only.
     */
    get iceServers() {
      return this.privIceServers;
    }
    // Creates the synthesis adapter
    createSynthesisAdapter(u, l, p) {
      return new t.AvatarSynthesisAdapter(u, l, p, this, this.privAvatarConfig);
    }
    createRestSynthesisAdapter(u, l) {
    }
    createSynthesizerConfig(u) {
      const l = super.createSynthesizerConfig(u);
      return l.avatarEnabled = !0, l;
    }
    async speak(u, l) {
      const p = (0, r.createNoDashGuid)(), d = new r.Deferred();
      return this.synthesisRequestQueue.enqueue(new o.SynthesisRequest(p, u, l, (h) => {
        d.resolve(h), this.privSynthesizing = !1, this.adapterSpeak();
      }, (h) => {
        d.reject(h), this.privSynthesizing = !1;
      })), this.adapterSpeak(), d.promise;
    }
  };
  return si.AvatarSynthesizer = n, si;
}
var bt = {}, Jp;
function BP() {
  if (Jp) return bt;
  Jp = 1, Object.defineProperty(bt, "__esModule", { value: !0 }), bt.AvatarVideoFormat = bt.Coordinate = void 0;
  class e {
    constructor(s, i) {
      this.x = s, this.y = i;
    }
  }
  bt.Coordinate = e;
  let t = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} codec - The video codec.
     * @param {number} bitrate - The video bitrate.
     * @param {number} width - The video width.
     * @param {number} height - The video height.
     */
    constructor(s = "H264", i = 2e6, a = 1920, o = 1080) {
      this.codec = s, this.bitrate = i, this.width = a, this.height = o;
    }
    /**
     * Sets the video crop range.
     */
    setCropRange(s, i) {
      this.cropRange = {
        bottomRight: i,
        topLeft: s
      };
    }
  };
  return bt.AvatarVideoFormat = t, bt;
}
var ai = {}, Gp;
function UP() {
  if (Gp) return ai;
  Gp = 1, Object.defineProperty(ai, "__esModule", { value: !0 }), ai.AvatarWebRTCConnectionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {RTCSessionDescriptionInit} SDPAnswer - The SDP answer of WebRTC connection.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(s, i, a, o, n) {
      super(i, a, o, n), this.privSDPAnswer = s;
    }
    /**
     * Specifies SDP (Session Description Protocol) answer of WebRTC connection.
     * @member AvatarWebRTCConnectionResult.prototype.SDPAnswer
     * @function
     * @public
     * @returns {RTCSessionDescriptionInit} Specifies the SDP answer of WebRTC connection.
     */
    get SDPAnswer() {
      return this.privSDPAnswer;
    }
  };
  return ai.AvatarWebRTCConnectionResult = t, ai;
}
var ci = {}, Qp;
function $P() {
  if (Qp) return ci;
  Qp = 1, Object.defineProperty(ci, "__esModule", { value: !0 }), ci.Diagnostics = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ D();
  let r = class {
    static SetLoggingLevel(i) {
      this.privListener = new e.ConsoleLoggingListener(i), t.Events.instance.attachConsoleListener(this.privListener);
    }
    static StartConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !0);
    }
    static StopConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !1);
    }
    static SetLogOutputPath(i) {
      if (typeof window > "u")
        this.privListener && (this.privListener.logPath = i);
      else
        throw new Error("File system logging not available in browser.");
    }
    static set onLogOutput(i) {
      this.privListener && (this.privListener.logCallback = i);
    }
  };
  return ci.Diagnostics = r, r.privListener = void 0, ci;
}
var Yp;
function A() {
  return Yp || (Yp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionEventArgs = e.CancellationErrorCode = e.CancellationDetails = e.CancellationDetailsBase = e.IntentRecognitionCanceledEventArgs = e.TranslationRecognitionCanceledEventArgs = e.NoMatchDetails = e.NoMatchReason = e.Translations = e.TranslationRecognizer = e.VoiceProfileType = e.IntentRecognizer = e.SpeechRecognizer = e.Recognizer = e.PropertyId = e.PropertyCollection = e.SpeechTranslationConfigImpl = e.SpeechTranslationConfig = e.SpeechConfigImpl = e.SpeechConfig = e.ResultReason = e.TranslationSynthesisResult = e.TranslationRecognitionResult = e.TranslationSynthesisEventArgs = e.TranslationRecognitionEventArgs = e.SpeechRecognitionCanceledEventArgs = e.MeetingTranscriptionEventArgs = e.ConversationTranscriptionEventArgs = e.SpeechRecognitionEventArgs = e.LanguageUnderstandingModel = e.IntentRecognitionResult = e.SpeechRecognitionResult = e.RecognitionResult = e.IntentRecognitionEventArgs = e.OutputFormat = e.RecognitionEventArgs = e.SessionEventArgs = e.KeywordRecognitionModel = e.PushAudioOutputStreamCallback = e.PullAudioInputStreamCallback = e.CancellationReason = e.PushAudioOutputStream = e.PullAudioOutputStream = e.AudioOutputStream = e.PushAudioInputStream = e.PullAudioInputStream = e.AudioInputStream = e.AudioFormatTag = e.AudioStreamFormat = e.AudioConfig = void 0, e.SpeechSynthesisEventArgs = e.SpeechSynthesisResult = e.SynthesisResult = e.SpeechSynthesizer = e.SpeechSynthesisOutputFormat = e.Synthesizer = e.User = e.ParticipantChangedReason = e.Participant = e.MeetingTranscriber = e.Meeting = e.ConversationTranscriptionResult = e.ConversationTranscriber = e.ConversationTranslator = e.ConversationTranslationResult = e.ConversationTranslationEventArgs = e.ConversationTranslationCanceledEventArgs = e.ConversationParticipantsChangedEventArgs = e.ConversationExpirationEventArgs = e.Conversation = e.SpeakerRecognitionCancellationDetails = e.SpeakerRecognitionResultType = e.SpeakerRecognitionResult = e.SourceLanguageConfig = e.AutoDetectSourceLanguageResult = e.AutoDetectSourceLanguageConfig = e.SpeakerVerificationModel = e.SpeakerIdentificationModel = e.SpeakerRecognizer = e.VoiceProfileClient = e.VoiceProfilePhraseResult = e.VoiceProfileCancellationDetails = e.VoiceProfileResult = e.VoiceProfileEnrollmentCancellationDetails = e.VoiceProfileEnrollmentResult = e.VoiceProfile = e.ConnectionMessage = e.ConnectionMessageEventArgs = e.BaseAudioPlayer = e.ProfanityOption = e.ServicePropertyChannel = e.TurnStatusReceivedEventArgs = e.ActivityReceivedEventArgs = e.DialogServiceConnector = e.CustomCommandsConfig = e.BotFrameworkConfig = e.DialogServiceConfig = e.PhraseListGrammar = e.Connection = e.ServiceEventArgs = void 0, e.LogLevel = e.Diagnostics = e.AvatarWebRTCConnectionResult = e.Coordinate = e.AvatarVideoFormat = e.AvatarSynthesizer = e.AvatarEventArgs = e.AvatarConfig = e.LanguageIdMode = e.PronunciationAssessmentResult = e.PronunciationAssessmentConfig = e.PronunciationAssessmentGranularity = e.PronunciationAssessmentGradingSystem = e.MeetingTranscriptionCanceledEventArgs = e.ConversationTranscriptionCanceledEventArgs = e.SpeakerAudioDestination = e.VoiceInfo = e.SynthesisVoiceType = e.SynthesisVoiceGender = e.SynthesisVoicesResult = e.SpeechSynthesisBoundaryType = e.SpeechSynthesisVisemeEventArgs = e.SpeechSynthesisBookmarkEventArgs = e.SpeechSynthesisWordBoundaryEventArgs = void 0;
    var t = /* @__PURE__ */ sv();
    Object.defineProperty(e, "AudioConfig", { enumerable: !0, get: function() {
      return t.AudioConfig;
    } });
    var r = /* @__PURE__ */ Dt();
    Object.defineProperty(e, "AudioStreamFormat", { enumerable: !0, get: function() {
      return r.AudioStreamFormat;
    } }), Object.defineProperty(e, "AudioFormatTag", { enumerable: !0, get: function() {
      return r.AudioFormatTag;
    } });
    var s = /* @__PURE__ */ rv();
    Object.defineProperty(e, "AudioInputStream", { enumerable: !0, get: function() {
      return s.AudioInputStream;
    } }), Object.defineProperty(e, "PullAudioInputStream", { enumerable: !0, get: function() {
      return s.PullAudioInputStream;
    } }), Object.defineProperty(e, "PushAudioInputStream", { enumerable: !0, get: function() {
      return s.PushAudioInputStream;
    } });
    var i = /* @__PURE__ */ Wt();
    Object.defineProperty(e, "AudioOutputStream", { enumerable: !0, get: function() {
      return i.AudioOutputStream;
    } }), Object.defineProperty(e, "PullAudioOutputStream", { enumerable: !0, get: function() {
      return i.PullAudioOutputStream;
    } }), Object.defineProperty(e, "PushAudioOutputStream", { enumerable: !0, get: function() {
      return i.PushAudioOutputStream;
    } });
    var a = /* @__PURE__ */ rR();
    Object.defineProperty(e, "CancellationReason", { enumerable: !0, get: function() {
      return a.CancellationReason;
    } });
    var o = /* @__PURE__ */ nR();
    Object.defineProperty(e, "PullAudioInputStreamCallback", { enumerable: !0, get: function() {
      return o.PullAudioInputStreamCallback;
    } });
    var n = /* @__PURE__ */ iR();
    Object.defineProperty(e, "PushAudioOutputStreamCallback", { enumerable: !0, get: function() {
      return n.PushAudioOutputStreamCallback;
    } });
    var c = /* @__PURE__ */ sR();
    Object.defineProperty(e, "KeywordRecognitionModel", { enumerable: !0, get: function() {
      return c.KeywordRecognitionModel;
    } });
    var u = /* @__PURE__ */ oR();
    Object.defineProperty(e, "SessionEventArgs", { enumerable: !0, get: function() {
      return u.SessionEventArgs;
    } });
    var l = /* @__PURE__ */ aR();
    Object.defineProperty(e, "RecognitionEventArgs", { enumerable: !0, get: function() {
      return l.RecognitionEventArgs;
    } });
    var p = /* @__PURE__ */ cR();
    Object.defineProperty(e, "OutputFormat", { enumerable: !0, get: function() {
      return p.OutputFormat;
    } });
    var d = /* @__PURE__ */ uR();
    Object.defineProperty(e, "IntentRecognitionEventArgs", { enumerable: !0, get: function() {
      return d.IntentRecognitionEventArgs;
    } });
    var h = /* @__PURE__ */ lR();
    Object.defineProperty(e, "RecognitionResult", { enumerable: !0, get: function() {
      return h.RecognitionResult;
    } });
    var f = /* @__PURE__ */ pR();
    Object.defineProperty(e, "SpeechRecognitionResult", { enumerable: !0, get: function() {
      return f.SpeechRecognitionResult;
    } });
    var g = /* @__PURE__ */ dR();
    Object.defineProperty(e, "IntentRecognitionResult", { enumerable: !0, get: function() {
      return g.IntentRecognitionResult;
    } });
    var m = /* @__PURE__ */ hR();
    Object.defineProperty(e, "LanguageUnderstandingModel", { enumerable: !0, get: function() {
      return m.LanguageUnderstandingModel;
    } });
    var v = /* @__PURE__ */ fR();
    Object.defineProperty(e, "SpeechRecognitionEventArgs", { enumerable: !0, get: function() {
      return v.SpeechRecognitionEventArgs;
    } }), Object.defineProperty(e, "ConversationTranscriptionEventArgs", { enumerable: !0, get: function() {
      return v.ConversationTranscriptionEventArgs;
    } }), Object.defineProperty(e, "MeetingTranscriptionEventArgs", { enumerable: !0, get: function() {
      return v.MeetingTranscriptionEventArgs;
    } });
    var y = /* @__PURE__ */ vR();
    Object.defineProperty(e, "SpeechRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return y.SpeechRecognitionCanceledEventArgs;
    } });
    var S = /* @__PURE__ */ gR();
    Object.defineProperty(e, "TranslationRecognitionEventArgs", { enumerable: !0, get: function() {
      return S.TranslationRecognitionEventArgs;
    } });
    var C = /* @__PURE__ */ mR();
    Object.defineProperty(e, "TranslationSynthesisEventArgs", { enumerable: !0, get: function() {
      return C.TranslationSynthesisEventArgs;
    } });
    var R = /* @__PURE__ */ av();
    Object.defineProperty(e, "TranslationRecognitionResult", { enumerable: !0, get: function() {
      return R.TranslationRecognitionResult;
    } });
    var w = /* @__PURE__ */ yR();
    Object.defineProperty(e, "TranslationSynthesisResult", { enumerable: !0, get: function() {
      return w.TranslationSynthesisResult;
    } });
    var I = /* @__PURE__ */ SR();
    Object.defineProperty(e, "ResultReason", { enumerable: !0, get: function() {
      return I.ResultReason;
    } });
    var E = /* @__PURE__ */ CR();
    Object.defineProperty(e, "SpeechConfig", { enumerable: !0, get: function() {
      return E.SpeechConfig;
    } }), Object.defineProperty(e, "SpeechConfigImpl", { enumerable: !0, get: function() {
      return E.SpeechConfigImpl;
    } });
    var T = /* @__PURE__ */ RR();
    Object.defineProperty(e, "SpeechTranslationConfig", { enumerable: !0, get: function() {
      return T.SpeechTranslationConfig;
    } }), Object.defineProperty(e, "SpeechTranslationConfigImpl", { enumerable: !0, get: function() {
      return T.SpeechTranslationConfigImpl;
    } });
    var b = /* @__PURE__ */ uv();
    Object.defineProperty(e, "PropertyCollection", { enumerable: !0, get: function() {
      return b.PropertyCollection;
    } });
    var _ = /* @__PURE__ */ nc();
    Object.defineProperty(e, "PropertyId", { enumerable: !0, get: function() {
      return _.PropertyId;
    } });
    var k = /* @__PURE__ */ PR();
    Object.defineProperty(e, "Recognizer", { enumerable: !0, get: function() {
      return k.Recognizer;
    } });
    var B = /* @__PURE__ */ bR();
    Object.defineProperty(e, "SpeechRecognizer", { enumerable: !0, get: function() {
      return B.SpeechRecognizer;
    } });
    var V = /* @__PURE__ */ wR();
    Object.defineProperty(e, "IntentRecognizer", { enumerable: !0, get: function() {
      return V.IntentRecognizer;
    } });
    var Q = /* @__PURE__ */ ER();
    Object.defineProperty(e, "VoiceProfileType", { enumerable: !0, get: function() {
      return Q.VoiceProfileType;
    } });
    var K = /* @__PURE__ */ IR();
    Object.defineProperty(e, "TranslationRecognizer", { enumerable: !0, get: function() {
      return K.TranslationRecognizer;
    } });
    var le = /* @__PURE__ */ AR();
    Object.defineProperty(e, "Translations", { enumerable: !0, get: function() {
      return le.Translations;
    } });
    var he = /* @__PURE__ */ TR();
    Object.defineProperty(e, "NoMatchReason", { enumerable: !0, get: function() {
      return he.NoMatchReason;
    } });
    var J = /* @__PURE__ */ _R();
    Object.defineProperty(e, "NoMatchDetails", { enumerable: !0, get: function() {
      return J.NoMatchDetails;
    } });
    var re = /* @__PURE__ */ kR();
    Object.defineProperty(e, "TranslationRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return re.TranslationRecognitionCanceledEventArgs;
    } });
    var Y = /* @__PURE__ */ OR();
    Object.defineProperty(e, "IntentRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return Y.IntentRecognitionCanceledEventArgs;
    } });
    var $e = /* @__PURE__ */ gv();
    Object.defineProperty(e, "CancellationDetailsBase", { enumerable: !0, get: function() {
      return $e.CancellationDetailsBase;
    } });
    var Me = /* @__PURE__ */ MR();
    Object.defineProperty(e, "CancellationDetails", { enumerable: !0, get: function() {
      return Me.CancellationDetails;
    } });
    var Kt = /* @__PURE__ */ DR();
    Object.defineProperty(e, "CancellationErrorCode", { enumerable: !0, get: function() {
      return Kt.CancellationErrorCode;
    } });
    var et = /* @__PURE__ */ NR();
    Object.defineProperty(e, "ConnectionEventArgs", { enumerable: !0, get: function() {
      return et.ConnectionEventArgs;
    } });
    var tt = /* @__PURE__ */ xR();
    Object.defineProperty(e, "ServiceEventArgs", { enumerable: !0, get: function() {
      return tt.ServiceEventArgs;
    } });
    var Ve = /* @__PURE__ */ hv();
    Object.defineProperty(e, "Connection", { enumerable: !0, get: function() {
      return Ve.Connection;
    } });
    var De = /* @__PURE__ */ zR();
    Object.defineProperty(e, "PhraseListGrammar", { enumerable: !0, get: function() {
      return De.PhraseListGrammar;
    } });
    var Ce = /* @__PURE__ */ ic();
    Object.defineProperty(e, "DialogServiceConfig", { enumerable: !0, get: function() {
      return Ce.DialogServiceConfig;
    } });
    var Jt = /* @__PURE__ */ LR();
    Object.defineProperty(e, "BotFrameworkConfig", { enumerable: !0, get: function() {
      return Jt.BotFrameworkConfig;
    } });
    var Nt = /* @__PURE__ */ jR();
    Object.defineProperty(e, "CustomCommandsConfig", { enumerable: !0, get: function() {
      return Nt.CustomCommandsConfig;
    } });
    var xt = /* @__PURE__ */ FR();
    Object.defineProperty(e, "DialogServiceConnector", { enumerable: !0, get: function() {
      return xt.DialogServiceConnector;
    } });
    var We = /* @__PURE__ */ BR();
    Object.defineProperty(e, "ActivityReceivedEventArgs", { enumerable: !0, get: function() {
      return We.ActivityReceivedEventArgs;
    } });
    var Ps = /* @__PURE__ */ $R();
    Object.defineProperty(e, "TurnStatusReceivedEventArgs", { enumerable: !0, get: function() {
      return Ps.TurnStatusReceivedEventArgs;
    } });
    var Gt = /* @__PURE__ */ VR();
    Object.defineProperty(e, "ServicePropertyChannel", { enumerable: !0, get: function() {
      return Gt.ServicePropertyChannel;
    } });
    var me = /* @__PURE__ */ WR();
    Object.defineProperty(e, "ProfanityOption", { enumerable: !0, get: function() {
      return me.ProfanityOption;
    } });
    var zt = /* @__PURE__ */ HR();
    Object.defineProperty(e, "BaseAudioPlayer", { enumerable: !0, get: function() {
      return zt.BaseAudioPlayer;
    } });
    var pe = /* @__PURE__ */ KR();
    Object.defineProperty(e, "ConnectionMessageEventArgs", { enumerable: !0, get: function() {
      return pe.ConnectionMessageEventArgs;
    } });
    var He = /* @__PURE__ */ dv();
    Object.defineProperty(e, "ConnectionMessage", { enumerable: !0, get: function() {
      return He.ConnectionMessage;
    } });
    var Re = /* @__PURE__ */ JR();
    Object.defineProperty(e, "VoiceProfile", { enumerable: !0, get: function() {
      return Re.VoiceProfile;
    } });
    var rt = /* @__PURE__ */ GR();
    Object.defineProperty(e, "VoiceProfileEnrollmentResult", { enumerable: !0, get: function() {
      return rt.VoiceProfileEnrollmentResult;
    } }), Object.defineProperty(e, "VoiceProfileEnrollmentCancellationDetails", { enumerable: !0, get: function() {
      return rt.VoiceProfileEnrollmentCancellationDetails;
    } });
    var N = /* @__PURE__ */ QR();
    Object.defineProperty(e, "VoiceProfileResult", { enumerable: !0, get: function() {
      return N.VoiceProfileResult;
    } }), Object.defineProperty(e, "VoiceProfileCancellationDetails", { enumerable: !0, get: function() {
      return N.VoiceProfileCancellationDetails;
    } });
    var ee = /* @__PURE__ */ YR();
    Object.defineProperty(e, "VoiceProfilePhraseResult", { enumerable: !0, get: function() {
      return ee.VoiceProfilePhraseResult;
    } });
    var Lt = /* @__PURE__ */ ZR();
    Object.defineProperty(e, "VoiceProfileClient", { enumerable: !0, get: function() {
      return Lt.VoiceProfileClient;
    } });
    var bs = /* @__PURE__ */ XR();
    Object.defineProperty(e, "SpeakerRecognizer", { enumerable: !0, get: function() {
      return bs.SpeakerRecognizer;
    } });
    var nt = /* @__PURE__ */ eP();
    Object.defineProperty(e, "SpeakerIdentificationModel", { enumerable: !0, get: function() {
      return nt.SpeakerIdentificationModel;
    } });
    var Ys = /* @__PURE__ */ tP();
    Object.defineProperty(e, "SpeakerVerificationModel", { enumerable: !0, get: function() {
      return Ys.SpeakerVerificationModel;
    } });
    var Zs = /* @__PURE__ */ rP();
    Object.defineProperty(e, "AutoDetectSourceLanguageConfig", { enumerable: !0, get: function() {
      return Zs.AutoDetectSourceLanguageConfig;
    } });
    var Xs = /* @__PURE__ */ nP();
    Object.defineProperty(e, "AutoDetectSourceLanguageResult", { enumerable: !0, get: function() {
      return Xs.AutoDetectSourceLanguageResult;
    } });
    var ws = /* @__PURE__ */ iP();
    Object.defineProperty(e, "SourceLanguageConfig", { enumerable: !0, get: function() {
      return ws.SourceLanguageConfig;
    } });
    var Qt = /* @__PURE__ */ sP();
    Object.defineProperty(e, "SpeakerRecognitionResult", { enumerable: !0, get: function() {
      return Qt.SpeakerRecognitionResult;
    } }), Object.defineProperty(e, "SpeakerRecognitionResultType", { enumerable: !0, get: function() {
      return Qt.SpeakerRecognitionResultType;
    } }), Object.defineProperty(e, "SpeakerRecognitionCancellationDetails", { enumerable: !0, get: function() {
      return Qt.SpeakerRecognitionCancellationDetails;
    } });
    var ie = /* @__PURE__ */ sc();
    Object.defineProperty(e, "Conversation", { enumerable: !0, get: function() {
      return ie.Conversation;
    } }), Object.defineProperty(e, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return ie.ConversationExpirationEventArgs;
    } }), Object.defineProperty(e, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return ie.ConversationParticipantsChangedEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return ie.ConversationTranslationCanceledEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return ie.ConversationTranslationEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return ie.ConversationTranslationResult;
    } }), Object.defineProperty(e, "ConversationTranslator", { enumerable: !0, get: function() {
      return ie.ConversationTranslator;
    } }), Object.defineProperty(e, "ConversationTranscriber", { enumerable: !0, get: function() {
      return ie.ConversationTranscriber;
    } }), Object.defineProperty(e, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return ie.ConversationTranscriptionResult;
    } }), Object.defineProperty(e, "Meeting", { enumerable: !0, get: function() {
      return ie.Meeting;
    } }), Object.defineProperty(e, "MeetingTranscriber", { enumerable: !0, get: function() {
      return ie.MeetingTranscriber;
    } }), Object.defineProperty(e, "Participant", { enumerable: !0, get: function() {
      return ie.Participant;
    } }), Object.defineProperty(e, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return ie.ParticipantChangedReason;
    } }), Object.defineProperty(e, "User", { enumerable: !0, get: function() {
      return ie.User;
    } });
    var q = /* @__PURE__ */ oc();
    Object.defineProperty(e, "Synthesizer", { enumerable: !0, get: function() {
      return q.Synthesizer;
    } });
    var W = /* @__PURE__ */ nv();
    Object.defineProperty(e, "SpeechSynthesisOutputFormat", { enumerable: !0, get: function() {
      return W.SpeechSynthesisOutputFormat;
    } });
    var U = /* @__PURE__ */ RP();
    Object.defineProperty(e, "SpeechSynthesizer", { enumerable: !0, get: function() {
      return U.SpeechSynthesizer;
    } });
    var $ = /* @__PURE__ */ PP();
    Object.defineProperty(e, "SynthesisResult", { enumerable: !0, get: function() {
      return $.SynthesisResult;
    } });
    var Ke = /* @__PURE__ */ bP();
    Object.defineProperty(e, "SpeechSynthesisResult", { enumerable: !0, get: function() {
      return Ke.SpeechSynthesisResult;
    } });
    var te = /* @__PURE__ */ wP();
    Object.defineProperty(e, "SpeechSynthesisEventArgs", { enumerable: !0, get: function() {
      return te.SpeechSynthesisEventArgs;
    } });
    var Pe = /* @__PURE__ */ EP();
    Object.defineProperty(e, "SpeechSynthesisWordBoundaryEventArgs", { enumerable: !0, get: function() {
      return Pe.SpeechSynthesisWordBoundaryEventArgs;
    } });
    var ye = /* @__PURE__ */ IP();
    Object.defineProperty(e, "SpeechSynthesisBookmarkEventArgs", { enumerable: !0, get: function() {
      return ye.SpeechSynthesisBookmarkEventArgs;
    } });
    var Yt = /* @__PURE__ */ AP();
    Object.defineProperty(e, "SpeechSynthesisVisemeEventArgs", { enumerable: !0, get: function() {
      return Yt.SpeechSynthesisVisemeEventArgs;
    } });
    var eo = /* @__PURE__ */ TP();
    Object.defineProperty(e, "SpeechSynthesisBoundaryType", { enumerable: !0, get: function() {
      return eo.SpeechSynthesisBoundaryType;
    } });
    var to = /* @__PURE__ */ _P();
    Object.defineProperty(e, "SynthesisVoicesResult", { enumerable: !0, get: function() {
      return to.SynthesisVoicesResult;
    } });
    var Zt = /* @__PURE__ */ kP();
    Object.defineProperty(e, "SynthesisVoiceGender", { enumerable: !0, get: function() {
      return Zt.SynthesisVoiceGender;
    } }), Object.defineProperty(e, "SynthesisVoiceType", { enumerable: !0, get: function() {
      return Zt.SynthesisVoiceType;
    } }), Object.defineProperty(e, "VoiceInfo", { enumerable: !0, get: function() {
      return Zt.VoiceInfo;
    } });
    var ro = /* @__PURE__ */ OP();
    Object.defineProperty(e, "SpeakerAudioDestination", { enumerable: !0, get: function() {
      return ro.SpeakerAudioDestination;
    } });
    var no = /* @__PURE__ */ MP();
    Object.defineProperty(e, "ConversationTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return no.ConversationTranscriptionCanceledEventArgs;
    } });
    var io = /* @__PURE__ */ DP();
    Object.defineProperty(e, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return io.MeetingTranscriptionCanceledEventArgs;
    } });
    var cg = /* @__PURE__ */ NP();
    Object.defineProperty(e, "PronunciationAssessmentGradingSystem", { enumerable: !0, get: function() {
      return cg.PronunciationAssessmentGradingSystem;
    } });
    var ug = /* @__PURE__ */ xP();
    Object.defineProperty(e, "PronunciationAssessmentGranularity", { enumerable: !0, get: function() {
      return ug.PronunciationAssessmentGranularity;
    } });
    var lg = /* @__PURE__ */ zP();
    Object.defineProperty(e, "PronunciationAssessmentConfig", { enumerable: !0, get: function() {
      return lg.PronunciationAssessmentConfig;
    } });
    var pg = /* @__PURE__ */ LP();
    Object.defineProperty(e, "PronunciationAssessmentResult", { enumerable: !0, get: function() {
      return pg.PronunciationAssessmentResult;
    } });
    var dg = /* @__PURE__ */ Rv();
    Object.defineProperty(e, "LanguageIdMode", { enumerable: !0, get: function() {
      return dg.LanguageIdMode;
    } });
    var hg = /* @__PURE__ */ jP();
    Object.defineProperty(e, "AvatarConfig", { enumerable: !0, get: function() {
      return hg.AvatarConfig;
    } });
    var fg = /* @__PURE__ */ qP();
    Object.defineProperty(e, "AvatarEventArgs", { enumerable: !0, get: function() {
      return fg.AvatarEventArgs;
    } });
    var vg = /* @__PURE__ */ FP();
    Object.defineProperty(e, "AvatarSynthesizer", { enumerable: !0, get: function() {
      return vg.AvatarSynthesizer;
    } });
    var pc = /* @__PURE__ */ BP();
    Object.defineProperty(e, "AvatarVideoFormat", { enumerable: !0, get: function() {
      return pc.AvatarVideoFormat;
    } }), Object.defineProperty(e, "Coordinate", { enumerable: !0, get: function() {
      return pc.Coordinate;
    } });
    var gg = /* @__PURE__ */ UP();
    Object.defineProperty(e, "AvatarWebRTCConnectionResult", { enumerable: !0, get: function() {
      return gg.AvatarWebRTCConnectionResult;
    } });
    var mg = /* @__PURE__ */ $P();
    Object.defineProperty(e, "Diagnostics", { enumerable: !0, get: function() {
      return mg.Diagnostics;
    } });
    var yg = /* @__PURE__ */ Xf();
    Object.defineProperty(e, "LogLevel", { enumerable: !0, get: function() {
      return yg.LogLevel;
    } });
  }(Do)), Do;
}
var Zp;
function VP() {
  if (Zp) return xr;
  Zp = 1, Object.defineProperty(xr, "__esModule", { value: !0 }), xr.ProxyInfo = void 0;
  const e = /* @__PURE__ */ A();
  let t = class Mv {
    constructor(s, i, a, o) {
      this.privProxyHostName = s, this.privProxyPort = i, this.privProxyUserName = a, this.privProxyPassword = o;
    }
    static fromParameters(s) {
      return new Mv(s.getProperty(e.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(s.getProperty(e.PropertyId.SpeechServiceConnection_ProxyPort), 10), s.getProperty(e.PropertyId.SpeechServiceConnection_ProxyUserName), s.getProperty(e.PropertyId.SpeechServiceConnection_ProxyPassword));
    }
    static fromRecognizerConfig(s) {
      return this.fromParameters(s.parameters);
    }
    get HostName() {
      return this.privProxyHostName;
    }
    get Port() {
      return this.privProxyPort;
    }
    get UserName() {
      return this.privProxyUserName;
    }
    get Password() {
      return this.privProxyPassword;
    }
  };
  return xr.ProxyInfo = t, xr;
}
var ui = {}, ta, Xp;
function WP() {
  if (Xp) return ta;
  Xp = 1;
  const e = /* @__PURE__ */ new Set(["json", "buffer", "string"]);
  return ta = (t) => (...r) => {
    const s = /* @__PURE__ */ new Set();
    let i, a, o, n = "";
    return r.forEach((c) => {
      if (typeof c == "string")
        if (c.toUpperCase() === c)
          if (i) {
            const u = `Can't set method to ${c}, already set to ${i}.`;
            throw new Error(u);
          } else
            i = c;
        else if (c.startsWith("http:") || c.startsWith("https:"))
          n = c;
        else if (e.has(c))
          a = c;
        else
          throw new Error(`Unknown encoding, ${c}`);
      else if (typeof c == "number")
        s.add(c);
      else if (typeof c == "object")
        if (Array.isArray(c) || c instanceof Set)
          c.forEach((u) => s.add(u));
        else {
          if (o)
            throw new Error("Cannot set headers twice.");
          o = c;
        }
      else
        throw new Error(`Unknown type: ${typeof c}`);
    }), i || (i = "GET"), s.size === 0 && s.add(200), t(s, i, a, o, n);
  }, ta;
}
var ra, ed;
function HP() {
  if (ed) return ra;
  ed = 1;
  const e = WP();
  class t extends Error {
    constructor(i, ...a) {
      super(...a), Error.captureStackTrace && Error.captureStackTrace(this, t), this.name = "StatusError", this.message = i.statusMessage, this.statusCode = i.status, this.res = i, this.json = i.json.bind(i), this.text = i.text.bind(i), this.arrayBuffer = i.arrayBuffer.bind(i);
      let o;
      Object.defineProperty(this, "responseBody", { get: () => (o || (o = this.arrayBuffer()), o) }), this.headers = {};
      for (const [c, u] of i.headers.entries())
        this.headers[c.toLowerCase()] = u;
    }
  }
  return ra = e((s, i, a, o, n) => async (c, u, l = {}) => {
    c = n + (c || "");
    let p = new URL(c);
    if (o || (o = {}), p.username && (o.Authorization = "Basic " + btoa(p.username + ":" + p.password), p = new URL(p.protocol + "//" + p.host + p.pathname + p.search)), p.protocol !== "https:" && p.protocol !== "http:")
      throw new Error(`Unknown protocol, ${p.protocol}`);
    if (u && !(u instanceof ArrayBuffer || ArrayBuffer.isView(u) || typeof u == "string"))
      if (typeof u == "object")
        u = JSON.stringify(u), o["Content-Type"] = "application/json";
      else
        throw new Error("Unknown body type.");
    l = new Headers({ ...o || {}, ...l });
    const d = await fetch(p, { method: i, headers: l, body: u });
    if (d.statusCode = d.status, !s.has(d.status))
      throw new t(d);
    return a === "json" ? d.json() : a === "buffer" ? d.arrayBuffer() : a === "string" ? d.text() : d;
  }), ra;
}
var td;
function KP() {
  return td || (td = 1, function(e) {
    var t = ui && ui.__importDefault || function(o) {
      return o && o.__esModule ? o : { default: o };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RestMessageAdapter = e.RestRequestType = void 0;
    const r = t(HP()), s = /* @__PURE__ */ D();
    var i;
    (function(o) {
      o.Get = "GET", o.Post = "POST", o.Delete = "DELETE", o.File = "file";
    })(i = e.RestRequestType || (e.RestRequestType = {}));
    let a = class {
      constructor(n) {
        if (!n)
          throw new s.ArgumentNullError("configParams");
        this.privHeaders = n.headers, this.privIgnoreCache = n.ignoreCache;
      }
      static extractHeaderValue(n, c) {
        let u = "";
        try {
          const l = c.trim().split(/[\r\n]+/), p = {};
          l.forEach((d) => {
            const h = d.split(": "), f = h.shift().toLowerCase(), g = h.join(": ");
            p[f] = g;
          }), u = p[n.toLowerCase()];
        } catch {
        }
        return u;
      }
      set options(n) {
        this.privHeaders = n.headers, this.privIgnoreCache = n.ignoreCache;
      }
      setHeaders(n, c) {
        this.privHeaders[n] = c;
      }
      request(n, c, u = {}, l = null) {
        const p = new s.Deferred(), d = n === i.File ? "POST" : n, h = (g, m = {}) => {
          const v = g;
          return {
            data: JSON.stringify(m),
            headers: JSON.stringify(g.headers),
            json: m,
            ok: g.statusCode >= 200 && g.statusCode < 300,
            status: g.statusCode,
            statusText: m.error ? m.error.message : v.statusText ? v.statusText : v.statusMessage
          };
        }, f = (g) => {
          const m = (0, r.default)(c, d, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404), v = this.queryParams(u) === "" ? "" : `?${this.queryParams(u)}`;
          m(v, g).then(async (y) => {
            if (n === i.Delete || y.statusCode === 204)
              p.resolve(h(y));
            else
              try {
                const S = await y.json();
                p.resolve(h(y, S));
              } catch {
                p.resolve(h(y));
              }
          }).catch((y) => {
            p.reject(y);
          });
        };
        return this.privIgnoreCache && (this.privHeaders["Cache-Control"] = "no-cache"), n === i.Post && l && (this.privHeaders["content-type"] = "application/json", this.privHeaders["Content-Type"] = "application/json"), f(l), p.promise;
      }
      queryParams(n = {}) {
        return Object.keys(n).map((c) => encodeURIComponent(c) + "=" + encodeURIComponent(n[c])).join("&");
      }
    };
    e.RestMessageAdapter = a;
  }(ui)), ui;
}
var li = {}, rd;
function Dv() {
  if (rd) return li;
  rd = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.RestConfigBase = void 0;
  let e = class Os {
    static get requestOptions() {
      return Os.privDefaultRequestOptions;
    }
    static get configParams() {
      return Os.privDefaultParams;
    }
    static get restErrors() {
      return Os.privRestErrors;
    }
  };
  return li.RestConfigBase = e, e.privDefaultRequestOptions = {
    headers: {
      Accept: "application/json"
    },
    ignoreCache: !1,
    timeout: 1e4
  }, e.privRestErrors = {
    authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
    authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
    invalidArgs: "Required input not found: {arg}.",
    invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
    invalidParticipantRequest: "The requested participant was not found.",
    permissionDeniedConnect: "Required credentials not found.",
    permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
    permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
    permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
    permissionDeniedStart: "Invalid operation: there is already an active conversation."
  }, e.privDefaultParams = {
    apiVersion: "api-version",
    authorization: "Authorization",
    clientAppId: "X-ClientAppId",
    contentTypeKey: "Content-Type",
    correlationId: "X-CorrelationId",
    languageCode: "language",
    nickname: "nickname",
    profanity: "profanity",
    requestId: "X-RequestId",
    roomId: "roomid",
    sessionToken: "token",
    subscriptionKey: "Ocp-Apim-Subscription-Key",
    subscriptionRegion: "Ocp-Apim-Subscription-Region",
    token: "X-CapitoToken"
  }, li;
}
var nd;
function ne() {
  return nd || (nd = 1, function(e) {
    var t = lt && lt.__createBinding || (Object.create ? function(s, i, a, o) {
      o === void 0 && (o = a), Object.defineProperty(s, o, { enumerable: !0, get: function() {
        return i[a];
      } });
    } : function(s, i, a, o) {
      o === void 0 && (o = a), s[o] = i[a];
    }), r = lt && lt.__exportStar || function(s, i) {
      for (var a in s) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, s, a);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), r(/* @__PURE__ */ GC(), e), r(/* @__PURE__ */ QC(), e), r(/* @__PURE__ */ YC(), e), r(/* @__PURE__ */ ZC(), e), r(/* @__PURE__ */ XC(), e), r(/* @__PURE__ */ eR(), e), r(/* @__PURE__ */ ev(), e), r(/* @__PURE__ */ tR(), e), r(/* @__PURE__ */ VP(), e), r(/* @__PURE__ */ KP(), e), r(/* @__PURE__ */ Dv(), e);
  }(lt)), lt;
}
var id;
function JP() {
  if (id) return _r;
  id = 1, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.IntentConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Ae(), s = /* @__PURE__ */ O(), i = /* @__PURE__ */ ue();
  let a = class extends r.ConnectionFactoryBase {
    create(n, c, u) {
      let l = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint);
      if (!l) {
        const f = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_IntentRegion), g = r.ConnectionFactoryBase.getHostSuffix(f);
        l = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + f + ".sr.speech" + g) + "/speech/recognition/interactive/cognitiveservices/v1";
      }
      const p = {
        format: "simple",
        language: n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(n, p, l);
      const d = {};
      c.token !== void 0 && c.token !== "" && (d[c.headerName] = c.token), d[i.HeaderNames.ConnectionId] = u, n.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, l);
      const h = n.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(l, p, d, new s.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(n), h, u));
    }
    getSpeechRegionFromIntentRegion(n) {
      switch (n) {
        case "West US":
        case "US West":
        case "westus":
          return "uswest";
        case "West US 2":
        case "US West 2":
        case "westus2":
          return "uswest2";
        case "South Central US":
        case "US South Central":
        case "southcentralus":
          return "ussouthcentral";
        case "West Central US":
        case "US West Central":
        case "westcentralus":
          return "uswestcentral";
        case "East US":
        case "US East":
        case "eastus":
          return "useast";
        case "East US 2":
        case "US East 2":
        case "eastus2":
          return "useast2";
        case "West Europe":
        case "Europe West":
        case "westeurope":
          return "europewest";
        case "North Europe":
        case "Europe North":
        case "northeurope":
          return "europenorth";
        case "Brazil South":
        case "South Brazil":
        case "southbrazil":
          return "brazilsouth";
        case "Australia East":
        case "East Australia":
        case "eastaustralia":
          return "australiaeast";
        case "Southeast Asia":
        case "Asia Southeast":
        case "southeastasia":
          return "asiasoutheast";
        case "East Asia":
        case "Asia East":
        case "eastasia":
          return "asiaeast";
        default:
          return n;
      }
    }
  };
  return _r.IntentConnectionFactory = a, _r;
}
var wt = {}, sd;
function GP() {
  if (sd) return wt;
  sd = 1, Object.defineProperty(wt, "__esModule", { value: !0 }), wt.VoiceProfileConnectionFactory = wt.SpeakerRecognitionConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Ae(), s = /* @__PURE__ */ O(), i = /* @__PURE__ */ ue();
  class a extends r.ConnectionFactoryBase {
    create(u, l, p, d) {
      let h = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint);
      if (!h) {
        const v = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region), y = r.ConnectionFactoryBase.getHostSuffix(v), S = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, `wss://${v}.spr-frontend.speech${y}`), C = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
        h = `${S}/speaker/ws/${this.scenarioToPath(C)}/${p}`;
      }
      const f = {
        format: "simple",
        language: u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(u, f, h);
      const g = {};
      l.token !== void 0 && l.token !== "" && (g[l.headerName] = l.token), g[i.HeaderNames.ConnectionId] = d, g[i.HeaderNames.SpIDAuthKey] = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Key), u.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, h);
      const m = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(h, f, g, new s.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), m, d));
    }
    scenarioToPath(u) {
      switch (u) {
        case "TextIndependentVerification":
        case "2":
          return "verification/text-independent";
        case "TextDependentVerification":
        case "1":
          return "verification/text-dependent";
        default:
          return "identification/text-independent";
      }
    }
  }
  let o = class extends a {
    create(u, l, p) {
      return super.create(u, l, "recognition", p);
    }
  };
  wt.SpeakerRecognitionConnectionFactory = o;
  class n extends a {
    create(u, l, p) {
      return super.create(u, l, "profile", p);
    }
  }
  return wt.VoiceProfileConnectionFactory = n, wt;
}
var na = {}, od;
function ac() {
  return od || (od = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionEndedEvent = e.RecognitionCompletionStatus = e.RecognitionStartedEvent = e.ConnectingToServiceEvent = e.ListeningStartedEvent = e.RecognitionTriggeredEvent = e.SpeechRecognitionEvent = void 0;
    const t = /* @__PURE__ */ D();
    class r extends t.PlatformEvent {
      constructor(l, p, d, h = t.EventType.Info) {
        super(l, h), this.privRequestId = p, this.privSessionId = d;
      }
      get requestId() {
        return this.privRequestId;
      }
      get sessionId() {
        return this.privSessionId;
      }
    }
    e.SpeechRecognitionEvent = r;
    class s extends r {
      constructor(l, p, d, h) {
        super("RecognitionTriggeredEvent", l, p), this.privAudioSourceId = d, this.privAudioNodeId = h;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
    }
    e.RecognitionTriggeredEvent = s;
    class i extends r {
      constructor(l, p, d, h) {
        super("ListeningStartedEvent", l, p), this.privAudioSourceId = d, this.privAudioNodeId = h;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
    }
    e.ListeningStartedEvent = i;
    class a extends r {
      constructor(l, p, d) {
        super("ConnectingToServiceEvent", l, d), this.privAuthFetchEventid = p;
      }
      get authFetchEventid() {
        return this.privAuthFetchEventid;
      }
    }
    e.ConnectingToServiceEvent = a;
    class o extends r {
      constructor(l, p, d, h, f) {
        super("RecognitionStartedEvent", l, f), this.privAudioSourceId = p, this.privAudioNodeId = d, this.privAuthFetchEventId = h;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
      get authFetchEventId() {
        return this.privAuthFetchEventId;
      }
    }
    e.RecognitionStartedEvent = o;
    var n;
    (function(u) {
      u[u.Success = 0] = "Success", u[u.AudioSourceError = 1] = "AudioSourceError", u[u.AudioSourceTimeout = 2] = "AudioSourceTimeout", u[u.AuthTokenFetchError = 3] = "AuthTokenFetchError", u[u.AuthTokenFetchTimeout = 4] = "AuthTokenFetchTimeout", u[u.UnAuthorized = 5] = "UnAuthorized", u[u.ConnectTimeout = 6] = "ConnectTimeout", u[u.ConnectError = 7] = "ConnectError", u[u.ClientRecognitionActivityTimeout = 8] = "ClientRecognitionActivityTimeout", u[u.UnknownError = 9] = "UnknownError";
    })(n = e.RecognitionCompletionStatus || (e.RecognitionCompletionStatus = {}));
    class c extends r {
      constructor(l, p, d, h, f, g, m, v) {
        super("RecognitionEndedEvent", l, f, m === n.Success ? t.EventType.Info : t.EventType.Error), this.privAudioSourceId = p, this.privAudioNodeId = d, this.privAuthFetchEventId = h, this.privStatus = m, this.privError = v, this.privServiceTag = g;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
      get authFetchEventId() {
        return this.privAuthFetchEventId;
      }
      get serviceTag() {
        return this.privServiceTag;
      }
      get status() {
        return this.privStatus;
      }
      get error() {
        return this.privError;
      }
    }
    e.RecognitionEndedEvent = c;
  }(na)), na;
}
var pi = {}, di = {}, ad;
function Ht() {
  if (ad) return di;
  ad = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.SpeechConnectionMessage = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ ue();
  class r extends e.ConnectionMessage {
    constructor(i, a, o, n, c, u, l, p) {
      if (!a)
        throw new e.ArgumentNullError("path");
      if (!o)
        throw new e.ArgumentNullError("requestId");
      const d = {};
      if (d[t.HeaderNames.Path] = a, d[t.HeaderNames.RequestId] = o, d[t.HeaderNames.RequestTimestamp] = (/* @__PURE__ */ new Date()).toISOString(), n && (d[t.HeaderNames.ContentType] = n), u && (d[t.HeaderNames.RequestStreamId] = u), l)
        for (const h in l)
          h && (d[h] = l[h]);
      p ? super(i, c, d, p) : super(i, c, d), this.privPath = a, this.privRequestId = o, this.privContentType = n, this.privStreamId = u, this.privAdditionalHeaders = l;
    }
    get path() {
      return this.privPath;
    }
    get requestId() {
      return this.privRequestId;
    }
    get contentType() {
      return this.privContentType;
    }
    get streamId() {
      return this.privStreamId;
    }
    get additionalHeaders() {
      return this.privAdditionalHeaders;
    }
    static fromConnectionMessage(i) {
      let a = null, o = null, n = null, c = null;
      const u = {};
      if (i.headers)
        for (const l in i.headers)
          l && (l.toLowerCase() === t.HeaderNames.Path.toLowerCase() ? a = i.headers[l] : l.toLowerCase() === t.HeaderNames.RequestId.toLowerCase() ? o = i.headers[l] : l.toLowerCase() === t.HeaderNames.ContentType.toLowerCase() ? n = i.headers[l] : l.toLowerCase() === t.HeaderNames.RequestStreamId.toLowerCase() ? c = i.headers[l] : u[l] = i.headers[l]);
      return new r(i.messageType, a, o, n, i.body, c, u, i.id);
    }
  }
  return di.SpeechConnectionMessage = r, di;
}
var ia = {}, cd;
function QP() {
  return cd || (cd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SegmentationMode = void 0, function(t) {
      t.Normal = "Normal", t.Disabled = "Disabled", t.Custom = "Custom", t.Semantic = "Semantic";
    }(e.SegmentationMode || (e.SegmentationMode = {}));
  }(ia)), ia;
}
var sa = {}, ud;
function YP() {
  return ud || (ud = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.None = "None", t.Synthesize = "Synthesize";
    }(e.NextAction || (e.NextAction = {}));
  }(sa)), sa;
}
var oa = {}, ld;
function ZP() {
  return ld || (ld = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Mode = void 0, function(t) {
      t.None = "None", t.Always = "Always";
    }(e.Mode || (e.Mode = {}));
  }(oa)), oa;
}
var aa = {}, pd;
function XP() {
  return pd || (pd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LanguageIdDetectionPriority = e.LanguageIdDetectionMode = void 0, function(t) {
      t.DetectAtAudioStart = "DetectAtAudioStart", t.DetectContinuous = "DetectContinuous", t.DetectSegments = "DetectSegments";
    }(e.LanguageIdDetectionMode || (e.LanguageIdDetectionMode = {})), function(t) {
      t.Auto = "Auto", t.PrioritizeLatency = "PrioritizeLatency", t.PrioritizeAccuracy = "PrioritizeAccuracy";
    }(e.LanguageIdDetectionPriority || (e.LanguageIdDetectionPriority = {}));
  }(aa)), aa;
}
var ca = {}, dd;
function eb() {
  return dd || (dd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.Recognize = "Recognize", t.None = "None";
    }(e.NextAction || (e.NextAction = {}));
  }(ca)), ca;
}
var ua = {}, hd;
function tb() {
  return hd || (hd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OnUnknownAction = void 0, function(t) {
      t.RecognizeWithDefaultLanguage = "RecognizeWithDefaultLanguage", t.None = "None";
    }(e.OnUnknownAction || (e.OnUnknownAction = {}));
  }(ua)), ua;
}
var la = {}, fd;
function rb() {
  return fd || (fd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ResultType = void 0, function(t) {
      t.Auto = "Auto", t.StableFragment = "StableFragment", t.Hypothesis = "Hypothesis", t.None = "None";
    }(e.ResultType || (e.ResultType = {}));
  }(la)), la;
}
var pa = {}, vd;
function nb() {
  return vd || (vd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PhraseResultOutputType = void 0, function(t) {
      t.Always = "Always", t.None = "None";
    }(e.PhraseResultOutputType || (e.PhraseResultOutputType = {}));
  }(pa)), pa;
}
var da = {}, gd;
function ib() {
  return gd || (gd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.None = "None", t.Translate = "Translate";
    }(e.NextAction || (e.NextAction = {}));
  }(da)), da;
}
var md;
function sb() {
  if (md) return pi;
  md = 1, Object.defineProperty(pi, "__esModule", { value: !0 }), pi.ServiceRecognizerBase = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ O(), i = /* @__PURE__ */ Ht(), a = /* @__PURE__ */ QP(), o = /* @__PURE__ */ Se(), n = /* @__PURE__ */ YP(), c = /* @__PURE__ */ ZP(), u = /* @__PURE__ */ XP(), l = /* @__PURE__ */ eb(), p = /* @__PURE__ */ tb(), d = /* @__PURE__ */ rb(), h = /* @__PURE__ */ nb(), f = /* @__PURE__ */ ib();
  let g = class us {
    constructor(v, y, S, C, R) {
      if (this.privConnectionConfigurationPromise = void 0, this.privConnectionPromise = void 0, this.privSetTimeout = setTimeout, this.privIsLiveAudio = !1, this.privAverageBytesPerMs = 0, this.privEnableSpeakerId = !1, this.privExpectContentAssessmentResponse = !1, this.recognizeOverride = void 0, this.recognizeSpeaker = void 0, this.disconnectOverride = void 0, this.receiveMessageOverride = void 0, this.sendPrePayloadJSONOverride = void 0, this.postConnectImplOverride = void 0, this.configConnectionOverride = void 0, this.handleSpeechPhraseMessage = void 0, this.handleSpeechHypothesisMessage = void 0, !v)
        throw new t.ArgumentNullError("authentication");
      if (!y)
        throw new t.ArgumentNullError("connectionFactory");
      if (!S)
        throw new t.ArgumentNullError("audioSource");
      if (!C)
        throw new t.ArgumentNullError("recognizerConfig");
      this.privEnableSpeakerId = C.isSpeakerDiarizationEnabled, this.privMustReportEndOfStream = !1, this.privAuthentication = v, this.privConnectionFactory = y, this.privAudioSource = S, this.privRecognizerConfig = C, this.privIsDisposed = !1, this.privRecognizer = R, this.privRequestSession = new s.RequestSession(this.privAudioSource.id()), this.privConnectionEvents = new t.EventSource(), this.privServiceEvents = new t.EventSource(), this.privDynamicGrammar = new s.DynamicGrammarBuilder(), this.privSpeechContext = new s.SpeechContext(this.privDynamicGrammar), this.privAgentConfig = new s.AgentConfig(), this.privRecognizerConfig.parameters.getProperty(r.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? this.privSetTimeout = t.Timeout.setTimeout : (typeof window < "u" && (this.privSetTimeout = window.setTimeout.bind(window)), typeof globalThis < "u" && (this.privSetTimeout = globalThis.setTimeout.bind(globalThis))), this.connectionEvents.attach((I) => {
        if (I.name === "ConnectionClosedEvent") {
          const E = I;
          (E.statusCode === 1003 || E.statusCode === 1007 || E.statusCode === 1002 || E.statusCode === 4e3 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) && this.cancelRecognitionLocal(r.CancellationReason.Error, E.statusCode === 1007 ? r.CancellationErrorCode.BadRequestParameters : r.CancellationErrorCode.ConnectionFailure, `${E.reason} websocket error code: ${E.statusCode}`);
        }
      }), this.privEnableSpeakerId && (this.privDiarizationSessionId = (0, t.createNoDashGuid)());
    }
    setTranslationJson() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0);
      if (v !== void 0) {
        const y = v.split(","), S = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0), C = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationCategoryId, void 0), R = S !== void 0 ? n.NextAction.Synthesize : n.NextAction.None;
        if (this.privSpeechContext.getContext().translation = {
          onPassthrough: { action: R },
          onSuccess: { action: R },
          output: {
            includePassThroughResults: !0,
            interimResults: { mode: c.Mode.Always }
          },
          targetLanguages: y
        }, C !== void 0 && (this.privSpeechContext.getContext().translation.category = C), S !== void 0) {
          const I = {};
          for (const E of y)
            I[E] = S;
          this.privSpeechContext.getContext().synthesis = {
            defaultVoices: I
          };
        }
        const w = this.privSpeechContext.getContext().phraseDetection || {};
        w.onSuccess = { action: f.NextAction.Translate }, w.onInterim = { action: f.NextAction.Translate }, this.privSpeechContext.getContext().phraseDetection = w;
      }
    }
    setSpeechSegmentationTimeoutJson() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationSilenceTimeoutMs, void 0), y = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationMaximumTimeMs, void 0), S = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationStrategy, void 0), C = {
        mode: a.SegmentationMode.Normal
      };
      let R = !1;
      if (S !== void 0) {
        R = !0;
        let w = a.SegmentationMode.Normal;
        switch (S.toLowerCase()) {
          case "default":
            break;
          case "time":
            w = a.SegmentationMode.Custom;
            break;
          case "semantic":
            w = a.SegmentationMode.Semantic;
            break;
        }
        C.mode = w;
      }
      if (v !== void 0) {
        R = !0;
        const w = parseInt(v, 10);
        C.mode = a.SegmentationMode.Custom, C.segmentationSilenceTimeoutMs = w;
      }
      if (y !== void 0) {
        R = !0;
        const w = parseInt(y, 10);
        C.mode = a.SegmentationMode.Custom, C.segmentationForcedTimeoutMs = w;
      }
      if (R) {
        const w = this.privSpeechContext.getContext().phraseDetection || {};
        switch (w.mode = this.recognitionMode, this.recognitionMode) {
          case o.RecognitionMode.Conversation:
            w.conversation = w.conversation ?? { segmentation: {} }, w.conversation.segmentation = C;
            break;
          case o.RecognitionMode.Interactive:
            w.interactive = w.interactive ?? { segmentation: {} }, w.interactive.segmentation = C;
            break;
          case o.RecognitionMode.Dictation:
            w.dictation = w.dictation ?? {}, w.dictation.segmentation = C;
            break;
        }
        this.privSpeechContext.getContext().phraseDetection = w;
      }
    }
    setLanguageIdJson() {
      const v = this.privSpeechContext.getContext().phraseDetection || {};
      if (this.privRecognizerConfig.autoDetectSourceLanguages !== void 0) {
        const y = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
        y.length === 1 && y[0] === s.AutoDetectSourceLanguagesOpenRangeOptionName && (y[0] = "UND");
        let S;
        this.privRecognizerConfig.languageIdMode === "Continuous" ? S = u.LanguageIdDetectionMode.DetectContinuous : S = u.LanguageIdDetectionMode.DetectAtAudioStart, this.privSpeechContext.getContext().languageId = {
          languages: y,
          mode: S,
          onSuccess: { action: l.NextAction.Recognize },
          onUnknown: { action: p.OnUnknownAction.None },
          priority: u.LanguageIdDetectionPriority.PrioritizeLatency
        }, this.privSpeechContext.getContext().phraseOutput = {
          interimResults: {
            resultType: d.ResultType.Auto
          },
          phraseResults: {
            resultType: h.PhraseResultOutputType.Always
          }
        };
        const C = this.privRecognizerConfig.sourceLanguageModels;
        C !== void 0 && (v.customModels = C, v.onInterim = { action: f.NextAction.None }, v.onSuccess = { action: f.NextAction.None });
      }
      this.privSpeechContext.getContext().phraseDetection = v;
    }
    setOutputDetailLevelJson() {
      this.privEnableSpeakerId && (this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true" ? this.privSpeechContext.setWordLevelTimings() : this.privRecognizerConfig.parameters.getProperty(s.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase() === r.OutputFormat[r.OutputFormat.Detailed].toLocaleLowerCase() && this.privSpeechContext.setDetailedOutputFormat());
    }
    get isSpeakerDiarizationEnabled() {
      return this.privEnableSpeakerId;
    }
    get audioSource() {
      return this.privAudioSource;
    }
    get speechContext() {
      return this.privSpeechContext;
    }
    get dynamicGrammar() {
      return this.privDynamicGrammar;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    set conversationTranslatorToken(v) {
      this.privRecognizerConfig.parameters.setProperty(r.PropertyId.ConversationTranslator_Token, v);
    }
    set voiceProfileType(v) {
      this.privRecognizerConfig.parameters.setProperty(r.PropertyId.SpeechServiceConnection_SpeakerIdMode, v);
    }
    set authentication(v) {
      this.privAuthentication = v;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(v) {
      if (this.privIsDisposed = !0, this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose(v);
        } catch {
          return;
        }
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    get recognitionMode() {
      return this.privRecognizerConfig.recognitionMode;
    }
    async recognize(v, y, S) {
      if (this.recognizeOverride !== void 0) {
        await this.recognizeOverride(v, y, S);
        return;
      }
      if (this.privConnectionConfigurationPromise = void 0, this.privRecognizerConfig.recognitionMode = v, this.privRecognizerConfig.recognitionEndpointVersion === "2") {
        const E = this.privSpeechContext.getContext().phraseDetection || {};
        E.mode = v, this.privSpeechContext.getContext().phraseDetection = E;
      }
      this.setLanguageIdJson(), this.setTranslationJson(), this.privRecognizerConfig.autoDetectSourceLanguages !== void 0 && this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 && this.setupTranslationWithLanguageId(), this.setSpeechSegmentationTimeoutJson(), this.setOutputDetailLevelJson(), this.privSuccessCallback = y, this.privErrorCallback = S, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
      const C = this.connectImpl();
      let R;
      try {
        const E = await this.audioSource.attach(this.privRequestSession.audioNodeId), T = await this.audioSource.format, b = await this.audioSource.deviceInfo;
        this.privIsLiveAudio = b.type && b.type === s.type.Microphones, R = new e.ReplayableAudioNode(E, T.avgBytesPerSec), await this.privRequestSession.onAudioSourceAttachCompleted(R, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: b };
      } catch (E) {
        throw await this.privRequestSession.onStopRecognizing(), E;
      }
      try {
        await C;
      } catch (E) {
        await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, E);
        return;
      }
      const w = new r.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, w), this.receiveMessage(), this.sendAudio(R).catch(async (E) => {
        await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, E);
      });
    }
    async stopRecognizing() {
      if (this.privRequestSession.isRecognizing)
        try {
          await this.audioSource.turnOff(), await this.sendFinalAudio(), await this.privRequestSession.onStopRecognizing(), await this.privRequestSession.turnCompletionPromise;
        } finally {
          await this.privRequestSession.dispose();
        }
    }
    async connect() {
      return await this.connectImpl(), Promise.resolve();
    }
    connectAsync(v, y) {
      this.connectImpl().then(() => {
        try {
          v && v();
        } catch (S) {
          y && y(S);
        }
      }, (S) => {
        try {
          y && y(S);
        } catch {
        }
      });
    }
    async disconnect() {
      if (await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.NoError, "Disconnecting"), this.disconnectOverride !== void 0 && await this.disconnectOverride(), this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose();
        } catch {
        }
      this.privConnectionPromise = void 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendMessage(v) {
    }
    async sendNetworkMessage(v, y) {
      const S = typeof y == "string" ? t.MessageType.Text : t.MessageType.Binary, C = typeof y == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new i.SpeechConnectionMessage(S, v, this.privRequestSession.requestId, C, y));
    }
    set activityTemplate(v) {
      this.privActivityTemplate = v;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set expectContentAssessmentResponse(v) {
      this.privExpectContentAssessmentResponse = v;
    }
    async sendTelemetryData() {
      const v = this.privRequestSession.getTelemetry();
      if (us.telemetryDataEnabled !== !0 || this.privIsDisposed || v === null)
        return;
      if (us.telemetryData)
        try {
          us.telemetryData(v);
        } catch {
        }
      await (await this.fetchConnection()).send(new i.SpeechConnectionMessage(t.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", v));
    }
    // Cancels recognition.
    async cancelRecognitionLocal(v, y, S) {
      this.privRequestSession.isRecognizing && (await this.privRequestSession.onStopRecognizing(), this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, v, y, S));
    }
    async receiveMessage() {
      try {
        if (this.privIsDisposed)
          return;
        let v = await this.fetchConnection();
        const y = await v.read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (!y)
          return this.receiveMessage();
        this.privServiceHasSentMessage = !0;
        const S = i.SpeechConnectionMessage.fromConnectionMessage(y);
        if (S.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase())
          switch (S.path.toLowerCase()) {
            case "turn.start":
              this.privMustReportEndOfStream = !0, this.privRequestSession.onServiceTurnStartResponse();
              break;
            case "speech.startdetected":
              const C = s.SpeechDetected.fromJSON(S.textBody, this.privRequestSession.currentTurnAudioOffset), R = new r.RecognitionEventArgs(C.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, R);
              break;
            case "speech.enddetected":
              let w;
              S.textBody.length > 0 ? w = S.textBody : w = "{ Offset: 0 }";
              const I = s.SpeechDetected.fromJSON(w, this.privRequestSession.currentTurnAudioOffset), E = new r.RecognitionEventArgs(I.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, E);
              break;
            case "turn.end":
              await this.sendTelemetryData(), this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream && (this.privMustReportEndOfStream = !1, await this.cancelRecognitionLocal(r.CancellationReason.EndOfStream, r.CancellationErrorCode.NoError, void 0));
              const T = new r.SessionEventArgs(this.privRequestSession.sessionId);
              if (await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition), !this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, T);
                return;
              } else
                v = await this.fetchConnection(), await this.sendPrePayloadJSON(v);
              break;
            default:
              await this.processTypeSpecificMessages(S) || this.privServiceEvents && this.serviceEvents.onEvent(new t.ServiceEvent(S.path.toLowerCase(), S.textBody));
          }
        return this.receiveMessage();
      } catch {
        return null;
      }
    }
    updateSpeakerDiarizationAudioOffset() {
      const v = this.privRequestSession.recognitionBytesSent, y = this.privAverageBytesPerMs !== 0 ? v / this.privAverageBytesPerMs : 0;
      this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(y);
    }
    sendSpeechContext(v, y) {
      this.privEnableSpeakerId && this.updateSpeakerDiarizationAudioOffset();
      const S = this.speechContext.toJSON();
      if (y && this.privRequestSession.onSpeechContext(), S)
        return v.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", S));
    }
    setupTranslationWithLanguageId() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0), y = this.privRecognizerConfig.autoDetectSourceLanguages !== void 0;
      if (v !== void 0 && y) {
        this.privSpeechContext.getContext().phraseOutput = {
          interimResults: {
            resultType: d.ResultType.None
          },
          phraseResults: {
            resultType: h.PhraseResultOutputType.None
          }
        };
        const S = this.privSpeechContext.getContext().translation;
        if (S) {
          const C = this.privRecognizerConfig.sourceLanguageModels;
          if (C !== void 0 && C.length > 0) {
            const w = this.privSpeechContext.getContext().phraseDetection || {};
            w.customModels = C, this.privSpeechContext.getContext().phraseDetection = w;
          }
          this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && (S.onSuccess = { action: n.NextAction.Synthesize }, S.onPassthrough = { action: n.NextAction.Synthesize });
        }
      }
    }
    noOp() {
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendPrePayloadJSON(v, y = !0) {
      if (this.sendPrePayloadJSONOverride !== void 0)
        return this.sendPrePayloadJSONOverride(v);
      await this.sendSpeechContext(v, y), await this.sendWaveHeader(v);
    }
    async sendWaveHeader(v) {
      const y = await this.audioSource.format;
      return v.send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", y.header));
    }
    // Establishes a websocket connection to the end point.
    connectImpl() {
      return this.privConnectionPromise !== void 0 ? this.privConnectionPromise.then((v) => v.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl())) : (this.privConnectionPromise = this.retryableConnect(), this.privConnectionPromise.catch(() => {
      }), this.postConnectImplOverride !== void 0 ? this.postConnectImplOverride(this.privConnectionPromise) : this.privConnectionPromise);
    }
    sendSpeechServiceConfig(v, y, S) {
      if (y.onSpeechContext(), us.telemetryDataEnabled !== !0) {
        const R = {
          context: {
            system: JSON.parse(S).context.system
          }
        };
        S = JSON.stringify(R);
      }
      if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
        const C = JSON.parse(S);
        C.context.DisableReferenceChannel = "True", C.context.MicSpec = "1_0_0", S = JSON.stringify(C);
      }
      if (S)
        return v.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speech.config", y.requestId, "application/json", S));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((v) => v.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    async sendAudio(v) {
      const y = await this.audioSource.format;
      this.privAverageBytesPerMs = y.avgBytesPerSec / 1e3;
      let S = Date.now();
      const C = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000"), R = y.avgBytesPerSec / 1e3 * parseInt(C, 10), w = this.privRequestSession.recogNumber, I = async () => {
        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === w) {
          const E = await this.fetchConnection(), T = await v.read();
          if (this.privRequestSession.isSpeechEnded)
            return;
          let b, _;
          if (!T || T.isEnd ? (b = null, _ = 0) : (b = T.buffer, this.privRequestSession.onAudioSent(b.byteLength), R >= this.privRequestSession.bytesSent ? _ = 0 : _ = Math.max(0, S - Date.now())), _ !== 0 && await this.delay(_), b !== null && (S = Date.now() + b.byteLength * 1e3 / (y.avgBytesPerSec * 2)), !this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === w)
            if (E.send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, null, b)).catch(() => {
              this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {
              });
            }), T?.isEnd)
              this.privIsLiveAudio || this.privRequestSession.onSpeechEnded();
            else
              return I();
        }
      };
      return I();
    }
    async retryableConnect() {
      let v = !1;
      this.privAuthFetchEventId = (0, t.createNoDashGuid)();
      const y = this.privRequestSession.sessionId;
      this.privConnectionId = y !== void 0 ? y : (0, t.createNoDashGuid)(), this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
      let S = 0, C = "";
      for (; this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount; ) {
        this.privRequestSession.onRetryConnection();
        const w = await (v ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId));
        await this.privRequestSession.onAuthCompleted(!1);
        const I = await this.privConnectionFactory.create(this.privRecognizerConfig, w, this.privConnectionId);
        this.privRequestSession.listenForServiceTelemetry(I.events), I.events.attach((T) => {
          this.connectionEvents.onEvent(T);
        });
        const E = await I.open();
        if (E.statusCode === 200)
          return await this.privRequestSession.onConnectionEstablishCompleted(E.statusCode), Promise.resolve(I);
        E.statusCode === 1006 && (v = !0), S = E.statusCode, C = E.reason;
      }
      return await this.privRequestSession.onConnectionEstablishCompleted(S, C), Promise.reject(`Unable to contact server. StatusCode: ${S}, ${this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${C}`);
    }
    delay(v) {
      return new Promise((y) => this.privSetTimeout(y, v));
    }
    writeBufferToConsole(v) {
      let y = "Buffer Size: ";
      if (v === null)
        y += "null";
      else {
        const S = new Uint8Array(v);
        y += `${v.byteLength}\r
`;
        for (let C = 0; C < v.byteLength; C++)
          y += S[C].toString(16).padStart(2, "0") + " ", (C + 1) % 16 === 0 && (console.info(y), y = "");
      }
      console.info(y);
    }
    async sendFinalAudio() {
      await (await this.fetchConnection()).send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const v = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(v) : (await this.sendSpeechServiceConfig(v, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendPrePayloadJSON(v, !1), v);
    }
  };
  return pi.ServiceRecognizerBase = g, g.telemetryDataEnabled = !0, pi;
}
var hi = {}, yd;
function ob() {
  if (yd) return hi;
  yd = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.ConversationServiceRecognizer = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ O();
  let r = class extends t.ServiceRecognizerBase {
    constructor(i, a, o, n, c) {
      super(i, a, o, n, c), this.handleSpeechPhraseMessage = async (u) => this.handleSpeechPhrase(u), this.handleSpeechHypothesisMessage = (u) => this.handleSpeechHypothesis(u);
    }
    processTypeSpecificMessages(i) {
    }
    handleRecognizedCallback(i, a, o) {
    }
    handleRecognizingCallback(i, a, o) {
    }
    async processSpeechMessages(i) {
      let a = !1;
      switch (i.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          this.handleSpeechHypothesisMessage && this.handleSpeechHypothesisMessage(i.textBody), a = !0;
          break;
        case "speech.phrase":
          this.handleSpeechPhraseMessage && await this.handleSpeechPhraseMessage(i.textBody), a = !0;
          break;
      }
      return a;
    }
    cancelRecognition(i, a, o, n, c) {
    }
    async handleSpeechPhrase(i) {
      const a = t.SimpleSpeechPhrase.fromJSON(i, this.privRequestSession.currentTurnAudioOffset), o = t.EnumTranslation.implTranslateRecognitionResult(a.RecognitionStatus);
      let n;
      const c = new e.PropertyCollection();
      if (c.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, i), this.privRequestSession.onPhraseRecognized(a.Offset + a.Duration), e.ResultReason.Canceled === o) {
        const u = t.EnumTranslation.implTranslateCancelResult(a.RecognitionStatus), l = t.EnumTranslation.implTranslateCancelErrorCode(a.RecognitionStatus);
        await this.cancelRecognitionLocal(u, l, t.EnumTranslation.implTranslateErrorDetails(l));
      } else if (a.RecognitionStatus !== t.RecognitionStatus.EndOfDictation) {
        if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
          n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, o, a.DisplayText, a.Duration, a.Offset, a.Language, a.LanguageDetectionConfidence, a.SpeakerId, void 0, a.asJson(), c);
        else {
          const u = t.DetailedSpeechPhrase.fromJSON(i, this.privRequestSession.currentTurnAudioOffset);
          n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, o, u.Text, u.Duration, u.Offset, u.Language, u.LanguageDetectionConfidence, u.SpeakerId, void 0, u.asJson(), c);
        }
        this.handleRecognizedCallback(n, n.offset, this.privRequestSession.sessionId);
      }
    }
    handleSpeechHypothesis(i) {
      const a = t.SpeechHypothesis.fromJSON(i, this.privRequestSession.currentTurnAudioOffset), o = new e.PropertyCollection();
      o.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, i);
      const n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, e.ResultReason.RecognizingSpeech, a.Text, a.Duration, a.Offset, a.Language, a.LanguageDetectionConfidence, a.SpeakerId, void 0, a.asJson(), o);
      this.privRequestSession.onHypothesis(a.Offset), this.handleRecognizingCallback(n, a.Duration, this.privRequestSession.sessionId);
    }
  };
  return hi.ConversationServiceRecognizer = r, hi;
}
var ha = {}, Sd;
function ab() {
  return Sd || (Sd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognizerConfig = e.SpeechResultFormat = void 0;
    const t = /* @__PURE__ */ A(), r = /* @__PURE__ */ O(), s = /* @__PURE__ */ Se();
    (function(a) {
      a[a.Simple = 0] = "Simple", a[a.Detailed = 1] = "Detailed";
    })(e.SpeechResultFormat || (e.SpeechResultFormat = {}));
    class i {
      constructor(o, n) {
        this.privSpeechServiceConfig = o || new r.SpeechServiceConfig(new r.Context(null)), this.privParameters = n, this.privMaxRetryCount = parseInt(n.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10), this.privLanguageIdMode = n.getProperty(t.PropertyId.SpeechServiceConnection_LanguageIdMode, void 0), this.privEnableSpeakerId = !1;
      }
      get parameters() {
        return this.privParameters;
      }
      get recognitionMode() {
        return this.privRecognitionMode;
      }
      set recognitionMode(o) {
        this.privRecognitionMode = o, this.privRecognitionActivityTimeout = o === s.RecognitionMode.Interactive ? 8e3 : 25e3, this.privSpeechServiceConfig.Recognition = s.RecognitionMode[o];
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
      get recognitionActivityTimeout() {
        return this.privRecognitionActivityTimeout;
      }
      get isContinuousRecognition() {
        return this.privRecognitionMode !== s.RecognitionMode.Interactive;
      }
      get languageIdMode() {
        return this.privLanguageIdMode;
      }
      get autoDetectSourceLanguages() {
        return this.parameters.getProperty(t.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0);
      }
      get recognitionEndpointVersion() {
        return this.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
      }
      set recognitionEndpointVersion(o) {
        this.parameters.setProperty(t.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, o);
      }
      get sourceLanguageModels() {
        const o = [];
        let n = !1;
        if (this.autoDetectSourceLanguages !== void 0)
          for (const c of this.autoDetectSourceLanguages.split(",")) {
            const u = c + t.PropertyId.SpeechServiceConnection_EndpointId.toString(), l = this.parameters.getProperty(u, void 0);
            l !== void 0 ? (o.push({ language: c, endpoint: l }), n = !0) : o.push({ language: c, endpoint: "" });
          }
        return n ? o : void 0;
      }
      get maxRetryCount() {
        return this.privMaxRetryCount;
      }
      get isSpeakerDiarizationEnabled() {
        return this.privEnableSpeakerId;
      }
      set isSpeakerDiarizationEnabled(o) {
        this.privEnableSpeakerId = o;
      }
    }
    e.RecognizerConfig = i;
  }(ha)), ha;
}
var fa = {}, Cd;
function cb() {
  return Cd || (Cd = 1, Object.defineProperty(fa, "__esModule", { value: !0 })), fa;
}
var fi = {}, Rd;
function ub() {
  if (Rd) return fi;
  Rd = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.WebsocketMessageFormatter = void 0;
  const e = /* @__PURE__ */ D(), t = `\r
`;
  let r = class {
    toConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const o = i.textContent;
          let n = {}, c = null;
          if (o) {
            const u = o.split(`\r
\r
`);
            u && u.length > 0 && (n = this.parseHeaders(u[0]), u.length > 1 && (c = u[1]));
          }
          a.resolve(new e.ConnectionMessage(i.messageType, c, n, i.id));
        } else if (i.messageType === e.MessageType.Binary) {
          const o = i.binaryContent;
          let n = {}, c = null;
          if (!o || o.byteLength < 2)
            throw new Error("Invalid binary message format. Header length missing.");
          const u = new DataView(o), l = u.getInt16(0);
          if (o.byteLength < l + 2)
            throw new Error("Invalid binary message format. Header content missing.");
          let p = "";
          for (let d = 0; d < l; d++)
            p += String.fromCharCode(u.getInt8(d + 2));
          n = this.parseHeaders(p), o.byteLength > l + 2 && (c = o.slice(2 + l)), a.resolve(new e.ConnectionMessage(i.messageType, c, n, i.id));
        }
      } catch (o) {
        a.reject(`Error formatting the message. Error: ${o}`);
      }
      return a.promise;
    }
    fromConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const o = `${this.makeHeaders(i)}${t}${i.textBody ? i.textBody : ""}`;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Text, o, i.id));
        } else if (i.messageType === e.MessageType.Binary) {
          const o = this.makeHeaders(i), n = i.binaryBody, c = this.stringToArrayBuffer(o), u = new Int8Array(c), l = u.byteLength, p = new Int8Array(2 + l + (n ? n.byteLength : 0));
          if (p[0] = l >> 8 & 255, p[1] = l & 255, p.set(u, 2), n) {
            const h = new Int8Array(n);
            p.set(h, 2 + l);
          }
          const d = p.buffer;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Binary, d, i.id));
        }
      } catch (o) {
        a.reject(`Error formatting the message. ${o}`);
      }
      return a.promise;
    }
    makeHeaders(i) {
      let a = "";
      if (i.headers)
        for (const o in i.headers)
          o && (a += `${o}: ${i.headers[o]}${t}`);
      return a;
    }
    parseHeaders(i) {
      const a = {};
      if (i) {
        const o = i.match(/[^\r\n]+/g);
        if (a) {
          for (const n of o)
            if (n) {
              const c = n.indexOf(":"), u = c > 0 ? n.substr(0, c).trim().toLowerCase() : n, l = c > 0 && n.length > c + 1 ? n.substr(c + 1).trim() : "";
              a[u] = l;
            }
        }
      }
      return a;
    }
    stringToArrayBuffer(i) {
      const a = new ArrayBuffer(i.length), o = new DataView(a);
      for (let n = 0; n < i.length; n++)
        o.setUint8(n, i.charCodeAt(n));
      return a;
    }
  };
  return fi.WebsocketMessageFormatter = r, fi;
}
var vi = {}, Pd;
function lb() {
  if (Pd) return vi;
  Pd = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.SpeechConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ Ae(), i = /* @__PURE__ */ O(), a = /* @__PURE__ */ ue(), o = /* @__PURE__ */ Xe(), n = /* @__PURE__ */ Se();
  let c = class extends s.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1", this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1", this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1", this.universalUri = "/stt/speech/universal/v";
    }
    async create(l, p, d) {
      let h = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region, void 0), g = s.ConnectionFactoryBase.getHostSuffix(f), m = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://" + f + ".stt.speech" + g), v = {}, y = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId, void 0), S = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (y ? (!h || h.search(o.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (v[o.QueryParameterNames.CustomSpeechDeploymentId] = y) : S && (!h || h.search(o.QueryParameterNames.Language) === -1) && (v[o.QueryParameterNames.Language] = S), (!h || h.search(o.QueryParameterNames.Format) === -1) && (v[o.QueryParameterNames.Format] = l.parameters.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase()), l.autoDetectSourceLanguages !== void 0 && (v[o.QueryParameterNames.EnableLanguageId] = "true"), this.setCommonUrlParams(l, v, h), h) {
        const E = new URL(h), T = E.pathname;
        (T === "" || T === "/") && (E.pathname = this.universalUri + l.recognitionEndpointVersion, h = await s.ConnectionFactoryBase.getRedirectUrlFromEndpoint(E.toString()));
      }
      if (!h)
        switch (l.recognitionMode) {
          case n.RecognitionMode.Conversation:
            l.parameters.getProperty(t.ForceDictationPropertyName, "false") === "true" ? h = m + this.dictationRelativeUri : l.recognitionEndpointVersion !== void 0 && parseInt(l.recognitionEndpointVersion, 10) > 1 ? h = `${m}${this.universalUri}${l.recognitionEndpointVersion}` : h = m + this.conversationRelativeUri;
            break;
          case n.RecognitionMode.Dictation:
            h = m + this.dictationRelativeUri;
            break;
          default:
            l.recognitionEndpointVersion !== void 0 && parseInt(l.recognitionEndpointVersion, 10) > 1 ? h = `${m}${this.universalUri}${l.recognitionEndpointVersion}` : h = m + this.interactiveRelativeUri;
            break;
        }
      const C = {};
      p.token !== void 0 && p.token !== "" && (C[p.headerName] = p.token), C[a.HeaderNames.ConnectionId] = d, C.connectionId = d;
      const R = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", w = new e.WebsocketConnection(h, v, C, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), R, d), I = w.uri;
      return l.parameters.setProperty(r.PropertyId.SpeechServiceConnection_Url, I), w;
    }
  };
  return vi.SpeechConnectionFactory = c, vi;
}
var gi = {}, bd;
function pb() {
  if (bd) return gi;
  bd = 1, Object.defineProperty(gi, "__esModule", { value: !0 }), gi.ConversationTranscriberConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ O(), s = /* @__PURE__ */ Ae(), i = /* @__PURE__ */ O(), a = /* @__PURE__ */ ue(), o = /* @__PURE__ */ Xe();
  let n = class extends s.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/stt/speech/universal/v2";
    }
    async create(u, l, p) {
      let d = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, void 0), f = s.ConnectionFactoryBase.getHostSuffix(h), g = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + h + ".stt.speech" + f), m = {}, v = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), y = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (v ? (!d || d.search(o.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (m[o.QueryParameterNames.CustomSpeechDeploymentId] = v) : y && (!d || d.search(o.QueryParameterNames.Language) === -1) && (m[o.QueryParameterNames.Language] = y), u.autoDetectSourceLanguages !== void 0 && (m[o.QueryParameterNames.EnableLanguageId] = "true"), this.setV2UrlParams(u, m, d), d) {
        const I = new URL(d), E = I.pathname;
        (E === "" || E === "/") && (I.pathname = this.universalUri, d = await s.ConnectionFactoryBase.getRedirectUrlFromEndpoint(I.toString()));
      }
      d || (d = `${g}${this.universalUri}`);
      const S = {};
      l.token !== void 0 && l.token !== "" && (S[l.headerName] = l.token), S[a.HeaderNames.ConnectionId] = p;
      const C = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", R = new e.WebsocketConnection(d, m, S, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), C, p), w = R.uri;
      return u.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, w), R;
    }
    setV2UrlParams(u, l, p) {
      (/* @__PURE__ */ new Map([
        [t.PropertyId.Speech_SegmentationSilenceTimeoutMs, o.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceConnection_EnableAudioLogging, o.QueryParameterNames.EnableAudioLogging],
        [t.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, o.QueryParameterNames.EndSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, o.QueryParameterNames.InitialSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceResponse_PostProcessingOption, o.QueryParameterNames.Postprocessing],
        [t.PropertyId.SpeechServiceResponse_ProfanityOption, o.QueryParameterNames.Profanity],
        [t.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, o.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((f, g) => {
        this.setUrlParameter(g, f, u, l, p);
      });
      const h = JSON.parse(u.parameters.getProperty(r.ServicePropertiesPropertyName, "{}"));
      Object.keys(h).forEach((f) => {
        l[f] = h[f];
      });
    }
  };
  return gi.ConversationTranscriberConnectionFactory = n, gi;
}
var mi = {}, wd;
function db() {
  if (wd) return mi;
  wd = 1, Object.defineProperty(mi, "__esModule", { value: !0 }), mi.TranscriberConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Ae(), s = /* @__PURE__ */ O(), i = /* @__PURE__ */ ue(), a = /* @__PURE__ */ Xe();
  let o = class extends r.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
    }
    create(c, u, l) {
      let p = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const d = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, "centralus"), h = r.ConnectionFactoryBase.getHostSuffix(d), f = "wss://transcribe." + d + ".cts.speech" + h + this.multiaudioRelativeUri, g = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, f), m = {};
      this.setQueryParams(m, c, p), p || (p = g);
      const v = {};
      u.token !== void 0 && u.token !== "" && (v[u.headerName] = u.token), v[i.HeaderNames.ConnectionId] = l, c.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, p);
      const y = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(p, m, v, new s.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(c), y, l));
    }
    setQueryParams(c, u, l) {
      const p = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), d = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      p && !(a.QueryParameterNames.CustomSpeechDeploymentId in c) && (c[a.QueryParameterNames.CustomSpeechDeploymentId] = p), d && !(a.QueryParameterNames.Language in c) && (c[a.QueryParameterNames.Language] = d);
      const h = u.parameters.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true", f = u.parameters.getProperty(s.OutputFormatPropertyName, t.OutputFormat[t.OutputFormat.Simple]) !== t.OutputFormat[t.OutputFormat.Simple];
      (h || f) && (c[a.QueryParameterNames.Format] = t.OutputFormat[t.OutputFormat.Detailed].toLowerCase()), this.setCommonUrlParams(u, c, l);
    }
  };
  return mi.TranscriberConnectionFactory = o, mi;
}
var yi = {}, Ed;
function hb() {
  if (Ed) return yi;
  Ed = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.TranslationConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ wv(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ Ae(), i = /* @__PURE__ */ O(), a = /* @__PURE__ */ ue(), o = /* @__PURE__ */ Xe(), n = /* @__PURE__ */ Se();
  let c = class extends s.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/stt/speech/universal/v2", this.translationV1Uri = "/speech/translation/cognitiveservices/v1";
    }
    async create(l, p, d) {
      let h = this.getEndpointUrl(l);
      const f = {};
      if (this.setQueryParams(f, l, h), h) {
        const y = new URL(h), S = y.pathname;
        (S === "" || S === "/") && (y.pathname = this.universalUri, h = await s.ConnectionFactoryBase.getRedirectUrlFromEndpoint(y.toString()));
      }
      const g = {};
      p.token !== void 0 && p.token !== "" && (g[p.headerName] = p.token), g[a.HeaderNames.ConnectionId] = d, l.parameters.setProperty(r.PropertyId.SpeechServiceConnection_Url, h);
      const m = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new e.WebsocketConnection(h, f, g, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), m, d);
    }
    getEndpointUrl(l, p) {
      const d = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region), h = s.ConnectionFactoryBase.getHostSuffix(d);
      let f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      return f ? p === !0 ? f : t.StringUtils.formatString(f, { region: d }) : (l.parameters.getProperty("SPEECH-ForceV1Endpoint", "false") === "true" ? f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + h) + this.translationV1Uri : f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + h) + this.universalUri, p === !0 ? f : t.StringUtils.formatString(f, { region: d }));
    }
    setQueryParams(l, p, d) {
      l.from = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), l.to = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages), l.scenario = p.recognitionMode === n.RecognitionMode.Interactive ? "interactive" : p.recognitionMode === n.RecognitionMode.Conversation ? "conversation" : "", this.setCommonUrlParams(p, l, d), this.setUrlParameter(r.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, o.QueryParameterNames.StableTranslation, p, l, d);
      const h = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
      h !== void 0 && (l.voice = h, l.features = "requireVoice");
    }
  };
  return yi.TranslationConnectionFactory = c, yi;
}
var Si = {}, Id;
function fb() {
  if (Id) return Si;
  Id = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.EnumTranslation = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ O();
  let r = class {
    static implTranslateRecognitionResult(i, a = !1) {
      let o = e.ResultReason.Canceled;
      switch (i) {
        case t.RecognitionStatus.Success:
          o = e.ResultReason.RecognizedSpeech;
          break;
        case t.RecognitionStatus.EndOfDictation:
          o = a ? e.ResultReason.RecognizedSpeech : e.ResultReason.NoMatch;
          break;
        case t.RecognitionStatus.NoMatch:
        case t.RecognitionStatus.InitialSilenceTimeout:
        case t.RecognitionStatus.BabbleTimeout:
          o = e.ResultReason.NoMatch;
          break;
        case t.RecognitionStatus.Error:
        case t.RecognitionStatus.BadRequest:
        case t.RecognitionStatus.Forbidden:
        default:
          o = e.ResultReason.Canceled;
          break;
      }
      return o;
    }
    static implTranslateCancelResult(i) {
      let a = e.CancellationReason.EndOfStream;
      switch (i) {
        case t.RecognitionStatus.Success:
        case t.RecognitionStatus.EndOfDictation:
        case t.RecognitionStatus.NoMatch:
          a = e.CancellationReason.EndOfStream;
          break;
        case t.RecognitionStatus.InitialSilenceTimeout:
        case t.RecognitionStatus.BabbleTimeout:
        case t.RecognitionStatus.Error:
        case t.RecognitionStatus.BadRequest:
        case t.RecognitionStatus.Forbidden:
        default:
          a = e.CancellationReason.Error;
          break;
      }
      return a;
    }
    static implTranslateCancelErrorCode(i) {
      let a = e.CancellationErrorCode.NoError;
      switch (i) {
        case t.RecognitionStatus.Error:
          a = e.CancellationErrorCode.ServiceError;
          break;
        case t.RecognitionStatus.TooManyRequests:
          a = e.CancellationErrorCode.TooManyRequests;
          break;
        case t.RecognitionStatus.BadRequest:
          a = e.CancellationErrorCode.BadRequestParameters;
          break;
        case t.RecognitionStatus.Forbidden:
          a = e.CancellationErrorCode.Forbidden;
          break;
        default:
          a = e.CancellationErrorCode.NoError;
          break;
      }
      return a;
    }
    static implTranslateErrorDetails(i) {
      let a = "The speech service encountered an internal error and could not continue.";
      switch (i) {
        case e.CancellationErrorCode.Forbidden:
          a = "The recognizer is using a free subscription that ran out of quota.";
          break;
        case e.CancellationErrorCode.BadRequestParameters:
          a = "Invalid parameter or unsupported audio format in the request.";
          break;
        case e.CancellationErrorCode.TooManyRequests:
          a = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
          break;
      }
      return a;
    }
  };
  return Si.EnumTranslation = r, Si;
}
var va = {}, Ad;
function vb() {
  return Ad || (Ad = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionStatus = e.SynthesisStatus = void 0, function(t) {
      t[t.Success = 0] = "Success", t[t.SynthesisEnd = 1] = "SynthesisEnd", t[t.Error = 2] = "Error";
    }(e.SynthesisStatus || (e.SynthesisStatus = {})), function(t) {
      t[t.Success = 0] = "Success", t[t.NoMatch = 1] = "NoMatch", t[t.InitialSilenceTimeout = 2] = "InitialSilenceTimeout", t[t.BabbleTimeout = 3] = "BabbleTimeout", t[t.Error = 4] = "Error", t[t.EndOfDictation = 5] = "EndOfDictation", t[t.TooManyRequests = 6] = "TooManyRequests", t[t.BadRequest = 7] = "BadRequest", t[t.Forbidden = 8] = "Forbidden";
    }(e.RecognitionStatus || (e.RecognitionStatus = {}));
  }(va)), va;
}
var Ci = {}, Td;
function gb() {
  if (Td) return Ci;
  Td = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.TranslationSynthesisEnd = void 0;
  const e = /* @__PURE__ */ O();
  let t = class Nv {
    constructor(s) {
      this.privSynthesisEnd = JSON.parse(s), this.privSynthesisEnd.SynthesisStatus && (this.privSynthesisEnd.SynthesisStatus = e.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus]), this.privSynthesisEnd.Status && (this.privSynthesisEnd.SynthesisStatus = e.SynthesisStatus[this.privSynthesisEnd.Status]);
    }
    static fromJSON(s) {
      return new Nv(s);
    }
    get SynthesisStatus() {
      return this.privSynthesisEnd.SynthesisStatus;
    }
    get FailureReason() {
      return this.privSynthesisEnd.FailureReason;
    }
  };
  return Ci.TranslationSynthesisEnd = t, Ci;
}
var Ri = {}, _d;
function mb() {
  if (_d) return Ri;
  _d = 1, Object.defineProperty(Ri, "__esModule", { value: !0 }), Ri.TranslationHypothesis = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ tc();
  let r = class Ua {
    constructor(i, a) {
      this.privTranslationHypothesis = i, this.privTranslationHypothesis.Offset += a, this.privTranslationHypothesis.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationHypothesis.Translation.TranslationStatus);
    }
    static fromJSON(i, a) {
      return new Ua(JSON.parse(i), a);
    }
    static fromTranslationResponse(i, a) {
      e.Contracts.throwIfNullOrUndefined(i, "translationHypothesis");
      const o = i.SpeechHypothesis;
      return i.SpeechHypothesis = void 0, o.Translation = i, new Ua(o, a);
    }
    get Duration() {
      return this.privTranslationHypothesis.Duration;
    }
    get Offset() {
      return this.privTranslationHypothesis.Offset;
    }
    get Text() {
      return this.privTranslationHypothesis.Text;
    }
    get Translation() {
      return this.privTranslationHypothesis.Translation;
    }
    get Language() {
      return this.privTranslationHypothesis.PrimaryLanguage?.Language;
    }
    asJson() {
      const i = { ...this.privTranslationHypothesis };
      return i.Translation !== void 0 ? JSON.stringify({
        ...i,
        TranslationStatus: t.TranslationStatus[i.Translation.TranslationStatus]
      }) : JSON.stringify(i);
    }
    mapTranslationStatus(i) {
      if (typeof i == "string")
        return t.TranslationStatus[i];
      if (typeof i == "number")
        return i;
    }
  };
  return Ri.TranslationHypothesis = r, Ri;
}
var Pi = {}, kd;
function yb() {
  if (kd) return Pi;
  kd = 1, Object.defineProperty(Pi, "__esModule", { value: !0 }), Pi.TranslationPhrase = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ tc();
  let s = class $a {
    constructor(a, o) {
      this.privTranslationPhrase = a, this.privTranslationPhrase.Offset += o, this.privTranslationPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privTranslationPhrase.RecognitionStatus), this.privTranslationPhrase.Translation !== void 0 && (this.privTranslationPhrase.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationPhrase.Translation.TranslationStatus));
    }
    static fromJSON(a, o) {
      return new $a(JSON.parse(a), o);
    }
    static fromTranslationResponse(a, o) {
      e.Contracts.throwIfNullOrUndefined(a, "translationResponse");
      const n = a.SpeechPhrase;
      return a.SpeechPhrase = void 0, n.Translation = a, n.Text = n.DisplayText, new $a(n, o);
    }
    get RecognitionStatus() {
      return this.privTranslationPhrase.RecognitionStatus;
    }
    get Offset() {
      return this.privTranslationPhrase.Offset;
    }
    get Duration() {
      return this.privTranslationPhrase.Duration;
    }
    get Text() {
      return this.privTranslationPhrase.Text;
    }
    get Language() {
      return this.privTranslationPhrase.PrimaryLanguage?.Language;
    }
    get Confidence() {
      return this.privTranslationPhrase.PrimaryLanguage?.Confidence;
    }
    get Translation() {
      return this.privTranslationPhrase.Translation;
    }
    asJson() {
      const a = { ...this.privTranslationPhrase }, o = {
        ...a,
        RecognitionStatus: t.RecognitionStatus[a.RecognitionStatus]
      };
      return a.Translation && (o.Translation = {
        ...a.Translation,
        TranslationStatus: r.TranslationStatus[a.Translation.TranslationStatus]
      }), JSON.stringify(o);
    }
    mapRecognitionStatus(a) {
      if (typeof a == "string")
        return t.RecognitionStatus[a];
      if (typeof a == "number")
        return a;
    }
    mapTranslationStatus(a) {
      if (typeof a == "string")
        return r.TranslationStatus[a];
      if (typeof a == "number")
        return a;
    }
  };
  return Pi.TranslationPhrase = s, Pi;
}
var bi = {}, Od;
function Sb() {
  if (Od) return bi;
  Od = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.TranslationServiceRecognizer = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ O();
  let s = class extends r.ConversationServiceRecognizer {
    constructor(a, o, n, c, u) {
      super(a, o, n, c, u), this.privTranslationRecognizer = u, this.connectionEvents.attach((l) => {
        l.name === "ConnectionEstablishedEvent" && this.privTranslationRecognizer.onConnection();
      });
    }
    async processTypeSpecificMessages(a) {
      const o = new t.PropertyCollection();
      let n = await this.processSpeechMessages(a);
      if (n)
        return !0;
      const c = async (l) => {
        if (o.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, l.asJson()), this.privRequestSession.onPhraseRecognized(l.Offset + l.Duration), l.RecognitionStatus === r.RecognitionStatus.Success) {
          const p = this.fireEventForResult(l, o);
          if (this.privTranslationRecognizer.recognized)
            try {
              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, p);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(p.result);
            } catch (d) {
              this.privErrorCallback && this.privErrorCallback(d);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
        } else {
          const p = r.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus), d = new t.TranslationRecognitionResult(void 0, this.privRequestSession.requestId, p, l.Text, l.Duration, l.Offset, l.Language, l.Confidence, void 0, l.asJson(), o);
          if (p === t.ResultReason.Canceled) {
            const h = r.EnumTranslation.implTranslateCancelResult(l.RecognitionStatus), f = r.EnumTranslation.implTranslateCancelErrorCode(l.RecognitionStatus);
            await this.cancelRecognitionLocal(h, f, r.EnumTranslation.implTranslateErrorDetails(f));
          } else if (l.RecognitionStatus !== r.RecognitionStatus.EndOfDictation) {
            const h = new t.TranslationRecognitionEventArgs(d, d.offset, this.privRequestSession.sessionId);
            if (this.privTranslationRecognizer.recognized)
              try {
                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, h);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(d);
              } catch (f) {
                this.privErrorCallback && this.privErrorCallback(f);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          n = !0;
        }
      }, u = (l) => {
        o.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, l.asJson());
        const p = this.fireEventForResult(l, o);
        if (this.privRequestSession.onHypothesis(p.offset), this.privTranslationRecognizer.recognizing)
          try {
            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, p);
          } catch {
          }
        n = !0;
      };
      switch (a.messageType === e.MessageType.Text && o.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, a.textBody), a.path.toLowerCase()) {
        case "translation.hypothesis":
          u(r.TranslationHypothesis.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.response":
          const l = JSON.parse(a.textBody);
          if (l.SpeechPhrase)
            await c(r.TranslationPhrase.fromTranslationResponse(l, this.privRequestSession.currentTurnAudioOffset));
          else {
            const d = JSON.parse(a.textBody);
            d.SpeechHypothesis && u(r.TranslationHypothesis.fromTranslationResponse(d, this.privRequestSession.currentTurnAudioOffset));
          }
          break;
        case "translation.phrase":
          await c(r.TranslationPhrase.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.synthesis":
        case "audio":
          this.sendSynthesisAudio(a.binaryBody, this.privRequestSession.sessionId), n = !0;
          break;
        case "audio.end":
        case "translation.synthesis.end":
          const p = r.TranslationSynthesisEnd.fromJSON(a.textBody);
          switch (p.SynthesisStatus) {
            case r.SynthesisStatus.Error:
              if (this.privTranslationRecognizer.synthesizing) {
                const d = new t.TranslationSynthesisResult(t.ResultReason.Canceled, void 0), h = new t.TranslationSynthesisEventArgs(d, this.privRequestSession.sessionId);
                try {
                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, h);
                } catch {
                }
              }
              if (this.privTranslationRecognizer.canceled) {
                const d = new t.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, t.CancellationReason.Error, p.FailureReason, t.CancellationErrorCode.ServiceError, null);
                try {
                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, d);
                } catch {
                }
              }
              break;
            case r.SynthesisStatus.Success:
              this.sendSynthesisAudio(void 0, this.privRequestSession.sessionId);
              break;
          }
          n = !0;
          break;
      }
      return n;
    }
    // Cancels recognition.
    cancelRecognition(a, o, n, c, u) {
      const l = new t.PropertyCollection();
      if (l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]), this.privTranslationRecognizer.canceled) {
        const p = new t.TranslationRecognitionCanceledEventArgs(a, n, u, c, void 0);
        try {
          this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.TranslationRecognitionResult(
          void 0,
          // Translations
          o,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Druation
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          l
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    handleRecognizingCallback(a, o, n) {
      try {
        const c = new t.TranslationRecognitionEventArgs(t.TranslationRecognitionResult.fromSpeechRecognitionResult(a), o, n);
        this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    handleRecognizedCallback(a, o, n) {
      try {
        const c = new t.TranslationRecognitionEventArgs(t.TranslationRecognitionResult.fromSpeechRecognitionResult(a), o, n);
        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    fireEventForResult(a, o) {
      let n;
      if (a.Translation.Translations !== void 0) {
        n = new t.Translations();
        for (const h of a.Translation.Translations)
          n.set(h.Language, h.Text || h.DisplayText);
      }
      let c, u;
      a instanceof r.TranslationPhrase ? (a.Translation && a.Translation.TranslationStatus === e.TranslationStatus.Success ? c = t.ResultReason.TranslatedSpeech : c = t.ResultReason.RecognizedSpeech, u = a.Confidence) : c = t.ResultReason.TranslatingSpeech;
      const l = a.Language, p = new t.TranslationRecognitionResult(n, this.privRequestSession.requestId, c, a.Text, a.Duration, a.Offset, l, u, a.Translation.FailureReason, a.asJson(), o);
      return new t.TranslationRecognitionEventArgs(p, a.Offset, this.privRequestSession.sessionId);
    }
    sendSynthesisAudio(a, o) {
      const n = a === void 0 ? t.ResultReason.SynthesizingAudioCompleted : t.ResultReason.SynthesizingAudio, c = new t.TranslationSynthesisResult(n, a), u = new t.TranslationSynthesisEventArgs(c, o);
      if (this.privTranslationRecognizer.synthesizing)
        try {
          this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, u);
        } catch {
        }
    }
  };
  return bi.TranslationServiceRecognizer = s, bi;
}
var wi = {}, Md;
function Cb() {
  if (Md) return wi;
  Md = 1, Object.defineProperty(wi, "__esModule", { value: !0 }), wi.SpeechDetected = void 0;
  let e = class xv {
    constructor(r, s) {
      this.privSpeechStartDetected = JSON.parse(r), this.privSpeechStartDetected.Offset += s;
    }
    static fromJSON(r, s) {
      return new xv(r, s);
    }
    get Offset() {
      return this.privSpeechStartDetected.Offset;
    }
  };
  return wi.SpeechDetected = e, wi;
}
var Ei = {}, Dd;
function Rb() {
  if (Dd) return Ei;
  Dd = 1, Object.defineProperty(Ei, "__esModule", { value: !0 }), Ei.SpeechHypothesis = void 0;
  let e = class zv {
    constructor(r, s) {
      this.privSpeechHypothesis = JSON.parse(r), this.updateOffset(s);
    }
    static fromJSON(r, s) {
      return new zv(r, s);
    }
    updateOffset(r) {
      this.privSpeechHypothesis.Offset += r;
    }
    asJson() {
      return JSON.stringify(this.privSpeechHypothesis);
    }
    get Text() {
      return this.privSpeechHypothesis.Text;
    }
    get Offset() {
      return this.privSpeechHypothesis.Offset;
    }
    get Duration() {
      return this.privSpeechHypothesis.Duration;
    }
    get Language() {
      return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSpeechHypothesis.SpeakerId;
    }
  };
  return Ei.SpeechHypothesis = e, Ei;
}
var Ii = {}, Nd;
function Pb() {
  if (Nd) return Ii;
  Nd = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.SpeechKeyword = void 0;
  let e = class Lv {
    constructor(r, s) {
      this.privSpeechKeyword = JSON.parse(r), this.privSpeechKeyword.Offset += s;
    }
    static fromJSON(r, s) {
      return new Lv(r, s);
    }
    get Status() {
      return this.privSpeechKeyword.Status;
    }
    get Text() {
      return this.privSpeechKeyword.Text;
    }
    get Offset() {
      return this.privSpeechKeyword.Offset;
    }
    get Duration() {
      return this.privSpeechKeyword.Duration;
    }
    asJson() {
      return JSON.stringify(this.privSpeechKeyword);
    }
  };
  return Ii.SpeechKeyword = e, Ii;
}
var Ai = {}, xd;
function bb() {
  if (xd) return Ai;
  xd = 1, Object.defineProperty(Ai, "__esModule", { value: !0 }), Ai.SpeechServiceRecognizer = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ O();
  let r = class extends t.ServiceRecognizerBase {
    constructor(i, a, o, n, c) {
      super(i, a, o, n, c), this.privSpeechRecognizer = c;
    }
    async processTypeSpecificMessages(i) {
      let a;
      const o = new e.PropertyCollection();
      let n = !1;
      switch (i.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const c = t.SpeechHypothesis.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
          o.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, c.asJson()), a = new e.SpeechRecognitionResult(
            this.privRequestSession.requestId,
            e.ResultReason.RecognizingSpeech,
            c.Text,
            c.Duration,
            c.Offset,
            c.Language,
            c.LanguageDetectionConfidence,
            void 0,
            // Speaker Id
            void 0,
            c.asJson(),
            o
          ), this.privRequestSession.onHypothesis(c.Offset);
          const u = new e.SpeechRecognitionEventArgs(a, c.Offset, this.privRequestSession.sessionId);
          if (this.privSpeechRecognizer.recognizing)
            try {
              this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, u);
            } catch {
            }
          n = !0;
          break;
        case "speech.phrase":
          const l = t.SimpleSpeechPhrase.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
          o.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, l.asJson());
          const p = t.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus, this.privExpectContentAssessmentResponse);
          if (this.privRequestSession.onPhraseRecognized(l.Offset + l.Duration), e.ResultReason.Canceled === p) {
            const d = t.EnumTranslation.implTranslateCancelResult(l.RecognitionStatus), h = t.EnumTranslation.implTranslateCancelErrorCode(l.RecognitionStatus);
            await this.cancelRecognitionLocal(d, h, t.EnumTranslation.implTranslateErrorDetails(h));
          } else {
            if (l.RecognitionStatus === t.RecognitionStatus.EndOfDictation)
              break;
            if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
              a = new e.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                p,
                l.DisplayText,
                l.Duration,
                l.Offset,
                l.Language,
                l.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                l.asJson(),
                o
              );
            else {
              const h = t.DetailedSpeechPhrase.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
              o.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, h.asJson()), a = new e.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                p,
                h.RecognitionStatus === t.RecognitionStatus.Success ? h.NBest[0].Display : "",
                h.Duration,
                h.Offset,
                h.Language,
                h.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                h.asJson(),
                o
              );
            }
            const d = new e.SpeechRecognitionEventArgs(a, a.offset, this.privRequestSession.sessionId);
            if (this.privSpeechRecognizer.recognized)
              try {
                this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, d);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(a);
              } catch (h) {
                this.privErrorCallback && this.privErrorCallback(h);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          n = !0;
          break;
      }
      return n;
    }
    // Cancels recognition.
    cancelRecognition(i, a, o, n, c) {
      const u = new e.PropertyCollection();
      if (u.setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[n]), this.privSpeechRecognizer.canceled) {
        const l = new e.SpeechRecognitionCanceledEventArgs(o, c, n, void 0, i);
        try {
          this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, l);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const l = new e.SpeechRecognitionResult(
          a,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          c,
          void 0,
          // Json
          u
        );
        try {
          this.privSuccessCallback(l), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Ai.SpeechServiceRecognizer = r, Ai;
}
var Ti = {}, ga = {}, zd;
function wb() {
  return zd || (zd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.IdentityProvider = e.SpeakerDiarizationMode = void 0, function(t) {
      t.None = "None", t.Identity = "Identity", t.Anonymous = "Anonymous";
    }(e.SpeakerDiarizationMode || (e.SpeakerDiarizationMode = {})), function(t) {
      t.CallCenter = "CallCenter";
    }(e.IdentityProvider || (e.IdentityProvider = {}));
  }(ga)), ga;
}
var Ld;
function Eb() {
  if (Ld) return Ti;
  Ld = 1, Object.defineProperty(Ti, "__esModule", { value: !0 }), Ti.ConversationTranscriptionServiceRecognizer = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ wb(), s = /* @__PURE__ */ Se();
  let i = class extends t.ServiceRecognizerBase {
    constructor(o, n, c, u, l) {
      super(o, n, c, u, l), this.privConversationTranscriber = l, this.setSpeakerDiarizationJson();
    }
    setSpeakerDiarizationJson() {
      if (this.privEnableSpeakerId) {
        const o = this.privSpeechContext.getContext().phraseDetection || {};
        o.mode = s.RecognitionMode.Conversation;
        const n = {};
        n.mode = r.SpeakerDiarizationMode.Anonymous, n.audioSessionId = this.privDiarizationSessionId, n.audioOffsetMs = 0, n.diarizeIntermediates = this.privRecognizerConfig.parameters.getProperty(e.PropertyId.SpeechServiceResponse_DiarizeIntermediateResults, "false") === "true", o.speakerDiarization = n, this.privSpeechContext.getContext().phraseDetection = o;
      }
    }
    async processTypeSpecificMessages(o) {
      let n;
      const c = new e.PropertyCollection();
      c.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, o.textBody);
      let u = !1;
      switch (o.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const l = t.SpeechHypothesis.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset);
          n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, e.ResultReason.RecognizingSpeech, l.Text, l.Duration, l.Offset, l.Language, l.LanguageDetectionConfidence, l.SpeakerId, void 0, l.asJson(), c), this.privRequestSession.onHypothesis(l.Offset);
          const p = new e.ConversationTranscriptionEventArgs(n, l.Duration, this.privRequestSession.sessionId);
          if (this.privConversationTranscriber.transcribing)
            try {
              this.privConversationTranscriber.transcribing(this.privConversationTranscriber, p);
            } catch {
            }
          u = !0;
          break;
        case "speech.phrase":
          const d = t.SimpleSpeechPhrase.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset), h = t.EnumTranslation.implTranslateRecognitionResult(d.RecognitionStatus);
          if (this.privRequestSession.onPhraseRecognized(d.Offset + d.Duration), e.ResultReason.Canceled === h) {
            const f = t.EnumTranslation.implTranslateCancelResult(d.RecognitionStatus), g = t.EnumTranslation.implTranslateCancelErrorCode(d.RecognitionStatus);
            await this.cancelRecognitionLocal(f, g, t.EnumTranslation.implTranslateErrorDetails(g));
          } else if (!(this.privRequestSession.isSpeechEnded && h === e.ResultReason.NoMatch && d.RecognitionStatus !== t.RecognitionStatus.InitialSilenceTimeout)) {
            if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
              n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, h, d.DisplayText, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, d.SpeakerId, void 0, d.asJson(), c);
            else {
              const g = t.DetailedSpeechPhrase.fromJSON(o.textBody, this.privRequestSession.currentTurnAudioOffset);
              n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, h, g.RecognitionStatus === t.RecognitionStatus.Success ? g.NBest[0].Display : void 0, g.Duration, g.Offset, g.Language, g.LanguageDetectionConfidence, d.SpeakerId, void 0, g.asJson(), c);
            }
            const f = new e.ConversationTranscriptionEventArgs(n, n.offset, this.privRequestSession.sessionId);
            if (this.privConversationTranscriber.transcribed)
              try {
                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, f);
              } catch {
              }
          }
          u = !0;
          break;
      }
      return u;
    }
    // Cancels recognition.
    cancelRecognition(o, n, c, u, l) {
      if (new e.PropertyCollection().setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[u]), this.privConversationTranscriber.canceled) {
        const d = new e.ConversationTranscriptionCanceledEventArgs(c, l, u, void 0, o);
        try {
          this.privConversationTranscriber.canceled(this.privConversationTranscriber, d);
        } catch {
        }
      }
    }
  };
  return Ti.ConversationTranscriptionServiceRecognizer = i, Ti;
}
var _i = {}, jd;
function Ib() {
  if (jd) return _i;
  jd = 1, Object.defineProperty(_i, "__esModule", { value: !0 }), _i.TranscriptionServiceRecognizer = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ O(), s = /* @__PURE__ */ Ht();
  let i = class extends r.ConversationServiceRecognizer {
    constructor(o, n, c, u, l) {
      super(o, n, c, u, l), this.privTranscriberRecognizer = l, this.sendPrePayloadJSONOverride = (p) => this.sendTranscriptionStartJSON(p), this.privRecognizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true" && this.privSpeechContext.setWordLevelTimings();
    }
    async sendSpeechEventAsync(o, n) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createSpeechEventPayload(o, n));
      }
    }
    async sendMeetingSpeechEventAsync(o, n) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createMeetingSpeechEventPayload(o, n));
      }
    }
    processTypeSpecificMessages(o) {
      return this.processSpeechMessages(o);
    }
    handleRecognizedCallback(o, n, c) {
      try {
        const u = new t.SpeechRecognitionEventArgs(o, n, c);
        if (this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, u), this.privSuccessCallback) {
          try {
            this.privSuccessCallback(o);
          } catch (l) {
            this.privErrorCallback && this.privErrorCallback(l);
          }
          this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
        }
      } catch {
      }
    }
    handleRecognizingCallback(o, n, c) {
      try {
        const u = new t.SpeechRecognitionEventArgs(o, n, c);
        this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, u);
      } catch {
      }
    }
    // Cancels recognition.
    cancelRecognition(o, n, c, u, l) {
      const p = new t.PropertyCollection();
      if (p.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[u]), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        if (this.privTranscriberRecognizer.canceled) {
          const d = new t.MeetingTranscriptionCanceledEventArgs(c, l, u, void 0, o);
          try {
            this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, d);
          } catch {
          }
        }
      } else if (this.privTranscriberRecognizer.canceled) {
        const d = new t.ConversationTranscriptionCanceledEventArgs(c, l, u, void 0, o);
        try {
          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, d);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const d = new t.SpeechRecognitionResult(
          n,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          l,
          void 0,
          // Json
          p
        );
        try {
          this.privSuccessCallback(d), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendTranscriptionStartJSON(o) {
      if (await this.sendSpeechContext(o, !0), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        const n = this.privTranscriberRecognizer.getMeetingInfo(), c = this.createMeetingSpeechEventPayload(n, "start");
        await this.sendSpeechEvent(o, c);
      } else {
        const n = this.privTranscriberRecognizer.getConversationInfo(), c = this.createSpeechEventPayload(n, "start");
        await this.sendSpeechEvent(o, c);
      }
      await this.sendWaveHeader(o);
    }
    sendSpeechEvent(o, n) {
      const c = JSON.stringify(n);
      if (c)
        return o.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", c));
    }
    createSpeechEventPayload(o, n) {
      const c = { id: "meeting", name: n, meeting: o.conversationProperties };
      return c.meeting.id = o.id, c.meeting.attendees = o.participants, c;
    }
    createMeetingSpeechEventPayload(o, n) {
      const c = { id: "meeting", name: n, meeting: o.meetingProperties };
      return c.meeting.id = o.id, c.meeting.attendees = o.participants, c;
    }
  };
  return _i.TranscriptionServiceRecognizer = i, _i;
}
var ki = {}, qd;
function Ab() {
  if (qd) return ki;
  qd = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.DetailedSpeechPhrase = void 0;
  const e = /* @__PURE__ */ O();
  let t = class jv {
    constructor(s, i) {
      this.privDetailedSpeechPhrase = JSON.parse(s), this.privDetailedSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privDetailedSpeechPhrase.RecognitionStatus), this.updateOffsets(i);
    }
    static fromJSON(s, i) {
      return new jv(s, i);
    }
    updateOffsets(s) {
      if (this.privDetailedSpeechPhrase.Offset += s, this.privDetailedSpeechPhrase.NBest)
        for (const i of this.privDetailedSpeechPhrase.NBest) {
          if (i.Words)
            for (const a of i.Words)
              a.Offset += s;
          if (i.DisplayWords)
            for (const a of i.DisplayWords)
              a.Offset += s;
        }
    }
    asJson() {
      const s = { ...this.privDetailedSpeechPhrase };
      return JSON.stringify({
        ...s,
        RecognitionStatus: e.RecognitionStatus[s.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privDetailedSpeechPhrase.RecognitionStatus;
    }
    get NBest() {
      return this.privDetailedSpeechPhrase.NBest;
    }
    get Duration() {
      return this.privDetailedSpeechPhrase.Duration;
    }
    get Offset() {
      return this.privDetailedSpeechPhrase.Offset;
    }
    get Language() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get Text() {
      return this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0] ? this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText : this.privDetailedSpeechPhrase.DisplayText;
    }
    get SpeakerId() {
      return this.privDetailedSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(s) {
      if (typeof s == "string")
        return e.RecognitionStatus[s];
      if (typeof s == "number")
        return s;
    }
  };
  return ki.DetailedSpeechPhrase = t, ki;
}
var Oi = {}, Fd;
function Tb() {
  if (Fd) return Oi;
  Fd = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.SimpleSpeechPhrase = void 0;
  const e = /* @__PURE__ */ O();
  let t = class qv {
    constructor(s, i = 0) {
      this.privSimpleSpeechPhrase = JSON.parse(s), this.privSimpleSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privSimpleSpeechPhrase.RecognitionStatus), this.updateOffset(i);
    }
    static fromJSON(s, i) {
      return new qv(s, i);
    }
    updateOffset(s) {
      this.privSimpleSpeechPhrase.Offset += s;
    }
    asJson() {
      const s = { ...this.privSimpleSpeechPhrase };
      return JSON.stringify({
        ...s,
        RecognitionStatus: e.RecognitionStatus[s.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privSimpleSpeechPhrase.RecognitionStatus;
    }
    get DisplayText() {
      return this.privSimpleSpeechPhrase.DisplayText;
    }
    get Offset() {
      return this.privSimpleSpeechPhrase.Offset;
    }
    get Duration() {
      return this.privSimpleSpeechPhrase.Duration;
    }
    get Language() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSimpleSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(s) {
      if (typeof s == "string")
        return e.RecognitionStatus[s];
      if (typeof s == "number")
        return s;
    }
  };
  return Oi.SimpleSpeechPhrase = t, Oi;
}
var Mi = {}, Bd;
function _b() {
  if (Bd) return Mi;
  Bd = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.AddedLmIntent = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param modelImpl - The model.
     * @param intentName - The intent name.
     */
    constructor(r, s) {
      this.modelImpl = r, this.intentName = s;
    }
  };
  return Mi.AddedLmIntent = e, Mi;
}
var Di = {}, Ud;
function kb() {
  if (Ud) return Di;
  Ud = 1, Object.defineProperty(Di, "__esModule", { value: !0 }), Di.IntentServiceRecognizer = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ O();
  let s = class extends r.ServiceRecognizerBase {
    constructor(a, o, n, c, u) {
      super(a, o, n, c, u), this.privIntentRecognizer = u, this.privIntentDataSent = !1, c.recognitionEndpointVersion = "1";
    }
    setIntents(a, o) {
      this.privAddedLmIntents = a, this.privUmbrellaIntent = o, this.privIntentDataSent = !0;
    }
    processTypeSpecificMessages(a) {
      let o, n, c = !1;
      const u = new t.PropertyCollection();
      switch (a.messageType === e.MessageType.Text && u.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, a.textBody), a.path.toLowerCase()) {
        case "speech.hypothesis":
          const p = r.SpeechHypothesis.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (o = new t.IntentRecognitionResult(void 0, this.privRequestSession.requestId, t.ResultReason.RecognizingIntent, p.Text, p.Duration, p.Offset, p.Language, p.LanguageDetectionConfidence, void 0, p.asJson(), u), this.privRequestSession.onHypothesis(o.offset), n = new t.IntentRecognitionEventArgs(o, p.Offset, this.privRequestSession.sessionId), this.privIntentRecognizer.recognizing)
            try {
              this.privIntentRecognizer.recognizing(this.privIntentRecognizer, n);
            } catch {
            }
          c = !0;
          break;
        case "speech.phrase":
          const d = r.SimpleSpeechPhrase.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset);
          o = new t.IntentRecognitionResult(void 0, this.privRequestSession.requestId, r.EnumTranslation.implTranslateRecognitionResult(d.RecognitionStatus), d.DisplayText, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, void 0, d.asJson(), u), n = new t.IntentRecognitionEventArgs(o, o.offset, this.privRequestSession.sessionId);
          const h = () => {
            if (this.privIntentRecognizer.recognized)
              try {
                this.privIntentRecognizer.recognized(this.privIntentRecognizer, n);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(o);
              } catch (g) {
                this.privErrorCallback && this.privErrorCallback(g);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          };
          this.privIntentDataSent === !1 || t.ResultReason.NoMatch === n.result.reason ? (this.privRequestSession.onPhraseRecognized(n.offset + n.result.duration), h()) : this.privPendingIntentArgs = n, c = !0;
          break;
        case "response":
          if (n = this.privPendingIntentArgs, this.privPendingIntentArgs = void 0, n === void 0) {
            if (a.textBody === "")
              return;
            n = new t.IntentRecognitionEventArgs(new t.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
          }
          const f = r.IntentResponse.fromJSON(a.textBody);
          if (f !== null && f.topScoringIntent && f.topScoringIntent.intent) {
            let g = this.privAddedLmIntents[f.topScoringIntent.intent];
            if (this.privUmbrellaIntent !== void 0 && (g = this.privUmbrellaIntent), g) {
              const m = g === void 0 || g.intentName === void 0 ? f.topScoringIntent.intent : g.intentName;
              let v = n.result.reason;
              m !== void 0 && (v = t.ResultReason.RecognizedIntent);
              const y = n.result.properties !== void 0 ? n.result.properties : new t.PropertyCollection();
              y.setProperty(t.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, a.textBody), n = new t.IntentRecognitionEventArgs(new t.IntentRecognitionResult(m, n.result.resultId, v, n.result.text, n.result.duration, n.result.offset, void 0, void 0, n.result.errorDetails, n.result.json, y), n.offset, n.sessionId);
            }
          }
          if (this.privRequestSession.onPhraseRecognized(n.offset + n.result.duration), this.privIntentRecognizer.recognized)
            try {
              this.privIntentRecognizer.recognized(this.privIntentRecognizer, n);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(n.result);
            } catch (g) {
              this.privErrorCallback && this.privErrorCallback(g);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
          c = !0;
          break;
      }
      const l = new e.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(a, o, n, c, u) {
      const l = new t.PropertyCollection();
      if (l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]), this.privIntentRecognizer.canceled) {
        const p = new t.IntentRecognitionCanceledEventArgs(n, u, c, void 0, void 0, a);
        try {
          this.privIntentRecognizer.canceled(this.privIntentRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.IntentRecognitionResult(
          void 0,
          // Intent Id
          o,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          l
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Di.IntentServiceRecognizer = s, Di;
}
var Ni = {}, $d;
function Ob() {
  if ($d) return Ni;
  $d = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.IntentResponse = void 0;
  let e = class Fv {
    constructor(r) {
      r === "" ? this.privIntentResponse = {} : this.privIntentResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new Fv(r);
    }
    get query() {
      return this.privIntentResponse.query;
    }
    get topScoringIntent() {
      return this.privIntentResponse.topScoringIntent;
    }
    get entities() {
      return this.privIntentResponse.entities;
    }
  };
  return Ni.IntentResponse = e, Ni;
}
var ma = {}, Vd;
function Mb() {
  return Vd || (Vd = 1, Object.defineProperty(ma, "__esModule", { value: !0 })), ma;
}
var xi = {}, zi = {}, Wd;
function Db() {
  if (Wd) return zi;
  Wd = 1, Object.defineProperty(zi, "__esModule", { value: !0 }), zi.ServiceTelemetryListener = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ ac();
  class r {
    constructor(i, a, o) {
      this.privIsDisposed = !1, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privRequestId = i, this.privAudioSourceId = a, this.privAudioNodeId = o, this.privReceivedMessages = {}, this.privPhraseLatencies = [], this.privHypothesisLatencies = [];
    }
    phraseReceived(i) {
      i > 0 && this.privPhraseLatencies.push(Date.now() - i);
    }
    hypothesisReceived(i) {
      i > 0 && this.privHypothesisLatencies.push(Date.now() - i);
    }
    onEvent(i) {
      this.privIsDisposed || (i instanceof t.RecognitionTriggeredEvent && i.requestId === this.privRequestId && (this.privListeningTriggerMetric = {
        End: i.eventTime,
        Name: "ListeningTrigger",
        Start: i.eventTime
      }), i instanceof e.AudioStreamNodeAttachingEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = i.eventTime), i instanceof e.AudioStreamNodeAttachedEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = i.eventTime), i instanceof e.AudioSourceErrorEvent && i.audioSourceId === this.privAudioSourceId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Error: i.error,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof e.AudioStreamNodeErrorEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Error: i.error,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof e.AudioStreamNodeDetachedEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof t.ConnectingToServiceEvent && i.requestId === this.privRequestId && (this.privConnectionId = i.sessionId), i instanceof e.ConnectionStartEvent && i.connectionId === this.privConnectionId && (this.privConnectionStartTime = i.eventTime), i instanceof e.ConnectionEstablishedEvent && i.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
        End: i.eventTime,
        Id: this.privConnectionId,
        Name: "Connection",
        Start: this.privConnectionStartTime
      })), i instanceof e.ConnectionEstablishErrorEvent && i.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
        End: i.eventTime,
        Error: this.getConnectionError(i.statusCode),
        Id: this.privConnectionId,
        Name: "Connection",
        Start: this.privConnectionStartTime
      })), i instanceof e.ConnectionMessageReceivedEvent && i.connectionId === this.privConnectionId && i.message && i.message.headers && i.message.headers.path && (this.privReceivedMessages[i.message.headers.path] || (this.privReceivedMessages[i.message.headers.path] = new Array()), this.privReceivedMessages[i.message.headers.path].length < 50 && this.privReceivedMessages[i.message.headers.path].push(i.networkReceivedTime)));
    }
    getTelemetry() {
      const i = new Array();
      this.privListeningTriggerMetric && i.push(this.privListeningTriggerMetric), this.privMicMetric && i.push(this.privMicMetric), this.privConnectionEstablishMetric && i.push(this.privConnectionEstablishMetric), this.privPhraseLatencies.length > 0 && i.push({
        PhraseLatencyMs: this.privPhraseLatencies
      }), this.privHypothesisLatencies.length > 0 && i.push({
        FirstHypothesisLatencyMs: this.privHypothesisLatencies
      });
      const a = {
        Metrics: i,
        ReceivedMessages: this.privReceivedMessages
      }, o = JSON.stringify(a);
      return this.privReceivedMessages = {}, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privPhraseLatencies = [], this.privHypothesisLatencies = [], o;
    }
    // Determines if there are any telemetry events to send to the service.
    get hasTelemetry() {
      return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
    }
    dispose() {
      this.privIsDisposed = !0;
    }
    getConnectionError(i) {
      switch (i) {
        case 400:
        case 1002:
        case 1003:
        case 1005:
        case 1007:
        case 1008:
        case 1009:
          return "BadRequest";
        case 401:
          return "Unauthorized";
        case 403:
          return "Forbidden";
        case 503:
        case 1001:
          return "ServerUnavailable";
        case 500:
        case 1011:
          return "ServerError";
        case 408:
        case 504:
          return "Timeout";
        default:
          return "statuscode:" + i.toString();
      }
    }
  }
  return zi.ServiceTelemetryListener = r, zi;
}
var Hd;
function Nb() {
  if (Hd) return xi;
  Hd = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.RequestSession = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ ac(), r = /* @__PURE__ */ Db();
  let s = class {
    constructor(a) {
      this.privIsDisposed = !1, this.privDetachables = new Array(), this.privIsAudioNodeDetached = !1, this.privIsRecognizing = !1, this.privIsSpeechEnded = !1, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privHypothesisReceived = !1, this.privBytesSent = 0, this.privRecognitionBytesSent = 0, this.privRecogNumber = 0, this.privInTurn = !1, this.privConnectionAttempts = 0, this.privAudioSourceId = a, this.privRequestId = (0, e.createNoDashGuid)(), this.privAudioNodeId = (0, e.createNoDashGuid)(), this.privTurnDeferral = new e.Deferred(), this.privTurnDeferral.resolve();
    }
    get sessionId() {
      return this.privSessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSpeechEnded() {
      return this.privIsSpeechEnded;
    }
    get isRecognizing() {
      return this.privIsRecognizing;
    }
    get currentTurnAudioOffset() {
      return this.privTurnStartAudioOffset;
    }
    get recogNumber() {
      return this.privRecogNumber;
    }
    get numConnectionAttempts() {
      return this.privConnectionAttempts;
    }
    // The number of bytes sent for the current connection.
    // Counter is reset to 0 each time a connection is established.
    get bytesSent() {
      return this.privBytesSent;
    }
    // The number of bytes sent for the current recognition.
    // Counter is reset to 0 each time recognition is started.
    get recognitionBytesSent() {
      return this.privRecognitionBytesSent;
    }
    listenForServiceTelemetry(a) {
      this.privServiceTelemetryListener && this.privDetachables.push(a.attachListener(this.privServiceTelemetryListener));
    }
    startNewRecognition() {
      this.privRecognitionBytesSent = 0, this.privIsSpeechEnded = !1, this.privIsRecognizing = !0, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privRecogNumber++, this.privServiceTelemetryListener = new r.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId), this.onEvent(new t.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
    async onAudioSourceAttachCompleted(a, o) {
      this.privAudioNode = a, this.privIsAudioNodeDetached = !1, o ? await this.onComplete() : this.onEvent(new t.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
    onPreConnectionStart(a, o) {
      this.privAuthFetchEventId = a, this.privSessionId = o, this.onEvent(new t.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
    }
    async onAuthCompleted(a) {
      a && await this.onComplete();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onConnectionEstablishCompleted(a, o) {
      if (a === 200) {
        this.onEvent(new t.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId)), this.privAudioNode && this.privAudioNode.replay(), this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privBytesSent = 0;
        return;
      } else a === 403 && await this.onComplete();
    }
    async onServiceTurnEndResponse(a) {
      this.privTurnDeferral.resolve(), !a || this.isSpeechEnded ? (await this.onComplete(), this.privInTurn = !1) : (this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privAudioNode.replay());
    }
    onSpeechContext() {
      this.privRequestId = (0, e.createNoDashGuid)();
    }
    onServiceTurnStartResponse() {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new e.Deferred();
    }
    onHypothesis(a) {
      this.privHypothesisReceived || (this.privHypothesisReceived = !0, this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(a)));
    }
    onPhraseRecognized(a) {
      this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(a)), this.onServiceRecognized(a);
    }
    onServiceRecognized(a) {
      this.privLastRecoOffset = a, this.privHypothesisReceived = !1, this.privAudioNode.shrinkBuffers(a), this.privConnectionAttempts = 0;
    }
    onAudioSent(a) {
      this.privBytesSent += a, this.privRecognitionBytesSent += a;
    }
    onRetryConnection() {
      this.privConnectionAttempts++;
    }
    async dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = !0;
        for (const a of this.privDetachables)
          await a.detach();
        this.privServiceTelemetryListener && this.privServiceTelemetryListener.dispose(), this.privIsRecognizing = !1;
      }
    }
    getTelemetry() {
      return this.privServiceTelemetryListener.hasTelemetry ? this.privServiceTelemetryListener.getTelemetry() : null;
    }
    async onStopRecognizing() {
      await this.onComplete();
    }
    // Should be called with the audioNode for this session has indicated that it is out of speech.
    onSpeechEnded() {
      this.privIsSpeechEnded = !0;
    }
    onEvent(a) {
      this.privServiceTelemetryListener && this.privServiceTelemetryListener.onEvent(a), e.Events.instance.onEvent(a);
    }
    async onComplete() {
      this.privIsRecognizing && (this.privIsRecognizing = !1, await this.detachAudioNode());
    }
    async detachAudioNode() {
      this.privIsAudioNodeDetached || (this.privIsAudioNodeDetached = !0, this.privAudioNode && await this.privAudioNode.detach());
    }
  };
  return xi.RequestSession = s, xi;
}
var Li = {}, ya = {}, Kd;
function xb() {
  return Kd || (Kd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TentativePhraseResultsOption = e.OutputFormat = e.PhraseExtension = e.PhraseOption = void 0, function(t) {
      t.WordTimings = "WordTimings", t.SNR = "SNR", t.Pronunciation = "Pronunciation", t.WordPronunciation = "WordPronunciation", t.WordConfidence = "WordConfidence", t.Words = "Words", t.Sentiment = "Sentiment", t.PronunciationAssessment = "PronunciationAssessment", t.ContentAssessment = "ContentAssessment", t.PhraseAMScore = "PhraseAMScore", t.PhraseLMScore = "PhraseLMScore", t.WordAMScore = "WordAMScore", t.WordLMScore = "WordLMScore", t.RuleTree = "RuleTree", t.NBestTimings = "NBestTimings", t.DecoderDiagnostics = "DecoderDiagnostics", t.DisplayWordTimings = "DisplayWordTimings", t.DisplayWords = "DisplayWords";
    }(e.PhraseOption || (e.PhraseOption = {})), function(t) {
      t.Graph = "Graph", t.Corrections = "Corrections", t.Sentiment = "Sentiment";
    }(e.PhraseExtension || (e.PhraseExtension = {})), function(t) {
      t.Simple = "Simple", t.Detailed = "Detailed";
    }(e.OutputFormat || (e.OutputFormat = {})), function(t) {
      t.None = "None", t.Always = "Always";
    }(e.TentativePhraseResultsOption || (e.TentativePhraseResultsOption = {}));
  }(ya)), ya;
}
var Jd;
function zb() {
  if (Jd) return Li;
  Jd = 1, Object.defineProperty(Li, "__esModule", { value: !0 }), Li.SpeechContext = void 0;
  const e = /* @__PURE__ */ Se(), t = /* @__PURE__ */ xb();
  let r = class {
    constructor(i) {
      this.privContext = {}, this.privDynamicGrammar = i;
    }
    getContext() {
      return this.privContext;
    }
    /**
     * @Internal
     * This is only used by pronunciation assessment config.
     * Do not use externally, object returned will change without warning or notice.
     */
    setPronunciationAssessmentParams(i, a, o = !1) {
      this.privContext.phraseDetection === void 0 && (this.privContext.phraseDetection = {
        enrichment: {
          pronunciationAssessment: {}
        }
      }), this.privContext.phraseDetection.enrichment === void 0 && (this.privContext.phraseDetection.enrichment = {
        pronunciationAssessment: {}
      }), this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(i) || {}, o && (this.privContext.phraseDetection.mode = e.RecognitionMode.Conversation), this.setWordLevelTimings(), this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.PronunciationAssessment), this.privContext.phraseOutput.detailed.options.indexOf(t.PhraseOption.SNR) === -1 && this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.SNR), a && (this.privContext.phraseDetection.enrichment.contentAssessment = {
        topic: a
      }, this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.ContentAssessment));
    }
    setDetailedOutputFormat() {
      this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
        detailed: {
          options: []
        }
      }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
        options: []
      }), this.privContext.phraseOutput.format = t.OutputFormat.Detailed;
    }
    setWordLevelTimings() {
      this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
        detailed: {
          options: []
        }
      }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
        options: []
      }), this.privContext.phraseOutput.format = t.OutputFormat.Detailed, this.privContext.phraseOutput.detailed.options.indexOf(t.PhraseOption.WordTimings) === -1 && this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.WordTimings);
    }
    setSpeakerDiarizationAudioOffsetMs(i) {
      this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = i;
    }
    toJSON() {
      const i = this.privDynamicGrammar.generateGrammarObject();
      return this.privContext.dgi = i, JSON.stringify(this.privContext);
    }
  };
  return Li.SpeechContext = r, Li;
}
var ji = {}, Sa = {}, Gd;
function Lb() {
  return Gd || (Gd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SubstringMatchType = e.GroupType = void 0, function(t) {
      t.IntentText = "IntentText", t.IntentEntity = "IntentEntity", t.Generic = "Generic", t.People = "People", t.Place = "Place", t.DynamicEntity = "DynamicEntity";
    }(e.GroupType || (e.GroupType = {})), function(t) {
      t.None = "None", t.LeftRooted = "LeftRooted", t.PartialName = "PartialName", t.MiddleOfSentence = "MiddleOfSentence";
    }(e.SubstringMatchType || (e.SubstringMatchType = {}));
  }(Sa)), Sa;
}
var Qd;
function jb() {
  if (Qd) return ji;
  Qd = 1, Object.defineProperty(ji, "__esModule", { value: !0 }), ji.DynamicGrammarBuilder = void 0;
  const e = /* @__PURE__ */ Lb();
  let t = class {
    // Adds one more reference phrases to the dynamic grammar to send.
    // All added phrases are generic phrases.
    addPhrase(s) {
      this.privPhrases || (this.privPhrases = []), s instanceof Array ? this.privPhrases = this.privPhrases.concat(s) : this.privPhrases.push(s);
    }
    // Clears all phrases stored in the current object.
    clearPhrases() {
      this.privPhrases = void 0;
    }
    // Adds one or more reference grammars to the current grammar.
    addReferenceGrammar(s) {
      this.privGrammars || (this.privGrammars = []), s instanceof Array ? this.privGrammars = this.privGrammars.concat(s) : this.privGrammars.push(s);
    }
    // clears all grammars stored on the recognizer.
    clearGrammars() {
      this.privGrammars = void 0;
    }
    // Generates an object that represents the dynamic grammar used by the Speech Service.
    // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
    // of a DynamicGrammarBuilder
    generateGrammarObject() {
      if (this.privGrammars === void 0 && this.privPhrases === void 0)
        return;
      const s = {};
      if (s.referenceGrammars = this.privGrammars, this.privPhrases !== void 0 && this.privPhrases.length !== 0) {
        const i = [];
        this.privPhrases.forEach((a) => {
          i.push({
            text: a
          });
        }), s.groups = [{ type: e.GroupType.Generic, items: i }];
      }
      return s;
    }
  };
  return ji.DynamicGrammarBuilder = t, ji;
}
var qi = {}, Fi = {}, Bi = {}, Ca = {}, Yd;
function Bv() {
  return Yd || (Yd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MessageDataStreamType = e.ActivityPayloadResponse = void 0;
    class t {
      constructor(s) {
        this.privActivityResponse = JSON.parse(s);
      }
      static fromJSON(s) {
        return new t(s);
      }
      get conversationId() {
        return this.privActivityResponse.conversationId;
      }
      get messageDataStreamType() {
        return this.privActivityResponse.messageDataStreamType;
      }
      get messagePayload() {
        return this.privActivityResponse.messagePayload;
      }
      get version() {
        return this.privActivityResponse.version;
      }
    }
    e.ActivityPayloadResponse = t, function(r) {
      r[r.None = 0] = "None", r[r.TextToSpeechAudio = 1] = "TextToSpeechAudio";
    }(e.MessageDataStreamType || (e.MessageDataStreamType = {}));
  }(Ca)), Ca;
}
var Zd;
function qb() {
  if (Zd) return Bi;
  Zd = 1, Object.defineProperty(Bi, "__esModule", { value: !0 }), Bi.DialogServiceTurnState = void 0;
  const e = /* @__PURE__ */ Cs(), t = /* @__PURE__ */ Wt(), r = /* @__PURE__ */ Bv();
  let s = class {
    constructor(a, o) {
      this.privRequestId = o, this.privIsCompleted = !1, this.privAudioStream = null, this.privTurnManager = a, this.resetTurnEndTimeout();
    }
    get audioStream() {
      return this.resetTurnEndTimeout(), this.privAudioStream;
    }
    processActivityPayload(a, o) {
      return a.messageDataStreamType === r.MessageDataStreamType.TextToSpeechAudio && (this.privAudioStream = t.AudioOutputStream.createPullStream(), this.privAudioStream.format = o !== void 0 ? o : e.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privAudioStream;
    }
    endAudioStream() {
      this.privAudioStream !== null && !this.privAudioStream.isClosed && this.privAudioStream.close();
    }
    complete() {
      this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.endAudioStream();
    }
    resetTurnEndTimeout() {
      this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.privTimeoutToken = setTimeout(() => {
        this.privTurnManager.CompleteTurn(this.privRequestId);
      }, 2e3);
    }
  };
  return Bi.DialogServiceTurnState = s, Bi;
}
var Xd;
function Fb() {
  if (Xd) return Fi;
  Xd = 1, Object.defineProperty(Fi, "__esModule", { value: !0 }), Fi.DialogServiceTurnStateManager = void 0;
  const e = /* @__PURE__ */ Oe(), t = /* @__PURE__ */ qb();
  let r = class {
    constructor() {
      this.privTurnMap = /* @__PURE__ */ new Map();
    }
    StartTurn(i) {
      if (this.privTurnMap.has(i))
        throw new e.InvalidOperationError("Service error: There is already a turn with id:" + i);
      const a = new t.DialogServiceTurnState(this, i);
      return this.privTurnMap.set(i, a), this.privTurnMap.get(i);
    }
    GetTurn(i) {
      return this.privTurnMap.get(i);
    }
    CompleteTurn(i) {
      if (!this.privTurnMap.has(i))
        throw new e.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + i);
      const a = this.privTurnMap.get(i);
      return a.complete(), this.privTurnMap.delete(i), a;
    }
  };
  return Fi.DialogServiceTurnStateManager = r, Fi;
}
var Ra = {}, eh;
function Bb() {
  return eh || (eh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.InvocationSource = void 0, function(t) {
      t.None = "None", t.VoiceActivationWithKeyword = "VoiceActivationWithKeyword";
    }(e.InvocationSource || (e.InvocationSource = {}));
  }(Ra)), Ra;
}
var Pa = {}, th;
function Ub() {
  return th || (th = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OnRejectAction = e.KeywordDetectionType = void 0, function(t) {
      t.StartTrigger = "StartTrigger";
    }(e.KeywordDetectionType || (e.KeywordDetectionType = {})), function(t) {
      t.EndOfTurn = "EndOfTurn", t.Continue = "Continue";
    }(e.OnRejectAction || (e.OnRejectAction = {}));
  }(Pa)), Pa;
}
var rh;
function $b() {
  if (rh) return qi;
  rh = 1, Object.defineProperty(qi, "__esModule", { value: !0 }), qi.DialogServiceAdapter = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ Jf(), r = /* @__PURE__ */ D(), s = /* @__PURE__ */ Cs(), i = /* @__PURE__ */ A(), a = /* @__PURE__ */ Fb(), o = /* @__PURE__ */ O(), n = /* @__PURE__ */ Bv(), c = /* @__PURE__ */ Bb(), u = /* @__PURE__ */ Ub(), l = /* @__PURE__ */ Ht();
  let p = class extends o.ServiceRecognizerBase {
    constructor(h, f, g, m, v) {
      super(h, f, g, m, v), this.privEvents = new r.EventSource(), this.privDialogServiceConnector = v, this.receiveMessageOverride = () => this.receiveDialogMessageOverride(), this.privTurnStateManager = new a.DialogServiceTurnStateManager(), this.recognizeOverride = (y, S, C) => this.listenOnce(y, S, C), this.postConnectImplOverride = (y) => this.dialogConnectImpl(y), this.configConnectionOverride = (y) => this.configConnection(y), this.disconnectOverride = () => this.privDisconnect(), this.privDialogAudioSource = g, this.agentConfigSent = !1, this.privLastResult = null, this.connectionEvents.attach((y) => {
        y.name === "ConnectionClosedEvent" && (this.terminateMessageLoop = !0);
      });
    }
    async sendMessage(h) {
      const f = (0, r.createGuid)(), g = (0, r.createNoDashGuid)(), m = {
        context: {
          interactionId: f
        },
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        messagePayload: JSON.parse(h),
        version: 0.5
      }, v = JSON.stringify(m);
      await (await this.fetchConnection()).send(new l.SpeechConnectionMessage(r.MessageType.Text, "agent", g, "application/json", v));
    }
    async privDisconnect() {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, this.agentConfigSent = !1;
    }
    processTypeSpecificMessages(h) {
      const f = new i.PropertyCollection();
      h.messageType === r.MessageType.Text && f.setProperty(i.PropertyId.SpeechServiceResponse_JsonResult, h.textBody);
      let g, m;
      switch (h.path.toLowerCase()) {
        case "speech.phrase":
          const y = o.SimpleSpeechPhrase.fromJSON(h.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (this.privRequestSession.onPhraseRecognized(y.Offset + y.Duration), y.RecognitionStatus !== o.RecognitionStatus.TooManyRequests && y.RecognitionStatus !== o.RecognitionStatus.Error) {
            const I = this.fireEventForResult(y, f);
            if (this.privLastResult = I.result, this.privDialogServiceConnector.recognized)
              try {
                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, I);
              } catch {
              }
          }
          m = !0;
          break;
        case "speech.hypothesis":
          const S = o.SpeechHypothesis.fromJSON(h.textBody, this.privRequestSession.currentTurnAudioOffset);
          g = new i.SpeechRecognitionResult(this.privRequestSession.requestId, i.ResultReason.RecognizingSpeech, S.Text, S.Duration, S.Offset, S.Language, S.LanguageDetectionConfidence, void 0, void 0, S.asJson(), f), this.privRequestSession.onHypothesis(S.Offset);
          const C = new i.SpeechRecognitionEventArgs(g, S.Offset, this.privRequestSession.sessionId);
          if (this.privDialogServiceConnector.recognizing)
            try {
              this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, C);
            } catch {
            }
          m = !0;
          break;
        case "speech.keyword":
          const R = o.SpeechKeyword.fromJSON(h.textBody, this.privRequestSession.currentTurnAudioOffset);
          g = new i.SpeechRecognitionResult(this.privRequestSession.requestId, R.Status === "Accepted" ? i.ResultReason.RecognizedKeyword : i.ResultReason.NoMatch, R.Text, R.Duration, R.Offset, void 0, void 0, void 0, void 0, R.asJson(), f), R.Status !== "Accepted" && (this.privLastResult = g);
          const w = new i.SpeechRecognitionEventArgs(g, g.duration, g.resultId);
          if (this.privDialogServiceConnector.recognized)
            try {
              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, w);
            } catch {
            }
          m = !0;
          break;
        case "audio":
          {
            const I = h.requestId.toUpperCase(), E = this.privTurnStateManager.GetTurn(I);
            try {
              h.binaryBody ? E.audioStream.write(h.binaryBody) : E.endAudioStream();
            } catch {
            }
          }
          m = !0;
          break;
        case "response":
          this.handleResponseMessage(h), m = !0;
          break;
      }
      const v = new r.Deferred();
      return v.resolve(m), v.promise;
    }
    // Cancels recognition.
    async cancelRecognition(h, f, g, m, v) {
      if (this.terminateMessageLoop = !0, this.privRequestSession.isRecognizing && await this.privRequestSession.onStopRecognizing(), this.privDialogServiceConnector.canceled) {
        const y = new i.PropertyCollection();
        y.setProperty(o.CancellationErrorCodePropertyName, i.CancellationErrorCode[m]);
        const S = new i.SpeechRecognitionCanceledEventArgs(g, v, m, void 0, h);
        try {
          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, S);
        } catch {
        }
        if (this.privSuccessCallback) {
          const C = new i.SpeechRecognitionResult(
            void 0,
            // ResultId
            i.ResultReason.Canceled,
            void 0,
            // Text
            void 0,
            // Duration
            void 0,
            // Offset
            void 0,
            // Language
            void 0,
            // Language Detection Confidence
            void 0,
            // Speaker Id
            v,
            void 0,
            // Json
            y
          );
          try {
            this.privSuccessCallback(C), this.privSuccessCallback = void 0;
          } catch {
          }
        }
      }
    }
    async listenOnce(h, f, g) {
      this.privRecognizerConfig.recognitionMode = h, this.privSuccessCallback = f, this.privErrorCallback = g, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events), this.privRecognizerConfig.parameters.setProperty(i.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const m = this.connectImpl(), v = this.sendPreAudioMessages(), y = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId), S = await this.privDialogAudioSource.format, C = await this.privDialogAudioSource.deviceInfo, R = new e.ReplayableAudioNode(y, S.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(R, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: C };
      try {
        await m, await v;
      } catch (E) {
        return await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.ConnectionFailure, E), Promise.resolve();
      }
      const w = new i.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, w), this.sendAudio(R).then(() => {
      }, async (E) => {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.RuntimeError, E);
      });
    }
    // Establishes a websocket connection to the end point.
    dialogConnectImpl(h) {
      return this.privConnectionLoop = this.startMessageLoop(), h;
    }
    receiveDialogMessageOverride() {
      const h = new r.Deferred(), f = async () => {
        try {
          const g = this.isDisposed(), m = !this.isDisposed() && this.terminateMessageLoop;
          if (g || m) {
            h.resolve(void 0);
            return;
          }
          const y = await (await this.fetchConnection()).read();
          if (!y)
            return f();
          const S = l.SpeechConnectionMessage.fromConnectionMessage(y);
          switch (S.path.toLowerCase()) {
            case "turn.start":
              {
                const b = S.requestId.toUpperCase(), _ = this.privRequestSession.requestId.toUpperCase();
                b !== _ ? this.privTurnStateManager.StartTurn(b) : this.privRequestSession.onServiceTurnStartResponse();
              }
              break;
            case "speech.startdetected":
              const R = o.SpeechDetected.fromJSON(S.textBody, this.privRequestSession.currentTurnAudioOffset), w = new i.RecognitionEventArgs(R.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, w);
              break;
            case "speech.enddetected":
              let I;
              S.textBody.length > 0 ? I = S.textBody : I = "{ Offset: 0 }";
              const E = o.SpeechDetected.fromJSON(I, this.privRequestSession.currentTurnAudioOffset);
              this.privRequestSession.onServiceRecognized(E.Offset);
              const T = new i.RecognitionEventArgs(E.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, T);
              break;
            case "turn.end":
              {
                const b = S.requestId.toUpperCase(), _ = this.privRequestSession.requestId.toUpperCase();
                if (b !== _)
                  this.privTurnStateManager.CompleteTurn(b);
                else {
                  const k = new i.SessionEventArgs(this.privRequestSession.sessionId);
                  if (await this.privRequestSession.onServiceTurnEndResponse(!1), (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) && this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, k), this.privSuccessCallback && this.privLastResult) {
                    try {
                      this.privSuccessCallback(this.privLastResult), this.privLastResult = null;
                    } catch (B) {
                      this.privErrorCallback && this.privErrorCallback(B);
                    }
                    this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
                  }
                }
              }
              break;
            default:
              try {
                await this.processTypeSpecificMessages(S) || this.serviceEvents && this.serviceEvents.onEvent(new r.ServiceEvent(S.path.toLowerCase(), S.textBody));
              } catch {
              }
          }
          return f();
        } catch {
          this.terminateMessageLoop = !0, h.resolve();
        }
      };
      return f().catch((g) => {
        r.Events.instance.onEvent(new r.BackgroundEvent(g));
      }), h.promise;
    }
    async startMessageLoop() {
      this.terminateMessageLoop = !1;
      try {
        await this.receiveDialogMessageOverride();
      } catch (h) {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.RuntimeError, h);
      }
      return Promise.resolve();
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configConnection(h) {
      return this.terminateMessageLoop ? (this.terminateMessageLoop = !1, Promise.reject("Connection to service terminated.")) : (await this.sendSpeechServiceConfig(h, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendAgentConfig(h), h);
    }
    async sendPreAudioMessages() {
      const h = await this.fetchConnection();
      this.addKeywordContextData(), await this.sendSpeechContext(h, !0), await this.sendAgentContext(h), await this.sendWaveHeader(h);
    }
    sendAgentConfig(h) {
      if (this.agentConfig && !this.agentConfigSent) {
        if (this.privRecognizerConfig.parameters.getProperty(i.PropertyId.Conversation_DialogType) === i.DialogServiceConfig.DialogTypes.CustomCommands) {
          const g = this.agentConfig.get();
          g.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us"), this.agentConfig.set(g);
        }
        this.onEvent(new t.SendingAgentContextMessageEvent(this.agentConfig));
        const f = this.agentConfig.toJsonString();
        return this.agentConfigSent = !0, h.send(new l.SpeechConnectionMessage(r.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", f));
      }
    }
    sendAgentContext(h) {
      const f = (0, r.createGuid)(), g = this.privDialogServiceConnector.properties.getProperty(i.PropertyId.Conversation_Speech_Activity_Template), v = JSON.stringify({
        channelData: "",
        context: {
          interactionId: f
        },
        messagePayload: typeof g === void 0 ? void 0 : g,
        version: 0.5
      });
      return h.send(new l.SpeechConnectionMessage(r.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", v));
    }
    fireEventForResult(h, f) {
      const g = o.EnumTranslation.implTranslateRecognitionResult(h.RecognitionStatus), m = new i.SpeechRecognitionResult(this.privRequestSession.requestId, g, h.DisplayText, h.Duration, h.Offset, h.Language, h.LanguageDetectionConfidence, void 0, void 0, h.asJson(), f);
      return new i.SpeechRecognitionEventArgs(m, h.Offset, this.privRequestSession.sessionId);
    }
    handleResponseMessage(h) {
      const f = JSON.parse(h.textBody);
      switch (f.messageType.toLowerCase()) {
        case "message":
          const g = h.requestId.toUpperCase(), m = n.ActivityPayloadResponse.fromJSON(h.textBody), v = this.privTurnStateManager.GetTurn(g);
          if (m.conversationId) {
            const C = this.agentConfig.get();
            C.botInfo.conversationId = m.conversationId, this.agentConfig.set(C);
          }
          const y = v.processActivityPayload(m, s.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(i.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0))), S = new i.ActivityReceivedEventArgs(m.messagePayload, y);
          if (this.privDialogServiceConnector.activityReceived)
            try {
              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, S);
            } catch {
            }
          break;
        case "messagestatus":
          if (this.privDialogServiceConnector.turnStatusReceived)
            try {
              this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new i.TurnStatusReceivedEventArgs(h.textBody));
            } catch {
            }
          break;
        default:
          r.Events.instance.onEvent(new r.BackgroundEvent(`Unexpected response of type ${f.messageType}. Ignoring.`));
          break;
      }
    }
    onEvent(h) {
      this.privEvents.onEvent(h), r.Events.instance.onEvent(h);
    }
    addKeywordContextData() {
      const h = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
      if (h === void 0)
        return;
      const f = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets"), g = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations"), m = h.split(";"), v = f === void 0 ? [] : f.split(";"), y = g === void 0 ? [] : g.split(";"), S = [];
      for (let C = 0; C < m.length; C++) {
        const R = {
          text: m[C]
        };
        C < v.length && (R.startOffset = Number(v[C])), C < y.length && (R.duration = Number(y[C])), S.push(R);
      }
      this.speechContext.getContext().invocationSource = c.InvocationSource.VoiceActivationWithKeyword, this.speechContext.getContext().keywordDetection = [{
        clientDetectedKeywords: S,
        onReject: { action: u.OnRejectAction.EndOfTurn },
        type: u.KeywordDetectionType.StartTrigger
      }];
    }
  };
  return qi.DialogServiceAdapter = p, qi;
}
var Ui = {}, nh;
function Vb() {
  if (nh) return Ui;
  nh = 1, Object.defineProperty(Ui, "__esModule", { value: !0 }), Ui.AgentConfig = void 0;
  let e = class {
    toJsonString() {
      return JSON.stringify(this.iPrivConfig);
    }
    get() {
      return this.iPrivConfig;
    }
    /**
     * Setter for the agent.config object.
     * @param value a JSON serializable object.
     */
    set(r) {
      this.iPrivConfig = r;
    }
  };
  return Ui.AgentConfig = e, Ui;
}
var ba = {}, $i = {}, Vi = {}, ih;
function cc() {
  if (ih) return Vi;
  ih = 1, Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.ConversationConnectionConfig = void 0;
  const e = /* @__PURE__ */ Dv();
  let t = class Ze extends e.RestConfigBase {
    static get host() {
      return Ze.privHost;
    }
    static get apiVersion() {
      return Ze.privApiVersion;
    }
    static get clientAppId() {
      return Ze.privClientAppId;
    }
    static get defaultLanguageCode() {
      return Ze.privDefaultLanguageCode;
    }
    static get restPath() {
      return Ze.privRestPath;
    }
    static get webSocketPath() {
      return Ze.privWebSocketPath;
    }
    static get transcriptionEventKeys() {
      return Ze.privTranscriptionEventKeys;
    }
  };
  return Vi.ConversationConnectionConfig = t, t.privHost = "dev.microsofttranslator.com", t.privRestPath = "/capito/room", t.privApiVersion = "2.0", t.privDefaultLanguageCode = "en-US", t.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15", t.privWebSocketPath = "/capito/translate", t.privTranscriptionEventKeys = ["iCalUid", "callId", "organizer", "FLAC", "MTUri", "DifferentiateGuestSpeakers", "audiorecording", "Threadid", "OrganizerMri", "OrganizerTenantId", "UserToken"], Vi;
}
var sh;
function Wb() {
  if (sh) return $i;
  sh = 1, Object.defineProperty($i, "__esModule", { value: !0 }), $i.ConversationManager = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ cc();
  let i = class {
    constructor() {
      this.privRequestParams = s.ConversationConnectionConfig.configParams, this.privErrors = s.ConversationConnectionConfig.restErrors, this.privHost = s.ConversationConnectionConfig.host, this.privApiVersion = s.ConversationConnectionConfig.apiVersion, this.privRestPath = s.ConversationConnectionConfig.restPath, this.privRestAdapter = new e.RestMessageAdapter({});
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */
    createOrJoin(o, n, c, u) {
      try {
        t.Contracts.throwIfNullOrUndefined(o, "args");
        const l = o.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, s.ConversationConnectionConfig.defaultLanguageCode), p = o.getProperty(r.PropertyId.ConversationTranslator_Name, "conversation_host"), d = o.getProperty(r.PropertyId.ConversationTranslator_Host, this.privHost), h = o.getProperty(r.PropertyId.ConversationTranslator_CorrelationId), f = o.getProperty(r.PropertyId.SpeechServiceConnection_Key), g = o.getProperty(r.PropertyId.SpeechServiceConnection_Region), m = o.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
        t.Contracts.throwIfNullOrWhitespace(l, "languageCode"), t.Contracts.throwIfNullOrWhitespace(p, "nickname"), t.Contracts.throwIfNullOrWhitespace(d, "endpointHost");
        const v = {};
        v[this.privRequestParams.apiVersion] = this.privApiVersion, v[this.privRequestParams.languageCode] = l, v[this.privRequestParams.nickname] = p;
        const y = {};
        h && (y[this.privRequestParams.correlationId] = h), y[this.privRequestParams.clientAppId] = s.ConversationConnectionConfig.clientAppId, n !== void 0 ? v[this.privRequestParams.roomId] = n : (t.Contracts.throwIfNullOrUndefined(g, this.privErrors.authInvalidSubscriptionRegion), y[this.privRequestParams.subscriptionRegion] = g, f ? y[this.privRequestParams.subscriptionKey] = f : m ? y[this.privRequestParams.authorization] = `Bearer ${m}` : t.Contracts.throwIfNullOrUndefined(f, this.privErrors.authInvalidSubscriptionKey));
        const S = {};
        S.headers = y, this.privRestAdapter.options = S;
        const C = `https://${d}${this.privRestPath}`;
        this.privRestAdapter.request(e.RestRequestType.Post, C, v, null).then((R) => {
          const w = e.RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, R.headers);
          if (!R.ok) {
            if (u) {
              let E = this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", R.status.toString()), T;
              try {
                T = JSON.parse(R.data), E += ` [${T.error.code}: ${T.error.message}]`;
              } catch {
                E += ` [${R.data}]`;
              }
              w && (E += ` ${w}`), u(E);
            }
            return;
          }
          const I = JSON.parse(R.data);
          if (I && (I.requestId = w), c) {
            try {
              c(I);
            } catch (E) {
              u && u(E);
            }
            c = void 0;
          }
        }).catch(() => {
        });
      } catch (l) {
        if (u)
          if (l instanceof Error) {
            const p = l;
            u(p.name + ": " + p.message);
          } else
            u(l);
      }
    }
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */
    leave(o, n) {
      return new Promise((c, u) => {
        try {
          t.Contracts.throwIfNullOrUndefined(o, this.privErrors.invalidArgs.replace("{arg}", "config")), t.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "token"));
          const l = o.getProperty(r.PropertyId.ConversationTranslator_Host, this.privHost), p = o.getProperty(r.PropertyId.ConversationTranslator_CorrelationId), d = {};
          d[this.privRequestParams.apiVersion] = this.privApiVersion, d[this.privRequestParams.sessionToken] = n;
          const h = {};
          p && (h[this.privRequestParams.correlationId] = p);
          const f = {};
          f.headers = h, this.privRestAdapter.options = f;
          const g = `https://${l}${this.privRestPath}`;
          this.privRestAdapter.request(e.RestRequestType.Delete, g, d, null).then((m) => {
            m.ok, c();
          }).catch(() => {
          });
        } catch (l) {
          if (l instanceof Error) {
            const p = l;
            u(p.name + ": " + p.message);
          } else
            u(l);
        }
      });
    }
  };
  return $i.ConversationManager = i, $i;
}
var Et = {}, Wi = {}, Hi = {}, Ki = {}, oh;
function Uv() {
  if (oh) return Ki;
  oh = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.ConversationConnectionMessage = void 0;
  const e = /* @__PURE__ */ D();
  let t = class extends e.ConnectionMessage {
    constructor(s, i, a, o) {
      super(s, i, a, o);
      const n = JSON.parse(this.textBody);
      n.type !== void 0 && (this.privConversationMessageType = n.type);
    }
    get conversationMessageType() {
      return this.privConversationMessageType;
    }
  };
  return Ki.ConversationConnectionMessage = t, Ki;
}
var ah;
function Hb() {
  if (ah) return Hi;
  ah = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.ConversationWebsocketMessageFormatter = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ Uv();
  let r = class {
    /**
     * Format incoming messages: text (speech partial/final, IM) or binary (tts)
     */
    toConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const o = new t.ConversationConnectionMessage(i.messageType, i.textContent, {}, i.id);
          a.resolve(o);
        } else i.messageType === e.MessageType.Binary && a.resolve(new t.ConversationConnectionMessage(i.messageType, i.binaryContent, void 0, i.id));
      } catch (o) {
        a.reject(`Error formatting the message. Error: ${o}`);
      }
      return a.promise;
    }
    /**
     * Format outgoing messages: text (commands or IM)
     */
    fromConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const o = `${i.textBody ? i.textBody : ""}`;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Text, o, i.id));
        }
      } catch (o) {
        a.reject(`Error formatting the message. ${o}`);
      }
      return a.promise;
    }
  };
  return Hi.ConversationWebsocketMessageFormatter = r, Hi;
}
var ch;
function Kb() {
  if (ch) return Wi;
  ch = 1, Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.ConversationConnectionFactory = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A(), i = /* @__PURE__ */ Ae(), a = /* @__PURE__ */ cc(), o = /* @__PURE__ */ Hb();
  let n = class extends i.ConnectionFactoryBase {
    create(u, l, p) {
      const d = u.parameters.getProperty(s.PropertyId.ConversationTranslator_Host, a.ConversationConnectionConfig.host), h = u.parameters.getProperty(s.PropertyId.ConversationTranslator_CorrelationId, (0, t.createGuid)()), f = `wss://${d}${a.ConversationConnectionConfig.webSocketPath}`, g = u.parameters.getProperty(s.PropertyId.ConversationTranslator_Token, void 0);
      r.Contracts.throwIfNullOrUndefined(g, "token");
      const m = {};
      m[a.ConversationConnectionConfig.configParams.apiVersion] = a.ConversationConnectionConfig.apiVersion, m[a.ConversationConnectionConfig.configParams.token] = g, m[a.ConversationConnectionConfig.configParams.correlationId] = h;
      const v = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(f, m, {}, new o.ConversationWebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), v, p));
    }
  };
  return Wi.ConversationConnectionFactory = n, Wi;
}
var Ji = {}, Gi = {}, uh;
function Jb() {
  if (uh) return Gi;
  uh = 1, Object.defineProperty(Gi, "__esModule", { value: !0 }), Gi.ConversationRequestSession = void 0;
  const e = /* @__PURE__ */ D();
  let t = class {
    constructor(s) {
      this.privIsDisposed = !1, this.privDetachables = new Array(), this.privSessionId = s, this.privRequestId = (0, e.createNoDashGuid)(), this.privRequestCompletionDeferral = new e.Deferred();
    }
    get sessionId() {
      return this.privSessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get completionPromise() {
      return this.privRequestCompletionDeferral.promise;
    }
    onPreConnectionStart(s, i) {
      this.privSessionId = i;
    }
    onAuthCompleted(s) {
      s && this.onComplete();
    }
    onConnectionEstablishCompleted(s) {
      s !== 200 && s === 403 && this.onComplete();
    }
    onServiceTurnEndResponse(s) {
      s ? this.privRequestId = (0, e.createNoDashGuid)() : this.onComplete();
    }
    async dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = !0;
        for (const s of this.privDetachables)
          await s.detach();
      }
    }
    onComplete() {
    }
  };
  return Gi.ConversationRequestSession = t, Gi;
}
var ae = {}, lh;
function $v() {
  if (lh) return ae;
  lh = 1, Object.defineProperty(ae, "__esModule", { value: !0 }), ae.ConversationReceivedTranslationEventArgs = ae.ParticipantsListEventArgs = ae.ParticipantAttributeEventArgs = ae.ParticipantEventArgs = ae.LockRoomEventArgs = ae.MuteAllEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  class t extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsMuted = c;
    }
    get isMuted() {
      return this.privIsMuted;
    }
  }
  ae.MuteAllEventArgs = t;
  class r extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsLocked = c;
    }
    get isMuted() {
      return this.privIsLocked;
    }
  }
  ae.LockRoomEventArgs = r;
  class s extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privParticipant = c;
    }
    get participant() {
      return this.privParticipant;
    }
  }
  ae.ParticipantEventArgs = s;
  class i extends e.SessionEventArgs {
    constructor(c, u, l, p) {
      super(p), this.privKey = u, this.privValue = l, this.privParticipantId = c;
    }
    get value() {
      return this.privValue;
    }
    get key() {
      return this.privKey;
    }
    get id() {
      return this.privParticipantId;
    }
  }
  ae.ParticipantAttributeEventArgs = i;
  class a extends e.SessionEventArgs {
    constructor(c, u, l, p, d, h, f, g, m) {
      super(m), this.privRoomId = c, this.privSessionToken = u, this.privTranslateTo = l, this.privProfanityFilter = p, this.privRoomProfanityFilter = d, this.privIsRoomLocked = h, this.privIsRoomLocked = f, this.privParticipants = g;
    }
    get sessionToken() {
      return this.privSessionToken;
    }
    get conversationId() {
      return this.privRoomId;
    }
    get translateTo() {
      return this.privTranslateTo;
    }
    get profanityFilter() {
      return this.privProfanityFilter;
    }
    get roomProfanityFilter() {
      return this.privRoomProfanityFilter;
    }
    get isRoomLocked() {
      return this.privIsRoomLocked;
    }
    get isMuteAll() {
      return this.privIsMuteAll;
    }
    get participants() {
      return this.privParticipants;
    }
  }
  ae.ParticipantsListEventArgs = a;
  class o {
    constructor(c, u, l) {
      this.privPayload = u, this.privCommand = c, this.privSessionId = l;
    }
    get payload() {
      return this.privPayload;
    }
    get command() {
      return this.privCommand;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  return ae.ConversationReceivedTranslationEventArgs = o, ae;
}
var je = {}, ph;
function Vv() {
  if (ph) return je;
  ph = 1, Object.defineProperty(je, "__esModule", { value: !0 }), je.ConversationTranslatorCommandTypes = je.ConversationTranslatorMessageTypes = je.InternalParticipants = void 0;
  class e {
    constructor(r = [], s) {
      this.participants = r, this.meId = s;
    }
    /**
     * Add or update a participant
     * @param value
     */
    addOrUpdateParticipant(r) {
      if (r === void 0)
        return;
      const s = this.getParticipantIndex(r.id);
      return s > -1 ? this.participants.splice(s, 1, r) : this.participants.push(r), this.getParticipant(r.id);
    }
    /**
     * Find the participant's position in the participants list.
     * @param id
     */
    getParticipantIndex(r) {
      return this.participants.findIndex((s) => s.id === r);
    }
    /**
     * Find the participant by id.
     * @param id
     */
    getParticipant(r) {
      return this.participants.find((s) => s.id === r);
    }
    /**
     * Remove a participant from the participants list.
     */
    deleteParticipant(r) {
      this.participants = this.participants.filter((s) => s.id !== r);
    }
    /**
     * Helper to return the conversation host.
     */
    get host() {
      return this.participants.find((r) => r.isHost === !0);
    }
    /**
     * Helper to return the current user.
     */
    get me() {
      return this.getParticipant(this.meId);
    }
  }
  return je.InternalParticipants = e, je.ConversationTranslatorMessageTypes = {
    command: "command",
    final: "final",
    info: "info",
    instantMessage: "instant_message",
    keepAlive: "keep_alive",
    partial: "partial",
    participantCommand: "participant_command",
    translatedMessage: "translated_message"
  }, je.ConversationTranslatorCommandTypes = {
    changeNickname: "ChangeNickname",
    disconnectSession: "DisconnectSession",
    ejectParticipant: "EjectParticipant",
    instant_message: "instant_message",
    joinSession: "JoinSession",
    leaveSession: "LeaveSession",
    participantList: "ParticipantList",
    roomExpirationWarning: "RoomExpirationWarning",
    setLockState: "SetLockState",
    setMute: "SetMute",
    setMuteAll: "SetMuteAll",
    setProfanityFiltering: "SetProfanityFiltering",
    setTranslateToLanguages: "SetTranslateToLanguages",
    setUseTTS: "SetUseTTS"
  }, je;
}
var wa = {}, Qi = {}, dh;
function Gb() {
  if (dh) return Qi;
  dh = 1, Object.defineProperty(Qi, "__esModule", { value: !0 }), Qi.CommandResponsePayload = void 0;
  const e = (r) => JSON.parse(r);
  let t = class Wv {
    constructor(s) {
      this.privCommandResponse = e(s);
    }
    get type() {
      return this.privCommandResponse.type;
    }
    get command() {
      return this.privCommandResponse.command;
    }
    get id() {
      return this.privCommandResponse.id;
    }
    get nickname() {
      return this.privCommandResponse.nickname;
    }
    get participantId() {
      return this.privCommandResponse.participantId;
    }
    get roomid() {
      return this.privCommandResponse.roomid;
    }
    get value() {
      return this.privCommandResponse.value;
    }
    get token() {
      return this.privCommandResponse.token;
    }
    static fromJSON(s) {
      return new Wv(s);
    }
  };
  return Qi.CommandResponsePayload = t, Qi;
}
var It = {}, hh;
function Qb() {
  if (hh) return It;
  hh = 1, Object.defineProperty(It, "__esModule", { value: !0 }), It.ParticipantPayloadResponse = It.ParticipantsListPayloadResponse = void 0;
  const e = (i) => JSON.parse(i), t = (i) => JSON.parse(i);
  class r {
    constructor(a) {
      this.privParticipantsPayloadResponse = e(a);
    }
    get roomid() {
      return this.privParticipantsPayloadResponse.roomid;
    }
    get id() {
      return this.privParticipantsPayloadResponse.id;
    }
    get command() {
      return this.privParticipantsPayloadResponse.command;
    }
    get participants() {
      return this.privParticipantsPayloadResponse.participants;
    }
    get token() {
      return this.privParticipantsPayloadResponse.token;
    }
    get translateTo() {
      return this.privParticipantsPayloadResponse.translateTo;
    }
    get profanityFilter() {
      return this.privParticipantsPayloadResponse.profanityFilter;
    }
    get roomProfanityFilter() {
      return this.privParticipantsPayloadResponse.roomProfanityFilter;
    }
    get roomLocked() {
      return this.privParticipantsPayloadResponse.roomLocked;
    }
    get muteAll() {
      return this.privParticipantsPayloadResponse.muteAll;
    }
    get type() {
      return this.privParticipantsPayloadResponse.type;
    }
    static fromJSON(a) {
      return new r(a);
    }
  }
  It.ParticipantsListPayloadResponse = r;
  class s {
    constructor(a) {
      this.privParticipantPayloadResponse = t(a);
    }
    get nickname() {
      return this.privParticipantPayloadResponse.nickname;
    }
    get locale() {
      return this.privParticipantPayloadResponse.locale;
    }
    get usetts() {
      return this.privParticipantPayloadResponse.usetts;
    }
    get ismuted() {
      return this.privParticipantPayloadResponse.ismuted;
    }
    get ishost() {
      return this.privParticipantPayloadResponse.ishost;
    }
    get participantId() {
      return this.privParticipantPayloadResponse.participantId;
    }
    get avatar() {
      return this.privParticipantPayloadResponse.avatar;
    }
    static fromJSON(a) {
      return new s(a);
    }
  }
  return It.ParticipantPayloadResponse = s, It;
}
var At = {}, fh;
function Yb() {
  if (fh) return At;
  fh = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.TextResponsePayload = At.SpeechResponsePayload = void 0;
  const e = (i) => JSON.parse(i), t = (i) => JSON.parse(i);
  class r {
    constructor(a) {
      this.privSpeechResponse = e(a);
    }
    get recognition() {
      return this.privSpeechResponse.recognition;
    }
    get translations() {
      return this.privSpeechResponse.translations;
    }
    get id() {
      return this.privSpeechResponse.id;
    }
    get language() {
      return this.privSpeechResponse.language;
    }
    get nickname() {
      return this.privSpeechResponse.nickname;
    }
    get participantId() {
      return this.privSpeechResponse.participantId;
    }
    get roomid() {
      return this.privSpeechResponse.roomid;
    }
    get timestamp() {
      return this.privSpeechResponse.timestamp;
    }
    get type() {
      return this.privSpeechResponse.type;
    }
    get isFinal() {
      return this.privSpeechResponse.type === "final";
    }
    static fromJSON(a) {
      return new r(a);
    }
  }
  At.SpeechResponsePayload = r;
  class s {
    constructor(a) {
      this.privTextResponse = t(a);
    }
    get originalText() {
      return this.privTextResponse.originalText;
    }
    get translations() {
      return this.privTextResponse.translations;
    }
    get id() {
      return this.privTextResponse.id;
    }
    get language() {
      return this.privTextResponse.language;
    }
    get nickname() {
      return this.privTextResponse.nickname;
    }
    get participantId() {
      return this.privTextResponse.participantId;
    }
    get roomid() {
      return this.privTextResponse.roomid;
    }
    get timestamp() {
      return this.privTextResponse.timestamp;
    }
    get type() {
      return this.privTextResponse.type;
    }
    static fromJSON(a) {
      return new s(a);
    }
  }
  return At.TextResponsePayload = s, At;
}
var vh;
function Zb() {
  return vh || (vh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TextResponsePayload = e.SpeechResponsePayload = e.ParticipantPayloadResponse = e.ParticipantsListPayloadResponse = e.CommandResponsePayload = void 0;
    var t = /* @__PURE__ */ Gb();
    Object.defineProperty(e, "CommandResponsePayload", { enumerable: !0, get: function() {
      return t.CommandResponsePayload;
    } });
    var r = /* @__PURE__ */ Qb();
    Object.defineProperty(e, "ParticipantsListPayloadResponse", { enumerable: !0, get: function() {
      return r.ParticipantsListPayloadResponse;
    } }), Object.defineProperty(e, "ParticipantPayloadResponse", { enumerable: !0, get: function() {
      return r.ParticipantPayloadResponse;
    } });
    var s = /* @__PURE__ */ Yb();
    Object.defineProperty(e, "SpeechResponsePayload", { enumerable: !0, get: function() {
      return s.SpeechResponsePayload;
    } }), Object.defineProperty(e, "TextResponsePayload", { enumerable: !0, get: function() {
      return s.TextResponsePayload;
    } });
  }(wa)), wa;
}
var gh;
function Xb() {
  if (gh) return Ji;
  gh = 1, Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.ConversationServiceAdapter = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ O(), s = /* @__PURE__ */ Uv(), i = /* @__PURE__ */ Jb(), a = /* @__PURE__ */ $v(), o = /* @__PURE__ */ Vv(), n = /* @__PURE__ */ Zb();
  let c = class extends r.ServiceRecognizerBase {
    constructor(l, p, d, h, f) {
      super(l, p, d, h, f), this.privConnectionConfigPromise = void 0, this.privLastPartialUtteranceId = "", this.privConversationServiceConnector = f, this.privConversationAuthentication = l, this.receiveMessageOverride = () => this.receiveConversationMessageOverride(), this.recognizeOverride = () => this.noOp(), this.postConnectImplOverride = (g) => this.conversationConnectImpl(g), this.configConnectionOverride = () => this.configConnection(), this.disconnectOverride = () => this.privDisconnect(), this.privConversationRequestSession = new i.ConversationRequestSession((0, e.createNoDashGuid)()), this.privConversationConnectionFactory = p, this.privConversationIsDisposed = !1;
    }
    isDisposed() {
      return super.isDisposed() || this.privConversationIsDisposed;
    }
    async dispose(l) {
      this.privConversationIsDisposed = !0, this.privConnectionConfigPromise !== void 0 && await (await this.privConnectionConfigPromise).dispose(l), await super.dispose(l);
    }
    async sendMessage(l) {
      return (await this.fetchConnection()).send(new s.ConversationConnectionMessage(e.MessageType.Text, l));
    }
    async sendMessageAsync(l) {
      await (await this.fetchConnection()).send(new s.ConversationConnectionMessage(e.MessageType.Text, l));
    }
    privDisconnect() {
      if (!this.terminateMessageLoop)
        return this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, t.CancellationReason.Error, t.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async processTypeSpecificMessages() {
      return !0;
    }
    // Cancels recognition.
    cancelRecognition(l, p, d, h, f) {
      this.terminateMessageLoop = !0;
      const g = new t.ConversationTranslationCanceledEventArgs(d, f, h, void 0, l);
      try {
        this.privConversationServiceConnector.canceled && this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, g);
      } catch {
      }
    }
    /**
     * Establishes a websocket connection to the end point.
     */
    async conversationConnectImpl(l) {
      return this.privConnectionLoop = this.startMessageLoop(), l;
    }
    /**
     * Process incoming websocket messages
     */
    async receiveConversationMessageOverride() {
      if (this.isDisposed() || this.terminateMessageLoop)
        return Promise.resolve();
      const l = new e.Deferred();
      try {
        const d = await (await this.fetchConnection()).read();
        if (this.isDisposed() || this.terminateMessageLoop)
          return l.resolve(), Promise.resolve();
        if (!d)
          return this.receiveConversationMessageOverride();
        const h = this.privConversationRequestSession.sessionId, f = d.conversationMessageType.toLowerCase();
        let g = !1;
        try {
          switch (f) {
            case "info":
            case "participant_command":
            case "command":
              const m = n.CommandResponsePayload.fromJSON(d.textBody);
              switch (m.command.toLowerCase()) {
                /**
                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.
                 * The consuming client must wait for this message to arrive
                 * before starting to send their own data.
                 */
                case "participantlist":
                  const w = n.ParticipantsListPayloadResponse.fromJSON(d.textBody), I = w.participants.map((B) => ({
                    avatar: B.avatar,
                    displayName: B.nickname,
                    id: B.participantId,
                    isHost: B.ishost,
                    isMuted: B.ismuted,
                    isUsingTts: B.usetts,
                    preferredLanguage: B.locale
                  }));
                  this.privConversationServiceConnector.participantsListReceived && this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new a.ParticipantsListEventArgs(w.roomid, w.token, w.translateTo, w.profanityFilter, w.roomProfanityFilter, w.roomLocked, w.muteAll, I, h));
                  break;
                /**
                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).
                 * This is sent at the start of the Conversation
                 */
                case "settranslatetolanguages":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, o.ConversationTranslatorCommandTypes.setTranslateToLanguages, m.value, h));
                  break;
                /**
                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.
                 * If sent by the participant the setting will effect only their own profanity level.
                 * If sent by the host, the setting will effect all participants including the host.
                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'
                 */
                case "setprofanityfiltering":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, o.ConversationTranslatorCommandTypes.setProfanityFiltering, m.value, h));
                  break;
                /**
                 * 'SetMute' is sent if the participant has been muted by the host.
                 * Check the 'participantId' to determine if the current user has been muted.
                 */
                case "setmute":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, o.ConversationTranslatorCommandTypes.setMute, m.value, h));
                  break;
                /**
                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.
                 */
                case "setmuteall":
                  this.privConversationServiceConnector.muteAllCommandReceived && this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new a.MuteAllEventArgs(m.value, h));
                  break;
                /**
                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.
                 */
                case "roomexpirationwarning":
                  this.privConversationServiceConnector.conversationExpiration && this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new t.ConversationExpirationEventArgs(m.value, this.privConversationRequestSession.sessionId));
                  break;
                /**
                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.
                 */
                case "setusetts":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, o.ConversationTranslatorCommandTypes.setUseTTS, m.value, h));
                  break;
                /**
                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.
                 */
                case "setlockstate":
                  this.privConversationServiceConnector.lockRoomCommandReceived && this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new a.LockRoomEventArgs(m.value, h));
                  break;
                /**
                 * 'ChangeNickname' is received if a user changes their display name.
                 * Any cached particpiants list should be updated to reflect the display name.
                 */
                case "changenickname":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, o.ConversationTranslatorCommandTypes.changeNickname, m.value, h));
                  break;
                /**
                 * 'JoinSession' is sent when a user joins the Conversation.
                 */
                case "joinsession":
                  const E = n.ParticipantPayloadResponse.fromJSON(d.textBody), T = {
                    avatar: E.avatar,
                    displayName: E.nickname,
                    id: E.participantId,
                    isHost: E.ishost,
                    isMuted: E.ismuted,
                    isUsingTts: E.usetts,
                    preferredLanguage: E.locale
                  };
                  this.privConversationServiceConnector.participantJoinCommandReceived && this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new a.ParticipantEventArgs(T, h));
                  break;
                /**
                 * 'LeaveSession' is sent when a user leaves the Conversation'.
                 */
                case "leavesession":
                  const b = {
                    id: m.participantId
                  };
                  this.privConversationServiceConnector.participantLeaveCommandReceived && this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new a.ParticipantEventArgs(b, h));
                  break;
                /**
                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).
                 * Check the 'ParticipantId' to check whether the message is for the current user.
                 */
                case "disconnectsession":
                  const _ = {
                    id: m.participantId
                  };
                  break;
                case "token":
                  const k = new r.CognitiveTokenAuthentication(() => {
                    const B = m.token;
                    return Promise.resolve(B);
                  }, () => {
                    const B = m.token;
                    return Promise.resolve(B);
                  });
                  this.authentication = k, this.privConversationServiceConnector.onToken(k);
                  break;
                /**
                 * Message not recognized.
                 */
                default:
                  break;
              }
              break;
            /**
             * 'partial' (or 'hypothesis') represents a unfinalized speech message.
             */
            case "partial":
            /**
             * 'final' (or 'phrase') represents a finalized speech message.
             */
            case "final":
              const v = n.SpeechResponsePayload.fromJSON(d.textBody), y = f === "final" ? t.ResultReason.TranslatedParticipantSpeech : t.ResultReason.TranslatingParticipantSpeech, S = new t.ConversationTranslationResult(v.participantId, this.getTranslations(v.translations), v.language, v.id, y, v.recognition, void 0, void 0, d.textBody, void 0);
              v.isFinal ? ((S.text !== void 0 && S.text.length > 0 || v.id === this.privLastPartialUtteranceId) && (g = !0), g && this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(o.ConversationTranslatorMessageTypes.final, S, h))) : S.text !== void 0 && (this.privLastPartialUtteranceId = v.id, this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(o.ConversationTranslatorMessageTypes.partial, S, h)));
              break;
            /**
             * "translated_message" is a text message or instant message (IM).
             */
            case "translated_message":
              const C = n.TextResponsePayload.fromJSON(d.textBody), R = new t.ConversationTranslationResult(C.participantId, this.getTranslations(C.translations), C.language, void 0, void 0, C.originalText, void 0, void 0, void 0, d.textBody, void 0);
              this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(o.ConversationTranslatorMessageTypes.instantMessage, R, h));
              break;
            default:
              break;
          }
        } catch {
        }
        return this.receiveConversationMessageOverride();
      } catch {
        this.terminateMessageLoop = !0;
      }
      return l.promise;
    }
    async startMessageLoop() {
      if (this.isDisposed())
        return Promise.resolve();
      this.terminateMessageLoop = !1;
      const l = this.receiveConversationMessageOverride();
      try {
        return await l;
      } catch (p) {
        return this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", t.CancellationReason.Error, t.CancellationErrorCode.RuntimeError, p), null;
      }
    }
    // Takes an established websocket connection to the endpoint
    configConnection() {
      return this.isDisposed() ? Promise.resolve(void 0) : this.privConnectionConfigPromise !== void 0 ? this.privConnectionConfigPromise.then((l) => l.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection()) : this.privConnectionConfigPromise, () => (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection())) : this.terminateMessageLoop ? Promise.resolve(void 0) : (this.privConnectionConfigPromise = this.connectImpl().then((l) => l), this.privConnectionConfigPromise);
    }
    getTranslations(l) {
      let p;
      if (l !== void 0) {
        p = new t.Translations();
        for (const d of l)
          p.set(d.lang, d.translation);
      }
      return p;
    }
  };
  return Ji.ConversationServiceAdapter = c, Ji;
}
var mh;
function ew() {
  if (mh) return Et;
  mh = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.ConversationTranslatorRecognizer = Et.ConversationRecognizerFactory = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ z(), s = /* @__PURE__ */ A(), i = /* @__PURE__ */ Kb(), a = /* @__PURE__ */ Xb();
  class o {
    static fromConfig(u, l, p) {
      return new n(u, l, p);
    }
  }
  Et.ConversationRecognizerFactory = o;
  let n = class extends s.Recognizer {
    constructor(u, l, p) {
      const d = l;
      r.Contracts.throwIfNull(d, "speechConfig");
      const h = u;
      r.Contracts.throwIfNull(h, "conversationImpl"), super(p, d.properties, new i.ConversationConnectionFactory()), this.privConversation = h, this.privIsDisposed = !1, this.privProperties = d.properties.clone(), this.privConnection = s.Connection.fromRecognizer(this), this.privProperties.getProperty(s.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? (this.privSetTimeout = t.Timeout.setTimeout, this.privClearTimeout = t.Timeout.clearTimeout) : typeof window < "u" ? (this.privSetTimeout = window.setTimeout.bind(window), this.privClearTimeout = window.clearTimeout.bind(window)) : (this.privSetTimeout = setTimeout, this.privClearTimeout = clearTimeout);
    }
    set connected(u) {
      this.privConnection.connected = u;
    }
    set disconnected(u) {
      this.privConnection.disconnected = u;
    }
    /**
     * Return the speech language used by the recognizer
     */
    get speechRecognitionLanguage() {
      return this.privSpeechRecognitionLanguage;
    }
    /**
     * Return the properties for the recognizer
     */
    get properties() {
      return this.privProperties;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    /**
     * Connect to the recognizer
     * @param token
     */
    connect(u, l, p) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfNullOrWhitespace(u, "token"), this.privReco.conversationTranslatorToken = u, this.resetConversationTimeout(), this.privReco.connectAsync(l, p);
      } catch (d) {
        if (p)
          if (d instanceof Error) {
            const h = d;
            p(h.name + ": " + h.message);
          } else
            p(d);
      }
    }
    /**
     * Disconnect from the recognizer
     */
    disconnect(u, l) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privReco.disconnect().then(() => {
          u && u();
        }, (p) => {
          l && l(p);
        });
      } catch (p) {
        if (l)
          if (p instanceof Error) {
            const d = p;
            l(d.name + ": " + d.message);
          } else
            l(p);
        this.dispose(!0).catch((d) => {
          t.Events.instance.onEvent(new t.BackgroundEvent(d));
        });
      }
    }
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendRequest(u, l, p) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), this.sendMessage(u, l, p);
      } catch (d) {
        if (p)
          if (d instanceof Error) {
            const h = d;
            p(h.name + ": " + h.message);
          } else
            p(d);
        this.dispose(!0).catch((h) => {
          t.Events.instance.onEvent(new t.BackgroundEvent(h));
        });
      }
    }
    /**
     * Handle update of service auth token (#694)
     */
    onToken(u) {
      this.privConversation.onToken(u);
    }
    /**
     * Close and dispose the recognizer
     */
    async close() {
      this.privIsDisposed || (this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close()), this.privConnection = void 0, await this.dispose(!0));
    }
    /**
     * Dispose the recognizer
     * @param disposing
     */
    async dispose(u) {
      this.privIsDisposed || u && (this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privIsDisposed = !0, this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close(), this.privConnection = void 0), await super.dispose(u));
    }
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    createRecognizerConfig(u) {
      return new e.RecognizerConfig(u, this.privProperties);
    }
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    createServiceRecognizer(u, l, p, d) {
      const h = p;
      return new a.ConversationServiceAdapter(u, l, h, d, this);
    }
    sendMessage(u, l, p) {
      const d = this.privReco;
      ((f, g, m) => {
        f !== void 0 ? f.then(() => {
          try {
            g && g();
          } catch (v) {
            m && m(`'Unhandled error on promise callback: ${v}'`);
          }
        }, (v) => {
          try {
            m && m(v);
          } catch {
          }
        }) : m && m("Null promise");
      })(d.sendMessageAsync(u), l, p), this.resetConversationTimeout();
    }
    resetConversationTimeout() {
      this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privTimeoutToken = this.privSetTimeout(() => {
        this.sendRequest(this.privConversation.getKeepAlive());
      }, 6e4);
    }
  };
  return Et.ConversationTranslatorRecognizer = n, Et;
}
var Yi = {}, yh;
function tw() {
  if (yh) return Yi;
  yh = 1, Object.defineProperty(Yi, "__esModule", { value: !0 }), Yi.TranscriberRecognizer = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ O(), i = /* @__PURE__ */ Se();
  let a = class extends r.Recognizer {
    /**
     * TranscriberRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      t.Contracts.throwIfNull(u, "speechTranslationConfig");
      const l = c;
      t.Contracts.throwIfNull(l, "audioConfigImpl"), t.Contracts.throwIfNullOrWhitespace(u.speechRecognitionLanguage, r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new s.TranscriberConnectionFactory()), this.privDisposedRecognizer = !1, this.isMeetingRecognizer = !1;
    }
    get speechRecognitionLanguage() {
      return t.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    get properties() {
      return this.privProperties;
    }
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(n) {
      t.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    set conversation(n) {
      t.Contracts.throwIfNullOrUndefined(n, "Conversation"), this.isMeetingRecognizer = !1, this.privConversation = n;
    }
    getConversationInfo() {
      return t.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation"), this.privConversation.conversationInfo;
    }
    set meeting(n) {
      t.Contracts.throwIfNullOrUndefined(n, "Meeting"), this.isMeetingRecognizer = !0, this.privMeeting = n;
    }
    getMeetingInfo() {
      return t.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting"), this.privMeeting.meetingInfo;
    }
    IsMeetingRecognizer() {
      return this.isMeetingRecognizer;
    }
    startContinuousRecognitionAsync(n, c) {
      (0, e.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(i.RecognitionMode.Conversation), n, c);
    }
    stopContinuousRecognitionAsync(n, c) {
      (0, e.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    async close() {
      this.privDisposedRecognizer || await this.dispose(!0);
    }
    // Push async join/leave conversation message via serviceRecognizer
    async pushConversationEvent(n, c) {
      const u = this.privReco;
      t.Contracts.throwIfNullOrUndefined(u, "serviceRecognizer"), await u.sendSpeechEventAsync(n, c);
    }
    // Push async join/leave meeting message via serviceRecognizer
    async pushMeetingEvent(n, c) {
      const u = this.privReco;
      t.Contracts.throwIfNullOrUndefined(u, "serviceRecognizer"), await u.sendMeetingSpeechEventAsync(n, c);
    }
    async enforceAudioGating() {
      const u = (await this.audioConfig.format).channels;
      if (u === 1) {
        if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true")
          throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
      } else if (u !== 8)
        throw new Error(`Unsupported audio configuration: Detected ${u}-channel audio`);
    }
    connectMeetingCallbacks(n) {
      this.isMeetingRecognizer = !0, this.canceled = (c, u) => {
        n.canceled && n.canceled(n, u);
      }, this.recognizing = (c, u) => {
        n.transcribing && n.transcribing(n, u);
      }, this.recognized = (c, u) => {
        n.transcribed && n.transcribed(n, u);
      }, this.sessionStarted = (c, u) => {
        n.sessionStarted && n.sessionStarted(n, u);
      }, this.sessionStopped = (c, u) => {
        n.sessionStopped && n.sessionStopped(n, u);
      };
    }
    disconnectCallbacks() {
      this.canceled = void 0, this.recognizing = void 0, this.recognized = void 0, this.sessionStarted = void 0, this.sessionStopped = void 0;
    }
    /**
     * Disposes any resources held by the object.
     * @member ConversationTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new s.RecognizerConfig(n, this.properties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new s.TranscriptionServiceRecognizer(n, c, p, l, this);
    }
  };
  return Yi.TranscriberRecognizer = a, Yi;
}
var Sh;
function rw() {
  return Sh || (Sh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.InternalParticipants = e.ConversationTranslatorMessageTypes = e.ConversationTranslatorCommandTypes = e.ParticipantsListEventArgs = e.ParticipantEventArgs = e.ParticipantAttributeEventArgs = e.MuteAllEventArgs = e.LockRoomEventArgs = e.ConversationReceivedTranslationEventArgs = e.TranscriberRecognizer = e.ConversationRecognizerFactory = e.ConversationConnectionConfig = e.ConversationManager = void 0;
    var t = /* @__PURE__ */ Wb();
    Object.defineProperty(e, "ConversationManager", { enumerable: !0, get: function() {
      return t.ConversationManager;
    } });
    var r = /* @__PURE__ */ cc();
    Object.defineProperty(e, "ConversationConnectionConfig", { enumerable: !0, get: function() {
      return r.ConversationConnectionConfig;
    } });
    var s = /* @__PURE__ */ ew();
    Object.defineProperty(e, "ConversationRecognizerFactory", { enumerable: !0, get: function() {
      return s.ConversationRecognizerFactory;
    } });
    var i = /* @__PURE__ */ tw();
    Object.defineProperty(e, "TranscriberRecognizer", { enumerable: !0, get: function() {
      return i.TranscriberRecognizer;
    } });
    var a = /* @__PURE__ */ $v();
    Object.defineProperty(e, "ConversationReceivedTranslationEventArgs", { enumerable: !0, get: function() {
      return a.ConversationReceivedTranslationEventArgs;
    } }), Object.defineProperty(e, "LockRoomEventArgs", { enumerable: !0, get: function() {
      return a.LockRoomEventArgs;
    } }), Object.defineProperty(e, "MuteAllEventArgs", { enumerable: !0, get: function() {
      return a.MuteAllEventArgs;
    } }), Object.defineProperty(e, "ParticipantAttributeEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantAttributeEventArgs;
    } }), Object.defineProperty(e, "ParticipantEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantEventArgs;
    } }), Object.defineProperty(e, "ParticipantsListEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantsListEventArgs;
    } });
    var o = /* @__PURE__ */ Vv();
    Object.defineProperty(e, "ConversationTranslatorCommandTypes", { enumerable: !0, get: function() {
      return o.ConversationTranslatorCommandTypes;
    } }), Object.defineProperty(e, "ConversationTranslatorMessageTypes", { enumerable: !0, get: function() {
      return o.ConversationTranslatorMessageTypes;
    } }), Object.defineProperty(e, "InternalParticipants", { enumerable: !0, get: function() {
      return o.InternalParticipants;
    } });
  }(ba)), ba;
}
var Ea = {}, Ch;
function Hv() {
  return Ch || (Ch = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SynthesisAudioMetadata = e.MetadataType = void 0, function(r) {
      r.WordBoundary = "WordBoundary", r.Bookmark = "Bookmark", r.Viseme = "Viseme", r.SentenceBoundary = "SentenceBoundary", r.SessionEnd = "SessionEnd", r.AvatarSignal = "TalkingAvatarSignal";
    }(e.MetadataType || (e.MetadataType = {}));
    class t {
      constructor(s) {
        this.privSynthesisAudioMetadata = JSON.parse(s);
      }
      static fromJSON(s) {
        return new t(s);
      }
      get Metadata() {
        return this.privSynthesisAudioMetadata.Metadata;
      }
    }
    e.SynthesisAudioMetadata = t;
  }(Ea)), Ea;
}
var Zi = {}, Ee = {}, Rh;
function nw() {
  if (Rh) return Ee;
  Rh = 1, Object.defineProperty(Ee, "__esModule", { value: !0 }), Ee.SynthesisStartedEvent = Ee.ConnectingToSynthesisServiceEvent = Ee.SynthesisTriggeredEvent = Ee.SpeechSynthesisEvent = void 0;
  const e = /* @__PURE__ */ D();
  class t extends e.PlatformEvent {
    constructor(o, n, c = e.EventType.Info) {
      super(o, c), this.privRequestId = n;
    }
    get requestId() {
      return this.privRequestId;
    }
  }
  Ee.SpeechSynthesisEvent = t;
  class r extends t {
    constructor(o, n, c) {
      super("SynthesisTriggeredEvent", o), this.privSessionAudioDestinationId = n, this.privTurnAudioDestinationId = c;
    }
    get audioSessionDestinationId() {
      return this.privSessionAudioDestinationId;
    }
    get audioTurnDestinationId() {
      return this.privTurnAudioDestinationId;
    }
  }
  Ee.SynthesisTriggeredEvent = r;
  class s extends t {
    constructor(o, n) {
      super("ConnectingToSynthesisServiceEvent", o), this.privAuthFetchEventId = n;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  Ee.ConnectingToSynthesisServiceEvent = s;
  class i extends t {
    constructor(o, n) {
      super("SynthesisStartedEvent", o), this.privAuthFetchEventId = n;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  return Ee.SynthesisStartedEvent = i, Ee;
}
var Ph;
function iw() {
  if (Ph) return Zi;
  Ph = 1, Object.defineProperty(Zi, "__esModule", { value: !0 }), Zi.SynthesisTurn = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ Wt(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ Hv(), i = /* @__PURE__ */ nw();
  let a = class Va {
    constructor() {
      this.privIsDisposed = !1, this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !1, this.privBytesReceived = 0, this.privInTurn = !1, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privRequestId = (0, e.createNoDashGuid)(), this.privTurnDeferral = new e.Deferred(), this.privTurnDeferral.resolve();
    }
    get requestId() {
      return this.privRequestId;
    }
    get streamId() {
      return this.privStreamId;
    }
    set streamId(n) {
      this.privStreamId = n;
    }
    get audioOutputFormat() {
      return this.privAudioOutputFormat;
    }
    set audioOutputFormat(n) {
      this.privAudioOutputFormat = n;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSynthesisEnded() {
      return this.privIsSynthesisEnded;
    }
    get isSynthesizing() {
      return this.privIsSynthesizing;
    }
    get currentTextOffset() {
      return this.privTextOffset;
    }
    get currentSentenceOffset() {
      return this.privSentenceOffset;
    }
    // The number of bytes received for current turn
    get bytesReceived() {
      return this.privBytesReceived;
    }
    get audioDuration() {
      return this.privAudioDuration;
    }
    get extraProperties() {
      if (this.privWebRTCSDP) {
        const n = new r.PropertyCollection();
        return n.setProperty(r.PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP), n;
      }
    }
    async getAllReceivedAudio() {
      return this.privReceivedAudio ? Promise.resolve(this.privReceivedAudio) : this.privIsSynthesisEnded ? (await this.readAllAudioFromStream(), Promise.resolve(this.privReceivedAudio)) : null;
    }
    async getAllReceivedAudioWithHeader() {
      if (this.privReceivedAudioWithHeader)
        return this.privReceivedAudioWithHeader;
      if (!this.privIsSynthesisEnded)
        return null;
      if (this.audioOutputFormat.hasHeader) {
        const n = await this.getAllReceivedAudio();
        return this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(n), this.privReceivedAudioWithHeader;
      } else
        return this.getAllReceivedAudio();
    }
    startNewSynthesis(n, c, u, l) {
      this.privIsSynthesisEnded = !1, this.privIsSynthesizing = !0, this.privRequestId = n, this.privRawText = c, this.privIsSSML = u, this.privAudioOutputStream = new t.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privAudioOutputFormat, this.privReceivedAudio = null, this.privReceivedAudioWithHeader = null, this.privBytesReceived = 0, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privPartialVisemeAnimation = "", this.privWebRTCSDP = "", l !== void 0 && (this.privTurnAudioDestination = l, this.privTurnAudioDestination.format = this.privAudioOutputFormat), this.onEvent(new i.SynthesisTriggeredEvent(this.requestId, void 0, l === void 0 ? void 0 : l.id()));
    }
    onPreConnectionStart(n) {
      this.privAuthFetchEventId = n, this.onEvent(new i.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
    }
    onAuthCompleted(n) {
      n && this.onComplete();
    }
    onConnectionEstablishCompleted(n) {
      if (n === 200) {
        this.onEvent(new i.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId)), this.privBytesReceived = 0;
        return;
      } else n === 403 && this.onComplete();
    }
    onServiceResponseMessage(n) {
      const c = JSON.parse(n);
      this.streamId = c.audio.streamId;
    }
    onServiceTurnEndResponse() {
      this.privInTurn = !1, this.privTurnDeferral.resolve(), this.onComplete();
    }
    onServiceTurnStartResponse(n) {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new e.Deferred();
      const c = JSON.parse(n);
      c.webrtc && (this.privWebRTCSDP = c.webrtc.connectionString);
    }
    onAudioChunkReceived(n) {
      this.isSynthesizing && (this.privAudioOutputStream.write(n), this.privBytesReceived += n.byteLength, this.privTurnAudioDestination !== void 0 && this.privTurnAudioDestination.write(n));
    }
    onTextBoundaryEvent(n) {
      this.updateTextOffset(n.Data.text.Text, n.Type);
    }
    onVisemeMetadataReceived(n) {
      n.Data.AnimationChunk !== void 0 && (this.privPartialVisemeAnimation += n.Data.AnimationChunk);
    }
    onSessionEnd(n) {
      this.privAudioDuration = n.Data.Offset;
    }
    async constructSynthesisResult() {
      const n = await this.getAllReceivedAudioWithHeader();
      return new r.SpeechSynthesisResult(this.requestId, r.ResultReason.SynthesizingAudioCompleted, n, void 0, this.extraProperties, this.audioDuration);
    }
    dispose() {
      this.privIsDisposed || (this.privIsDisposed = !0);
    }
    onStopSynthesizing() {
      this.onComplete();
    }
    /**
     * Gets the viseme animation string (merged from animation chunk), and clears the internal
     * partial animation.
     */
    getAndClearVisemeAnimation() {
      const n = this.privPartialVisemeAnimation;
      return this.privPartialVisemeAnimation = "", n;
    }
    onEvent(n) {
      e.Events.instance.onEvent(n);
    }
    /**
     * Check if the text is an XML(SSML) tag
     * @param text
     * @private
     */
    static isXmlTag(n) {
      return n.length >= 2 && n[0] === "<" && n[n.length - 1] === ">";
    }
    updateTextOffset(n, c) {
      c === s.MetadataType.WordBoundary ? (this.privTextOffset = this.privRawText.indexOf(n, this.privNextSearchTextIndex), this.privTextOffset >= 0 && (this.privNextSearchTextIndex = this.privTextOffset + n.length, this.privIsSSML && this.withinXmlTag(this.privTextOffset) && !Va.isXmlTag(n) && this.updateTextOffset(n, c))) : (this.privSentenceOffset = this.privRawText.indexOf(n, this.privNextSearchSentenceIndex), this.privSentenceOffset >= 0 && (this.privNextSearchSentenceIndex = this.privSentenceOffset + n.length, this.privIsSSML && this.withinXmlTag(this.privSentenceOffset) && !Va.isXmlTag(n) && this.updateTextOffset(n, c)));
    }
    onComplete() {
      this.privIsSynthesizing && (this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !0, this.privAudioOutputStream.close(), this.privInTurn = !1, this.privTurnAudioDestination !== void 0 && (this.privTurnAudioDestination.close(), this.privTurnAudioDestination = void 0));
    }
    async readAllAudioFromStream() {
      if (this.privIsSynthesisEnded) {
        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
        try {
          await this.privAudioOutputStream.read(this.privReceivedAudio);
        } catch {
          this.privReceivedAudio = new ArrayBuffer(0);
        }
      }
    }
    /**
     * Check if current idx is in XML(SSML) tag
     * @param idx
     * @private
     */
    withinXmlTag(n) {
      return this.privRawText.indexOf("<", n + 1) > this.privRawText.indexOf(">", n + 1);
    }
  };
  return Zi.SynthesisTurn = a, Zi;
}
var Xi = {}, bh;
function sw() {
  if (bh) return Xi;
  bh = 1, Object.defineProperty(Xi, "__esModule", { value: !0 }), Xi.SynthesisAdapterBase = void 0;
  const e = /* @__PURE__ */ D(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ O(), s = /* @__PURE__ */ Ht();
  let i = class {
    constructor(o, n, c, u) {
      if (this.speakOverride = void 0, this.receiveMessageOverride = void 0, this.connectImplOverride = void 0, this.configConnectionOverride = void 0, this.privConnectionConfigurationPromise = void 0, !o)
        throw new e.ArgumentNullError("authentication");
      if (!n)
        throw new e.ArgumentNullError("connectionFactory");
      if (!c)
        throw new e.ArgumentNullError("synthesizerConfig");
      this.privAuthentication = o, this.privConnectionFactory = n, this.privSynthesizerConfig = c, this.privIsDisposed = !1, this.privSessionAudioDestination = u, this.privSynthesisTurn = new r.SynthesisTurn(), this.privConnectionEvents = new e.EventSource(), this.privServiceEvents = new e.EventSource(), this.privSynthesisContext = new r.SynthesisContext(), this.privAgentConfig = new r.AgentConfig(), this.connectionEvents.attach((l) => {
        if (l.name === "ConnectionClosedEvent") {
          const p = l;
          p.statusCode !== 1e3 && this.cancelSynthesisLocal(t.CancellationReason.Error, p.statusCode === 1007 ? t.CancellationErrorCode.BadRequestParameters : t.CancellationErrorCode.ConnectionFailure, `${p.reason} websocket error code: ${p.statusCode}`);
        }
      });
    }
    get synthesisContext() {
      return this.privSynthesisContext;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    set activityTemplate(o) {
      this.privActivityTemplate = o;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set audioOutputFormat(o) {
      this.privAudioOutputFormat = o, this.privSynthesisTurn.audioOutputFormat = o, this.privSessionAudioDestination !== void 0 && (this.privSessionAudioDestination.format = o), this.synthesisContext !== void 0 && (this.synthesisContext.audioOutputFormat = o);
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(o) {
      this.privIsDisposed = !0, this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.close(), this.privConnectionConfigurationPromise !== void 0 && await (await this.privConnectionConfigurationPromise).dispose(o);
    }
    async connect() {
      await this.connectImpl();
    }
    async sendNetworkMessage(o, n) {
      const c = typeof n == "string" ? e.MessageType.Text : e.MessageType.Binary, u = typeof n == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new s.SpeechConnectionMessage(c, o, this.privSynthesisTurn.requestId, u, n));
    }
    async Speak(o, n, c, u, l, p) {
      let d;
      if (n ? d = o : d = this.privSynthesizer.buildSsml(o), this.speakOverride !== void 0)
        return this.speakOverride(d, c, u, l);
      this.privSuccessCallback = u, this.privErrorCallback = l, this.privSynthesisTurn.startNewSynthesis(c, o, n, p);
      try {
        await this.connectImpl();
        const h = await this.fetchConnection();
        await this.sendSynthesisContext(h), await this.sendSsmlMessage(h, d, c), this.onSynthesisStarted(c), this.receiveMessage();
      } catch (h) {
        return this.cancelSynthesisLocal(t.CancellationReason.Error, t.CancellationErrorCode.ConnectionFailure, h), Promise.reject(h);
      }
    }
    async stopSpeaking() {
      return await this.connectImpl(), (await this.fetchConnection()).send(new s.SpeechConnectionMessage(e.MessageType.Text, "synthesis.control", this.privSynthesisTurn.requestId, "application/json", JSON.stringify({
        action: "stop"
      })));
    }
    // Cancels synthesis.
    cancelSynthesis(o, n, c, u) {
      const l = new t.PropertyCollection();
      l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]);
      const p = new t.SpeechSynthesisResult(o, t.ResultReason.Canceled, void 0, u, l);
      if (this.onSynthesisCancelled(p), this.privSuccessCallback)
        try {
          this.privSuccessCallback(p);
        } catch {
        }
    }
    // Cancels synthesis.
    cancelSynthesisLocal(o, n, c) {
      this.privSynthesisTurn.isSynthesizing && (this.privSynthesisTurn.onStopSynthesizing(), this.cancelSynthesis(this.privSynthesisTurn.requestId, o, n, c));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processTypeSpecificMessages(o) {
      return !0;
    }
    async receiveMessage() {
      try {
        const n = await (await this.fetchConnection()).read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (this.privIsDisposed)
          return;
        if (!n)
          return this.privSynthesisTurn.isSynthesizing ? this.receiveMessage() : void 0;
        const c = s.SpeechConnectionMessage.fromConnectionMessage(n);
        if (c.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase())
          switch (c.path.toLowerCase()) {
            case "turn.start":
              this.privSynthesisTurn.onServiceTurnStartResponse(c.textBody);
              break;
            case "response":
              this.privSynthesisTurn.onServiceResponseMessage(c.textBody);
              break;
            case "audio":
              this.privSynthesisTurn.streamId.toLowerCase() === c.streamId.toLowerCase() && c.binaryBody && (this.privSynthesisTurn.onAudioChunkReceived(c.binaryBody), this.onSynthesizing(c.binaryBody), this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.write(c.binaryBody));
              break;
            case "audio.metadata":
              const u = r.SynthesisAudioMetadata.fromJSON(c.textBody).Metadata;
              for (const p of u)
                switch (p.Type) {
                  case r.MetadataType.WordBoundary:
                  case r.MetadataType.SentenceBoundary:
                    this.privSynthesisTurn.onTextBoundaryEvent(p);
                    const d = new t.SpeechSynthesisWordBoundaryEventArgs(p.Data.Offset, p.Data.Duration, p.Data.text.Text, p.Data.text.Length, p.Type === r.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, p.Data.text.BoundaryType);
                    this.onWordBoundary(d);
                    break;
                  case r.MetadataType.Bookmark:
                    const h = new t.SpeechSynthesisBookmarkEventArgs(p.Data.Offset, p.Data.Bookmark);
                    this.onBookmarkReached(h);
                    break;
                  case r.MetadataType.Viseme:
                    if (this.privSynthesisTurn.onVisemeMetadataReceived(p), p.Data.IsLastAnimation) {
                      const f = new t.SpeechSynthesisVisemeEventArgs(p.Data.Offset, p.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                      this.onVisemeReceived(f);
                    }
                    break;
                  case r.MetadataType.AvatarSignal:
                    this.onAvatarEvent(p);
                    break;
                  case r.MetadataType.SessionEnd:
                    this.privSynthesisTurn.onSessionEnd(p);
                    break;
                }
              break;
            case "turn.end":
              this.privSynthesisTurn.onServiceTurnEndResponse();
              let l;
              try {
                l = await this.privSynthesisTurn.constructSynthesisResult(), this.privSuccessCallback && this.privSuccessCallback(l);
              } catch (p) {
                this.privErrorCallback && this.privErrorCallback(p);
              }
              this.onSynthesisCompleted(l);
              break;
            default:
              this.processTypeSpecificMessages(c) || this.privServiceEvents && this.serviceEvents.onEvent(new e.ServiceEvent(c.path.toLowerCase(), c.textBody));
          }
        return this.receiveMessage();
      } catch {
      }
    }
    sendSynthesisContext(o) {
      this.setSynthesisContextSynthesisSection();
      const n = this.synthesisContext.toJSON();
      if (n)
        return o.send(new s.SpeechConnectionMessage(e.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", n));
    }
    setSpeechConfigSynthesisSection() {
    }
    connectImpl(o = !1) {
      if (this.privConnectionPromise != null)
        return this.privConnectionPromise.then((c) => c.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()));
      this.privAuthFetchEventId = (0, e.createNoDashGuid)(), this.privConnectionId = (0, e.createNoDashGuid)(), this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
      const n = o ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
      return this.privConnectionPromise = n.then(async (c) => {
        this.privSynthesisTurn.onAuthCompleted(!1);
        const u = await this.privConnectionFactory.create(this.privSynthesizerConfig, c, this.privConnectionId);
        u.events.attach((p) => {
          this.connectionEvents.onEvent(p);
        });
        const l = await u.open();
        return l.statusCode === 200 ? (this.privSynthesisTurn.onConnectionEstablishCompleted(l.statusCode), Promise.resolve(u)) : l.statusCode === 403 && !o ? this.connectImpl(!0) : (this.privSynthesisTurn.onConnectionEstablishCompleted(l.statusCode), Promise.reject(`Unable to contact server. StatusCode: ${l.statusCode},
                    ${this.privSynthesizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Url)} Reason: ${l.reason}`));
      }, (c) => {
        throw this.privSynthesisTurn.onAuthCompleted(!0), new Error(c);
      }), this.privConnectionPromise.catch(() => {
      }), this.privConnectionPromise;
    }
    sendSpeechServiceConfig(o, n) {
      if (n)
        return o.send(new s.SpeechConnectionMessage(e.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", n));
    }
    sendSsmlMessage(o, n, c) {
      return o.send(new s.SpeechConnectionMessage(e.MessageType.Text, "ssml", c, "application/ssml+xml", n));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((o) => o.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const o = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(o) : (this.setSpeechConfigSynthesisSection(), await this.sendSpeechServiceConfig(o, this.privSynthesizerConfig.SpeechServiceConfig.serialize()), o);
    }
    onAvatarEvent(o) {
    }
    onSynthesisStarted(o) {
    }
    onSynthesizing(o) {
    }
    onSynthesisCancelled(o) {
    }
    onSynthesisCompleted(o) {
    }
    onWordBoundary(o) {
    }
    onVisemeReceived(o) {
    }
    onBookmarkReached(o) {
    }
  };
  return Xi.SynthesisAdapterBase = i, i.telemetryDataEnabled = !0, Xi;
}
var es = {}, wh;
function ow() {
  if (wh) return es;
  wh = 1, Object.defineProperty(es, "__esModule", { value: !0 }), es.AvatarSynthesisAdapter = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ O();
  let r = class extends t.SynthesisAdapterBase {
    constructor(i, a, o, n, c) {
      super(i, a, o, void 0), this.privAvatarSynthesizer = n, this.privSynthesizer = n, this.privAvatarConfig = c;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(void 0);
    }
    setSpeechConfigSynthesisSection() {
      this.privSynthesizerConfig.synthesisVideoSection = {
        format: {
          bitrate: this.privAvatarConfig.videoFormat?.bitrate,
          codec: this.privAvatarConfig.videoFormat?.codec,
          crop: {
            bottomRight: {
              x: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.x,
              y: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.y
            },
            topLeft: {
              x: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.x,
              y: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.y
            }
          },
          resolution: {
            height: this.privAvatarConfig.videoFormat?.height,
            width: this.privAvatarConfig.videoFormat?.width
          }
        },
        protocol: {
          name: "WebRTC",
          webrtcConfig: {
            clientDescription: btoa(this.privSynthesizerConfig.parameters.getProperty(e.PropertyId.TalkingAvatarService_WebRTC_SDP)),
            iceServers: this.privAvatarConfig.remoteIceServers ?? this.privAvatarSynthesizer.iceServers
          }
        },
        talkingAvatar: {
          background: {
            color: this.privAvatarConfig.backgroundColor,
            image: {
              url: this.privAvatarConfig.backgroundImage?.toString()
            }
          },
          character: this.privAvatarConfig.character,
          customized: this.privAvatarConfig.customized,
          style: this.privAvatarConfig.style,
          useBuiltInVoice: this.privAvatarConfig.useBuiltInVoice
        }
      };
    }
    onAvatarEvent(i) {
      if (this.privAvatarSynthesizer.avatarEventReceived) {
        const a = new e.AvatarEventArgs(i.Data.Offset, i.Data.Name);
        try {
          this.privAvatarSynthesizer.avatarEventReceived(this.privAvatarSynthesizer, a);
        } catch {
        }
      }
    }
  };
  return es.AvatarSynthesisAdapter = r, es;
}
var ts = {}, Eh;
function aw() {
  if (Eh) return ts;
  Eh = 1, Object.defineProperty(ts, "__esModule", { value: !0 }), ts.SpeechSynthesisAdapter = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ O();
  let r = class extends t.SynthesisAdapterBase {
    constructor(i, a, o, n, c) {
      super(i, a, o, c), this.privSpeechSynthesizer = n, this.privSynthesizer = n;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(this.privSpeechSynthesizer);
    }
    onSynthesisStarted(i) {
      const a = new e.SpeechSynthesisEventArgs(new e.SpeechSynthesisResult(i, e.ResultReason.SynthesizingAudioStarted));
      this.privSpeechSynthesizer.synthesisStarted && this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, a);
    }
    onSynthesizing(i) {
      if (this.privSpeechSynthesizer.synthesizing)
        try {
          const a = this.privSynthesisTurn.audioOutputFormat.addHeader(i), o = new e.SpeechSynthesisEventArgs(new e.SpeechSynthesisResult(this.privSynthesisTurn.requestId, e.ResultReason.SynthesizingAudio, a));
          this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, o);
        } catch {
        }
    }
    onSynthesisCancelled(i) {
      if (this.privSpeechSynthesizer.SynthesisCanceled) {
        const a = new e.SpeechSynthesisEventArgs(i);
        try {
          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, a);
        } catch {
        }
      }
    }
    onSynthesisCompleted(i) {
      if (this.privSpeechSynthesizer.synthesisCompleted)
        try {
          this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new e.SpeechSynthesisEventArgs(i));
        } catch {
        }
    }
    onWordBoundary(i) {
      if (this.privSpeechSynthesizer.wordBoundary)
        try {
          this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
    onVisemeReceived(i) {
      if (this.privSpeechSynthesizer.visemeReceived)
        try {
          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
    onBookmarkReached(i) {
      if (this.privSpeechSynthesizer.bookmarkReached)
        try {
          this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
  };
  return ts.SpeechSynthesisAdapter = r, ts;
}
var rs = {}, Ih;
function cw() {
  if (Ih) return rs;
  Ih = 1, Object.defineProperty(rs, "__esModule", { value: !0 }), rs.SynthesisRestAdapter = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Ae(), s = /* @__PURE__ */ ue();
  let i = class {
    constructor(o, n) {
      let c = o.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      if (!c) {
        const l = o.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, "westus"), p = r.ConnectionFactoryBase.getHostSuffix(l);
        c = o.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, `https://${l}.tts.speech${p}`);
      }
      this.privUri = `${c}/cognitiveservices/voices/list`;
      const u = e.RestConfigBase.requestOptions;
      this.privRestAdapter = new e.RestMessageAdapter(u), this.privAuthentication = n;
    }
    /**
     * Sends list voices request to endpoint.
     * @function
     * @public
     * @param connectionId - guid for connectionId
     * @returns {Promise<IRestResponse>} rest response to status request
     */
    getVoicesList(o) {
      return this.privRestAdapter.setHeaders(s.HeaderNames.ConnectionId, o), this.privAuthentication.fetch(o).then((n) => (this.privRestAdapter.setHeaders(n.headerName, n.token), this.privRestAdapter.request(e.RestRequestType.Get, this.privUri)));
    }
  };
  return rs.SynthesisRestAdapter = i, rs;
}
var Ia = {}, Ah;
function uw() {
  return Ah || (Ah = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SynthesizerConfig = e.SynthesisServiceType = void 0;
    const t = /* @__PURE__ */ O();
    var r;
    (function(i) {
      i[i.Standard = 0] = "Standard", i[i.Custom = 1] = "Custom";
    })(r = e.SynthesisServiceType || (e.SynthesisServiceType = {}));
    class s {
      constructor(a, o) {
        this.privSynthesisServiceType = r.Standard, this.avatarEnabled = !1, this.privSpeechServiceConfig = a || new t.SpeechServiceConfig(new t.Context(null)), this.privParameters = o;
      }
      get parameters() {
        return this.privParameters;
      }
      get synthesisServiceType() {
        return this.privSynthesisServiceType;
      }
      set synthesisServiceType(a) {
        this.privSynthesisServiceType = a;
      }
      set synthesisVideoSection(a) {
        this.privSpeechServiceConfig.Context.synthesis = {
          video: a
        };
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
    }
    e.SynthesizerConfig = s;
  }(Ia)), Ia;
}
var ns = {}, Th;
function lw() {
  if (Th) return ns;
  Th = 1, Object.defineProperty(ns, "__esModule", { value: !0 }), ns.SynthesisContext = void 0;
  const e = /* @__PURE__ */ A();
  let t = class {
    constructor() {
      this.privContext = {};
    }
    /**
     * Adds a section to the synthesis.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */
    setSection(s, i) {
      this.privContext[s] = i;
    }
    /**
     * Sets the audio output format for synthesis context generation.
     * @param format {AudioOutputFormatImpl} the output format
     */
    set audioOutputFormat(s) {
      this.privAudioOutputFormat = s;
    }
    toJSON() {
      return JSON.stringify(this.privContext);
    }
    setSynthesisSection(s) {
      const i = this.buildSynthesisContext(s);
      this.setSection("synthesis", i);
    }
    buildSynthesisContext(s) {
      return {
        audio: {
          metadataOptions: {
            bookmarkEnabled: !!s?.bookmarkReached,
            punctuationBoundaryEnabled: s?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!s?.wordBoundary),
            sentenceBoundaryEnabled: s?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, !1),
            sessionEndEnabled: !0,
            visemeEnabled: !!s?.visemeReceived,
            wordBoundaryEnabled: s?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!s?.wordBoundary)
          },
          outputFormat: this.privAudioOutputFormat.requestAudioFormatString
        },
        language: {
          autoDetection: s?.autoDetectSourceLanguage
        }
      };
    }
  };
  return ns.SynthesisContext = t, ns;
}
var is = {}, _h;
function pw() {
  if (_h) return is;
  _h = 1, Object.defineProperty(is, "__esModule", { value: !0 }), is.SpeakerRecognitionConfig = void 0;
  const e = /* @__PURE__ */ O();
  let t = class {
    constructor(s, i) {
      this.privContext = s || new e.Context(null), this.privParameters = i;
    }
    get parameters() {
      return this.privParameters;
    }
    get Context() {
      return this.privContext;
    }
  };
  return is.SpeakerRecognitionConfig = t, is;
}
var ss = {}, kh;
function dw() {
  if (kh) return ss;
  kh = 1, Object.defineProperty(ss, "__esModule", { value: !0 }), ss.SpeakerServiceRecognizer = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ O(), i = /* @__PURE__ */ Ht();
  let a = class extends s.ServiceRecognizerBase {
    constructor(n, c, u, l, p) {
      super(n, c, u, l, p), this.privSpeakerRecognizer = p, this.privSpeakerAudioSource = u, this.recognizeSpeaker = (d) => this.recognizeSpeakerOnce(d), this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    processTypeSpecificMessages(n) {
      let c = !1;
      const u = new r.PropertyCollection();
      switch (n.messageType === t.MessageType.Text && u.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, n.textBody), n.path.toLowerCase()) {
        case "speaker.response":
          const p = JSON.parse(n.textBody);
          let d;
          p.status.statusCode.toLowerCase() !== "success" ? d = new r.SpeakerRecognitionResult(p, r.ResultReason.Canceled, r.CancellationErrorCode.ServiceError, p.status.reason) : d = new r.SpeakerRecognitionResult(p, r.ResultReason.RecognizedSpeaker), this.privResultDeferral && this.privResultDeferral.resolve(d), c = !0;
          break;
      }
      const l = new t.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(n, c, u, l, p) {
      if (new r.PropertyCollection().setProperty(s.CancellationErrorCodePropertyName, r.CancellationErrorCode[l]), this.privResultDeferral) {
        const h = new r.SpeakerRecognitionResult({
          scenario: this.privSpeakerModel.scenario,
          status: { statusCode: p, reason: p }
        }, r.ResultReason.Canceled, l, p);
        try {
          this.privResultDeferral.resolve(h);
        } catch (f) {
          this.privResultDeferral.reject(f);
        }
      }
    }
    async recognizeSpeakerOnce(n) {
      this.privSpeakerModel = n, this.voiceProfileType = n.scenario, this.privResultDeferral || (this.privResultDeferral = new t.Deferred()), this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(r.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const c = this.connectImpl(), u = this.sendPreAudioMessages(this.extractSpeakerContext(n)), l = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), p = await this.privSpeakerAudioSource.format, d = await this.privSpeakerAudioSource.deviceInfo, h = new e.ReplayableAudioNode(l, p.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(h, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: d };
      try {
        await c, await u;
      } catch (m) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, m);
      }
      const f = new r.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, f), this.receiveMessage(), this.sendAudio(h).then(() => {
      }, (m) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, m);
      }), this.privResultDeferral.promise;
    }
    async sendPreAudioMessages(n) {
      const c = await this.fetchConnection();
      await this.sendSpeakerRecognition(c, n);
    }
    async sendSpeakerRecognition(n, c) {
      const u = JSON.stringify(c);
      return n.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", u));
    }
    extractSpeakerContext(n) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: n.profileIds,
        scenario: n.scenario
      };
    }
  };
  return ss.SpeakerServiceRecognizer = a, ss;
}
var os = {}, Oh;
function hw() {
  if (Oh) return os;
  Oh = 1, Object.defineProperty(os, "__esModule", { value: !0 }), os.VoiceServiceRecognizer = void 0;
  const e = /* @__PURE__ */ ne(), t = /* @__PURE__ */ D(), r = /* @__PURE__ */ A(), s = /* @__PURE__ */ O(), i = /* @__PURE__ */ Ht();
  let a = class extends s.ServiceRecognizerBase {
    constructor(n, c, u, l, p) {
      super(n, c, u, l, p), this.privDeferralMap = new t.DeferralMap(), this.privSpeakerAudioSource = u, this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    set SpeakerAudioSource(n) {
      this.privSpeakerAudioSource = n;
    }
    processTypeSpecificMessages(n) {
      let c = !1;
      const u = new r.PropertyCollection();
      switch (n.messageType === t.MessageType.Text && u.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, n.textBody), n.path.toLowerCase()) {
        // Profile management response for create, fetch, delete, reset
        case "speaker.profiles":
          const p = JSON.parse(n.textBody);
          switch (p.operation.toLowerCase()) {
            case "create":
              this.handleCreateResponse(p, n.requestId);
              break;
            case "delete":
            case "reset":
              this.handleResultResponse(p, n.requestId);
              break;
            case "fetch":
              const g = JSON.parse(n.textBody);
              this.handleFetchResponse(g, n.requestId);
              break;
          }
          c = !0;
          break;
        // Activation and authorization phrase response
        case "speaker.phrases":
          const d = JSON.parse(n.textBody);
          this.handlePhrasesResponse(d, n.requestId), c = !0;
          break;
        // Enrollment response
        case "speaker.profile.enrollment":
          const h = JSON.parse(n.textBody), f = new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(h.enrollment ? h.enrollment.enrollmentStatus : h.status.statusCode), h.enrollment ? JSON.stringify(h.enrollment) : void 0, h.status.reason);
          this.privDeferralMap.getId(n.requestId) && this.privDeferralMap.complete(n.requestId, f), this.privRequestSession.onSpeechEnded(), c = !0;
          break;
      }
      const l = new t.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(n, c, u, l, p) {
      new r.PropertyCollection().setProperty(s.CancellationErrorCodePropertyName, r.CancellationErrorCode[l]);
      const h = new r.VoiceProfileEnrollmentResult(r.ResultReason.Canceled, p, p);
      this.privDeferralMap.getId(c) && this.privDeferralMap.complete(c, h);
    }
    async createProfile(n, c) {
      this.voiceProfileType = n.toString();
      const u = this.connectImpl();
      try {
        const l = new t.Deferred();
        return await u, await this.sendCreateProfile(l, n, c), this.receiveMessage(), l.promise;
      } catch (l) {
        throw l;
      }
    }
    async resetProfile(n) {
      return this.voiceProfileType = n.profileType.toString(), this.sendCommonRequest("reset", n.profileType, n);
    }
    async deleteProfile(n) {
      return this.voiceProfileType = n.profileType.toString(), this.sendCommonRequest("delete", n.profileType, n);
    }
    async retrieveEnrollmentResult(n) {
      return this.voiceProfileType = n.profileType.toString(), this.privExpectedProfileId = n.profileId, this.sendCommonRequest("fetch", n.profileType, n);
    }
    async getAllProfiles(n) {
      return this.voiceProfileType = n.toString(), this.sendCommonRequest("fetch", n);
    }
    async getActivationPhrases(n, c) {
      this.voiceProfileType = n.toString();
      const u = this.connectImpl();
      try {
        const l = new t.Deferred();
        return await u, await this.sendPhrasesRequest(l, n, c), this.receiveMessage(), l.promise;
      } catch (l) {
        throw l;
      }
    }
    async enrollProfile(n) {
      this.voiceProfileType = n.profileType.toString();
      const c = new t.Deferred();
      this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(r.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const u = this.connectImpl(), l = this.sendPreAudioMessages(n, c), p = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), d = await this.privSpeakerAudioSource.format, h = await this.privSpeakerAudioSource.deviceInfo, f = new e.ReplayableAudioNode(p, d.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(f, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: h };
      try {
        await u, await l;
      } catch (v) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, v);
      }
      const g = new r.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, g), this.receiveMessage(), this.sendAudio(f).then(() => {
      }, (v) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, v);
      }), c.promise;
    }
    async sendPreAudioMessages(n, c) {
      const u = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, c), await this.sendBaseRequest(u, "enroll", this.scenarioFrom(n.profileType), n);
    }
    async sendPhrasesRequest(n, c, u) {
      const l = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, n);
      const p = this.scenarioFrom(c), d = {
        locale: u,
        scenario: p
      };
      return l.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(d)));
    }
    async sendCreateProfile(n, c, u) {
      const l = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, n);
      const p = c === r.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : c === r.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification", d = {
        locale: u,
        number: "1",
        scenario: p
      };
      return l.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(d)));
    }
    async sendCommonRequest(n, c, u = void 0) {
      const l = this.connectImpl();
      try {
        const p = new t.Deferred();
        this.privRequestSession.onSpeechContext(), await l;
        const d = await this.fetchConnection();
        return this.privDeferralMap.add(this.privRequestSession.requestId, p), await this.sendBaseRequest(d, n, this.scenarioFrom(c), u), this.receiveMessage(), p.promise;
      } catch (p) {
        throw p;
      }
    }
    async sendBaseRequest(n, c, u, l) {
      const p = {
        scenario: u
      };
      return l ? p.profileIds = [l.profileId] : p.maxPageSize = -1, n.send(new i.SpeechConnectionMessage(t.MessageType.Text, `speaker.profile.${c}`, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(p)));
    }
    extractSpeakerContext(n) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: n.profileIds,
        scenario: n.scenario
      };
    }
    handlePhrasesResponse(n, c) {
      if (this.privDeferralMap.getId(c))
        if (n.status.statusCode.toLowerCase() !== "success") {
          const u = r.ResultReason.Canceled, l = new r.VoiceProfilePhraseResult(u, n.status.statusCode, n.passPhraseType, []);
          this.privDeferralMap.complete(c, l);
        } else if (n.phrases && n.phrases.length > 0) {
          const u = r.ResultReason.EnrollingVoiceProfile, l = new r.VoiceProfilePhraseResult(u, n.status.statusCode, n.passPhraseType, n.phrases);
          this.privDeferralMap.complete(c, l);
        } else
          throw new Error("Voice Profile get activation phrases failed, no phrases received");
      else
        throw new Error(`Voice Profile get activation phrases request for requestID ${c} not found`);
    }
    handleCreateResponse(n, c) {
      if (n.profiles && n.profiles.length > 0)
        if (this.privDeferralMap.getId(c)) {
          const u = n.profiles.map((l) => l.profileId);
          this.privDeferralMap.complete(c, u);
        } else
          throw new Error(`Voice Profile create request for requestID ${c} not found`);
      else
        throw new Error("Voice Profile create failed, no profile id received");
    }
    handleResultResponse(n, c) {
      if (this.privDeferralMap.getId(c)) {
        const u = n.operation.toLowerCase() === "delete" ? r.ResultReason.DeletedVoiceProfile : r.ResultReason.ResetVoiceProfile, l = n.status.statusCode.toLowerCase() === "success" ? u : r.ResultReason.Canceled, p = new r.VoiceProfileResult(l, `statusCode: ${n.status.statusCode}, errorDetails: ${n.status.reason}`);
        this.privDeferralMap.complete(c, p);
      } else
        throw new Error(`Voice Profile create request for requestID ${c} not found`);
    }
    handleFetchResponse(n, c) {
      if (this.privDeferralMap.getId(c) && n.profiles[0]) {
        if (this.privExpectedProfileId && n.profiles.length === 1 && n.profiles[0].profileId === this.privExpectedProfileId) {
          this.privExpectedProfileId = void 0;
          const u = n.profiles[0], l = new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(u.enrollmentStatus), JSON.stringify(u), n.status.reason);
          this.privDeferralMap.complete(c, l);
        } else if (n.profiles.length > 0) {
          const u = n.profiles, l = [];
          for (const p of u)
            l.push(new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(p.enrollmentStatus), JSON.stringify(p), n.status.reason));
          this.privDeferralMap.complete(c, l);
        }
      } else
        throw new Error(`Voice Profile fetch request for requestID ${c} not found`);
    }
    enrollmentReasonFrom(n) {
      switch (n.toLowerCase()) {
        case "enrolled":
          return r.ResultReason.EnrolledVoiceProfile;
        case "invalidlocale":
        case "invalidphrase":
        case "invalidaudioformat":
        case "invalidscenario":
        case "invalidprofilecount":
        case "invalidoperation":
        case "audiotooshort":
        case "audiotoolong":
        case "toomanyenrollments":
        case "storageconflict":
        case "profilenotfound":
        case "incompatibleprofiles":
        case "incompleteenrollment":
          return r.ResultReason.Canceled;
        default:
          return r.ResultReason.EnrollingVoiceProfile;
      }
    }
    scenarioFrom(n) {
      return n === r.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : n === r.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    }
  };
  return os.VoiceServiceRecognizer = a, os;
}
var Aa = {}, Mh;
function fw() {
  return Mh || (Mh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.type = e.connectivity = e.Device = e.OS = e.System = e.Context = e.SpeechServiceConfig = void 0;
    class t {
      constructor(n) {
        this.context = n;
      }
      serialize() {
        return JSON.stringify(this, (n, c) => {
          if (c && typeof c == "object" && !Array.isArray(c)) {
            const u = {};
            for (const l in c)
              Object.hasOwnProperty.call(c, l) && (u[l && l.charAt(0).toLowerCase() + l.substring(1)] = c[l]);
            return u;
          }
          return c;
        });
      }
      get Context() {
        return this.context;
      }
      get Recognition() {
        return this.recognition;
      }
      set Recognition(n) {
        this.recognition = n.toLowerCase();
      }
    }
    e.SpeechServiceConfig = t;
    class r {
      constructor(n) {
        this.system = new s(), this.os = n;
      }
    }
    e.Context = r;
    class s {
      constructor() {
        const n = "1.44.1";
        this.name = "SpeechSDK", this.version = n, this.build = "JavaScript", this.lang = "JavaScript";
      }
    }
    e.System = s;
    class i {
      constructor(n, c, u) {
        this.platform = n, this.name = c, this.version = u;
      }
    }
    e.OS = i;
    class a {
      constructor(n, c, u) {
        this.manufacturer = n, this.model = c, this.version = u;
      }
    }
    e.Device = a, function(o) {
      o.Bluetooth = "Bluetooth", o.Wired = "Wired", o.WiFi = "WiFi", o.Cellular = "Cellular", o.InBuilt = "InBuilt", o.Unknown = "Unknown";
    }(e.connectivity || (e.connectivity = {})), function(o) {
      o.Phone = "Phone", o.Speaker = "Speaker", o.Car = "Car", o.Headset = "Headset", o.Thermostat = "Thermostat", o.Microphones = "Microphones", o.Deskphone = "Deskphone", o.RemoteControl = "RemoteControl", o.Unknown = "Unknown", o.File = "File", o.Stream = "Stream";
    }(e.type || (e.type = {}));
  }(Aa)), Aa;
}
var Dh;
function O() {
  return Dh || (Dh = 1, function(e) {
    var t = ot && ot.__createBinding || (Object.create ? function(a, o, n, c) {
      c === void 0 && (c = n), Object.defineProperty(a, c, { enumerable: !0, get: function() {
        return o[n];
      } });
    } : function(a, o, n, c) {
      c === void 0 && (c = n), a[c] = o[n];
    }), r = ot && ot.__exportStar || function(a, o) {
      for (var n in a) n !== "default" && !Object.prototype.hasOwnProperty.call(o, n) && t(o, a, n);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AutoDetectSourceLanguagesOpenRangeOptionName = e.ForceDictationPropertyName = e.ServicePropertiesPropertyName = e.CancellationErrorCodePropertyName = e.OutputFormatPropertyName = e.SpeechSynthesisAdapter = e.AvatarSynthesisAdapter = void 0, r(/* @__PURE__ */ $C(), e), r(/* @__PURE__ */ VC(), e), r(/* @__PURE__ */ rc(), e), r(/* @__PURE__ */ WC(), e), r(/* @__PURE__ */ HC(), e), r(/* @__PURE__ */ JP(), e), r(/* @__PURE__ */ GP(), e), r(/* @__PURE__ */ ac(), e), r(/* @__PURE__ */ sb(), e), r(/* @__PURE__ */ ob(), e), r(/* @__PURE__ */ ab(), e), r(/* @__PURE__ */ cb(), e), r(/* @__PURE__ */ ub(), e), r(/* @__PURE__ */ lb(), e), r(/* @__PURE__ */ pb(), e), r(/* @__PURE__ */ db(), e), r(/* @__PURE__ */ hb(), e), r(/* @__PURE__ */ Ov(), e), r(/* @__PURE__ */ fb(), e), r(/* @__PURE__ */ vb(), e), r(/* @__PURE__ */ gb(), e), r(/* @__PURE__ */ mb(), e), r(/* @__PURE__ */ yb(), e), r(/* @__PURE__ */ Sb(), e), r(/* @__PURE__ */ Cb(), e), r(/* @__PURE__ */ Rb(), e), r(/* @__PURE__ */ Pb(), e), r(/* @__PURE__ */ bb(), e), r(/* @__PURE__ */ Eb(), e), r(/* @__PURE__ */ Ib(), e), r(/* @__PURE__ */ Ab(), e), r(/* @__PURE__ */ Tb(), e), r(/* @__PURE__ */ _b(), e), r(/* @__PURE__ */ kb(), e), r(/* @__PURE__ */ Ob(), e), r(/* @__PURE__ */ Mb(), e), r(/* @__PURE__ */ Nb(), e), r(/* @__PURE__ */ zb(), e), r(/* @__PURE__ */ jb(), e), r(/* @__PURE__ */ $b(), e), r(/* @__PURE__ */ Vb(), e), r(/* @__PURE__ */ rw(), e), r(/* @__PURE__ */ Hv(), e), r(/* @__PURE__ */ iw(), e), r(/* @__PURE__ */ sw(), e);
    var s = /* @__PURE__ */ ow();
    Object.defineProperty(e, "AvatarSynthesisAdapter", { enumerable: !0, get: function() {
      return s.AvatarSynthesisAdapter;
    } });
    var i = /* @__PURE__ */ aw();
    Object.defineProperty(e, "SpeechSynthesisAdapter", { enumerable: !0, get: function() {
      return i.SpeechSynthesisAdapter;
    } }), r(/* @__PURE__ */ cw(), e), r(/* @__PURE__ */ uw(), e), r(/* @__PURE__ */ lw(), e), r(/* @__PURE__ */ pw(), e), r(/* @__PURE__ */ dw(), e), r(/* @__PURE__ */ hw(), e), r(/* @__PURE__ */ fw(), e), e.OutputFormatPropertyName = "OutputFormat", e.CancellationErrorCodePropertyName = "CancellationErrorCode", e.ServicePropertiesPropertyName = "ServiceProperties", e.ForceDictationPropertyName = "ForceDictation", e.AutoDetectSourceLanguagesOpenRangeOptionName = "UND";
  }(ot)), ot;
}
var Nh;
function vw() {
  return Nh || (Nh = 1, function(e) {
    var t = st && st.__createBinding || (Object.create ? function(i, a, o, n) {
      n === void 0 && (n = o), Object.defineProperty(i, n, { enumerable: !0, get: function() {
        return a[o];
      } });
    } : function(i, a, o, n) {
      n === void 0 && (n = o), i[n] = a[o];
    }), r = st && st.__exportStar || function(i, a) {
      for (var o in i) o !== "default" && !Object.prototype.hasOwnProperty.call(a, o) && t(a, i, o);
    };
    Object.defineProperty(e, "__esModule", { value: !0 });
    const s = /* @__PURE__ */ O();
    new s.AgentConfig(), r(/* @__PURE__ */ A(), e);
  }(st)), st;
}
var as = /* @__PURE__ */ vw();
const gw = ms.Provider, mw = ms.Root, yw = ms.Trigger, Kv = se.forwardRef(({ className: e, sideOffset: t = 4, ...r }, s) => /* @__PURE__ */ P(
  ms.Content,
  {
    ref: s,
    sideOffset: t,
    className: ls(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      e
    ),
    ...r
  }
));
Kv.displayName = ms.Content.displayName;
const Sw = {
  en: "en-US",
  es: "es-ES",
  pt: "pt-PT",
  fr: "fr-FR",
  de: "de-DE",
  zh: "zh-CN",
  ja: "ja-JP",
  hi: "hi-IN",
  ar: "ar-SA",
  ru: "ru-RU"
};
function Jv({
  avatarName: e,
  disabled: t = !1,
  voiceMode: r,
  setSpokenText: s,
  setIsSpeaking: i,
  setInterruptReplica: a,
  region: o,
  speechKey: n
}) {
  const [c, u] = L(!1), [l, p] = L(!1), [d, h] = L(null), f = localStorage.getItem("lang") || "en", g = c ? `You're now talking to ${e}` : `Click here to talk to ${e}`;
  H(() => (c ? m() : v(), () => {
    v();
  }), [c]);
  const m = async () => {
    try {
      const S = as.SpeechConfig.fromSubscription(
        n,
        o
      );
      S.speechRecognitionLanguage = Sw[f || "en"];
      const C = as.AudioConfig.fromDefaultMicrophoneInput(), R = new as.SpeechRecognizer(S, C);
      R.recognizing = (w, I) => {
        console.log(`RECOGNIZING: Text=${I.result.text}`);
      }, R.recognized = (w, I) => {
        I.result.reason === as.ResultReason.RecognizedSpeech && (console.log(`RECOGNIZED: Text=${I.result.text}`), I.result.text && (s(I.result.text), u(!1), i(!1), a(!1)));
      }, R.canceled = (w, I) => {
        console.log(`CANCELED: Reason=${I.reason}`), I.reason === as.CancellationReason.Error && console.error(`ERROR: Details=${I.errorDetails}`), u(!1), i(!1);
      }, R.sessionStopped = () => {
        u(!1), i(!1);
      }, await R.startContinuousRecognitionAsync(), h(R), i(!0), a(!0);
    } catch (S) {
      console.error("Error starting continuous recognition:", S), u(!1), i(!1);
    }
  }, v = async () => {
    if (d)
      try {
        await d.stopContinuousRecognitionAsync(), d.close(), h(null);
      } catch (S) {
        console.error("Error stopping recognition:", S);
      }
  }, y = () => {
    t || l || u(!c);
  };
  return r ? /* @__PURE__ */ P(gw, { children: /* @__PURE__ */ M(mw, { children: [
    /* @__PURE__ */ P(yw, { asChild: !0, children: /* @__PURE__ */ P(
      Te,
      {
        variant: "outline",
        size: "icon",
        onClick: y,
        disabled: t || l || !1,
        className: "rounded-full bg-primary hover:bg-secondary h-9 w-9",
        children: l ? /* @__PURE__ */ P(ka, { className: "w-6 h-6 text-white animate-spin" }) : c ? /* @__PURE__ */ P(Eg, { className: "w-6 h-6 text-white" }) : /* @__PURE__ */ P(Ig, { className: "w-6 h-6 text-white" })
      }
    ) }),
    /* @__PURE__ */ P(Kv, { children: /* @__PURE__ */ P("p", { children: g }) })
  ] }) }) : null;
}
const xh = async (e, t = "", r = "", s = "chat", i = "", a = 0, o = 1, n = "en", c) => {
  for (let u = 0; u < o; u++) {
    const l = new Headers();
    l.append("Accept", "application/json");
    const p = e + "Language: " + n, d = "52533633434137384342", h = new FormData();
    h.append("Input", p), h.append("UserId", t || d), h.append("BusinessId", r), h.append("Intent", s), h.append("SessionId", i), h.append("Platform", "EF0306CD"), c && c.size > 0 ? (h.append("Files", c), console.log("File appended to FormData")) : console.log("No file to append");
    const f = new AbortController(), g = setTimeout(() => f.abort(), 9e4), m = {
      method: "POST",
      headers: l,
      body: h,
      signal: f.signal
      // Add the abort signal to the request
    };
    try {
      const y = await fetch(
        "https://developmentapis.azure-api.net/sandbox/v1/api/AI/assistant",
        m
      );
      if (clearTimeout(g), !y.ok) {
        const C = await y.json();
        throw new Error(
          C?.Message || `HTTP error! Status: ${y.status}`
        );
      }
      const S = await y.json();
      if (S.Success && (S.Data?.Message === null || S.Data?.Message.toUpperCase() === "INVALID JSON" || S.Data?.Message === "local variable 'result' referenced before assignment" || S.Data?.Message === "Object reference not set to an instance of an object." || S.Data?.Message?.toLowerCase().includes("exception thrown"))) {
        console.warn(
          `Attempt ${u + 1}: Success but received null data. Retrying...`
        ), a > 0 && await new Promise((C) => setTimeout(C, a));
        continue;
      }
      return S;
    } catch (v) {
      if (clearTimeout(g), v instanceof Error && v.name === "AbortError")
        return console.error("Request timed out after 90 seconds"), { Success: !1, Message: "ERROR: API timed out", Data: null };
      console.error("Error in chat API:", v);
    }
  }
  return {
    Success: !1,
    Message: "API call failed after all retries",
    Data: null
  };
}, Cw = () => "https://developmentapis.azure-api.net/sandbox/v1/api", uc = (e) => {
  const t = Cw().replace(/\/$/, "");
  let r = e.startsWith("/") ? e : `/${e}`;
  return t.endsWith("/api") && r.startsWith("/api/") && (r = r.replace(/^\/api/, "")), `${t}${r}`;
}, Rw = async (e, t, r, s) => {
  const a = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
      // Indicate JSON payload
    },
    body: JSON.stringify({
      Input: e,
      UserId: t,
      BusinessId: r,
      Accepted: s
    })
    // Convert the payload to a JSON string
  };
  let o;
  try {
    const n = await fetch(
      uc("/api/AI/training"),
      a
    );
    if (!n.ok) {
      const c = await n.text();
      throw console.error("Error details:", c), new Error(`Failed: ${n.statusText} - ${c}`);
    }
    if (n.headers.get("content-length") === "0")
      o = {};
    else {
      const c = n.headers.get("content-type");
      c && c.includes("application/json") ? o = await n.json() : console.error("Unexpected response format:", c);
    }
  } catch (n) {
    console.error("Saving chat error:", n);
  }
  return o;
}, Pw = ({
  onStart: e,
  loading: t,
  buttonText: r = "Start Conversation",
  videoRef: s,
  platform: i,
  replicaId: a,
  containerClassName: o = "",
  imageHeight: n = "auto",
  buttonSize: c = "md",
  learningPrompts: u,
  onPromptClick: l,
  userCredits: p,
  avatars: d,
  config: h
}) => {
  const f = localStorage.getItem("lang") || "en", [g, m] = L({ loading: "Loading...", avatarNotFound: "Avatar not found" }), v = d.find((C) => C.ExternalId === a), y = i === "concierge" ? "AI Medical Concierge" : i === "home" ? "AI Concierge" : i === "pr" ? "PR Strategist" : i === "business_advisor" ? "Medical Advisor" : i === "university" ? "AI Instructor" : i === "survey" ? "AI Surveyor" : "AI Assistant", S = {
    sm: "text-sm px-4 py-2",
    md: "text-base px-6 py-3",
    lg: "text-lg px-8 py-4"
  };
  return H(() => {
    (async () => {
      if (f !== "en") {
        const [R, w] = await Ws(["Loading...", "Avatar not found"], f, "en", h?.azureTranslatorKey || "", h?.azureTranslatorEndpoint || "", h?.azureTranslatorRegion || "");
        m({ loading: R, avatarNotFound: w });
      } else
        m({ loading: "Loading...", avatarNotFound: "Avatar not found" });
    })();
  }, [f]), /* @__PURE__ */ M("div", { className: `flex flex-col items-center justify-center ${o}`, children: [
    /* @__PURE__ */ P("div", { className: `w-full ${n} max-h-[300px] mb-6 relative`, children: v ? /* @__PURE__ */ M(nf, { children: [
      /* @__PURE__ */ P(
        "img",
        {
          ref: s,
          src: v.ImageUrl,
          alt: v.Name,
          className: "w-full h-full object-cover rounded-lg"
        }
      ),
      /* @__PURE__ */ M("div", { className: "absolute top-3 right-3 flex items-center bg-black/70 px-2 py-1 rounded-full text-white text-xs font-medium shadow-md", children: [
        /* @__PURE__ */ M("div", { className: "relative flex h-3 w-3 mr-1.5", children: [
          /* @__PURE__ */ P("span", { className: "animate-ping absolute inline-flex h-full w-full rounded-full bg-green-500 opacity-75" }),
          /* @__PURE__ */ P("span", { className: "relative inline-flex rounded-full h-3 w-3 bg-green-600" })
        ] }),
        /* @__PURE__ */ P("span", { children: "LIVE" })
      ] }),
      /* @__PURE__ */ M("div", { className: "absolute bottom-3 left-3 right-3 bg-gradient-to-t from-black/70 to-transparent p-3 rounded-b-lg", children: [
        /* @__PURE__ */ P("h3", { className: "text-white font-semibold text-sm", children: v.Name }),
        /* @__PURE__ */ P("p", { className: "text-white/80 text-xs", children: y })
      ] })
    ] }) : /* @__PURE__ */ P("div", { className: "w-full h-full bg-light rounded-lg flex items-center justify-center", children: /* @__PURE__ */ P("p", { className: "text-secondary", children: g.avatarNotFound }) }) }),
    /* @__PURE__ */ P(
      "button",
      {
        onClick: e,
        disabled: t || p !== void 0 && p <= 0,
        className: `bg-primary text-white rounded-full font-semibold hover:bg-secondary transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${S[c]}`,
        children: t ? g.loading : r
      }
    ),
    u && u.length > 0 && /* @__PURE__ */ M("div", { className: "mt-6 w-full", children: [
      /* @__PURE__ */ P("h3", { className: "text-lg font-semibold mb-3", children: "Try asking about:" }),
      /* @__PURE__ */ P("div", { className: "space-y-2", children: u.map((C, R) => /* @__PURE__ */ P(
        "button",
        {
          onClick: () => l?.(C),
          className: "w-full text-left p-3 bg-gray-50 hover:bg-gray-100 rounded-lg transition-colors",
          children: C
        },
        R
      )) })
    ] })
  ] });
}, Gv = ({ id: e, style: t = {} }) => {
  const r = cf(e), s = r?.isOff, [i, a] = L(!1), o = Be(null);
  return H(() => {
    const n = o.current;
    if (!n) return;
    const c = () => a(!0);
    return n.addEventListener("canplay", c), () => {
      n.removeEventListener("canplay", c);
    };
  }, [r]), /* @__PURE__ */ M(
    "div",
    {
      className: `w-full rounded-lg overflow-hidden bg-slate-100 relative transition-all duration-300 mx-auto\r
                    h-[200px] sm:h-[250px] md:h-[350px] lg:h-[450px] xl:h-[500px]`,
      style: t,
      children: [
        e && /* @__PURE__ */ P(
          Lg,
          {
            automirror: !0,
            sessionId: e,
            type: "video",
            ref: o,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              display: s || !i ? "none" : "block"
            }
          }
        ),
        !i && !s && /* @__PURE__ */ P("div", { className: "absolute top-0 left-0 w-full h-full flex items-center justify-center bg-slate-100 z-10", children: /* @__PURE__ */ M(
          "svg",
          {
            className: "animate-spin h-8 w-8 text-blue-500",
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ P(
                "circle",
                {
                  className: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ P(
                "path",
                {
                  className: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                }
              )
            ]
          }
        ) }),
        s && /* @__PURE__ */ P("div", { className: "absolute top-0 left-0 w-full h-full flex items-center justify-center bg-slate-100 z-5", children: /* @__PURE__ */ P(
          "svg",
          {
            className: "h-1/2 w-auto",
            width: "24px",
            height: "24px",
            viewBox: "0 0 24 24",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg",
            children: /* @__PURE__ */ M("g", { stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: [
              /* @__PURE__ */ P(
                "path",
                {
                  d: "M18.571,4 C19.142,4 19.557,4.23 19.815,4.689 C20.073,5.148 20.073,5.622 19.815,6.111 L16,12 L19.815,17.889 C20.073,18.377 20.073,18.852 19.815,19.311 C19.557,19.77 19.142,20 18.571,20 L5.429,20 C4.857,20 4.443,19.77 4.185,19.311 C3.927,18.852 3.927,18.377 4.185,17.889 L8,12 L4.185,6.111 C3.927,5.622 3.927,5.148 4.185,4.689 C4.443,4.23 4.857,4 5.429,4 L18.571,4 Z",
                  fill: "#555555"
                }
              ),
              /* @__PURE__ */ P(
                "line",
                {
                  x1: "4",
                  y1: "4",
                  x2: "20",
                  y2: "20",
                  stroke: "#E92A09",
                  strokeWidth: "2.5",
                  strokeLinecap: "round"
                }
              )
            ] })
          }
        ) })
      ]
    }
  );
}, bw = ({
  handleJoin: e,
  handleEnd: t,
  platform: r,
  setScreen: s,
  containerClassName: i = "",
  videoDimensions: a = { width: "100%", height: "auto" },
  buttonsSize: o = "md"
}) => {
  const n = uf(), c = Fs();
  H(() => {
    (async () => {
      if (c) {
        const p = c?.meetingState();
        if (p === "new" || p === "loading")
          try {
            c.startCamera({ startVideoOff: !0, startAudioOff: !0 }), s("call");
          } catch (d) {
            console.warn("Failed to start camera:", d);
          }
        else
          console.log("Call already started, skipping startCamera()");
      }
    })();
  }, [c, n]);
  const u = {
    sm: "px-3 py-1.5 text-xs",
    md: "px-4 py-2 text-sm",
    lg: "px-6 py-3 text-base"
  };
  return /* @__PURE__ */ M(
    af.div,
    {
      className: `flex flex-col items-center ${i}`,
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      transition: { duration: 0.3 },
      children: [
        /* @__PURE__ */ M("div", { className: "mb-4 flex flex-col items-center justify-center gap-4 text-center w-full max-w-2xl mx-auto mt-4 px-2", children: [
          /* @__PURE__ */ P("h2", { className: "text-xl font-bold text-secondary mb-1", children: "Check your camera and microphone" }),
          /* @__PURE__ */ P("p", { className: "text-sm text-secondary", children: "Make sure your devices are working properly before joining" })
        ] }),
        /* @__PURE__ */ P("div", { className: "w-full max-w-lg mb-6 rounded-lg border border-gray-300 overflow-hidden bg-gray-100", children: /* @__PURE__ */ P("div", { className: "p-8 flex items-center justify-center bg-gradient-to-b from-gray-800 to-primary/60 text-white", children: /* @__PURE__ */ M("div", { className: "text-center", children: [
          /* @__PURE__ */ P("div", { className: "mx-auto h-24 w-24 rounded-full bg-black/80 flex items-center justify-center mb-4", children: /* @__PURE__ */ M(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "32",
              height: "32",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ P("path", { d: "M23 7l-7 5 7 5V7z" }),
                /* @__PURE__ */ P("rect", { x: "1", y: "5", width: "15", height: "14", rx: "2", ry: "2" })
              ]
            }
          ) }),
          /* @__PURE__ */ P(
            "div",
            {
              className: "relative rounded-xl border-4 border-primary overflow-hidden shadow-lg",
              style: {
                width: a.width || "100%",
                height: a.height || "auto"
              },
              children: /* @__PURE__ */ P(Gv, { id: n })
            }
          )
        ] }) }) }),
        /* @__PURE__ */ M("div", { className: `flex flex-wrap gap-4 mt-2 justify-center ${o === "sm" ? "scale-90" : o === "lg" ? "scale-110" : ""}`, children: [
          /* @__PURE__ */ M("div", { className: "flex items-center gap-2 px-3 py-2 bg-black/5 rounded-md", children: [
            /* @__PURE__ */ M(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "18",
                height: "18",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ P("path", { d: "M23 7l-7 5 7 5V7z" }),
                  /* @__PURE__ */ P("rect", { x: "1", y: "5", width: "15", height: "14", rx: "2", ry: "2" })
                ]
              }
            ),
            /* @__PURE__ */ P("span", { className: "text-sm", children: "Camera: Ready" })
          ] }),
          /* @__PURE__ */ M("div", { className: "flex items-center gap-2 px-3 py-2 bg-black/5 rounded-md", children: [
            /* @__PURE__ */ M(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "18",
                height: "18",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ P("path", { d: "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" }),
                  /* @__PURE__ */ P("path", { d: "M19 10v2a7 7 0 0 1-14 0v-2" }),
                  /* @__PURE__ */ P("line", { x1: "12", y1: "19", x2: "12", y2: "23" }),
                  /* @__PURE__ */ P("line", { x1: "8", y1: "23", x2: "16", y2: "23" })
                ]
              }
            ),
            /* @__PURE__ */ P("span", { className: "text-sm", children: "Microphone: Ready" })
          ] })
        ] }),
        /* @__PURE__ */ M("div", { className: "flex gap-4 mt-6", children: [
          /* @__PURE__ */ P(
            "button",
            {
              onClick: t,
              className: `border border-primary text-primary rounded-md hover:bg-secondary transition ${u[o]}`,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ P(
            "button",
            {
              onClick: e,
              className: `bg-primary hover:bg-secondary text-white rounded-md transition ${u[o]}`,
              children: "Join Conversation"
            }
          )
        ] })
      ]
    }
  );
}, ww = ({
  actionLabel: e,
  onAction: t,
  cancelLabel: r,
  onCancel: s,
  chatLabel: i,
  onChat: a,
  chatVisible: o = !1,
  platform: n,
  setInterruptReplica: c,
  setIsSpeaking: u,
  setSpokenText: l,
  region: p,
  speechKey: d
}) => {
  Fs();
  const { currentCam: h, currentMic: f, refreshDevices: g } = jg(), m = uf(), v = cf(m), y = qg(m);
  v.isOff, y.isOff;
  const [S, C] = L(!1);
  return H(() => {
    (() => {
      document.querySelectorAll("[data-replit-metadata]").forEach((I) => {
        I.hasAttribute("data-replit-metadata") && I.removeAttribute("data-replit-metadata");
      });
    })();
  }, []), Fg(
    "camera-error",
    Ga(() => {
      C(!0);
    }, [])
  ), /* @__PURE__ */ M("div", { className: "mt-2 p-2 rounded-lg max-w-md flex gap-4 justify-around items-center mx-auto bg-primary", children: [
    /* @__PURE__ */ P("div", { className: "flex items-center", children: /* @__PURE__ */ P(
      Jv,
      {
        avatarName: n === "university" ? "Instructor" : n === "pr" ? "PR Strategist" : n === "business_advisor" ? "Medical Advisor" : n === "survey" ? "AI Surveyor" : n === "concierge" ? "Concierge" : "Business Expert",
        disabled: !1,
        voiceMode: !0,
        setSpokenText: l,
        setIsSpeaking: u,
        setInterruptReplica: c,
        region: p,
        speechKey: d
      }
    ) }),
    e && e === "End Conversation" && /* @__PURE__ */ P(
      "button",
      {
        onClick: t,
        disabled: S || (!h || !f) && n !== "home" && n !== "university" && n !== "concierge" && n !== "pr" && n !== "business_advisor" && n !== "survey",
        className: "flex items-center justify-center p-1 rounded-full border border-white text-white w-10 h-10",
        children: /* @__PURE__ */ P(Wg, { className: "w-6 h-6" })
      }
    )
  ] });
}, Ew = ({
  conversationId: e,
  platform: t,
  videoMode: r,
  endConv: s,
  onAction: i,
  videoHeight: a = "auto",
  aspectRatio: o = "16:9",
  setInterruptReplica: n,
  currentScript: c,
  interruptReplica: u,
  config: l
}) => {
  const p = Fs(), d = Bg({ filter: "remote" }), [h, f] = L("full"), [g, m] = L([]), [v, y] = L(!1), S = localStorage.getItem("lang") || "en", C = Ug({
    onAppMessage: Ga((_) => {
      const k = _.data;
      m((B) => [...B, k]);
    }, [])
  });
  let R = t === "university" ? "AI Instructor" : t === "pr" ? "PR Strategist" : t === "business_advisor" ? "Medical Advisor" : t === "survey" ? "AI Surveyor" : "Medical Concierge";
  const [w, I] = L({ waiting: `${R} will be here shortly...`, endConversation: "Ending Conversation..." });
  H(() => {
    (async () => {
      if (S !== "en") {
        const [k, B] = await Ws([`${R} will be here shortly...`, "Ending Conversation..."], S, "en", l?.azureTranslatorKey || "", l?.azureTranslatorEndpoint || "", l?.azureTranslatorRegion || "");
        I({ waiting: k, endConversation: B });
      } else
        I({ waiting: `${R} will be here shortly...`, endConversation: "Ending Conversation..." });
    })();
  }, [S]);
  const E = (_) => _ ? _.replace(/\*\*/g, "").replace(/[#_][^\s]+/g, "").replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "").replace(/[^\w\s.,!?'"-]/g, "").replace(/\s+/g, " ").trim() : "";
  H(() => {
    const _ = () => y(!0);
    return p && p.on("joined-meeting", _), () => {
      p && p.off("joined-meeting", _);
    };
  }, [p]), H(() => {
    try {
      if (p && v && c) {
        n(!1);
        const _ = E(c);
        T(_);
      }
    } catch (_) {
      console.error("Error sending echo interaction:", _);
    }
  }, [c, v]), H(() => {
    p && v && u && b();
  }, [u]), H(() => {
    r && f(r);
  }, [r]);
  const T = (_) => {
    const k = {
      message_type: "conversation",
      event_type: "conversation.echo",
      conversation_id: e,
      properties: {
        modality: "text",
        text: `${_}`
      }
    };
    console.log("Sending Echo Interaction:", k), C(k, "*");
  }, b = () => {
    const _ = {
      message_type: "conversation",
      event_type: "conversation.interrupt",
      conversation_id: e
    };
    console.log("Sending Echo Interaction:", _), C(_, "*");
  };
  return /* @__PURE__ */ M(nf, { children: [
    /* @__PURE__ */ P("div", { className: "flex flex-col items-center justify-center gap-4 text-center mx-auto px-2 h-full overflow-hidden", children: /* @__PURE__ */ P("div", { className: "relative w-full h-full rounded-xl border-4 border-neutral overflow-hidden shadow-lg", children: d.length > 0 ? /* @__PURE__ */ P(
      "div",
      {
        className: "relative w-full h-full",
        style: {
          backgroundColor: "#000",
          position: "relative",
          overflow: "hidden"
          // To contain absolutely positioned elements
        },
        children: /* @__PURE__ */ P(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              // Add flex to center content if needed
              justifyContent: "center",
              // Center content horizontally
              alignItems: "center"
              // Center content vertically
            },
            children: /* @__PURE__ */ P(
              Gv,
              {
                id: d[0],
                style: {
                  borderRadius: "0px",
                  objectFit: "contain",
                  width: "100%",
                  height: "100%",
                  backgroundColor: "#000"
                }
              }
            )
          }
        )
      }
    ) : /* @__PURE__ */ P(
      "div",
      {
        className: "relative flex justify-center items-center w-full h-full",
        style: {
          backgroundColor: "#000",
          width: "100%",
          height: "100%",
          position: "relative"
        },
        children: /* @__PURE__ */ P("div", { className: "absolute inset-0 flex justify-center items-center", children: /* @__PURE__ */ P("h2", { className: "text-white text-xl text-center px-4", children: s ? w.endConversation : w.waiting }) })
      }
    ) }) }),
    /* @__PURE__ */ P($g, {})
  ] });
}, Iw = ({
  conversation: e,
  handleEnd: t,
  platform: r,
  videoMode: s,
  endConv: i,
  chatVisible: a,
  toggleChat: o,
  containerClassName: n = "",
  videoHeight: c = "auto",
  controlsSize: u = "md",
  aspectRatio: l = "16:9",
  setInterruptReplica: p,
  currentScript: d,
  setCurrentScript: h,
  interruptReplica: f,
  setIsSpeaking: g,
  setSpokenText: m,
  region: v,
  speechKey: y,
  config: S
}) => {
  const C = Fs();
  H(() => {
    (() => {
      document.querySelectorAll("[data-replit-metadata]").forEach((_) => {
        _.hasAttribute("data-replit-metadata") && _.removeAttribute("data-replit-metadata");
      });
    })();
  }, []), H(() => {
    if (e && C) {
      const { conversation_url: T } = e;
      C.join({
        url: T
      });
    }
  }, [C, e]);
  const R = async () => {
    await C?.leave(), t();
  }, w = {
    sm: "scale-75",
    md: "",
    lg: "scale-125"
  }, I = "bottom-4", E = () => c === "auto" ? "min-h-[360px]" : c;
  return /* @__PURE__ */ P("div", { className: `flex flex-col w-full h-full relative ${n}`, children: /* @__PURE__ */ M("div", { className: "flex-1 w-full h-full relative overflow-hidden", children: [
    /* @__PURE__ */ P(
      Ew,
      {
        conversationId: e.conversation_id,
        platform: r,
        videoMode: s,
        endConv: i,
        onAction: R,
        videoHeight: E(),
        aspectRatio: l,
        setInterruptReplica: p,
        currentScript: d,
        interruptReplica: f,
        config: S
      }
    ),
    /* @__PURE__ */ P("div", { className: `absolute ${I} left-0 right-0 z-10 flex justify-center ${w[u]}`, children: /* @__PURE__ */ P(
      ww,
      {
        actionLabel: "End Conversation",
        onAction: R,
        platform: r,
        chatLabel: "Open Chat",
        onChat: o,
        chatVisible: a,
        setInterruptReplica: p,
        setIsSpeaking: g,
        setSpokenText: m,
        region: v,
        speechKey: y
      }
    ) })
  ] }) });
}, Aw = async ({
  replicaId: e,
  personaId: t,
  conversationName: r,
  conversationalContext: s,
  customGreeting: i,
  language: a,
  apiKey: o
}) => {
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": o
    },
    body: JSON.stringify({
      replica_id: e,
      persona_id: t,
      conversation_name: r,
      conversational_context: s,
      custom_greeting: i,
      properties: {
        enable_recording: !1,
        participant_absent_timeout: 180,
        language: a
      }
    })
  };
  try {
    const c = await fetch(
      "https://tavusapi.com/v2/conversations",
      n
    );
    if (!c.ok) {
      const l = c.headers.get("content-type");
      let p;
      throw l && l.includes("application/json") ? p = await c.json() : p = { message: await c.text() }, new Error(
        p?.message || `HTTP error! Status: ${c.status}`
      );
    }
    return await c.json();
  } catch (c) {
    throw console.error("Error creating Tavus conversation:", c), c;
  }
}, zh = async ({
  conversationId: e,
  apiKey: t
}) => {
  const r = {
    method: "POST",
    headers: {
      "x-api-key": t
    }
  };
  try {
    await fetch(
      `https://tavusapi.com/v2/conversations/${e}/end`,
      r
    );
  } catch {
  }
}, Qv = async () => {
  const e = new Headers();
  e.append("Accept", "application/json");
  const t = {
    method: "GET",
    headers: e,
    redirect: "follow"
  };
  let r;
  try {
    const s = await fetch(uc("/api/Avatar/get/all"), t);
    if (!s.ok)
      throw new Error(`HTTP error! status: ${s.status}`);
    r = s.headers.get("content-length") === "0" ? { Success: !0, Data: [] } : await s.json();
  } catch (s) {
    console.error("Error fetching avatars:", s);
  }
  return r;
}, x = (e) => typeof e == "string", cs = () => {
  let e, t;
  const r = new Promise((s, i) => {
    e = s, t = i;
  });
  return r.resolve = e, r.reject = t, r;
}, Lh = (e) => e == null ? "" : "" + e, Tw = (e, t, r) => {
  e.forEach((s) => {
    t[s] && (r[s] = t[s]);
  });
}, _w = /###/g, jh = (e) => e && e.indexOf("###") > -1 ? e.replace(_w, ".") : e, qh = (e) => !e || x(e), ps = (e, t, r) => {
  const s = x(t) ? t.split(".") : t;
  let i = 0;
  for (; i < s.length - 1; ) {
    if (qh(e)) return {};
    const a = jh(s[i]);
    !e[a] && r && (e[a] = new r()), Object.prototype.hasOwnProperty.call(e, a) ? e = e[a] : e = {}, ++i;
  }
  return qh(e) ? {} : {
    obj: e,
    k: jh(s[i])
  };
}, Fh = (e, t, r) => {
  const {
    obj: s,
    k: i
  } = ps(e, t, Object);
  if (s !== void 0 || t.length === 1) {
    s[i] = r;
    return;
  }
  let a = t[t.length - 1], o = t.slice(0, t.length - 1), n = ps(e, o, Object);
  for (; n.obj === void 0 && o.length; )
    a = `${o[o.length - 1]}.${a}`, o = o.slice(0, o.length - 1), n = ps(e, o, Object), n?.obj && typeof n.obj[`${n.k}.${a}`] < "u" && (n.obj = void 0);
  n.obj[`${n.k}.${a}`] = r;
}, kw = (e, t, r, s) => {
  const {
    obj: i,
    k: a
  } = ps(e, t, Object);
  i[a] = i[a] || [], i[a].push(r);
}, Ns = (e, t) => {
  const {
    obj: r,
    k: s
  } = ps(e, t);
  if (r && Object.prototype.hasOwnProperty.call(r, s))
    return r[s];
}, Ow = (e, t, r) => {
  const s = Ns(e, r);
  return s !== void 0 ? s : Ns(t, r);
}, Yv = (e, t, r) => {
  for (const s in t)
    s !== "__proto__" && s !== "constructor" && (s in e ? x(e[s]) || e[s] instanceof String || x(t[s]) || t[s] instanceof String ? r && (e[s] = t[s]) : Yv(e[s], t[s], r) : e[s] = t[s]);
  return e;
}, qt = (e) => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var Mw = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const Dw = (e) => x(e) ? e.replace(/[&<>"'\/]/g, (t) => Mw[t]) : e;
class Nw {
  constructor(t) {
    this.capacity = t, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(t) {
    const r = this.regExpMap.get(t);
    if (r !== void 0)
      return r;
    const s = new RegExp(t);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, s), this.regExpQueue.push(t), s;
  }
}
const xw = [" ", ",", "?", "!", ";"], zw = new Nw(20), Lw = (e, t, r) => {
  t = t || "", r = r || "";
  const s = xw.filter((o) => t.indexOf(o) < 0 && r.indexOf(o) < 0);
  if (s.length === 0) return !0;
  const i = zw.getRegExp(`(${s.map((o) => o === "?" ? "\\?" : o).join("|")})`);
  let a = !i.test(e);
  if (!a) {
    const o = e.indexOf(r);
    o > 0 && !i.test(e.substring(0, o)) && (a = !0);
  }
  return a;
}, Wa = function(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!e) return;
  if (e[t])
    return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0;
  const s = t.split(r);
  let i = e;
  for (let a = 0; a < s.length; ) {
    if (!i || typeof i != "object")
      return;
    let o, n = "";
    for (let c = a; c < s.length; ++c)
      if (c !== a && (n += r), n += s[c], o = i[n], o !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof o) > -1 && c < s.length - 1)
          continue;
        a += c - a + 1;
        break;
      }
    i = o;
  }
  return i;
}, xs = (e) => e?.replace("_", "-"), jw = {
  type: "logger",
  log(e) {
    this.output("log", e);
  },
  warn(e) {
    this.output("warn", e);
  },
  error(e) {
    this.output("error", e);
  },
  output(e, t) {
    console?.[e]?.apply?.(console, t);
  }
};
class zs {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(t, r);
  }
  init(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = r.prefix || "i18next:", this.logger = t || jw, this.options = r, this.debug = r.debug;
  }
  log() {
    for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++)
      r[s] = arguments[s];
    return this.forward(r, "log", "", !0);
  }
  warn() {
    for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++)
      r[s] = arguments[s];
    return this.forward(r, "warn", "", !0);
  }
  error() {
    for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++)
      r[s] = arguments[s];
    return this.forward(r, "error", "");
  }
  deprecate() {
    for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++)
      r[s] = arguments[s];
    return this.forward(r, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(t, r, s, i) {
    return i && !this.debug ? null : (x(t[0]) && (t[0] = `${s}${this.prefix} ${t[0]}`), this.logger[r](t));
  }
  create(t) {
    return new zs(this.logger, {
      prefix: `${this.prefix}:${t}:`,
      ...this.options
    });
  }
  clone(t) {
    return t = t || this.options, t.prefix = t.prefix || this.prefix, new zs(this.logger, t);
  }
}
var _e = new zs();
class Js {
  constructor() {
    this.observers = {};
  }
  on(t, r) {
    return t.split(" ").forEach((s) => {
      this.observers[s] || (this.observers[s] = /* @__PURE__ */ new Map());
      const i = this.observers[s].get(r) || 0;
      this.observers[s].set(r, i + 1);
    }), this;
  }
  off(t, r) {
    if (this.observers[t]) {
      if (!r) {
        delete this.observers[t];
        return;
      }
      this.observers[t].delete(r);
    }
  }
  emit(t) {
    for (var r = arguments.length, s = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      s[i - 1] = arguments[i];
    this.observers[t] && Array.from(this.observers[t].entries()).forEach((o) => {
      let [n, c] = o;
      for (let u = 0; u < c; u++)
        n(...s);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((o) => {
      let [n, c] = o;
      for (let u = 0; u < c; u++)
        n.apply(n, [t, ...s]);
    });
  }
}
class Bh extends Js {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = t || {}, this.options = r, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(t) {
    this.options.ns.indexOf(t) < 0 && this.options.ns.push(t);
  }
  removeNamespaces(t) {
    const r = this.options.ns.indexOf(t);
    r > -1 && this.options.ns.splice(r, 1);
  }
  getResource(t, r, s) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, o = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let n;
    t.indexOf(".") > -1 ? n = t.split(".") : (n = [t, r], s && (Array.isArray(s) ? n.push(...s) : x(s) && a ? n.push(...s.split(a)) : n.push(s)));
    const c = Ns(this.data, n);
    return !c && !r && !s && t.indexOf(".") > -1 && (t = n[0], r = n[1], s = n.slice(2).join(".")), c || !o || !x(s) ? c : Wa(this.data?.[t]?.[r], s, a);
  }
  addResource(t, r, s, i) {
    let a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const o = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator;
    let n = [t, r];
    s && (n = n.concat(o ? s.split(o) : s)), t.indexOf(".") > -1 && (n = t.split("."), i = r, r = n[1]), this.addNamespaces(r), Fh(this.data, n, i), a.silent || this.emit("added", t, r, s, i);
  }
  addResources(t, r, s) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const a in s)
      (x(s[a]) || Array.isArray(s[a])) && this.addResource(t, r, a, s[a], {
        silent: !0
      });
    i.silent || this.emit("added", t, r, s);
  }
  addResourceBundle(t, r, s, i, a) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, n = [t, r];
    t.indexOf(".") > -1 && (n = t.split("."), i = s, s = r, r = n[1]), this.addNamespaces(r);
    let c = Ns(this.data, n) || {};
    o.skipCopy || (s = JSON.parse(JSON.stringify(s))), i ? Yv(c, s, a) : c = {
      ...c,
      ...s
    }, Fh(this.data, n, c), o.silent || this.emit("added", t, r, s);
  }
  removeResourceBundle(t, r) {
    this.hasResourceBundle(t, r) && delete this.data[t][r], this.removeNamespaces(r), this.emit("removed", t, r);
  }
  hasResourceBundle(t, r) {
    return this.getResource(t, r) !== void 0;
  }
  getResourceBundle(t, r) {
    return r || (r = this.options.defaultNS), this.getResource(t, r);
  }
  getDataByLanguage(t) {
    return this.data[t];
  }
  hasLanguageSomeTranslations(t) {
    const r = this.getDataByLanguage(t);
    return !!(r && Object.keys(r) || []).find((i) => r[i] && Object.keys(r[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var Zv = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e;
  },
  handle(e, t, r, s, i) {
    return e.forEach((a) => {
      t = this.processors[a]?.process(t, r, s, i) ?? t;
    }), t;
  }
};
const Uh = {}, $h = (e) => !x(e) && typeof e != "boolean" && typeof e != "number";
class Ls extends Js {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Tw(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = r, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = _e.create("translator");
  }
  changeLanguage(t) {
    t && (this.language = t);
  }
  exists(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    return t == null ? !1 : this.resolve(t, r)?.res !== void 0;
  }
  extractFromKey(t, r) {
    let s = r.nsSeparator !== void 0 ? r.nsSeparator : this.options.nsSeparator;
    s === void 0 && (s = ":");
    const i = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator;
    let a = r.ns || this.options.defaultNS || [];
    const o = s && t.indexOf(s) > -1, n = !this.options.userDefinedKeySeparator && !r.keySeparator && !this.options.userDefinedNsSeparator && !r.nsSeparator && !Lw(t, s, i);
    if (o && !n) {
      const c = t.match(this.interpolator.nestingRegexp);
      if (c && c.length > 0)
        return {
          key: t,
          namespaces: x(a) ? [a] : a
        };
      const u = t.split(s);
      (s !== i || s === i && this.options.ns.indexOf(u[0]) > -1) && (a = u.shift()), t = u.join(i);
    }
    return {
      key: t,
      namespaces: x(a) ? [a] : a
    };
  }
  translate(t, r, s) {
    if (typeof r != "object" && this.options.overloadTranslationOptionHandler && (r = this.options.overloadTranslationOptionHandler(arguments)), typeof r == "object" && (r = {
      ...r
    }), r || (r = {}), t == null) return "";
    Array.isArray(t) || (t = [String(t)]);
    const i = r.returnDetails !== void 0 ? r.returnDetails : this.options.returnDetails, a = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator, {
      key: o,
      namespaces: n
    } = this.extractFromKey(t[t.length - 1], r), c = n[n.length - 1], u = r.lng || this.language, l = r.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (u?.toLowerCase() === "cimode") {
      if (l) {
        const _ = r.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${c}${_}${o}`,
          usedKey: o,
          exactUsedKey: o,
          usedLng: u,
          usedNS: c,
          usedParams: this.getUsedParamsDetails(r)
        } : `${c}${_}${o}`;
      }
      return i ? {
        res: o,
        usedKey: o,
        exactUsedKey: o,
        usedLng: u,
        usedNS: c,
        usedParams: this.getUsedParamsDetails(r)
      } : o;
    }
    const p = this.resolve(t, r);
    let d = p?.res;
    const h = p?.usedKey || o, f = p?.exactUsedKey || o, g = ["[object Number]", "[object Function]", "[object RegExp]"], m = r.joinArrays !== void 0 ? r.joinArrays : this.options.joinArrays, v = !this.i18nFormat || this.i18nFormat.handleAsObject, y = r.count !== void 0 && !x(r.count), S = Ls.hasDefaultValue(r), C = y ? this.pluralResolver.getSuffix(u, r.count, r) : "", R = r.ordinal && y ? this.pluralResolver.getSuffix(u, r.count, {
      ordinal: !1
    }) : "", w = y && !r.ordinal && r.count === 0, I = w && r[`defaultValue${this.options.pluralSeparator}zero`] || r[`defaultValue${C}`] || r[`defaultValue${R}`] || r.defaultValue;
    let E = d;
    v && !d && S && (E = I);
    const T = $h(E), b = Object.prototype.toString.apply(E);
    if (v && E && T && g.indexOf(b) < 0 && !(x(m) && Array.isArray(E))) {
      if (!r.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const _ = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, E, {
          ...r,
          ns: n
        }) : `key '${o} (${this.language})' returned an object instead of string.`;
        return i ? (p.res = _, p.usedParams = this.getUsedParamsDetails(r), p) : _;
      }
      if (a) {
        const _ = Array.isArray(E), k = _ ? [] : {}, B = _ ? f : h;
        for (const V in E)
          if (Object.prototype.hasOwnProperty.call(E, V)) {
            const Q = `${B}${a}${V}`;
            S && !d ? k[V] = this.translate(Q, {
              ...r,
              defaultValue: $h(I) ? I[V] : void 0,
              joinArrays: !1,
              ns: n
            }) : k[V] = this.translate(Q, {
              ...r,
              joinArrays: !1,
              ns: n
            }), k[V] === Q && (k[V] = E[V]);
          }
        d = k;
      }
    } else if (v && x(m) && Array.isArray(d))
      d = d.join(m), d && (d = this.extendTranslation(d, t, r, s));
    else {
      let _ = !1, k = !1;
      !this.isValidLookup(d) && S && (_ = !0, d = I), this.isValidLookup(d) || (k = !0, d = o);
      const V = (r.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && k ? void 0 : d, Q = S && I !== d && this.options.updateMissing;
      if (k || _ || Q) {
        if (this.logger.log(Q ? "updateKey" : "missingKey", u, c, o, Q ? I : d), a) {
          const J = this.resolve(o, {
            ...r,
            keySeparator: !1
          });
          J && J.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let K = [];
        const le = this.languageUtils.getFallbackCodes(this.options.fallbackLng, r.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && le && le[0])
          for (let J = 0; J < le.length; J++)
            K.push(le[J]);
        else this.options.saveMissingTo === "all" ? K = this.languageUtils.toResolveHierarchy(r.lng || this.language) : K.push(r.lng || this.language);
        const he = (J, re, Y) => {
          const $e = S && Y !== d ? Y : V;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(J, c, re, $e, Q, r) : this.backendConnector?.saveMissing && this.backendConnector.saveMissing(J, c, re, $e, Q, r), this.emit("missingKey", J, c, re, d);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && y ? K.forEach((J) => {
          const re = this.pluralResolver.getSuffixes(J, r);
          w && r[`defaultValue${this.options.pluralSeparator}zero`] && re.indexOf(`${this.options.pluralSeparator}zero`) < 0 && re.push(`${this.options.pluralSeparator}zero`), re.forEach((Y) => {
            he([J], o + Y, r[`defaultValue${Y}`] || I);
          });
        }) : he(K, o, I));
      }
      d = this.extendTranslation(d, t, r, p, s), k && d === o && this.options.appendNamespaceToMissingKey && (d = `${c}:${o}`), (k || _) && this.options.parseMissingKeyHandler && (d = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${c}:${o}` : o, _ ? d : void 0));
    }
    return i ? (p.res = d, p.usedParams = this.getUsedParamsDetails(r), p) : d;
  }
  extendTranslation(t, r, s, i, a) {
    var o = this;
    if (this.i18nFormat?.parse)
      t = this.i18nFormat.parse(t, {
        ...this.options.interpolation.defaultVariables,
        ...s
      }, s.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!s.skipInterpolation) {
      s.interpolation && this.interpolator.init({
        ...s,
        interpolation: {
          ...this.options.interpolation,
          ...s.interpolation
        }
      });
      const u = x(t) && (s?.interpolation?.skipOnVariables !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let l;
      if (u) {
        const d = t.match(this.interpolator.nestingRegexp);
        l = d && d.length;
      }
      let p = s.replace && !x(s.replace) ? s.replace : s;
      if (this.options.interpolation.defaultVariables && (p = {
        ...this.options.interpolation.defaultVariables,
        ...p
      }), t = this.interpolator.interpolate(t, p, s.lng || this.language || i.usedLng, s), u) {
        const d = t.match(this.interpolator.nestingRegexp), h = d && d.length;
        l < h && (s.nest = !1);
      }
      !s.lng && i && i.res && (s.lng = this.language || i.usedLng), s.nest !== !1 && (t = this.interpolator.nest(t, function() {
        for (var d = arguments.length, h = new Array(d), f = 0; f < d; f++)
          h[f] = arguments[f];
        return a?.[0] === h[0] && !s.context ? (o.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${r[0]}`), null) : o.translate(...h, r);
      }, s)), s.interpolation && this.interpolator.reset();
    }
    const n = s.postProcess || this.options.postProcess, c = x(n) ? [n] : n;
    return t != null && c?.length && s.applyPostProcessor !== !1 && (t = Zv.handle(c, t, r, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(s)
      },
      ...s
    } : s, this)), t;
  }
  resolve(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s, i, a, o, n;
    return x(t) && (t = [t]), t.forEach((c) => {
      if (this.isValidLookup(s)) return;
      const u = this.extractFromKey(c, r), l = u.key;
      i = l;
      let p = u.namespaces;
      this.options.fallbackNS && (p = p.concat(this.options.fallbackNS));
      const d = r.count !== void 0 && !x(r.count), h = d && !r.ordinal && r.count === 0, f = r.context !== void 0 && (x(r.context) || typeof r.context == "number") && r.context !== "", g = r.lngs ? r.lngs : this.languageUtils.toResolveHierarchy(r.lng || this.language, r.fallbackLng);
      p.forEach((m) => {
        this.isValidLookup(s) || (n = m, !Uh[`${g[0]}-${m}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(n) && (Uh[`${g[0]}-${m}`] = !0, this.logger.warn(`key "${i}" for languages "${g.join(", ")}" won't get resolved as namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), g.forEach((v) => {
          if (this.isValidLookup(s)) return;
          o = v;
          const y = [l];
          if (this.i18nFormat?.addLookupKeys)
            this.i18nFormat.addLookupKeys(y, l, v, m, r);
          else {
            let C;
            d && (C = this.pluralResolver.getSuffix(v, r.count, r));
            const R = `${this.options.pluralSeparator}zero`, w = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (d && (y.push(l + C), r.ordinal && C.indexOf(w) === 0 && y.push(l + C.replace(w, this.options.pluralSeparator)), h && y.push(l + R)), f) {
              const I = `${l}${this.options.contextSeparator}${r.context}`;
              y.push(I), d && (y.push(I + C), r.ordinal && C.indexOf(w) === 0 && y.push(I + C.replace(w, this.options.pluralSeparator)), h && y.push(I + R));
            }
          }
          let S;
          for (; S = y.pop(); )
            this.isValidLookup(s) || (a = S, s = this.getResource(v, m, S, r));
        }));
      });
    }), {
      res: s,
      usedKey: i,
      exactUsedKey: a,
      usedLng: o,
      usedNS: n
    };
  }
  isValidLookup(t) {
    return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "");
  }
  getResource(t, r, s) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat?.getResource ? this.i18nFormat.getResource(t, r, s, i) : this.resourceStore.getResource(t, r, s, i);
  }
  getUsedParamsDetails() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const r = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], s = t.replace && !x(t.replace);
    let i = s ? t.replace : t;
    if (s && typeof t.count < "u" && (i.count = t.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !s) {
      i = {
        ...i
      };
      for (const a of r)
        delete i[a];
    }
    return i;
  }
  static hasDefaultValue(t) {
    const r = "defaultValue";
    for (const s in t)
      if (Object.prototype.hasOwnProperty.call(t, s) && r === s.substring(0, r.length) && t[s] !== void 0)
        return !0;
    return !1;
  }
}
class Vh {
  constructor(t) {
    this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = _e.create("languageUtils");
  }
  getScriptPartFromCode(t) {
    if (t = xs(t), !t || t.indexOf("-") < 0) return null;
    const r = t.split("-");
    return r.length === 2 || (r.pop(), r[r.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(r.join("-"));
  }
  getLanguagePartFromCode(t) {
    if (t = xs(t), !t || t.indexOf("-") < 0) return t;
    const r = t.split("-");
    return this.formatLanguageCode(r[0]);
  }
  formatLanguageCode(t) {
    if (x(t) && t.indexOf("-") > -1) {
      let r;
      try {
        r = Intl.getCanonicalLocales(t)[0];
      } catch {
      }
      return r && this.options.lowerCaseLng && (r = r.toLowerCase()), r || (this.options.lowerCaseLng ? t.toLowerCase() : t);
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
  }
  isSupportedCode(t) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1;
  }
  getBestMatchFromCodes(t) {
    if (!t) return null;
    let r;
    return t.forEach((s) => {
      if (r) return;
      const i = this.formatLanguageCode(s);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (r = i);
    }), !r && this.options.supportedLngs && t.forEach((s) => {
      if (r) return;
      const i = this.getLanguagePartFromCode(s);
      if (this.isSupportedCode(i)) return r = i;
      r = this.options.supportedLngs.find((a) => {
        if (a === i) return a;
        if (!(a.indexOf("-") < 0 && i.indexOf("-") < 0) && (a.indexOf("-") > 0 && i.indexOf("-") < 0 && a.substring(0, a.indexOf("-")) === i || a.indexOf(i) === 0 && i.length > 1))
          return a;
      });
    }), r || (r = this.getFallbackCodes(this.options.fallbackLng)[0]), r;
  }
  getFallbackCodes(t, r) {
    if (!t) return [];
    if (typeof t == "function" && (t = t(r)), x(t) && (t = [t]), Array.isArray(t)) return t;
    if (!r) return t.default || [];
    let s = t[r];
    return s || (s = t[this.getScriptPartFromCode(r)]), s || (s = t[this.formatLanguageCode(r)]), s || (s = t[this.getLanguagePartFromCode(r)]), s || (s = t.default), s || [];
  }
  toResolveHierarchy(t, r) {
    const s = this.getFallbackCodes(r || this.options.fallbackLng || [], t), i = [], a = (o) => {
      o && (this.isSupportedCode(o) ? i.push(o) : this.logger.warn(`rejecting language code not found in supportedLngs: ${o}`));
    };
    return x(t) && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && a(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && a(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && a(this.getLanguagePartFromCode(t))) : x(t) && a(this.formatLanguageCode(t)), s.forEach((o) => {
      i.indexOf(o) < 0 && a(this.formatLanguageCode(o));
    }), i;
  }
}
const Wh = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, Hh = {
  select: (e) => e === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class qw {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = t, this.options = r, this.logger = _e.create("pluralResolver"), this.pluralRulesCache = {};
  }
  addRule(t, r) {
    this.rules[t] = r;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const s = xs(t === "dev" ? "en" : t), i = r.ordinal ? "ordinal" : "cardinal", a = JSON.stringify({
      cleanedCode: s,
      type: i
    });
    if (a in this.pluralRulesCache)
      return this.pluralRulesCache[a];
    let o;
    try {
      o = new Intl.PluralRules(s, {
        type: i
      });
    } catch {
      if (!Intl)
        return this.logger.error("No Intl support, please use an Intl polyfill!"), Hh;
      if (!t.match(/-|_/)) return Hh;
      const c = this.languageUtils.getLanguagePartFromCode(t);
      o = this.getRule(c, r);
    }
    return this.pluralRulesCache[a] = o, o;
  }
  needsPlural(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = this.getRule(t, r);
    return s || (s = this.getRule("dev", r)), s?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(t, r) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(t, s).map((i) => `${r}${i}`);
  }
  getSuffixes(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, s = this.getRule(t, r);
    return s || (s = this.getRule("dev", r)), s ? s.resolvedOptions().pluralCategories.sort((i, a) => Wh[i] - Wh[a]).map((i) => `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : [];
  }
  getSuffix(t, r) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(t, s);
    return i ? `${this.options.prepend}${s.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(r)}` : (this.logger.warn(`no plural rule found for: ${t}`), this.getSuffix("dev", r, s));
  }
}
const Kh = function(e, t, r) {
  let s = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, a = Ow(e, t, r);
  return !a && i && x(r) && (a = Wa(e, r, s), a === void 0 && (a = Wa(t, r, s))), a;
}, Ta = (e) => e.replace(/\$/g, "$$$$");
class Fw {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = _e.create("interpolator"), this.options = t, this.format = t?.interpolation?.format || ((r) => r), this.init(t);
  }
  init() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    t.interpolation || (t.interpolation = {
      escapeValue: !0
    });
    const {
      escape: r,
      escapeValue: s,
      useRawValueToEscape: i,
      prefix: a,
      prefixEscaped: o,
      suffix: n,
      suffixEscaped: c,
      formatSeparator: u,
      unescapeSuffix: l,
      unescapePrefix: p,
      nestingPrefix: d,
      nestingPrefixEscaped: h,
      nestingSuffix: f,
      nestingSuffixEscaped: g,
      nestingOptionsSeparator: m,
      maxReplaces: v,
      alwaysFormat: y
    } = t.interpolation;
    this.escape = r !== void 0 ? r : Dw, this.escapeValue = s !== void 0 ? s : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = a ? qt(a) : o || "{{", this.suffix = n ? qt(n) : c || "}}", this.formatSeparator = u || ",", this.unescapePrefix = l ? "" : p || "-", this.unescapeSuffix = this.unescapePrefix ? "" : l || "", this.nestingPrefix = d ? qt(d) : h || qt("$t("), this.nestingSuffix = f ? qt(f) : g || qt(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = v || 1e3, this.alwaysFormat = y !== void 0 ? y : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const t = (r, s) => r?.source === s ? (r.lastIndex = 0, r) : new RegExp(s, "g");
    this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(t, r, s, i) {
    let a, o, n;
    const c = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, u = (h) => {
      if (h.indexOf(this.formatSeparator) < 0) {
        const v = Kh(r, c, h, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(v, void 0, s, {
          ...i,
          ...r,
          interpolationkey: h
        }) : v;
      }
      const f = h.split(this.formatSeparator), g = f.shift().trim(), m = f.join(this.formatSeparator).trim();
      return this.format(Kh(r, c, g, this.options.keySeparator, this.options.ignoreJSONStructure), m, s, {
        ...i,
        ...r,
        interpolationkey: g
      });
    };
    this.resetRegExp();
    const l = i?.missingInterpolationHandler || this.options.missingInterpolationHandler, p = i?.interpolation?.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (h) => Ta(h)
    }, {
      regex: this.regexp,
      safeValue: (h) => this.escapeValue ? Ta(this.escape(h)) : Ta(h)
    }].forEach((h) => {
      for (n = 0; a = h.regex.exec(t); ) {
        const f = a[1].trim();
        if (o = u(f), o === void 0)
          if (typeof l == "function") {
            const m = l(t, a, i);
            o = x(m) ? m : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, f))
            o = "";
          else if (p) {
            o = a[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${f} for interpolating ${t}`), o = "";
        else !x(o) && !this.useRawValueToEscape && (o = Lh(o));
        const g = h.safeValue(o);
        if (t = t.replace(a[0], g), p ? (h.regex.lastIndex += o.length, h.regex.lastIndex -= a[0].length) : h.regex.lastIndex = 0, n++, n >= this.maxReplaces)
          break;
      }
    }), t;
  }
  nest(t, r) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, a, o;
    const n = (c, u) => {
      const l = this.nestingOptionsSeparator;
      if (c.indexOf(l) < 0) return c;
      const p = c.split(new RegExp(`${l}[ ]*{`));
      let d = `{${p[1]}`;
      c = p[0], d = this.interpolate(d, o);
      const h = d.match(/'/g), f = d.match(/"/g);
      ((h?.length ?? 0) % 2 === 0 && !f || f.length % 2 !== 0) && (d = d.replace(/'/g, '"'));
      try {
        o = JSON.parse(d), u && (o = {
          ...u,
          ...o
        });
      } catch (g) {
        return this.logger.warn(`failed parsing options string in nesting for key ${c}`, g), `${c}${l}${d}`;
      }
      return o.defaultValue && o.defaultValue.indexOf(this.prefix) > -1 && delete o.defaultValue, c;
    };
    for (; i = this.nestingRegexp.exec(t); ) {
      let c = [];
      o = {
        ...s
      }, o = o.replace && !x(o.replace) ? o.replace : o, o.applyPostProcessor = !1, delete o.defaultValue;
      let u = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const l = i[1].split(this.formatSeparator).map((p) => p.trim());
        i[1] = l.shift(), c = l, u = !0;
      }
      if (a = r(n.call(this, i[1].trim(), o), o), a && i[0] === t && !x(a)) return a;
      x(a) || (a = Lh(a)), a || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`), a = ""), u && (a = c.reduce((l, p) => this.format(l, p, s.lng, {
        ...s,
        interpolationkey: i[1].trim()
      }), a.trim())), t = t.replace(i[0], a), this.regexp.lastIndex = 0;
    }
    return t;
  }
}
const Bw = (e) => {
  let t = e.toLowerCase().trim();
  const r = {};
  if (e.indexOf("(") > -1) {
    const s = e.split("(");
    t = s[0].toLowerCase().trim();
    const i = s[1].substring(0, s[1].length - 1);
    t === "currency" && i.indexOf(":") < 0 ? r.currency || (r.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? r.range || (r.range = i.trim()) : i.split(";").forEach((o) => {
      if (o) {
        const [n, ...c] = o.split(":"), u = c.join(":").trim().replace(/^'+|'+$/g, ""), l = n.trim();
        r[l] || (r[l] = u), u === "false" && (r[l] = !1), u === "true" && (r[l] = !0), isNaN(u) || (r[l] = parseInt(u, 10));
      }
    });
  }
  return {
    formatName: t,
    formatOptions: r
  };
}, Ft = (e) => {
  const t = {};
  return (r, s, i) => {
    let a = i;
    i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (a = {
      ...a,
      [i.interpolationkey]: void 0
    });
    const o = s + JSON.stringify(a);
    let n = t[o];
    return n || (n = e(xs(s), i), t[o] = n), n(r);
  };
};
class Uw {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = _e.create("formatter"), this.options = t, this.formats = {
      number: Ft((r, s) => {
        const i = new Intl.NumberFormat(r, {
          ...s
        });
        return (a) => i.format(a);
      }),
      currency: Ft((r, s) => {
        const i = new Intl.NumberFormat(r, {
          ...s,
          style: "currency"
        });
        return (a) => i.format(a);
      }),
      datetime: Ft((r, s) => {
        const i = new Intl.DateTimeFormat(r, {
          ...s
        });
        return (a) => i.format(a);
      }),
      relativetime: Ft((r, s) => {
        const i = new Intl.RelativeTimeFormat(r, {
          ...s
        });
        return (a) => i.format(a, s.range || "day");
      }),
      list: Ft((r, s) => {
        const i = new Intl.ListFormat(r, {
          ...s
        });
        return (a) => i.format(a);
      })
    }, this.init(t);
  }
  init(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = r.interpolation.formatSeparator || ",";
  }
  add(t, r) {
    this.formats[t.toLowerCase().trim()] = r;
  }
  addCached(t, r) {
    this.formats[t.toLowerCase().trim()] = Ft(r);
  }
  format(t, r, s) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const a = r.split(this.formatSeparator);
    if (a.length > 1 && a[0].indexOf("(") > 1 && a[0].indexOf(")") < 0 && a.find((n) => n.indexOf(")") > -1)) {
      const n = a.findIndex((c) => c.indexOf(")") > -1);
      a[0] = [a[0], ...a.splice(1, n)].join(this.formatSeparator);
    }
    return a.reduce((n, c) => {
      const {
        formatName: u,
        formatOptions: l
      } = Bw(c);
      if (this.formats[u]) {
        let p = n;
        try {
          const d = i?.formatParams?.[i.interpolationkey] || {}, h = d.locale || d.lng || i.locale || i.lng || s;
          p = this.formats[u](n, h, {
            ...l,
            ...i,
            ...d
          });
        } catch (d) {
          this.logger.warn(d);
        }
        return p;
      } else
        this.logger.warn(`there was no format function for ${u}`);
      return n;
    }, t);
  }
}
const $w = (e, t) => {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
};
class Vw extends Js {
  constructor(t, r, s) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = t, this.store = r, this.services = s, this.languageUtils = s.languageUtils, this.options = i, this.logger = _e.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend?.init?.(s, i.backend, i);
  }
  queueLoad(t, r, s, i) {
    const a = {}, o = {}, n = {}, c = {};
    return t.forEach((u) => {
      let l = !0;
      r.forEach((p) => {
        const d = `${u}|${p}`;
        !s.reload && this.store.hasResourceBundle(u, p) ? this.state[d] = 2 : this.state[d] < 0 || (this.state[d] === 1 ? o[d] === void 0 && (o[d] = !0) : (this.state[d] = 1, l = !1, o[d] === void 0 && (o[d] = !0), a[d] === void 0 && (a[d] = !0), c[p] === void 0 && (c[p] = !0)));
      }), l || (n[u] = !0);
    }), (Object.keys(a).length || Object.keys(o).length) && this.queue.push({
      pending: o,
      pendingCount: Object.keys(o).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(a),
      pending: Object.keys(o),
      toLoadLanguages: Object.keys(n),
      toLoadNamespaces: Object.keys(c)
    };
  }
  loaded(t, r, s) {
    const i = t.split("|"), a = i[0], o = i[1];
    r && this.emit("failedLoading", a, o, r), !r && s && this.store.addResourceBundle(a, o, s, void 0, void 0, {
      skipCopy: !0
    }), this.state[t] = r ? -1 : 2, r && s && (this.state[t] = 0);
    const n = {};
    this.queue.forEach((c) => {
      kw(c.loaded, [a], o), $w(c, t), r && c.errors.push(r), c.pendingCount === 0 && !c.done && (Object.keys(c.loaded).forEach((u) => {
        n[u] || (n[u] = {});
        const l = c.loaded[u];
        l.length && l.forEach((p) => {
          n[u][p] === void 0 && (n[u][p] = !0);
        });
      }), c.done = !0, c.errors.length ? c.callback(c.errors) : c.callback());
    }), this.emit("loaded", n), this.queue = this.queue.filter((c) => !c.done);
  }
  read(t, r, s) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, o = arguments.length > 5 ? arguments[5] : void 0;
    if (!t.length) return o(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: t,
        ns: r,
        fcName: s,
        tried: i,
        wait: a,
        callback: o
      });
      return;
    }
    this.readingCalls++;
    const n = (u, l) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const p = this.waitingReads.shift();
        this.read(p.lng, p.ns, p.fcName, p.tried, p.wait, p.callback);
      }
      if (u && l && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, t, r, s, i + 1, a * 2, o);
        }, a);
        return;
      }
      o(u, l);
    }, c = this.backend[s].bind(this.backend);
    if (c.length === 2) {
      try {
        const u = c(t, r);
        u && typeof u.then == "function" ? u.then((l) => n(null, l)).catch(n) : n(null, u);
      } catch (u) {
        n(u);
      }
      return;
    }
    return c(t, r, n);
  }
  prepareLoading(t, r) {
    let s = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    x(t) && (t = this.languageUtils.toResolveHierarchy(t)), x(r) && (r = [r]);
    const a = this.queueLoad(t, r, s, i);
    if (!a.toLoad.length)
      return a.pending.length || i(), null;
    a.toLoad.forEach((o) => {
      this.loadOne(o);
    });
  }
  load(t, r, s) {
    this.prepareLoading(t, r, {}, s);
  }
  reload(t, r, s) {
    this.prepareLoading(t, r, {
      reload: !0
    }, s);
  }
  loadOne(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = t.split("|"), i = s[0], a = s[1];
    this.read(i, a, "read", void 0, void 0, (o, n) => {
      o && this.logger.warn(`${r}loading namespace ${a} for language ${i} failed`, o), !o && n && this.logger.log(`${r}loaded namespace ${a} for language ${i}`, n), this.loaded(t, o, n);
    });
  }
  saveMissing(t, r, s, i, a) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, n = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(r)) {
      this.logger.warn(`did not save key "${s}" as the namespace "${r}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(s == null || s === "")) {
      if (this.backend?.create) {
        const c = {
          ...o,
          isUpdate: a
        }, u = this.backend.create.bind(this.backend);
        if (u.length < 6)
          try {
            let l;
            u.length === 5 ? l = u(t, r, s, i, c) : l = u(t, r, s, i), l && typeof l.then == "function" ? l.then((p) => n(null, p)).catch(n) : n(null, l);
          } catch (l) {
            n(l);
          }
        else
          u(t, r, s, i, n, c);
      }
      !t || !t[0] || this.store.addResource(t[0], r, s, i);
    }
  }
}
const Jh = () => ({
  debug: !1,
  initAsync: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (e) => {
    let t = {};
    if (typeof e[1] == "object" && (t = e[1]), x(e[1]) && (t.defaultValue = e[1]), x(e[2]) && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
      const r = e[3] || e[2];
      Object.keys(r).forEach((s) => {
        t[s] = r[s];
      });
    }
    return t;
  },
  interpolation: {
    escapeValue: !0,
    format: (e) => e,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), Gh = (e) => (x(e.ns) && (e.ns = [e.ns]), x(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), x(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs?.indexOf?.("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), typeof e.initImmediate == "boolean" && (e.initAsync = e.initImmediate), e), As = () => {
}, Ww = (e) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((r) => {
    typeof e[r] == "function" && (e[r] = e[r].bind(e));
  });
};
class fs extends Js {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = Gh(t), this.services = {}, this.logger = _e, this.modules = {
      external: []
    }, Ww(this), r && !this.isInitialized && !t.isClone) {
      if (!this.options.initAsync)
        return this.init(t, r), this;
      setTimeout(() => {
        this.init(t, r);
      }, 0);
    }
  }
  init() {
    var t = this;
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, s = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof r == "function" && (s = r, r = {}), r.defaultNS == null && r.ns && (x(r.ns) ? r.defaultNS = r.ns : r.ns.indexOf("translation") < 0 && (r.defaultNS = r.ns[0]));
    const i = Jh();
    this.options = {
      ...i,
      ...this.options,
      ...Gh(r)
    }, this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }, r.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = r.keySeparator), r.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = r.nsSeparator);
    const a = (l) => l ? typeof l == "function" ? new l() : l : null;
    if (!this.options.isClone) {
      this.modules.logger ? _e.init(a(this.modules.logger), this.options) : _e.init(null, this.options);
      let l;
      this.modules.formatter ? l = this.modules.formatter : l = Uw;
      const p = new Vh(this.options);
      this.store = new Bh(this.options.resources, this.options);
      const d = this.services;
      d.logger = _e, d.resourceStore = this.store, d.languageUtils = p, d.pluralResolver = new qw(p, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), l && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (d.formatter = a(l), d.formatter.init(d, this.options), this.options.interpolation.format = d.formatter.format.bind(d.formatter)), d.interpolator = new Fw(this.options), d.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, d.backendConnector = new Vw(a(this.modules.backend), d.resourceStore, d, this.options), d.backendConnector.on("*", function(h) {
        for (var f = arguments.length, g = new Array(f > 1 ? f - 1 : 0), m = 1; m < f; m++)
          g[m - 1] = arguments[m];
        t.emit(h, ...g);
      }), this.modules.languageDetector && (d.languageDetector = a(this.modules.languageDetector), d.languageDetector.init && d.languageDetector.init(d, this.options.detection, this.options)), this.modules.i18nFormat && (d.i18nFormat = a(this.modules.i18nFormat), d.i18nFormat.init && d.i18nFormat.init(this)), this.translator = new Ls(this.services, this.options), this.translator.on("*", function(h) {
        for (var f = arguments.length, g = new Array(f > 1 ? f - 1 : 0), m = 1; m < f; m++)
          g[m - 1] = arguments[m];
        t.emit(h, ...g);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, s || (s = As), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const l = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      l.length > 0 && l[0] !== "dev" && (this.options.lng = l[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((l) => {
      this[l] = function() {
        return t.store[l](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((l) => {
      this[l] = function() {
        return t.store[l](...arguments), t;
      };
    });
    const c = cs(), u = () => {
      const l = (p, d) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), c.resolve(d), s(p, d);
      };
      if (this.languages && !this.isInitialized) return l(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, l);
    };
    return this.options.resources || !this.options.initAsync ? u() : setTimeout(u, 0), c;
  }
  loadResources(t) {
    let s = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : As;
    const i = x(t) ? t : this.language;
    if (typeof t == "function" && (s = t), !this.options.resources || this.options.partialBundledLanguages) {
      if (i?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return s();
      const a = [], o = (n) => {
        if (!n || n === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(n).forEach((u) => {
          u !== "cimode" && a.indexOf(u) < 0 && a.push(u);
        });
      };
      i ? o(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((c) => o(c)), this.options.preload?.forEach?.((n) => o(n)), this.services.backendConnector.load(a, this.options.ns, (n) => {
        !n && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), s(n);
      });
    } else
      s(null);
  }
  reloadResources(t, r, s) {
    const i = cs();
    return typeof t == "function" && (s = t, t = void 0), typeof r == "function" && (s = r, r = void 0), t || (t = this.languages), r || (r = this.options.ns), s || (s = As), this.services.backendConnector.reload(t, r, (a) => {
      i.resolve(), s(a);
    }), i;
  }
  use(t) {
    if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && Zv.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this;
  }
  setResolvedLanguage(t) {
    if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1))
      for (let r = 0; r < this.languages.length; r++) {
        const s = this.languages[r];
        if (!(["cimode", "dev"].indexOf(s) > -1) && this.store.hasLanguageSomeTranslations(s)) {
          this.resolvedLanguage = s;
          break;
        }
      }
  }
  changeLanguage(t, r) {
    var s = this;
    this.isLanguageChangingTo = t;
    const i = cs();
    this.emit("languageChanging", t);
    const a = (c) => {
      this.language = c, this.languages = this.services.languageUtils.toResolveHierarchy(c), this.resolvedLanguage = void 0, this.setResolvedLanguage(c);
    }, o = (c, u) => {
      u ? (a(u), this.translator.changeLanguage(u), this.isLanguageChangingTo = void 0, this.emit("languageChanged", u), this.logger.log("languageChanged", u)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
        return s.t(...arguments);
      }), r && r(c, function() {
        return s.t(...arguments);
      });
    }, n = (c) => {
      !t && !c && this.services.languageDetector && (c = []);
      const u = x(c) ? c : this.services.languageUtils.getBestMatchFromCodes(c);
      u && (this.language || a(u), this.translator.language || this.translator.changeLanguage(u), this.services.languageDetector?.cacheUserLanguage?.(u)), this.loadResources(u, (l) => {
        o(l, u);
      });
    };
    return !t && this.services.languageDetector && !this.services.languageDetector.async ? n(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(n) : this.services.languageDetector.detect(n) : n(t), i;
  }
  getFixedT(t, r, s) {
    var i = this;
    const a = function(o, n) {
      let c;
      if (typeof n != "object") {
        for (var u = arguments.length, l = new Array(u > 2 ? u - 2 : 0), p = 2; p < u; p++)
          l[p - 2] = arguments[p];
        c = i.options.overloadTranslationOptionHandler([o, n].concat(l));
      } else
        c = {
          ...n
        };
      c.lng = c.lng || a.lng, c.lngs = c.lngs || a.lngs, c.ns = c.ns || a.ns, c.keyPrefix !== "" && (c.keyPrefix = c.keyPrefix || s || a.keyPrefix);
      const d = i.options.keySeparator || ".";
      let h;
      return c.keyPrefix && Array.isArray(o) ? h = o.map((f) => `${c.keyPrefix}${d}${f}`) : h = c.keyPrefix ? `${c.keyPrefix}${d}${o}` : o, i.t(h, c);
    };
    return x(t) ? a.lng = t : a.lngs = t, a.ns = r, a.keyPrefix = s, a;
  }
  t() {
    for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++)
      r[s] = arguments[s];
    return this.translator?.translate(...r);
  }
  exists() {
    for (var t = arguments.length, r = new Array(t), s = 0; s < t; s++)
      r[s] = arguments[s];
    return this.translator?.exists(...r);
  }
  setDefaultNamespace(t) {
    this.options.defaultNS = t;
  }
  hasLoadedNamespace(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const s = r.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, a = this.languages[this.languages.length - 1];
    if (s.toLowerCase() === "cimode") return !0;
    const o = (n, c) => {
      const u = this.services.backendConnector.state[`${n}|${c}`];
      return u === -1 || u === 0 || u === 2;
    };
    if (r.precheck) {
      const n = r.precheck(this, o);
      if (n !== void 0) return n;
    }
    return !!(this.hasResourceBundle(s, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || o(s, t) && (!i || o(a, t)));
  }
  loadNamespaces(t, r) {
    const s = cs();
    return this.options.ns ? (x(t) && (t = [t]), t.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      s.resolve(), r && r(i);
    }), s) : (r && r(), Promise.resolve());
  }
  loadLanguages(t, r) {
    const s = cs();
    x(t) && (t = [t]);
    const i = this.options.preload || [], a = t.filter((o) => i.indexOf(o) < 0 && this.services.languageUtils.isSupportedCode(o));
    return a.length ? (this.options.preload = i.concat(a), this.loadResources((o) => {
      s.resolve(), r && r(o);
    }), s) : (r && r(), Promise.resolve());
  }
  dir(t) {
    if (t || (t = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language)), !t) return "rtl";
    const r = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], s = this.services?.languageUtils || new Vh(Jh());
    return r.indexOf(s.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    return new fs(t, r);
  }
  cloneInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : As;
    const s = t.forkResourceStore;
    s && delete t.forkResourceStore;
    const i = {
      ...this.options,
      ...t,
      isClone: !0
    }, a = new fs(i);
    if ((t.debug !== void 0 || t.prefix !== void 0) && (a.logger = a.logger.clone(t)), ["store", "services", "language"].forEach((n) => {
      a[n] = this[n];
    }), a.services = {
      ...this.services
    }, a.services.utils = {
      hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
    }, s) {
      const n = Object.keys(this.store.data).reduce((c, u) => (c[u] = {
        ...this.store.data[u]
      }, Object.keys(c[u]).reduce((l, p) => (l[p] = {
        ...c[u][p]
      }, l), {})), {});
      a.store = new Bh(n, i), a.services.resourceStore = a.store;
    }
    return a.translator = new Ls(a.services, i), a.translator.on("*", function(n) {
      for (var c = arguments.length, u = new Array(c > 1 ? c - 1 : 0), l = 1; l < c; l++)
        u[l - 1] = arguments[l];
      a.emit(n, ...u);
    }), a.init(i, r), a.translator.options = i, a.translator.backendConnector.services.utils = {
      hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
    }, a;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const oe = fs.createInstance();
oe.createInstance = fs.createInstance;
oe.createInstance;
oe.dir;
oe.init;
oe.loadResources;
oe.reloadResources;
oe.use;
oe.changeLanguage;
oe.getFixedT;
oe.t;
oe.exists;
oe.setDefaultNamespace;
oe.hasLoadedNamespace;
oe.loadNamespaces;
oe.loadLanguages;
var Gs = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    return this.listeners.add(e), this.onSubscribe(), () => {
      this.listeners.delete(e), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Qs = typeof window > "u" || "Deno" in globalThis;
function Ie() {
}
function Hw(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Kw(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function Jw(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function Ha(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Gw(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Qh(e, t) {
  const {
    type: r = "all",
    exact: s,
    fetchStatus: i,
    predicate: a,
    queryKey: o,
    stale: n
  } = e;
  if (o) {
    if (s) {
      if (t.queryHash !== lc(o, t.options))
        return !1;
    } else if (!gs(t.queryKey, o))
      return !1;
  }
  if (r !== "all") {
    const c = t.isActive();
    if (r === "active" && !c || r === "inactive" && c)
      return !1;
  }
  return !(typeof n == "boolean" && t.isStale() !== n || i && i !== t.state.fetchStatus || a && !a(t));
}
function Yh(e, t) {
  const { exact: r, status: s, predicate: i, mutationKey: a } = e;
  if (a) {
    if (!t.options.mutationKey)
      return !1;
    if (r) {
      if (vs(t.options.mutationKey) !== vs(a))
        return !1;
    } else if (!gs(t.options.mutationKey, a))
      return !1;
  }
  return !(s && t.state.status !== s || i && !i(t));
}
function lc(e, t) {
  return (t?.queryKeyHashFn || vs)(e);
}
function vs(e) {
  return JSON.stringify(
    e,
    (t, r) => Ja(r) ? Object.keys(r).sort().reduce((s, i) => (s[i] = r[i], s), {}) : r
  );
}
function gs(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every((r) => gs(e[r], t[r])) : !1;
}
function Ka(e, t) {
  if (e === t)
    return e;
  const r = Zh(e) && Zh(t);
  if (r || Ja(e) && Ja(t)) {
    const s = r ? e : Object.keys(e), i = s.length, a = r ? t : Object.keys(t), o = a.length, n = r ? [] : {}, c = new Set(s);
    let u = 0;
    for (let l = 0; l < o; l++) {
      const p = r ? l : a[l];
      (!r && c.has(p) || r) && e[p] === void 0 && t[p] === void 0 ? (n[p] = void 0, u++) : (n[p] = Ka(e[p], t[p]), n[p] === e[p] && e[p] !== void 0 && u++);
    }
    return i === o && u === i ? e : n;
  }
  return t;
}
function Zh(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function Ja(e) {
  if (!Xh(e))
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const r = t.prototype;
  return !(!Xh(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function Xh(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Qw(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function Yw(e, t, r) {
  if (typeof r.structuralSharing == "function")
    return r.structuralSharing(e, t);
  if (r.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return Ka(e, t);
      } catch (s) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${s}`
        ), s;
      }
    return Ka(e, t);
  }
  return t;
}
function Zw(e, t, r = 0) {
  const s = [...e, t];
  return r && s.length > r ? s.slice(1) : s;
}
function Xw(e, t, r = 0) {
  const s = [t, ...e];
  return r && s.length > r ? s.slice(0, -1) : s;
}
var js = Symbol();
function Xv(e, t) {
  return process.env.NODE_ENV !== "production" && e.queryFn === js && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${e.queryHash}'`
  ), !e.queryFn && t?.initialPromise ? () => t.initialPromise : !e.queryFn || e.queryFn === js ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
var eE = class extends Gs {
  #e;
  #t;
  #r;
  constructor() {
    super(), this.#r = (e) => {
      if (!Qs && window.addEventListener) {
        const t = () => e();
        return window.addEventListener("visibilitychange", t, !1), () => {
          window.removeEventListener("visibilitychange", t);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#r);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(e) {
    this.#r = e, this.#t?.(), this.#t = e((t) => {
      typeof t == "boolean" ? this.setFocused(t) : this.onFocus();
    });
  }
  setFocused(e) {
    this.#e !== e && (this.#e = e, this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  isFocused() {
    return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden";
  }
}, eg = new eE(), tE = class extends Gs {
  #e = !0;
  #t;
  #r;
  constructor() {
    super(), this.#r = (e) => {
      if (!Qs && window.addEventListener) {
        const t = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", t, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", t), window.removeEventListener("offline", r);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#r);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(e) {
    this.#r = e, this.#t?.(), this.#t = e(this.setOnline.bind(this));
  }
  setOnline(e) {
    this.#e !== e && (this.#e = e, this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return this.#e;
  }
}, qs = new tE();
function rE() {
  let e, t;
  const r = new Promise((i, a) => {
    e = i, t = a;
  });
  r.status = "pending", r.catch(() => {
  });
  function s(i) {
    Object.assign(r, i), delete r.resolve, delete r.reject;
  }
  return r.resolve = (i) => {
    s({
      status: "fulfilled",
      value: i
    }), e(i);
  }, r.reject = (i) => {
    s({
      status: "rejected",
      reason: i
    }), t(i);
  }, r;
}
function nE(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function tg(e) {
  return (e ?? "online") === "online" ? qs.isOnline() : !0;
}
var rg = class extends Error {
  constructor(e) {
    super("CancelledError"), this.revert = e?.revert, this.silent = e?.silent;
  }
};
function _a(e) {
  return e instanceof rg;
}
function ng(e) {
  let t = !1, r = 0, s = !1, i;
  const a = rE(), o = (g) => {
    s || (d(new rg(g)), e.abort?.());
  }, n = () => {
    t = !0;
  }, c = () => {
    t = !1;
  }, u = () => eg.isFocused() && (e.networkMode === "always" || qs.isOnline()) && e.canRun(), l = () => tg(e.networkMode) && e.canRun(), p = (g) => {
    s || (s = !0, e.onSuccess?.(g), i?.(), a.resolve(g));
  }, d = (g) => {
    s || (s = !0, e.onError?.(g), i?.(), a.reject(g));
  }, h = () => new Promise((g) => {
    i = (m) => {
      (s || u()) && g(m);
    }, e.onPause?.();
  }).then(() => {
    i = void 0, s || e.onContinue?.();
  }), f = () => {
    if (s)
      return;
    let g;
    const m = r === 0 ? e.initialPromise : void 0;
    try {
      g = m ?? e.fn();
    } catch (v) {
      g = Promise.reject(v);
    }
    Promise.resolve(g).then(p).catch((v) => {
      if (s)
        return;
      const y = e.retry ?? (Qs ? 0 : 3), S = e.retryDelay ?? nE, C = typeof S == "function" ? S(r, v) : S, R = y === !0 || typeof y == "number" && r < y || typeof y == "function" && y(r, v);
      if (t || !R) {
        d(v);
        return;
      }
      r++, e.onFail?.(r, v), Qw(C).then(() => u() ? void 0 : h()).then(() => {
        t ? d(v) : f();
      });
    });
  };
  return {
    promise: a,
    cancel: o,
    continue: () => (i?.(), a),
    cancelRetry: n,
    continueRetry: c,
    canStart: l,
    start: () => (l() ? f() : h().then(f), a)
  };
}
var iE = (e) => setTimeout(e, 0);
function sE() {
  let e = [], t = 0, r = (n) => {
    n();
  }, s = (n) => {
    n();
  }, i = iE;
  const a = (n) => {
    t ? e.push(n) : i(() => {
      r(n);
    });
  }, o = () => {
    const n = e;
    e = [], n.length && i(() => {
      s(() => {
        n.forEach((c) => {
          r(c);
        });
      });
    });
  };
  return {
    batch: (n) => {
      let c;
      t++;
      try {
        c = n();
      } finally {
        t--, t || o();
      }
      return c;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (n) => (...c) => {
      a(() => {
        n(...c);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (n) => {
      r = n;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (n) => {
      s = n;
    },
    setScheduler: (n) => {
      i = n;
    }
  };
}
var ce = sE(), ig = class {
  #e;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Kw(this.gcTime) && (this.#e = setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(e) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      e ?? (Qs ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    this.#e && (clearTimeout(this.#e), this.#e = void 0);
  }
}, oE = class extends ig {
  #e;
  #t;
  #r;
  #i;
  #n;
  #o;
  #a;
  constructor(e) {
    super(), this.#a = !1, this.#o = e.defaultOptions, this.setOptions(e.options), this.observers = [], this.#i = e.client, this.#r = this.#i.getQueryCache(), this.queryKey = e.queryKey, this.queryHash = e.queryHash, this.#e = cE(this.options), this.state = e.state ?? this.#e, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#n?.promise;
  }
  setOptions(e) {
    this.options = { ...this.#o, ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.#r.remove(this);
  }
  setData(e, t) {
    const r = Yw(this.state.data, e, this.options);
    return this.#s({
      data: r,
      type: "success",
      dataUpdatedAt: t?.updatedAt,
      manual: t?.manual
    }), r;
  }
  setState(e, t) {
    this.#s({ type: "setState", state: e, setStateOptions: t });
  }
  cancel(e) {
    const t = this.#n?.promise;
    return this.#n?.cancel(e), t ? t.then(Ie).catch(Ie) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(this.#e);
  }
  isActive() {
    return this.observers.some(
      (e) => Gw(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === js || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => Ha(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !Jw(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#n?.continue();
  }
  onOnline() {
    this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#n?.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), this.#r.notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((t) => t !== e), this.observers.length || (this.#n && (this.#a ? this.#n.cancel({ revert: !0 }) : this.#n.cancelRetry()), this.scheduleGc()), this.#r.notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.#s({ type: "invalidate" });
  }
  fetch(e, t) {
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && t?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (this.#n)
        return this.#n.continueRetry(), this.#n.promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const c = this.observers.find((u) => u.options.queryFn);
      c && this.setOptions(c.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), s = (c) => {
      Object.defineProperty(c, "signal", {
        enumerable: !0,
        get: () => (this.#a = !0, r.signal)
      });
    }, i = () => {
      const c = Xv(this.options, t), l = (() => {
        const p = {
          client: this.#i,
          queryKey: this.queryKey,
          meta: this.meta
        };
        return s(p), p;
      })();
      return this.#a = !1, this.options.persister ? this.options.persister(
        c,
        l,
        this
      ) : c(l);
    }, o = (() => {
      const c = {
        fetchOptions: t,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#i,
        state: this.state,
        fetchFn: i
      };
      return s(c), c;
    })();
    this.options.behavior?.onFetch(o, this), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== o.fetchOptions?.meta) && this.#s({ type: "fetch", meta: o.fetchOptions?.meta });
    const n = (c) => {
      _a(c) && c.silent || this.#s({
        type: "error",
        error: c
      }), _a(c) || (this.#r.config.onError?.(
        c,
        this
      ), this.#r.config.onSettled?.(
        this.state.data,
        c,
        this
      )), this.scheduleGc();
    };
    return this.#n = ng({
      initialPromise: t?.initialPromise,
      fn: o.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (c) => {
        if (c === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), n(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(c);
        } catch (u) {
          n(u);
          return;
        }
        this.#r.config.onSuccess?.(c, this), this.#r.config.onSettled?.(
          c,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: n,
      onFail: (c, u) => {
        this.#s({ type: "failed", failureCount: c, error: u });
      },
      onPause: () => {
        this.#s({ type: "pause" });
      },
      onContinue: () => {
        this.#s({ type: "continue" });
      },
      retry: o.options.retry,
      retryDelay: o.options.retryDelay,
      networkMode: o.options.networkMode,
      canRun: () => !0
    }), this.#n.start();
  }
  #s(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return {
            ...r,
            fetchFailureCount: e.failureCount,
            fetchFailureReason: e.error
          };
        case "pause":
          return {
            ...r,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...r,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...r,
            ...aE(r.data, this.options),
            fetchMeta: e.meta ?? null
          };
        case "success":
          return this.#t = void 0, {
            ...r,
            data: e.data,
            dataUpdateCount: r.dataUpdateCount + 1,
            dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!e.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const s = e.error;
          return _a(s) && s.revert && this.#t ? { ...this.#t, fetchStatus: "idle" } : {
            ...r,
            error: s,
            errorUpdateCount: r.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: r.fetchFailureCount + 1,
            fetchFailureReason: s,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...r,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...r,
            ...e.state
          };
      }
    };
    this.state = t(this.state), ce.batch(() => {
      this.observers.forEach((r) => {
        r.onQueryUpdate();
      }), this.#r.notify({ query: this, type: "updated", action: e });
    });
  }
};
function aE(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: tg(t.networkMode) ? "fetching" : "paused",
    ...e === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function cE(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, r = t !== void 0, s = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? s ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var uE = class extends Gs {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Map();
  }
  #e;
  build(e, t, r) {
    const s = t.queryKey, i = t.queryHash ?? lc(s, t);
    let a = this.get(i);
    return a || (a = new oE({
      client: e,
      queryKey: s,
      queryHash: i,
      options: e.defaultQueryOptions(t),
      state: r,
      defaultOptions: e.getQueryDefaults(s)
    }), this.add(a)), a;
  }
  add(e) {
    this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const t = this.#e.get(e.queryHash);
    t && (e.destroy(), t === e && this.#e.delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    ce.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.#e.get(e);
  }
  getAll() {
    return [...this.#e.values()];
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (r) => Qh(t, r)
    );
  }
  findAll(e = {}) {
    const t = this.getAll();
    return Object.keys(e).length > 0 ? t.filter((r) => Qh(e, r)) : t;
  }
  notify(e) {
    ce.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  onFocus() {
    ce.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    ce.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, lE = class extends ig {
  #e;
  #t;
  #r;
  constructor(e) {
    super(), this.mutationId = e.mutationId, this.#t = e.mutationCache, this.#e = [], this.state = e.state || pE(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    this.#e.includes(e) || (this.#e.push(e), this.clearGcTimeout(), this.#t.notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    this.#e = this.#e.filter((t) => t !== e), this.scheduleGc(), this.#t.notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    this.#e.length || (this.state.status === "pending" ? this.scheduleGc() : this.#t.remove(this));
  }
  continue() {
    return this.#r?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    const t = () => {
      this.#i({ type: "continue" });
    };
    this.#r = ng({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (i, a) => {
        this.#i({ type: "failed", failureCount: i, error: a });
      },
      onPause: () => {
        this.#i({ type: "pause" });
      },
      onContinue: t,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#t.canRun(this)
    });
    const r = this.state.status === "pending", s = !this.#r.canStart();
    try {
      if (r)
        t();
      else {
        this.#i({ type: "pending", variables: e, isPaused: s }), await this.#t.config.onMutate?.(
          e,
          this
        );
        const a = await this.options.onMutate?.(e);
        a !== this.state.context && this.#i({
          type: "pending",
          context: a,
          variables: e,
          isPaused: s
        });
      }
      const i = await this.#r.start();
      return await this.#t.config.onSuccess?.(
        i,
        e,
        this.state.context,
        this
      ), await this.options.onSuccess?.(i, e, this.state.context), await this.#t.config.onSettled?.(
        i,
        null,
        this.state.variables,
        this.state.context,
        this
      ), await this.options.onSettled?.(i, null, e, this.state.context), this.#i({ type: "success", data: i }), i;
    } catch (i) {
      try {
        throw await this.#t.config.onError?.(
          i,
          e,
          this.state.context,
          this
        ), await this.options.onError?.(
          i,
          e,
          this.state.context
        ), await this.#t.config.onSettled?.(
          void 0,
          i,
          this.state.variables,
          this.state.context,
          this
        ), await this.options.onSettled?.(
          void 0,
          i,
          e,
          this.state.context
        ), i;
      } finally {
        this.#i({ type: "error", error: i });
      }
    } finally {
      this.#t.runNext(this);
    }
  }
  #i(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return {
            ...r,
            failureCount: e.failureCount,
            failureReason: e.error
          };
        case "pause":
          return {
            ...r,
            isPaused: !0
          };
        case "continue":
          return {
            ...r,
            isPaused: !1
          };
        case "pending":
          return {
            ...r,
            context: e.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: e.isPaused,
            status: "pending",
            variables: e.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...r,
            data: e.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...r,
            data: void 0,
            error: e.error,
            failureCount: r.failureCount + 1,
            failureReason: e.error,
            isPaused: !1,
            status: "error"
          };
      }
    };
    this.state = t(this.state), ce.batch(() => {
      this.#e.forEach((r) => {
        r.onMutationUpdate(e);
      }), this.#t.notify({
        mutation: this,
        type: "updated",
        action: e
      });
    });
  }
};
function pE() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var dE = class extends Gs {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Set(), this.#t = /* @__PURE__ */ new Map(), this.#r = 0;
  }
  #e;
  #t;
  #r;
  build(e, t, r) {
    const s = new lE({
      mutationCache: this,
      mutationId: ++this.#r,
      options: e.defaultMutationOptions(t),
      state: r
    });
    return this.add(s), s;
  }
  add(e) {
    this.#e.add(e);
    const t = Ts(e);
    if (typeof t == "string") {
      const r = this.#t.get(t);
      r ? r.push(e) : this.#t.set(t, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (this.#e.delete(e)) {
      const t = Ts(e);
      if (typeof t == "string") {
        const r = this.#t.get(t);
        if (r)
          if (r.length > 1) {
            const s = r.indexOf(e);
            s !== -1 && r.splice(s, 1);
          } else r[0] === e && this.#t.delete(t);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const t = Ts(e);
    if (typeof t == "string") {
      const s = this.#t.get(t)?.find(
        (i) => i.state.status === "pending"
      );
      return !s || s === e;
    } else
      return !0;
  }
  runNext(e) {
    const t = Ts(e);
    return typeof t == "string" ? this.#t.get(t)?.find((s) => s !== e && s.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    ce.batch(() => {
      this.#e.forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), this.#e.clear(), this.#t.clear();
    });
  }
  getAll() {
    return Array.from(this.#e);
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (r) => Yh(t, r)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((t) => Yh(e, t));
  }
  notify(e) {
    ce.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((t) => t.state.isPaused);
    return ce.batch(
      () => Promise.all(
        e.map((t) => t.continue().catch(Ie))
      )
    );
  }
};
function Ts(e) {
  return e.options.scope?.id;
}
function ef(e) {
  return {
    onFetch: (t, r) => {
      const s = t.options, i = t.fetchOptions?.meta?.fetchMore?.direction, a = t.state.data?.pages || [], o = t.state.data?.pageParams || [];
      let n = { pages: [], pageParams: [] }, c = 0;
      const u = async () => {
        let l = !1;
        const p = (f) => {
          Object.defineProperty(f, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? l = !0 : t.signal.addEventListener("abort", () => {
              l = !0;
            }), t.signal)
          });
        }, d = Xv(t.options, t.fetchOptions), h = async (f, g, m) => {
          if (l)
            return Promise.reject();
          if (g == null && f.pages.length)
            return Promise.resolve(f);
          const y = (() => {
            const w = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: g,
              direction: m ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(w), w;
          })(), S = await d(y), { maxPages: C } = t.options, R = m ? Xw : Zw;
          return {
            pages: R(f.pages, S, C),
            pageParams: R(f.pageParams, g, C)
          };
        };
        if (i && a.length) {
          const f = i === "backward", g = f ? hE : tf, m = {
            pages: a,
            pageParams: o
          }, v = g(s, m);
          n = await h(m, v, f);
        } else {
          const f = e ?? a.length;
          do {
            const g = c === 0 ? o[0] ?? s.initialPageParam : tf(s, n);
            if (c > 0 && g == null)
              break;
            n = await h(n, g), c++;
          } while (c < f);
        }
        return n;
      };
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        u,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        r
      ) : t.fetchFn = u;
    }
  };
}
function tf(e, { pages: t, pageParams: r }) {
  const s = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[s],
    t,
    r[s],
    r
  ) : void 0;
}
function hE(e, { pages: t, pageParams: r }) {
  return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, r[0], r) : void 0;
}
var fE = class {
  #e;
  #t;
  #r;
  #i;
  #n;
  #o;
  #a;
  #s;
  constructor(e = {}) {
    this.#e = e.queryCache || new uE(), this.#t = e.mutationCache || new dE(), this.#r = e.defaultOptions || {}, this.#i = /* @__PURE__ */ new Map(), this.#n = /* @__PURE__ */ new Map(), this.#o = 0;
  }
  mount() {
    this.#o++, this.#o === 1 && (this.#a = eg.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onFocus());
    }), this.#s = qs.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onOnline());
    }));
  }
  unmount() {
    this.#o--, this.#o === 0 && (this.#a?.(), this.#a = void 0, this.#s?.(), this.#s = void 0);
  }
  isFetching(e) {
    return this.#e.findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return this.#t.findAll({ ...e, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(t.queryHash)?.state.data;
  }
  ensureQueryData(e) {
    const t = this.defaultQueryOptions(e), r = this.#e.build(this, t), s = r.state.data;
    return s === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && r.isStaleByTime(Ha(t.staleTime, r)) && this.prefetchQuery(t), Promise.resolve(s));
  }
  getQueriesData(e) {
    return this.#e.findAll(e).map(({ queryKey: t, state: r }) => {
      const s = r.data;
      return [t, s];
    });
  }
  setQueryData(e, t, r) {
    const s = this.defaultQueryOptions({ queryKey: e }), a = this.#e.get(
      s.queryHash
    )?.state.data, o = Hw(t, a);
    if (o !== void 0)
      return this.#e.build(this, s).setData(o, { ...r, manual: !0 });
  }
  setQueriesData(e, t, r) {
    return ce.batch(
      () => this.#e.findAll(e).map(({ queryKey: s }) => [
        s,
        this.setQueryData(s, t, r)
      ])
    );
  }
  getQueryState(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(
      t.queryHash
    )?.state;
  }
  removeQueries(e) {
    const t = this.#e;
    ce.batch(() => {
      t.findAll(e).forEach((r) => {
        t.remove(r);
      });
    });
  }
  resetQueries(e, t) {
    const r = this.#e;
    return ce.batch(() => (r.findAll(e).forEach((s) => {
      s.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...e
      },
      t
    )));
  }
  cancelQueries(e, t = {}) {
    const r = { revert: !0, ...t }, s = ce.batch(
      () => this.#e.findAll(e).map((i) => i.cancel(r))
    );
    return Promise.all(s).then(Ie).catch(Ie);
  }
  invalidateQueries(e, t = {}) {
    return ce.batch(() => (this.#e.findAll(e).forEach((r) => {
      r.invalidate();
    }), e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...e,
        type: e?.refetchType ?? e?.type ?? "active"
      },
      t
    )));
  }
  refetchQueries(e, t = {}) {
    const r = {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }, s = ce.batch(
      () => this.#e.findAll(e).filter((i) => !i.isDisabled() && !i.isStatic()).map((i) => {
        let a = i.fetch(void 0, r);
        return r.throwOnError || (a = a.catch(Ie)), i.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(s).then(Ie);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const r = this.#e.build(this, t);
    return r.isStaleByTime(
      Ha(t.staleTime, r)
    ) ? r.fetch(t) : Promise.resolve(r.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(Ie).catch(Ie);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = ef(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(Ie).catch(Ie);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = ef(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return qs.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return this.#e;
  }
  getMutationCache() {
    return this.#t;
  }
  getDefaultOptions() {
    return this.#r;
  }
  setDefaultOptions(e) {
    this.#r = e;
  }
  setQueryDefaults(e, t) {
    this.#i.set(vs(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...this.#i.values()], r = {};
    return t.forEach((s) => {
      gs(e, s.queryKey) && Object.assign(r, s.defaultOptions);
    }), r;
  }
  setMutationDefaults(e, t) {
    this.#n.set(vs(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...this.#n.values()], r = {};
    return t.forEach((s) => {
      gs(e, s.mutationKey) && Object.assign(r, s.defaultOptions);
    }), r;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...this.#r.queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = lc(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === js && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e?._defaulted ? e : {
      ...this.#r.mutations,
      ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    this.#e.clear(), this.#t.clear();
  }
};
async function vE(e) {
  if (!e.ok) {
    const t = await e.text() || e.statusText;
    throw new Error(`${e.status}: ${t}`);
  }
}
function gE() {
  return "https://developmentapis.azure-api.net/sandbox/v1/";
}
const mE = ({ on401: e }) => async ({ queryKey: t }) => {
  const r = t[0], s = r.startsWith("http") ? r : `${gE()}${r}`, i = await fetch(s, {
    credentials: "include"
  });
  return await vE(i), await i.json();
};
new fE({
  defaultOptions: {
    queries: {
      queryFn: mE({ on401: "throw" }),
      refetchInterval: !1,
      refetchOnWindowFocus: !1,
      staleTime: 1 / 0,
      retry: !1
    },
    mutations: {
      retry: !1
    }
  }
});
const yE = "Welcome to Your Personal AI Medical Concierge", SE = "Your intelligent health assistant will ask you key questions to understand your needs and build a personalized profile to support your well-being and care journey.", CE = { title: "How It Works", steps: ["Your AI concierge asks you questions to find out how {{brand}} can help you succeed", "The concierge will personalize recommendations based on your needs", "Access tailored resources, courses, and marketplace options"] }, RE = { resetChat: "Reset Chat", retry: "Retry", continue: "Continue", upload: "Upload", uploading: "Uploading..." }, PE = { yourAIConcierge: "Your AI Concierge", chooseAvatar: "Choose Your Avatar", startConversation: "Start Conversation" }, bE = { chooseAvatarTitle: "Choose Your Avatar", chooseAvatarMessage: "Please select an avatar from the left panel to start your conversation with your AI Concierge.", mode: "Chat Mode", modes: { care: "Care", clear: "Clear", clinical: "Clinical" } }, wE = {
  title: yE,
  description: SE,
  howItWorks: CE,
  buttons: RE,
  avatar: PE,
  chat: bE
}, EE = "Bienvenido a tu Asistente de IA Personal de Salud", IE = "Tu asistente digital inteligente te hará preguntas clave para entender tus necesidades y crear un perfil personalizado para apoyarte en tu viaje de bienestar y cuidado.", AE = { title: "Cómo Funciona", steps: ["Tu asistente de IA te hará preguntas para averiguar cómo {{brand}} puede ayudarte a tener éxito", "El asistente personalizará recomendaciones basadas en tus necesidades", "Accede a recursos, cursos y opciones de mercado personalizados"] }, TE = { resetChat: "Restablecer Chat", retry: "Reintentar", continue: "Continuar", upload: "Cargar", uploading: "Cargando..." }, _E = { yourAIConcierge: "Tu Asistente de IA", chooseAvatar: "Elige tu Avatar", startConversation: "Iniciar Conversación" }, kE = { chooseAvatarTitle: "Elige tu Avatar", chooseAvatarMessage: "Por favor, selecciona un avatar de la izquierda para iniciar tu conversación con tu Asistente de IA.", mode: "Modo de Chat", modes: { care: "Cuidado", clear: "Claro", clinical: "Clínico" } }, OE = {
  title: EE,
  description: IE,
  howItWorks: AE,
  buttons: TE,
  avatar: _E,
  chat: kE
}, ME = "Bienvenue chez votre Assistant IA de Santé", DE = "Votre assistant numérique intelligent vous posera des questions clés pour comprendre vos besoins et créer un profil personnalisé pour vous aider dans votre parcours de bien-être et de soins.", NE = { title: "Comment ça Marche", steps: ["Votre assistant IA vous pose des questions pour savoir comment {{brand}} peut vous aider", "L'assistant personnalise des recommandations selon vos besoins", "Accédez à des ressources, cours et options adaptées"] }, xE = { resetChat: "Réinitialiser le Chat", retry: "Réessayer", continue: "Continuer", upload: "Télécharger", uploading: "Téléchargement..." }, zE = { yourAIConcierge: "Votre Assistant IA", chooseAvatar: "Choisissez votre Avatar", startConversation: "Démarrer la Conversation" }, LE = { chooseAvatarTitle: "Choisissez votre Avatar", chooseAvatarMessage: "Veuillez sélectionner un avatar de la gauche pour démarrer votre conversation avec votre Assistant IA.", mode: "Mode de Chat", modes: { care: "Soins", clear: "Clair", clinical: "Clinique" } }, jE = {
  title: ME,
  description: DE,
  howItWorks: NE,
  buttons: xE,
  avatar: zE,
  chat: LE
}, qE = "Willkommen bei Ihrem persönlichen KI-Medizin-Assistenten", FE = "Ihr intelligenter digitaler Assistent stellt Fragen, um Ihre Bedürfnisse zu verstehen und ein persönliches Profil zu erstellen, um Ihre Gesundheit und Pflege zu unterstützen.", BE = { title: "So funktioniert es", steps: ["Ihr KI-Assistent stellt Fragen, um herauszufinden, wie {{brand}} Sie unterstützen kann", "Der Assistent personalisiert Empfehlungen basierend auf Ihren Bedürfnissen", "Zugriff auf maßgeschneiderte Ressourcen, Kurse und Marktplatzoptionen"] }, UE = { resetChat: "Chat zurücksetzen", retry: "Wiederholen", continue: "Fortfahren", upload: "Datei hochladen", uploading: "Hochladen..." }, $E = { yourAIConcierge: "Ihr KI-Assistent", chooseAvatar: "Wählen Sie Ihren Avatar", startConversation: "Konversation starten" }, VE = { chooseAvatarTitle: "Wählen Sie Ihren Avatar", chooseAvatarMessage: "Bitte wählen Sie einen Avatar aus der linken Leiste, um mit Ihrem KI-Assistenten zu beginnen.", mode: "Chat-Modus", modes: { care: "Betreuung", clear: "Klar", clinical: "Klinisch" } }, WE = {
  title: qE,
  description: FE,
  howItWorks: BE,
  buttons: UE,
  avatar: $E,
  chat: VE
}, HE = ["Analyzing your request", "Gathering insights", "Processing information", "Preparing response", "Almost there", "Finalizing thoughts", "Crafting the perfect response", "Connecting the dots", "Synthesizing information", "Optimizing recommendations"], KE = {
  loadingMessages: HE
}, JE = ["Analizando tu solicitud", "Recopilando información", "Procesando información", "Preparando respuesta", "Casi listo", "Finalizando pensamientos", "Elaborando la respuesta perfecta", "Conectando los puntos", "Sintetizando información", "Optimizando recomendaciones"], GE = {
  loadingMessages: JE
}, QE = ["Analyse de votre demande", "Collecte d'informations", "Traitement des informations", "Préparation de la réponse", "Presque terminé", "Finalisation des réflexions", "Élaboration de la réponse parfaite", "Connexion des points", "Synthèse des informations", "Optimisation des recommandations"], YE = {
  loadingMessages: QE
}, ZE = ["Analysiere Ihre Anfrage", "Sammle Erkenntnisse", "Verarbeite Informationen", "Bereite Antwort vor", "Fast fertig", "Finalisiere Gedanken", "Erstelle die perfekte Antwort", "Verbinde die Punkte", "Synthetisiere Informationen", "Optimiere Empfehlungen"], XE = {
  loadingMessages: ZE
}, eI = {
  en: {
    concierge: wE,
    common: {
      loadingMessages: KE
    }
  },
  es: {
    concierge: OE,
    common: {
      loadingMessages: GE
    }
  },
  fr: {
    concierge: jE,
    common: {
      loadingMessages: YE
    }
  },
  de: {
    concierge: WE,
    common: {
      loadingMessages: XE
    }
  }
};
oe.use(Hg).init({
  resources: eI,
  lng: "en",
  // Default language
  fallbackLng: "en",
  interpolation: {
    escapeValue: !1
    // React already handles escaping
  }
});
const tI = [
  { code: "en", name: "English" },
  { code: "es", name: "Spanish" },
  { code: "fr", name: "French" },
  { code: "de", name: "German" }
], sg = {
  region: "",
  apiBaseUrl: "",
  speechKey: "",
  azureTranslatorKey: "",
  azureTranslatorEndpoint: "",
  azureTranslatorRegion: "",
  tavusApiKey: ""
}, og = sf(sg), rI = () => of(og), nI = ({ value: e, children: t }) => {
  const r = { ...sg, ...e };
  return /* @__PURE__ */ P(og.Provider, { value: r, children: t });
}, iI = Sg(
  ({
    replicaId: e = "r82081c7f26d",
    personaId: t = "pc9cb547c05e",
    conversationName: r = "Demo Conversation",
    conversationalContext: s,
    customGreeting: i,
    platform: a = "home",
    buttonText: o,
    videoMode: n,
    chatVisible: c,
    toggleChat: u,
    learningPrompts: l = [],
    onPromptClick: p,
    width: d = "100%",
    height: h = "100%",
    maxWidth: f = "2xl",
    className: g = "",
    setVoiceMode: m,
    setConversationStarted: v,
    setConversationId: y,
    setConversationUrl: S,
    setInterruptReplica: C,
    currentScript: R,
    setCurrentScript: w,
    interruptReplica: I,
    setIsSpeaking: E,
    setSpokenText: T,
    region: b,
    speechKey: _,
    config: k
  }, B) => {
    const [V, Q] = L("welcome"), [K, le] = L(null), [he, J] = L(!1), [re, Y] = L(!1), $e = Be(null), [Me, Kt] = L([]), [et, tt] = L("16:9"), { tavusApiKey: Ve } = rI(), De = localStorage.getItem("lang") || "en", Ce = tI.find((N) => N.code === De)?.name || "English", Jt = Be(localStorage.getItem("lang") || "en");
    H(() => {
      (async () => {
        if (Me.length === 0)
          try {
            const ee = await Qv();
            ee?.Success && ee.Data && Kt(ee.Data);
          } catch (ee) {
            console.error("Error fetching avatars:", ee);
          }
      })();
    }, [Me.length]);
    const Nt = Me.find((N) => N.ExternalId === e);
    H(() => {
      De !== "en" && De !== Jt.current && (Jt.current = De, We());
    }, [De]), H(() => {
      (async () => {
        if (Nt?.ImageUrl) {
          const ee = new Image();
          ee.onload = () => {
            const Lt = ee.width / ee.height;
            Math.abs(Lt - 1.7777777777777777) < Math.abs(Lt - 0.5625) ? tt("16:9") : tt("9:16");
          }, ee.onerror = () => {
            tt("16:9");
          }, ee.src = Nt.ImageUrl;
        }
      })();
    }, [Nt?.ImageUrl]), H(() => () => {
      K && zh({
        conversationId: K.conversation_id,
        apiKey: Ve
      });
    }, [K]), H(() => {
      a === "concierge" && xt();
    }, [a]);
    const xt = async () => {
      try {
        Y(!1), J(!0), m(!0), v(!0), $e.current && $e.current.pause();
        const N = await Aw({
          replicaId: e || "r82081c7f26d",
          personaId: t || "pc9cb547c05e",
          conversationName: r || "Demo Conversation",
          conversationalContext: s ?? "",
          customGreeting: i ?? "",
          language: Ce,
          apiKey: Ve
        });
        if (N?.conversation_id && N.conversation_url)
          le(N), y(N.conversation_id), S(N.conversation_url), Q("hairCheck");
        else
          throw new Error("Failed to start conversation");
      } catch (N) {
        console.error("Conversation error:", N);
      } finally {
        J(!1);
      }
    }, We = async () => {
      Y(!0), v(!1);
      try {
        if (!K) return;
        await zh({ conversationId: K.conversation_id, apiKey: Ve });
      } catch (N) {
        console.error(N);
      } finally {
        le(null), Q("welcome");
      }
    }, Ps = () => {
      Q("call");
    };
    Cg(B, () => ({
      handleEnd: We,
      handleStart: xt
    }));
    const Gt = (N) => typeof N == "string" ? N : N ? `${N}px` : "100%", me = (N) => typeof N == "string" ? N : N ? `${N}px` : "100%", zt = Gt(d), pe = me(h), He = (N) => {
      if (!N) return;
      const ee = typeof N == "string" ? N : `${N}px`;
      return ee.includes("sm") || parseInt(ee) < 350 ? "sm" : ee.includes("lg") || parseInt(ee) > 600 ? "lg" : "md";
    }, Re = typeof f == "string" ? f : f ? `${f}px` : void 0, rt = Re && !Re.includes("px") && !Re.includes("%") ? `max-w-${Re} mx-auto` : "";
    return /* @__PURE__ */ P("main", { className: `${g} relative w-full h-full`, style: { width: zt, height: pe }, children: /* @__PURE__ */ P(Vg, { children: /* @__PURE__ */ M("div", { className: `h-full w-full ${rt}`, style: Re && Re.includes("px") ? { maxWidth: Re } : {}, children: [
      V === "welcome" && /* @__PURE__ */ P(
        Pw,
        {
          onStart: xt,
          loading: he,
          buttonText: o,
          platform: a || "home",
          replicaId: e || "r82081c7f26d",
          containerClassName: g,
          imageHeight: pe === "100%" ? "auto" : pe,
          buttonSize: He(d) || "md",
          learningPrompts: l,
          onPromptClick: p,
          userCredits: 100,
          avatars: Me,
          config: k
        }
      ),
      V === "hairCheck" && /* @__PURE__ */ P(
        bw,
        {
          handleEnd: We,
          handleJoin: Ps,
          setScreen: Q,
          platform: a || "home",
          containerClassName: g,
          videoDimensions: {
            width: zt,
            height: pe === "100%" ? "auto" : pe
          },
          buttonsSize: He(d) || "md"
        }
      ),
      V === "call" && K && /* @__PURE__ */ P("div", { className: "w-full h-full", children: /* @__PURE__ */ P(
        Iw,
        {
          conversation: K,
          handleEnd: We,
          platform: a || "home",
          videoMode: n ?? "full",
          endConv: re,
          chatVisible: c ?? !1,
          toggleChat: u,
          containerClassName: g,
          videoHeight: pe === "100%" ? "auto" : pe,
          controlsSize: He(d) || "md",
          aspectRatio: et,
          setInterruptReplica: C,
          currentScript: R,
          setCurrentScript: w,
          interruptReplica: I,
          setIsSpeaking: E,
          setSpokenText: T,
          region: b,
          speechKey: _,
          config: k
        }
      ) })
    ] }) }) });
  }
), sI = async (e, t, r, s, i = !1, a = !1) => {
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      UserId: e,
      CourseId: t,
      Query: r,
      Answer: s,
      Avatar: i,
      STT: a
    })
  };
  let c;
  try {
    const u = uc("/api/User/education/chathistory/post"), l = await fetch(u, n);
    if (!l.ok) {
      let p = {};
      const d = l.headers.get("content-type");
      throw d && d.includes("application/json") ? p = await l.json() : p = { message: await l.text() }, console.error("Error details:", p), new Error(
        `Failed to post chat history: ${l.status} ${l.statusText} - ${JSON.stringify(p)}`
      );
    }
    return c = l.headers.get("content-length") === "0" ? { Data: !0, Success: !0, Message: "Ok" } : await l.json(), c;
  } catch (u) {
    return console.error("Error posting chat history:", u), {
      Success: !1,
      Message: u instanceof Error ? u.message : "Unknown error occurred",
      Data: null
    };
  }
}, oI = [
  { id: 1, text: "Explain my report", icon: Og },
  { id: 5, text: "Analyze my medical reports.", icon: Mg },
  { id: 6, text: "Answer my questions like a personal coach", icon: Dg }
], aI = [
  "r397c808f1cf",
  "rbc834dee6f2",
  "r89e4f7ec536"
], rf = {
  en: "r397c808f1cf",
  es: "rbc834dee6f2",
  fr: "rbc834dee6f2",
  de: "r89e4f7ec536"
};
function cI({
  brandName: e = "Growth Hub",
  personaName: t = "Personal AI Concierge",
  suggestedPrompts: r = oI,
  language: s = "en",
  navigateTo: i = "",
  file: a,
  onFileChange: o,
  onApiResponse: n,
  config: c = {
    region: "",
    apiBaseUrl: "",
    speechKey: "",
    azureTranslatorKey: "",
    azureTranslatorEndpoint: "",
    azureTranslatorRegion: ""
  }
}) {
  const [, u] = zg(), [l, p] = L([]), d = l.find((q) => q.ExternalId === "r397c808f1cf"), [h, f] = L(d || null), [g, m] = L("chat"), [v, y] = L(!1), [S, C] = L(!1), [R, w] = L(!1), [I, E] = L([]), [T, b] = L({}), [_, k] = L(""), [B, V] = L(!1), [Q, K] = L(!1), [le, he] = L(""), J = Be(null), [re, Y] = L(""), [$e, Me] = L(!1), [Kt, et] = L(!1), [tt, Ve] = L(!1), [De, Ce] = L(""), [Jt, Nt] = L(""), [xt, We] = L(""), [Ps, Gt] = L(""), [me, zt] = L(!1), pe = Be(null), He = Be(null), [Re, rt] = L([]), [N, ee] = L({
    avatar: {
      chooseAvatar: `Choose Your ${t}`,
      startConversation: "Start Conversation",
      yourAIHealthNavigator: `Your ${t}`,
      description: "I'm here to help you with your health and wellness."
    },
    buttons: {
      resetChat: "Reset Chat",
      retry: "Retry",
      continue: "Continue",
      uploading: "Uploading...",
      upload: "Upload report"
    },
    howItWorks: {
      title: "How It Works",
      steps: [
        `Your AI ${t} asks you questions to find out how ${e} can help you.`,
        `The ${t} will personalize recommendations based on your needs`,
        "Access tailored resources, courses, and marketplace options."
      ]
    }
  });
  H(() => {
    window.scrollTo(0, 0);
  }, []), H(() => {
    (async () => {
      try {
        const W = await Qv();
        if (W?.Success && W.Data) {
          const U = W.Data.filter(
            ($) => aI.includes($.ExternalId)
          );
          p(U), U.length > 0 && f(U[0]);
        }
      } catch (W) {
        console.error("Error fetching avatars:", W);
      }
    })();
  }, []), H(() => {
    if (!me && l.length > 0) {
      const q = rf[s] || rf.en, W = l.find((U) => U.ExternalId === q);
      f(W || l[0]);
    }
  }, [l, me, s]), H(() => {
    m(me ? "voice" : "chat");
  }, [me]), H(() => {
    if (!(!!c?.azureTranslatorKey && !!c?.azureTranslatorEndpoint && !!c?.azureTranslatorRegion)) {
      console.warn("Azure translation config is not yet ready.");
      return;
    }
    (async () => {
      if (s !== "en" && pe.current !== s) {
        const [
          U,
          $,
          Ke,
          te,
          Pe,
          ye,
          Yt,
          eo,
          to,
          Zt,
          ro,
          no,
          io
        ] = await Ws(
          [
            `Choose Your ${t}`,
            "Start Conversation",
            `Your ${t}`,
            `I'm here to help you with ${e}.`,
            "Reset Chat",
            "Retry",
            "Continue",
            "Uploading...",
            "Upload Report",
            "How It Works",
            `Your AI ${t} asks you questions to find out how ${e} can help you.`,
            `The ${t} will personalize recommendations based on your needs`,
            "Access tailored resources, courses, and marketplace options."
          ],
          s,
          "en",
          c.azureTranslatorKey,
          c.azureTranslatorEndpoint,
          c.azureTranslatorRegion
        );
        y(!1), k(""), E([]), ee({
          avatar: {
            chooseAvatar: U,
            startConversation: $,
            yourAIHealthNavigator: Ke,
            description: te
          },
          buttons: {
            resetChat: Pe,
            retry: ye,
            continue: Yt,
            uploading: eo,
            upload: to
          },
          howItWorks: {
            title: Zt,
            steps: [ro, no, io]
          }
        }), pe.current = s;
      }
      s === "en" && pe.current !== "en" && (y(!1), k(""), E([]), ee({
        avatar: {
          chooseAvatar: `Choose Your ${t}`,
          startConversation: "Start Conversation",
          yourAIHealthNavigator: `Your ${t}`,
          description: `I'm here to help you with ${e}.`
        },
        buttons: {
          resetChat: "Reset Chat",
          retry: "Retry",
          continue: "Continue",
          uploading: "Uploading...",
          upload: "Upload Report"
        },
        howItWorks: {
          title: "How It Works",
          steps: [
            `Your AI ${t} asks you questions to find out how ${e} can help you.`,
            `The ${t} will personalize recommendations based on your needs`,
            "Access tailored resources, courses, and marketplace options."
          ]
        }
      }), pe.current = "en");
    })();
  }, [
    s,
    c?.azureTranslatorKey,
    c?.azureTranslatorEndpoint,
    c?.azureTranslatorRegion,
    t,
    e
  ]), H(() => {
    a && (rt([a]), nt(`Uploaded file: ${a.name}`, [a]));
  }, [a]);
  const Lt = Ga(
    async (q) => {
      C(!0);
      const U = await xh(
        "I am user",
        "",
        "",
        "interview",
        _,
        0,
        1,
        s
      );
      return U.Success && U.Data?.Message ? U.Data.Message.includes("ERROR") ? (C(!1), Ce(`Hello there! I'm ${q?.Name}, your ${t}. I'm here to help you with ${e}. Can you tell me your name?`), {
        id: "welcome-message",
        sender: "ai",
        text: `Hello there! I'm ${q?.Name}, your ${t}. I'm here to help you with ${e}. Can you tell me a little about yourself?`,
        timestamp: /* @__PURE__ */ new Date()
      }) : (C(!1), k(U.Data.SessionId || ""), Ce(U.Data.Message), {
        id: "welcome-message",
        sender: "ai",
        text: U.Data.Message,
        timestamp: /* @__PURE__ */ new Date()
      }) : (C(!1), {
        id: "welcome-message",
        sender: "ai",
        text: `Hello there! I'm ${q?.Name}, your ${t}. I'm here to help you with ${e}. Can you tell me a little about yourself?`,
        timestamp: /* @__PURE__ */ new Date()
      });
    },
    [e]
  );
  H(() => {
    me && Lt(h || l[0]).then((q) => {
      E([q]);
    });
  }, [me]), H(() => {
    Ve(!0);
  }, []), H(() => {
    re && re.trim() !== "" && (nt(re), Y(""));
  }, [re]), H(() => {
    y(!!me);
  }, [me]);
  const bs = async (q) => {
    if (!h) return;
    const W = l.findIndex(
      ($) => $.ExternalId === h.ExternalId
    );
    let U;
    if (q === "next") {
      const $ = (W + 1) % l.length;
      U = l[$];
    } else {
      const $ = (W - 1 + l.length) % l.length;
      U = l[$];
    }
    f(U);
  }, nt = async (q, W = []) => {
    Q && K(!1);
    const U = {
      id: Date.now().toString(),
      sender: "user",
      text: q,
      timestamp: /* @__PURE__ */ new Date()
    };
    he(q), E((te) => [...te, U]), C(!0);
    let $ = `${q}`;
    const Ke = [...Re, ...W];
    W.length > 0 && ($ += "Summarize this file in 3–4 very simple sentences, as if you are explaining to a 3rd grader. Only include the most important points. Also, list anything in the file that should be double-checked or reviewed.");
    try {
      const te = await xh(
        $,
        "",
        // Send user ID instead of email
        "",
        // Business ID
        "interview",
        // Intent
        _,
        0,
        1,
        s,
        Ke.length > 0 ? Ke[0] : void 0
        // Only send last file
      );
      if (te.Success && te.Data?.Message) {
        if (te?.Data?.Message?.includes("ERROR") || te?.Data?.Type === "error") {
          C(!1);
          const ye = {
            id: (Date.now() + 1).toString(),
            sender: "ai",
            text: "Sorry, I couldn't process your request at the moment. Please try again.",
            timestamp: /* @__PURE__ */ new Date()
          };
          E((Yt) => [...Yt, ye]), Ce(ye.text), K(!0);
          return;
        }
        const Pe = {
          id: (Date.now() + 1).toString(),
          sender: "ai",
          text: te.Data.Message,
          timestamp: /* @__PURE__ */ new Date()
        };
        E((ye) => [...ye, Pe]), _ || k(te?.Data?.SessionId || ""), Ce(te.Data.Message), (te.Data.Message.toLowerCase().includes("click continue") || te.Data.Message.toLowerCase().includes("sign up") || te.Data.Message.toLowerCase().includes("thank you for choosing") || te.Data.Message.toLowerCase().includes("ready to connect")) && (V(!0), n && n(te)), await sI(
          "",
          "AIHealthNavigator",
          q,
          te.Data.Message || "",
          g === "voice",
          //isUserUsingAvatar
          q === re
          // isUserSpeaking
        ), he("");
      } else {
        const Pe = {
          id: (Date.now() + 1).toString(),
          sender: "ai",
          text: "Sorry, I couldn't process your request. Please try again.",
          timestamp: /* @__PURE__ */ new Date()
        };
        E((ye) => [...ye, Pe]), Ce(Pe.text), K(!0);
      }
    } catch (te) {
      console.error("Error fetching response from LLM: ", te);
      const Pe = {
        id: (Date.now() + 1).toString(),
        sender: "ai",
        text: "Sorry, I couldn't connect to the AI service. Please try again later.",
        timestamp: /* @__PURE__ */ new Date()
      };
      E((ye) => [...ye, Pe]), Ce(Pe.text), K(!0);
    } finally {
      C(!1);
    }
  }, Ys = () => {
    console.log("Toggle chat visibility");
  }, Zs = () => {
    i ? window.location.href = i : window.location.href = "https://growth-hub-git-feature-whitelabeljun25v1-real-business.vercel.app/auth/rgister";
  }, Xs = () => {
    E([]);
  }, ws = (q, W) => {
    const U = W === "like";
    b(($) => ({
      ...$,
      [q.id]: W
    })), Rw(
      q.text,
      "",
      "",
      U
    ).then(($) => {
    }).catch(($) => {
      console.error("Error sending feedback:", $);
    });
  }, Qt = async (q) => {
    w(!0);
    const W = Array.from(q.target.files || []);
    if (W.length > 0) {
      const U = W[0];
      rt([U]), o && o(U), w(!1), await nt(`Uploaded file: ${U.name}`, [U]);
    }
    q.target && (q.target.value = "");
  }, ie = () => {
    He.current?.click();
  };
  return /* @__PURE__ */ M("div", { className: "w-full h-full", children: [
    /* @__PURE__ */ P("div", { className: "container max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-8", children: /* @__PURE__ */ M("div", { className: "relative", children: [
      /* @__PURE__ */ P("div", { className: "relative z-10", children: /* @__PURE__ */ M(
        af.div,
        {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          transition: { duration: 0.5 },
          className: "rounded-lg shadow-2xl border border-primary/20 overflow-hidden",
          children: [
            /* @__PURE__ */ P("div", { className: "p-6 bg-neutral border-b border-primary/20", children: /* @__PURE__ */ M("div", { className: "flex items-center justify-between", children: [
              /* @__PURE__ */ M("div", { className: "flex items-center", children: [
                /* @__PURE__ */ P("div", { className: "h-12 w-12 rounded-full overflow-hidden mr-4", children: /* @__PURE__ */ P(
                  "img",
                  {
                    src: h?.ImageUrl,
                    alt: h?.Name,
                    className: "h-full w-full object-cover"
                  }
                ) }),
                /* @__PURE__ */ M("div", { children: [
                  /* @__PURE__ */ P("h1", { className: "text-2xl font-bold text-primary", children: N.avatar.yourAIHealthNavigator }),
                  /* @__PURE__ */ P("p", { className: "text-sm text-secondary", children: N.avatar.description })
                ] })
              ] }),
              /* @__PURE__ */ M("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ M(
                  Te,
                  {
                    variant: "outline",
                    size: "sm",
                    className: "text-xs text-primary border-primary/30 hover:bg-neutral",
                    onClick: ie,
                    disabled: R,
                    children: [
                      /* @__PURE__ */ P(Ag, { className: "h-3 w-3 mr-1" }),
                      R ? N.buttons.uploading : N.buttons.upload
                    ]
                  }
                ),
                /* @__PURE__ */ P(
                  Te,
                  {
                    variant: "outline",
                    size: "sm",
                    className: "text-xs text-primary border-primary/30 hover:bg-neutral",
                    onClick: Xs,
                    children: N.buttons.resetChat
                  }
                )
              ] })
            ] }) }),
            /* @__PURE__ */ M("div", { className: "grid grid-cols-1 md:grid-cols-2 h-[600px]", children: [
              /* @__PURE__ */ P("div", { className: "p-4 md:p-6 border-b md:border-b-0 md:border-r border-primary/20", children: /* @__PURE__ */ P("div", { className: "h-full w-full", children: v ? /* @__PURE__ */ P("div", { className: "h-full w-full rounded-xl overflow-hidden bg-gradient-to-br from-neutral to-white border border-primary/20", children: h && /* @__PURE__ */ P(
                iI,
                {
                  ref: J,
                  replicaId: h?.ExternalId || "",
                  personaId: "pb5d44035dbd",
                  conversationName: `Conversation with ${h?.Name || "your" + t} ${(/* @__PURE__ */ new Date()).toISOString()}`,
                  conversationalContext: "Initial business consultation",
                  customGreeting: I.length > 0 && I[I.length - 1].sender === "ai" ? I[I.length - 1].text : `Hello there! I'm ${h?.Name}, your ${t}. I'm here to help you on the ${e}. Ready to get started?`,
                  platform: "concierge",
                  buttonText: N.avatar.startConversation,
                  videoMode: "minimal",
                  chatVisible: !1,
                  toggleChat: Ys,
                  width: "100%",
                  height: "100%",
                  className: "w-full h-full",
                  setVoiceMode: Ve,
                  setConversationStarted: zt,
                  setConversationId: We,
                  setConversationUrl: Gt,
                  setInterruptReplica: et,
                  currentScript: De,
                  setCurrentScript: Ce,
                  interruptReplica: Kt,
                  setIsSpeaking: Me,
                  setSpokenText: Y,
                  region: c?.region || "",
                  speechKey: c?.speechKey || "",
                  config: c
                }
              ) }) : /* @__PURE__ */ M("div", { className: "h-full w-full flex flex-col items-center justify-center", children: [
                /* @__PURE__ */ P("h3", { className: "text-lg font-semibold text-center mb-4 text-primary", children: N.avatar.chooseAvatar }),
                /* @__PURE__ */ P("div", { className: "mb-6 flex items-center justify-center gap-2 text-sm text-secondary", children: /* @__PURE__ */ M("div", { className: "relative group", children: [
                  /* @__PURE__ */ M("div", { className: "flex items-center gap-2 cursor-help", children: [
                    /* @__PURE__ */ P(Tg, { className: "h-4 w-4 text-primary hover:text-secondary transition-colors" }),
                    /* @__PURE__ */ P("span", { children: N.howItWorks.title })
                  ] }),
                  /* @__PURE__ */ M("div", { className: "absolute left-1 -translate-x-1 bottom-full mb-2 w-64 p-3 bg-white rounded-lg shadow-lg border border-primary/20 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-10", children: [
                    /* @__PURE__ */ P("h4", { className: "font-medium text-primary mb-2", children: N.howItWorks.title }),
                    N.howItWorks.steps.map((q, W) => /* @__PURE__ */ M("li", { className: "flex items-start gap-2", children: [
                      /* @__PURE__ */ M("span", { className: "font-bold flex-shrink-0", children: [
                        W + 1,
                        "."
                      ] }),
                      /* @__PURE__ */ P("span", { className: "break-words", children: q })
                    ] }, W))
                  ] })
                ] }) }),
                /* @__PURE__ */ P("div", { className: "w-48 h-48 rounded-xl overflow-hidden mb-4 bg-gradient-to-br from-neutral to-white border border-primary/20", children: /* @__PURE__ */ P(
                  "img",
                  {
                    src: h?.ImageUrl,
                    alt: h?.Name,
                    className: "w-full h-full object-cover"
                  }
                ) }),
                /* @__PURE__ */ M("div", { className: "flex items-center justify-center gap-4 mb-6", children: [
                  /* @__PURE__ */ P(
                    Te,
                    {
                      variant: "outline",
                      size: "icon",
                      onClick: () => bs("prev"),
                      className: "rounded-full",
                      children: /* @__PURE__ */ P(_g, { className: "h-4 w-4" })
                    }
                  ),
                  /* @__PURE__ */ P("span", { className: "text-primary font-medium", children: h?.Name }),
                  /* @__PURE__ */ P(
                    Te,
                    {
                      variant: "outline",
                      size: "icon",
                      onClick: () => bs("next"),
                      className: "rounded-full",
                      children: /* @__PURE__ */ P(kg, { className: "h-4 w-4" })
                    }
                  )
                ] }),
                /* @__PURE__ */ P(
                  Te,
                  {
                    onClick: () => y(!0),
                    className: "w-full bg-primary hover:bg-secondary text-white py-3 px-6 rounded-lg font-semibold shadow-md transition",
                    children: N.avatar.startConversation
                  }
                )
              ] }) }) }),
              /* @__PURE__ */ P("div", { className: "flex flex-col h-full overflow-hidden p-4 md:p-6", children: /* @__PURE__ */ P("div", { className: "flex-1 min-h-0 overflow-y-auto p-6", children: /* @__PURE__ */ P(
                aC,
                {
                  language: s,
                  config: c,
                  setInterruptReplica: et,
                  messages: I,
                  onSendMessage: nt,
                  className: "h-full",
                  isLoading: S,
                  rightElement: /* @__PURE__ */ P(
                    Jv,
                    {
                      avatarName: h?.Name || "AI Health Navigator",
                      disabled: S,
                      voiceMode: tt,
                      setSpokenText: Y,
                      setIsSpeaking: Me,
                      setInterruptReplica: et,
                      region: c?.region || "",
                      speechKey: c?.speechKey || ""
                    }
                  ),
                  suggestedPrompts: r,
                  renderMessage: (q, W) => {
                    if (q.sender === "ai" && q.id !== "welcome-message") {
                      const U = W === I.length - 1;
                      return /* @__PURE__ */ M("div", { className: "relative", children: [
                        /* @__PURE__ */ P(
                          Oa,
                          {
                            remarkPlugins: [xa],
                            components: {
                              p: ({ children: $ }) => /* @__PURE__ */ P("p", { className: "text-sm mb-2", children: $ }),
                              ol: ({ children: $ }) => /* @__PURE__ */ P("ol", { style: { listStyleType: "circle" }, className: "ml-6 mb-2", children: $ }),
                              ul: ({ children: $ }) => /* @__PURE__ */ P("ul", { className: "list-disc ml-6 mb-2", children: $ }),
                              li: ({ children: $ }) => /* @__PURE__ */ P("li", { className: "mb-1", children: $ }),
                              strong: ({ children: $ }) => /* @__PURE__ */ P("strong", { className: "font-semibold", children: $ }),
                              a: ({ href: $, children: Ke }) => /* @__PURE__ */ P(
                                "a",
                                {
                                  href: $,
                                  target: "_blank",
                                  rel: "noopener noreferrer",
                                  className: "text-blue-600 underline",
                                  children: Ke
                                }
                              )
                            },
                            children: q.text
                          }
                        ),
                        /* @__PURE__ */ M("div", { className: "flex justify-end gap-2 mt-2", children: [
                          /* @__PURE__ */ P(
                            "button",
                            {
                              className: `p-1 rounded-full transition-colors ${T[q.id] === "like" ? "bg-green-100 text-green-600" : "hover:bg-gray-200 text-gray-600"}`,
                              onClick: () => ws(q, "like"),
                              children: /* @__PURE__ */ P(Ng, { className: "h-4 w-4" })
                            }
                          ),
                          /* @__PURE__ */ P(
                            "button",
                            {
                              className: `p-1 rounded-full transition-colors ${T[q.id] === "dislike" ? "bg-red-100 text-red-600" : "hover:bg-gray-200 text-gray-600"}`,
                              onClick: () => ws(q, "dislike"),
                              children: /* @__PURE__ */ P(xg, { className: "h-4 w-4" })
                            }
                          )
                        ] }),
                        Q && U && /* @__PURE__ */ P("div", { className: "mt-4 flex", children: /* @__PURE__ */ P(
                          "button",
                          {
                            className: "bg-primary hover:bg-secondary text-white px-6 py-3 rounded-lg font-semibold shadow-md transition",
                            onClick: () => {
                              nt(le), K(!1);
                            },
                            children: N.buttons.retry
                          }
                        ) }),
                        U && B && /* @__PURE__ */ P("div", { className: "mt-4 flex justify-center", children: /* @__PURE__ */ P(
                          "button",
                          {
                            className: "bg-primary hover:bg-secondary text-white px-6 py-3 rounded-lg font-semibold shadow-md transition",
                            onClick: Zs,
                            children: N.buttons.continue
                          }
                        ) })
                      ] });
                    }
                    return /* @__PURE__ */ P(
                      Oa,
                      {
                        remarkPlugins: [xa],
                        components: {
                          p: ({ children: U }) => /* @__PURE__ */ P("p", { className: "text-sm whitespace-pre-line", children: U })
                        },
                        children: q.text
                      }
                    );
                  }
                }
              ) }) })
            ] })
          ]
        }
      ) }),
      /* @__PURE__ */ P("div", { className: "absolute -top-4 -right-4 w-72 h-72 bg-primary/20 rounded-full blur-3xl" }),
      /* @__PURE__ */ P("div", { className: "absolute -bottom-8 -left-8 w-96 h-96 bg-secondary/10 rounded-full blur-3xl" })
    ] }) }),
    /* @__PURE__ */ P(
      "input",
      {
        type: "file",
        ref: He,
        onChange: Qt,
        accept: ".pdf,.doc,.docx,.jpg,.jpeg,.png,.txt",
        style: { display: "none" }
      }
    )
  ] });
}
function NT(e) {
  return /* @__PURE__ */ P(nI, { value: e.config || {}, children: /* @__PURE__ */ P(cI, { ...e }) });
}
const ag = sf(void 0), xT = ({ children: e, value: t }) => /* @__PURE__ */ P(ag.Provider, { value: t, children: e }), zT = () => {
  const e = of(ag);
  if (!e)
    throw new Error("useConciergeContext must be used within a ConciergeProvider");
  return e;
};
export {
  NT as ConciergeModule,
  cI as ConciergeModuleRaw,
  xT as ConciergeProvider,
  iI as ConversationComponent,
  Jv as SpeechComponent,
  zT as useConciergeContext
};
