import { jsx as P, jsxs as k, Fragment as zs } from "react/jsx-runtime";
import * as ae from "react";
import { useState as D, useRef as Ve, useEffect as B, useCallback as nc, createContext as hf, useContext as ff, forwardRef as Cg, useImperativeHandle as Rg } from "react";
import { motion as vf } from "framer-motion";
import { Bot as Cc, RotateCcw as Pg, Loader2 as ja, ChevronDown as bg, ChevronUp as wg, Send as Eg, Mic as Ig, MicOff as Ag, Upload as Rc, X as Tg, Menu as _g, HelpCircle as kg, GraduationCap as Og, Sparkles as Mg, MessageSquare as Dg, ThumbsUp as Ng, ThumbsDown as xg } from "lucide-react";
import qa from "react-markdown";
import * as ys from "@radix-ui/react-tooltip";
import { useVideoTrack as gf, DailyVideo as zg, useLocalSessionId as mf, useDaily as Ws, useDevices as Lg, useAudioTrack as jg, useDailyEvent as qg, useParticipantIds as Fg, useAppMessage as Bg, DailyAudio as Ug, DailyProvider as $g } from "@daily-co/daily-react";
import Vg from "@mui/icons-material/CallEnd";
import { initReactI18next as Wg } from "react-i18next";
function Pc(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Hg(...e) {
  return (t) => {
    let r = !1;
    const o = e.map((i) => {
      const a = Pc(i, t);
      return !r && typeof a == "function" && (r = !0), a;
    });
    if (r)
      return () => {
        for (let i = 0; i < o.length; i++) {
          const a = o[i];
          typeof a == "function" ? a() : Pc(e[i], null);
        }
      };
  };
}
// @__NO_SIDE_EFFECTS__
function Kg(e) {
  const t = /* @__PURE__ */ Gg(e), r = ae.forwardRef((o, i) => {
    const { children: a, ...s } = o, n = ae.Children.toArray(a), c = n.find(Yg);
    if (c) {
      const u = c.props.children, l = n.map((p) => p === c ? ae.Children.count(u) > 1 ? ae.Children.only(null) : ae.isValidElement(u) ? u.props.children : null : p);
      return /* @__PURE__ */ P(t, { ...s, ref: i, children: ae.isValidElement(u) ? ae.cloneElement(u, void 0, l) : null });
    }
    return /* @__PURE__ */ P(t, { ...s, ref: i, children: a });
  });
  return r.displayName = `${e}.Slot`, r;
}
var Jg = /* @__PURE__ */ Kg("Slot");
// @__NO_SIDE_EFFECTS__
function Gg(e) {
  const t = ae.forwardRef((r, o) => {
    const { children: i, ...a } = r;
    if (ae.isValidElement(i)) {
      const s = Xg(i), n = Zg(a, i.props);
      return i.type !== ae.Fragment && (n.ref = o ? Hg(o, s) : s), ae.cloneElement(i, n);
    }
    return ae.Children.count(i) > 1 ? ae.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Qg = Symbol("radix.slottable");
function Yg(e) {
  return ae.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Qg;
}
function Zg(e, t) {
  const r = { ...t };
  for (const o in t) {
    const i = e[o], a = t[o];
    /^on[A-Z]/.test(o) ? i && a ? r[o] = (...n) => {
      const c = a(...n);
      return i(...n), c;
    } : i && (r[o] = i) : o === "style" ? r[o] = { ...i, ...a } : o === "className" && (r[o] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...r };
}
function Xg(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
function yf(e) {
  var t, r, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = yf(e[t])) && (o && (o += " "), o += r);
  } else for (r in e) e[r] && (o && (o += " "), o += r);
  return o;
}
function Sf() {
  for (var e, t, r = 0, o = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = yf(e)) && (o && (o += " "), o += t);
  return o;
}
const bc = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, wc = Sf, em = (e, t) => (r) => {
  var o;
  if (t?.variants == null) return wc(e, r?.class, r?.className);
  const { variants: i, defaultVariants: a } = t, s = Object.keys(i).map((u) => {
    const l = r?.[u], p = a?.[u];
    if (l === null) return null;
    const d = bc(l) || bc(p);
    return i[u][d];
  }), n = r && Object.entries(r).reduce((u, l) => {
    let [p, d] = l;
    return d === void 0 || (u[p] = d), u;
  }, {}), c = t == null || (o = t.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((u, l) => {
    let { class: p, className: d, ...h } = l;
    return Object.entries(h).every((f) => {
      let [g, m] = f;
      return Array.isArray(m) ? m.includes({
        ...a,
        ...n
      }[g]) : {
        ...a,
        ...n
      }[g] === m;
    }) ? [
      ...u,
      p,
      d
    ] : u;
  }, []);
  return wc(e, s, c, r?.class, r?.className);
}, ic = "-", tm = (e) => {
  const t = nm(e), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: o
  } = e;
  return {
    getClassGroupId: (s) => {
      const n = s.split(ic);
      return n[0] === "" && n.length !== 1 && n.shift(), Cf(n, t) || rm(s);
    },
    getConflictingClassGroupIds: (s, n) => {
      const c = r[s] || [];
      return n && o[s] ? [...c, ...o[s]] : c;
    }
  };
}, Cf = (e, t) => {
  if (e.length === 0)
    return t.classGroupId;
  const r = e[0], o = t.nextPart.get(r), i = o ? Cf(e.slice(1), o) : void 0;
  if (i)
    return i;
  if (t.validators.length === 0)
    return;
  const a = e.join(ic);
  return t.validators.find(({
    validator: s
  }) => s(a))?.classGroupId;
}, Ec = /^\[(.+)\]$/, rm = (e) => {
  if (Ec.test(e)) {
    const t = Ec.exec(e)[1], r = t?.substring(0, t.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, nm = (e) => {
  const {
    theme: t,
    prefix: r
  } = e, o = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return sm(Object.entries(e.classGroups), r).forEach(([a, s]) => {
    Fa(s, o, a, t);
  }), o;
}, Fa = (e, t, r, o) => {
  e.forEach((i) => {
    if (typeof i == "string") {
      const a = i === "" ? t : Ic(t, i);
      a.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (im(i)) {
        Fa(i(o), t, r, o);
        return;
      }
      t.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([a, s]) => {
      Fa(s, Ic(t, a), r, o);
    });
  });
}, Ic = (e, t) => {
  let r = e;
  return t.split(ic).forEach((o) => {
    r.nextPart.has(o) || r.nextPart.set(o, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(o);
  }), r;
}, im = (e) => e.isThemeGetter, sm = (e, t) => t ? e.map(([r, o]) => {
  const i = o.map((a) => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([s, n]) => [t + s, n])) : a);
  return [r, i];
}) : e, om = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  const i = (a, s) => {
    r.set(a, s), t++, t > e && (t = 0, o = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(a) {
      let s = r.get(a);
      if (s !== void 0)
        return s;
      if ((s = o.get(a)) !== void 0)
        return i(a, s), s;
    },
    set(a, s) {
      r.has(a) ? r.set(a, s) : i(a, s);
    }
  };
}, Rf = "!", am = (e) => {
  const {
    separator: t,
    experimentalParseClassName: r
  } = e, o = t.length === 1, i = t[0], a = t.length, s = (n) => {
    const c = [];
    let u = 0, l = 0, p;
    for (let m = 0; m < n.length; m++) {
      let v = n[m];
      if (u === 0) {
        if (v === i && (o || n.slice(m, m + a) === t)) {
          c.push(n.slice(l, m)), l = m + a;
          continue;
        }
        if (v === "/") {
          p = m;
          continue;
        }
      }
      v === "[" ? u++ : v === "]" && u--;
    }
    const d = c.length === 0 ? n : n.substring(l), h = d.startsWith(Rf), f = h ? d.substring(1) : d, g = p && p > l ? p - l : void 0;
    return {
      modifiers: c,
      hasImportantModifier: h,
      baseClassName: f,
      maybePostfixModifierPosition: g
    };
  };
  return r ? (n) => r({
    className: n,
    parseClassName: s
  }) : s;
}, cm = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let r = [];
  return e.forEach((o) => {
    o[0] === "[" ? (t.push(...r.sort(), o), r = []) : r.push(o);
  }), t.push(...r.sort()), t;
}, um = (e) => ({
  cache: om(e.cacheSize),
  parseClassName: am(e),
  ...tm(e)
}), lm = /\s+/, pm = (e, t) => {
  const {
    parseClassName: r,
    getClassGroupId: o,
    getConflictingClassGroupIds: i
  } = t, a = [], s = e.trim().split(lm);
  let n = "";
  for (let c = s.length - 1; c >= 0; c -= 1) {
    const u = s[c], {
      modifiers: l,
      hasImportantModifier: p,
      baseClassName: d,
      maybePostfixModifierPosition: h
    } = r(u);
    let f = !!h, g = o(f ? d.substring(0, h) : d);
    if (!g) {
      if (!f) {
        n = u + (n.length > 0 ? " " + n : n);
        continue;
      }
      if (g = o(d), !g) {
        n = u + (n.length > 0 ? " " + n : n);
        continue;
      }
      f = !1;
    }
    const m = cm(l).join(":"), v = p ? m + Rf : m, y = v + g;
    if (a.includes(y))
      continue;
    a.push(y);
    const S = i(g, f);
    for (let C = 0; C < S.length; ++C) {
      const b = S[C];
      a.push(v + b);
    }
    n = u + (n.length > 0 ? " " + n : n);
  }
  return n;
};
function dm() {
  let e = 0, t, r, o = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (r = Pf(t)) && (o && (o += " "), o += r);
  return o;
}
const Pf = (e) => {
  if (typeof e == "string")
    return e;
  let t, r = "";
  for (let o = 0; o < e.length; o++)
    e[o] && (t = Pf(e[o])) && (r && (r += " "), r += t);
  return r;
};
function hm(e, ...t) {
  let r, o, i, a = s;
  function s(c) {
    const u = t.reduce((l, p) => p(l), e());
    return r = um(u), o = r.cache.get, i = r.cache.set, a = n, n(c);
  }
  function n(c) {
    const u = o(c);
    if (u)
      return u;
    const l = pm(c, r);
    return i(c, l), l;
  }
  return function() {
    return a(dm.apply(null, arguments));
  };
}
const J = (e) => {
  const t = (r) => r[e] || [];
  return t.isThemeGetter = !0, t;
}, bf = /^\[(?:([a-z-]+):)?(.+)\]$/i, fm = /^\d+\/\d+$/, vm = /* @__PURE__ */ new Set(["px", "full", "screen"]), gm = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, mm = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, ym = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Sm = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Cm = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Le = (e) => Wt(e) || vm.has(e) || fm.test(e), Ye = (e) => Ht(e, "length", Tm), Wt = (e) => !!e && !Number.isNaN(Number(e)), fo = (e) => Ht(e, "number", Wt), er = (e) => !!e && Number.isInteger(Number(e)), Rm = (e) => e.endsWith("%") && Wt(e.slice(0, -1)), j = (e) => bf.test(e), Ze = (e) => gm.test(e), Pm = /* @__PURE__ */ new Set(["length", "size", "percentage"]), bm = (e) => Ht(e, Pm, wf), wm = (e) => Ht(e, "position", wf), Em = /* @__PURE__ */ new Set(["image", "url"]), Im = (e) => Ht(e, Em, km), Am = (e) => Ht(e, "", _m), tr = () => !0, Ht = (e, t, r) => {
  const o = bf.exec(e);
  return o ? o[1] ? typeof t == "string" ? o[1] === t : t.has(o[1]) : r(o[2]) : !1;
}, Tm = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  mm.test(e) && !ym.test(e)
), wf = () => !1, _m = (e) => Sm.test(e), km = (e) => Cm.test(e), Om = () => {
  const e = J("colors"), t = J("spacing"), r = J("blur"), o = J("brightness"), i = J("borderColor"), a = J("borderRadius"), s = J("borderSpacing"), n = J("borderWidth"), c = J("contrast"), u = J("grayscale"), l = J("hueRotate"), p = J("invert"), d = J("gap"), h = J("gradientColorStops"), f = J("gradientColorStopPositions"), g = J("inset"), m = J("margin"), v = J("opacity"), y = J("padding"), S = J("saturate"), C = J("scale"), b = J("sepia"), w = J("skew"), I = J("space"), E = J("translate"), N = () => ["auto", "contain", "none"], R = () => ["auto", "hidden", "clip", "visible", "scroll"], M = () => ["auto", j, t], T = () => [j, t], L = () => ["", Le, Ye], U = () => ["auto", Wt, j], Q = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], ee = () => ["solid", "dashed", "dotted", "double", "none"], re = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], he = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], W = () => ["", "0", j], ie = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], K = () => [Wt, j];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [tr],
      spacing: [Le, Ye],
      blur: ["none", "", Ze, j],
      brightness: K(),
      borderColor: [e],
      borderRadius: ["none", "", "full", Ze, j],
      borderSpacing: T(),
      borderWidth: L(),
      contrast: K(),
      grayscale: W(),
      hueRotate: K(),
      invert: W(),
      gap: T(),
      gradientColorStops: [e],
      gradientColorStopPositions: [Rm, Ye],
      inset: M(),
      margin: M(),
      opacity: K(),
      padding: T(),
      saturate: K(),
      scale: K(),
      sepia: W(),
      skew: K(),
      space: T(),
      translate: T()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", j]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ze]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": ie()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": ie()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...Q(), j]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: R()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": R()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": R()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: N()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": N()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": N()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", er, j]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: M()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", j]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: W()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: W()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", er, j]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [tr]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", er, j]
        }, j]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": U()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": U()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [tr]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [er, j]
        }, j]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": U()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": U()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", j]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", j]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [d]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [d]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [d]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...he()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...he(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...he(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [y]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [y]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [y]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [y]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [y]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [y]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [y]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [y]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [y]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [m]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [m]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [m]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [m]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [m]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [m]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [m]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [m]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [m]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [I]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [I]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", j, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [j, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [j, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [Ze]
        }, Ze]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [j, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [j, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [j, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [j, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Ze, Ye]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", fo]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [tr]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", j]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Wt, fo]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Le, j]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", j]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", j]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [v]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [v]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...ee(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Le, Ye]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Le, j]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: T()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", j]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", j]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [v]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...Q(), wm]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", bm]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Im]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [f]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [f]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [f]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [h]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [n]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [n]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [n]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [n]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [n]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [n]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [n]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [n]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [n]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [v]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...ee(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [n]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [n]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [v]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: ee()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...ee()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Le, j]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Le, Ye]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: L()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [v]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Le, Ye]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Ze, Am]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [tr]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [v]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...re(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": re()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [o]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [c]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Ze, j]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [u]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [l]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [S]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [b]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [o]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [c]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [u]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [l]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [v]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [S]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [b]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [s]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [s]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [s]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", j]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: K()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", j]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: K()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", j]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [C]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [C]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [C]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [er, j]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [E]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [E]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [w]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [w]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", j]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", j]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": T()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": T()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": T()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": T()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": T()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": T()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": T()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": T()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": T()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": T()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": T()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": T()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": T()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": T()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": T()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": T()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": T()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": T()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", j]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Le, Ye, fo]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Mm = /* @__PURE__ */ hm(Om);
function ps(...e) {
  return Mm(Sf(e));
}
const Dm = em(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), ke = ae.forwardRef(
  ({ className: e, variant: t, size: r, asChild: o = !1, ...i }, a) => /* @__PURE__ */ P(
    o ? Jg : "button",
    {
      className: ps(Dm({ variant: t, size: r, className: e })),
      ref: a,
      ...i
    }
  )
);
ke.displayName = "Button";
function Ac(e, t) {
  const r = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let o = 0, i = r.indexOf(t);
  for (; i !== -1; )
    o++, i = r.indexOf(t, i + t.length);
  return o;
}
const hs = Ks(/[A-Za-z]/), sc = Ks(/[\dA-Za-z]/);
function Nm(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
function Vt(e) {
  return e !== null && e < -2;
}
function de(e) {
  return e !== null && (e < 0 || e === 32);
}
function Ue(e) {
  return e === -2 || e === -1 || e === 32;
}
const Hs = Ks(new RegExp("\\p{P}|\\p{S}", "u")), zt = Ks(/\s/);
function Ks(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function xm(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const Js = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return qm;
    if (typeof e == "function")
      return Gs(e);
    if (typeof e == "object")
      return Array.isArray(e) ? zm(e) : Lm(e);
    if (typeof e == "string")
      return jm(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function zm(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = Js(e[r]);
  return Gs(o);
  function o(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function Lm(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Gs(r);
  function r(o) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      o
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function jm(e) {
  return Gs(t);
  function t(r) {
    return r && r.type === e;
  }
}
function Gs(e) {
  return t;
  function t(r, o, i) {
    return !!(Fm(r) && e.call(
      this,
      r,
      typeof o == "number" ? o : void 0,
      i || void 0
    ));
  }
}
function qm() {
  return !0;
}
function Fm(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const Ef = [], Bm = !0, Ba = !1, Um = "skip";
function If(e, t, r, o) {
  let i;
  typeof t == "function" && typeof r != "function" ? (o = r, r = t) : i = t;
  const a = Js(i), s = o ? -1 : 1;
  n(e, void 0, [])();
  function n(c, u, l) {
    const p = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof p.type == "string") {
      const h = (
        // `hast`
        typeof p.tagName == "string" ? p.tagName : (
          // `xast`
          typeof p.name == "string" ? p.name : void 0
        )
      );
      Object.defineProperty(d, "name", {
        value: "node (" + (c.type + (h ? "<" + h + ">" : "")) + ")"
      });
    }
    return d;
    function d() {
      let h = Ef, f, g, m;
      if ((!t || a(c, u, l[l.length - 1] || void 0)) && (h = $m(r(c, l)), h[0] === Ba))
        return h;
      if ("children" in c && c.children) {
        const v = (
          /** @type {UnistParent} */
          c
        );
        if (v.children && h[0] !== Um)
          for (g = (o ? v.children.length : -1) + s, m = l.concat(v); g > -1 && g < v.children.length; ) {
            const y = v.children[g];
            if (f = n(y, g, m)(), f[0] === Ba)
              return f;
            g = typeof f[1] == "number" ? f[1] : g + s;
          }
      }
      return h;
    }
  }
}
function $m(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Bm, e] : e == null ? Ef : [e];
}
function Vm(e, t, r) {
  const i = Js((r || {}).ignore || []), a = Wm(t);
  let s = -1;
  for (; ++s < a.length; )
    If(e, "text", n);
  function n(u, l) {
    let p = -1, d;
    for (; ++p < l.length; ) {
      const h = l[p], f = d ? d.children : void 0;
      if (i(
        h,
        f ? f.indexOf(h) : void 0,
        d
      ))
        return;
      d = h;
    }
    if (d)
      return c(u, l);
  }
  function c(u, l) {
    const p = l[l.length - 1], d = a[s][0], h = a[s][1];
    let f = 0;
    const m = p.children.indexOf(u);
    let v = !1, y = [];
    d.lastIndex = 0;
    let S = d.exec(u.value);
    for (; S; ) {
      const C = S.index, b = {
        index: S.index,
        input: S.input,
        stack: [...l, u]
      };
      let w = h(...S, b);
      if (typeof w == "string" && (w = w.length > 0 ? { type: "text", value: w } : void 0), w === !1 ? d.lastIndex = C + 1 : (f !== C && y.push({
        type: "text",
        value: u.value.slice(f, C)
      }), Array.isArray(w) ? y.push(...w) : w && y.push(w), f = C + S[0].length, v = !0), !d.global)
        break;
      S = d.exec(u.value);
    }
    return v ? (f < u.value.length && y.push({ type: "text", value: u.value.slice(f) }), p.children.splice(m, 1, ...y)) : y = [u], m + y.length;
  }
}
function Wm(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const r = !e[0] || Array.isArray(e[0]) ? e : [e];
  let o = -1;
  for (; ++o < r.length; ) {
    const i = r[o];
    t.push([Hm(i[0]), Km(i[1])]);
  }
  return t;
}
function Hm(e) {
  return typeof e == "string" ? new RegExp(xm(e), "g") : e;
}
function Km(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const vo = "phrasing", go = ["autolink", "link", "image", "label"];
function Jm() {
  return {
    transforms: [ty],
    enter: {
      literalAutolink: Qm,
      literalAutolinkEmail: mo,
      literalAutolinkHttp: mo,
      literalAutolinkWww: mo
    },
    exit: {
      literalAutolink: ey,
      literalAutolinkEmail: Xm,
      literalAutolinkHttp: Ym,
      literalAutolinkWww: Zm
    }
  };
}
function Gm() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: vo,
        notInConstruct: go
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: vo,
        notInConstruct: go
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: vo,
        notInConstruct: go
      }
    ]
  };
}
function Qm(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function mo(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function Ym(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function Zm(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function Xm(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function ey(e) {
  this.exit(e);
}
function ty(e) {
  Vm(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, ry],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), ny]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function ry(e, t, r, o, i) {
  let a = "";
  if (!Af(i) || (/^w/i.test(t) && (r = t + r, t = "", a = "http://"), !iy(r)))
    return !1;
  const s = sy(r + o);
  if (!s[0]) return !1;
  const n = {
    type: "link",
    title: null,
    url: a + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [n, { type: "text", value: s[1] }] : n;
}
function ny(e, t, r, o) {
  return (
    // Not an expected previous character.
    !Af(o, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(r) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + r,
      children: [{ type: "text", value: t + "@" + r }]
    }
  );
}
function iy(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function sy(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let r = t[0], o = r.indexOf(")");
  const i = Ac(e, "(");
  let a = Ac(e, ")");
  for (; o !== -1 && i > a; )
    e += r.slice(0, o + 1), r = r.slice(o + 1), o = r.indexOf(")"), a++;
  return [e, r];
}
function Af(e, t) {
  const r = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || zt(r) || Hs(r)) && // If its an email, the previous character should not be a slash.
  (!t || r !== 47);
}
function Ss(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
Tf.peek = fy;
function oy() {
  this.buffer();
}
function ay(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function cy() {
  this.buffer();
}
function uy(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function ly(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = Ss(
    this.sliceSerialize(e)
  ).toLowerCase(), r.label = t;
}
function py(e) {
  this.exit(e);
}
function dy(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = Ss(
    this.sliceSerialize(e)
  ).toLowerCase(), r.label = t;
}
function hy(e) {
  this.exit(e);
}
function fy() {
  return "[";
}
function Tf(e, t, r, o) {
  const i = r.createTracker(o);
  let a = i.move("[^");
  const s = r.enter("footnoteReference"), n = r.enter("reference");
  return a += i.move(
    r.safe(r.associationId(e), { after: "]", before: a })
  ), n(), s(), a += i.move("]"), a;
}
function vy() {
  return {
    enter: {
      gfmFootnoteCallString: oy,
      gfmFootnoteCall: ay,
      gfmFootnoteDefinitionLabelString: cy,
      gfmFootnoteDefinition: uy
    },
    exit: {
      gfmFootnoteCallString: ly,
      gfmFootnoteCall: py,
      gfmFootnoteDefinitionLabelString: dy,
      gfmFootnoteDefinition: hy
    }
  };
}
function gy(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: r, footnoteReference: Tf },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function r(o, i, a, s) {
    const n = a.createTracker(s);
    let c = n.move("[^");
    const u = a.enter("footnoteDefinition"), l = a.enter("label");
    return c += n.move(
      a.safe(a.associationId(o), { before: c, after: "]" })
    ), l(), c += n.move("]:"), o.children && o.children.length > 0 && (n.shift(4), c += n.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(o, n.current()),
        t ? _f : my
      )
    )), u(), c;
  }
}
function my(e, t, r) {
  return t === 0 ? e : _f(e, t, r);
}
function _f(e, t, r) {
  return (r ? "" : "    ") + e;
}
const yy = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
kf.peek = by;
function Sy() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Ry },
    exit: { strikethrough: Py }
  };
}
function Cy() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: yy
      }
    ],
    handlers: { delete: kf }
  };
}
function Ry(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Py(e) {
  this.exit(e);
}
function kf(e, t, r, o) {
  const i = r.createTracker(o), a = r.enter("strikethrough");
  let s = i.move("~~");
  return s += r.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), a(), s;
}
function by() {
  return "~";
}
function wy(e) {
  return e.length;
}
function Ey(e, t) {
  const r = t || {}, o = (r.align || []).concat(), i = r.stringLength || wy, a = [], s = [], n = [], c = [];
  let u = 0, l = -1;
  for (; ++l < e.length; ) {
    const g = [], m = [];
    let v = -1;
    for (e[l].length > u && (u = e[l].length); ++v < e[l].length; ) {
      const y = Iy(e[l][v]);
      if (r.alignDelimiters !== !1) {
        const S = i(y);
        m[v] = S, (c[v] === void 0 || S > c[v]) && (c[v] = S);
      }
      g.push(y);
    }
    s[l] = g, n[l] = m;
  }
  let p = -1;
  if (typeof o == "object" && "length" in o)
    for (; ++p < u; )
      a[p] = Tc(o[p]);
  else {
    const g = Tc(o);
    for (; ++p < u; )
      a[p] = g;
  }
  p = -1;
  const d = [], h = [];
  for (; ++p < u; ) {
    const g = a[p];
    let m = "", v = "";
    g === 99 ? (m = ":", v = ":") : g === 108 ? m = ":" : g === 114 && (v = ":");
    let y = r.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[p] - m.length - v.length
    );
    const S = m + "-".repeat(y) + v;
    r.alignDelimiters !== !1 && (y = m.length + y + v.length, y > c[p] && (c[p] = y), h[p] = y), d[p] = S;
  }
  s.splice(1, 0, d), n.splice(1, 0, h), l = -1;
  const f = [];
  for (; ++l < s.length; ) {
    const g = s[l], m = n[l];
    p = -1;
    const v = [];
    for (; ++p < u; ) {
      const y = g[p] || "";
      let S = "", C = "";
      if (r.alignDelimiters !== !1) {
        const b = c[p] - (m[p] || 0), w = a[p];
        w === 114 ? S = " ".repeat(b) : w === 99 ? b % 2 ? (S = " ".repeat(b / 2 + 0.5), C = " ".repeat(b / 2 - 0.5)) : (S = " ".repeat(b / 2), C = S) : C = " ".repeat(b);
      }
      r.delimiterStart !== !1 && !p && v.push("|"), r.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(r.alignDelimiters === !1 && y === "") && (r.delimiterStart !== !1 || p) && v.push(" "), r.alignDelimiters !== !1 && v.push(S), v.push(y), r.alignDelimiters !== !1 && v.push(C), r.padding !== !1 && v.push(" "), (r.delimiterEnd !== !1 || p !== u - 1) && v.push("|");
    }
    f.push(
      r.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join("")
    );
  }
  return f.join(`
`);
}
function Iy(e) {
  return e == null ? "" : String(e);
}
function Tc(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function Ay(e, t, r, o) {
  const i = r.enter("blockquote"), a = r.createTracker(o);
  a.move("> "), a.shift(2);
  const s = r.indentLines(
    r.containerFlow(e, a.current()),
    Ty
  );
  return i(), s;
}
function Ty(e, t, r) {
  return ">" + (r ? "" : " ") + e;
}
function _y(e, t) {
  return _c(e, t.inConstruct, !0) && !_c(e, t.notInConstruct, !1);
}
function _c(e, t, r) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return r;
  let o = -1;
  for (; ++o < t.length; )
    if (e.includes(t[o]))
      return !0;
  return !1;
}
function kc(e, t, r, o) {
  let i = -1;
  for (; ++i < r.unsafe.length; )
    if (r.unsafe[i].character === `
` && _y(r.stack, r.unsafe[i]))
      return /[ \t]/.test(o.before) ? "" : " ";
  return `\\
`;
}
function ky(e, t) {
  const r = String(e);
  let o = r.indexOf(t), i = o, a = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; o !== -1; )
    o === i ? ++a > s && (s = a) : a = 1, i = o + t.length, o = r.indexOf(t, i);
  return s;
}
function Oy(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function My(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Dy(e, t, r, o) {
  const i = My(r), a = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (Oy(e, r)) {
    const p = r.enter("codeIndented"), d = r.indentLines(a, Ny);
    return p(), d;
  }
  const n = r.createTracker(o), c = i.repeat(Math.max(ky(a, i) + 1, 3)), u = r.enter("codeFenced");
  let l = n.move(c);
  if (e.lang) {
    const p = r.enter(`codeFencedLang${s}`);
    l += n.move(
      r.safe(e.lang, {
        before: l,
        after: " ",
        encode: ["`"],
        ...n.current()
      })
    ), p();
  }
  if (e.lang && e.meta) {
    const p = r.enter(`codeFencedMeta${s}`);
    l += n.move(" "), l += n.move(
      r.safe(e.meta, {
        before: l,
        after: `
`,
        encode: ["`"],
        ...n.current()
      })
    ), p();
  }
  return l += n.move(`
`), a && (l += n.move(a + `
`)), l += n.move(c), u(), l;
}
function Ny(e, t, r) {
  return (r ? "" : "    ") + e;
}
function oc(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function xy(e, t, r, o) {
  const i = oc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.enter("definition");
  let n = r.enter("label");
  const c = r.createTracker(o);
  let u = c.move("[");
  return u += c.move(
    r.safe(r.associationId(e), {
      before: u,
      after: "]",
      ...c.current()
    })
  ), u += c.move("]: "), n(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (n = r.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    r.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (n = r.enter("destinationRaw"), u += c.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), n(), e.title && (n = r.enter(`title${a}`), u += c.move(" " + i), u += c.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), n()), s(), u;
}
function zy(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function fs(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function Ls(e) {
  if (e === null || de(e) || zt(e))
    return 1;
  if (Hs(e))
    return 2;
}
function js(e, t, r) {
  const o = Ls(e), i = Ls(t);
  return o === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    r === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : o === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Of.peek = Ly;
function Of(e, t, r, o) {
  const i = zy(r), a = r.enter("emphasis"), s = r.createTracker(o), n = s.move(i);
  let c = s.move(
    r.containerPhrasing(e, {
      after: i,
      before: n,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), l = js(
    o.before.charCodeAt(o.before.length - 1),
    u,
    i
  );
  l.inside && (c = fs(u) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), d = js(o.after.charCodeAt(0), p, i);
  d.inside && (c = c.slice(0, -1) + fs(p));
  const h = s.move(i);
  return a(), r.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: l.outside
  }, n + c + h;
}
function Ly(e, t, r) {
  return r.options.emphasis || "*";
}
function jy(e, t, r, o) {
  let i, a, s;
  typeof t == "function" && typeof r != "function" ? (a = void 0, s = t, i = r) : (a = t, s = r, i = o), If(e, a, n, i);
  function n(c, u) {
    const l = u[u.length - 1], p = l ? l.children.indexOf(c) : void 0;
    return s(c, p, l);
  }
}
const qy = {};
function Mf(e, t) {
  const r = qy, o = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, i = typeof r.includeHtml == "boolean" ? r.includeHtml : !0;
  return Df(e, o, i);
}
function Df(e, t, r) {
  if (Fy(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Oc(e.children, t, r);
  }
  return Array.isArray(e) ? Oc(e, t, r) : "";
}
function Oc(e, t, r) {
  const o = [];
  let i = -1;
  for (; ++i < e.length; )
    o[i] = Df(e[i], t, r);
  return o.join("");
}
function Fy(e) {
  return !!(e && typeof e == "object");
}
function By(e, t) {
  let r = !1;
  return jy(e, function(o) {
    if ("value" in o && /\r?\n|\r/.test(o.value) || o.type === "break")
      return r = !0, Ba;
  }), !!((!e.depth || e.depth < 3) && Mf(e) && (t.options.setext || r));
}
function Uy(e, t, r, o) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = r.createTracker(o);
  if (By(e, r)) {
    const l = r.enter("headingSetext"), p = r.enter("phrasing"), d = r.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return p(), l(), d + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size
      d.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(d.lastIndexOf("\r"), d.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), n = r.enter("headingAtx"), c = r.enter("phrasing");
  a.move(s + " ");
  let u = r.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(u) && (u = fs(u.charCodeAt(0)) + u.slice(1)), u = u ? s + " " + u : s, r.options.closeAtx && (u += " " + s), c(), n(), u;
}
Nf.peek = $y;
function Nf(e) {
  return e.value || "";
}
function $y() {
  return "<";
}
xf.peek = Vy;
function xf(e, t, r, o) {
  const i = oc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.enter("image");
  let n = r.enter("label");
  const c = r.createTracker(o);
  let u = c.move("![");
  return u += c.move(
    r.safe(e.alt, { before: u, after: "]", ...c.current() })
  ), u += c.move("]("), n(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (n = r.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    r.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (n = r.enter("destinationRaw"), u += c.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), n(), e.title && (n = r.enter(`title${a}`), u += c.move(" " + i), u += c.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), n()), u += c.move(")"), s(), u;
}
function Vy() {
  return "!";
}
zf.peek = Wy;
function zf(e, t, r, o) {
  const i = e.referenceType, a = r.enter("imageReference");
  let s = r.enter("label");
  const n = r.createTracker(o);
  let c = n.move("![");
  const u = r.safe(e.alt, {
    before: c,
    after: "]",
    ...n.current()
  });
  c += n.move(u + "]["), s();
  const l = r.stack;
  r.stack = [], s = r.enter("reference");
  const p = r.safe(r.associationId(e), {
    before: c,
    after: "]",
    ...n.current()
  });
  return s(), r.stack = l, a(), i === "full" || !u || u !== p ? c += n.move(p + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += n.move("]"), c;
}
function Wy() {
  return "!";
}
Lf.peek = Hy;
function Lf(e, t, r) {
  let o = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(o); )
    i += "`";
  for (/[^ \r\n]/.test(o) && (/^[ \r\n]/.test(o) && /[ \r\n]$/.test(o) || /^`|`$/.test(o)) && (o = " " + o + " "); ++a < r.unsafe.length; ) {
    const s = r.unsafe[a], n = r.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = n.exec(o); ) {
        let u = c.index;
        o.charCodeAt(u) === 10 && o.charCodeAt(u - 1) === 13 && u--, o = o.slice(0, u) + " " + o.slice(c.index + 1);
      }
  }
  return i + o + i;
}
function Hy() {
  return "`";
}
function jf(e, t) {
  const r = Mf(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (r === e.url || "mailto:" + r === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
qf.peek = Ky;
function qf(e, t, r, o) {
  const i = oc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.createTracker(o);
  let n, c;
  if (jf(e, r)) {
    const l = r.stack;
    r.stack = [], n = r.enter("autolink");
    let p = s.move("<");
    return p += s.move(
      r.containerPhrasing(e, {
        before: p,
        after: ">",
        ...s.current()
      })
    ), p += s.move(">"), n(), r.stack = l, p;
  }
  n = r.enter("link"), c = r.enter("label");
  let u = s.move("[");
  return u += s.move(
    r.containerPhrasing(e, {
      before: u,
      after: "](",
      ...s.current()
    })
  ), u += s.move("]("), c(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = r.enter("destinationLiteral"), u += s.move("<"), u += s.move(
    r.safe(e.url, { before: u, after: ">", ...s.current() })
  ), u += s.move(">")) : (c = r.enter("destinationRaw"), u += s.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = r.enter(`title${a}`), u += s.move(" " + i), u += s.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...s.current()
    })
  ), u += s.move(i), c()), u += s.move(")"), n(), u;
}
function Ky(e, t, r) {
  return jf(e, r) ? "<" : "[";
}
Ff.peek = Jy;
function Ff(e, t, r, o) {
  const i = e.referenceType, a = r.enter("linkReference");
  let s = r.enter("label");
  const n = r.createTracker(o);
  let c = n.move("[");
  const u = r.containerPhrasing(e, {
    before: c,
    after: "]",
    ...n.current()
  });
  c += n.move(u + "]["), s();
  const l = r.stack;
  r.stack = [], s = r.enter("reference");
  const p = r.safe(r.associationId(e), {
    before: c,
    after: "]",
    ...n.current()
  });
  return s(), r.stack = l, a(), i === "full" || !u || u !== p ? c += n.move(p + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += n.move("]"), c;
}
function Jy() {
  return "[";
}
function ac(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function Gy(e) {
  const t = ac(e), r = e.options.bulletOther;
  if (!r)
    return t === "*" ? "-" : "*";
  if (r !== "*" && r !== "+" && r !== "-")
    throw new Error(
      "Cannot serialize items with `" + r + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (r === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + r + "`) to be different"
    );
  return r;
}
function Qy(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function Bf(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function Yy(e, t, r, o) {
  const i = r.enter("list"), a = r.bulletCurrent;
  let s = e.ordered ? Qy(r) : ac(r);
  const n = e.ordered ? s === "." ? ")" : "." : Gy(r);
  let c = t && r.bulletLastUsed ? s === r.bulletLastUsed : !1;
  if (!e.ordered) {
    const l = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      l && (!l.children || !l.children[0]) && // Directly in two other list items:
      r.stack[r.stack.length - 1] === "list" && r.stack[r.stack.length - 2] === "listItem" && r.stack[r.stack.length - 3] === "list" && r.stack[r.stack.length - 4] === "listItem" && // That are each the first child.
      r.indexStack[r.indexStack.length - 1] === 0 && r.indexStack[r.indexStack.length - 2] === 0 && r.indexStack[r.indexStack.length - 3] === 0 && (c = !0), Bf(r) === s && l
    ) {
      let p = -1;
      for (; ++p < e.children.length; ) {
        const d = e.children[p];
        if (d && d.type === "listItem" && d.children && d.children[0] && d.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = n), r.bulletCurrent = s;
  const u = r.containerFlow(e, o);
  return r.bulletLastUsed = s, r.bulletCurrent = a, i(), u;
}
function Zy(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function Xy(e, t, r, o) {
  const i = Zy(r);
  let a = r.bulletCurrent || ac(r);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (r.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let s = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const n = r.createTracker(o);
  n.move(a + " ".repeat(s - a.length)), n.shift(s);
  const c = r.enter("listItem"), u = r.indentLines(
    r.containerFlow(e, n.current()),
    l
  );
  return c(), u;
  function l(p, d, h) {
    return d ? (h ? "" : " ".repeat(s)) + p : (h ? a : a + " ".repeat(s - a.length)) + p;
  }
}
function eS(e, t, r, o) {
  const i = r.enter("paragraph"), a = r.enter("phrasing"), s = r.containerPhrasing(e, o);
  return a(), i(), s;
}
const tS = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Js([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function rS(e, t, r, o) {
  return (e.children.some(function(s) {
    return tS(s);
  }) ? r.containerPhrasing : r.containerFlow).call(r, e, o);
}
function nS(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Uf.peek = iS;
function Uf(e, t, r, o) {
  const i = nS(r), a = r.enter("strong"), s = r.createTracker(o), n = s.move(i + i);
  let c = s.move(
    r.containerPhrasing(e, {
      after: i,
      before: n,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), l = js(
    o.before.charCodeAt(o.before.length - 1),
    u,
    i
  );
  l.inside && (c = fs(u) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), d = js(o.after.charCodeAt(0), p, i);
  d.inside && (c = c.slice(0, -1) + fs(p));
  const h = s.move(i + i);
  return a(), r.attentionEncodeSurroundingInfo = {
    after: d.outside,
    before: l.outside
  }, n + c + h;
}
function iS(e, t, r) {
  return r.options.strong || "*";
}
function sS(e, t, r, o) {
  return r.safe(e.value, o);
}
function oS(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function aS(e, t, r) {
  const o = (Bf(r) + (r.options.ruleSpaces ? " " : "")).repeat(oS(r));
  return r.options.ruleSpaces ? o.slice(0, -1) : o;
}
const $f = {
  blockquote: Ay,
  break: kc,
  code: Dy,
  definition: xy,
  emphasis: Of,
  hardBreak: kc,
  heading: Uy,
  html: Nf,
  image: xf,
  imageReference: zf,
  inlineCode: Lf,
  link: qf,
  linkReference: Ff,
  list: Yy,
  listItem: Xy,
  paragraph: eS,
  root: rS,
  strong: Uf,
  text: sS,
  thematicBreak: aS
};
function cS() {
  return {
    enter: {
      table: uS,
      tableData: Mc,
      tableHeader: Mc,
      tableRow: pS
    },
    exit: {
      codeText: dS,
      table: lS,
      tableData: yo,
      tableHeader: yo,
      tableRow: yo
    }
  };
}
function uS(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(r) {
        return r === "none" ? null : r;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function lS(e) {
  this.exit(e), this.data.inTable = void 0;
}
function pS(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function yo(e) {
  this.exit(e);
}
function Mc(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function dS(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, hS));
  const r = this.stack[this.stack.length - 1];
  r.type, r.value = t, this.exit(e);
}
function hS(e, t) {
  return t === "|" ? t : e;
}
function fS(e) {
  const t = e || {}, r = t.tableCellPadding, o = t.tablePipeAlign, i = t.stringLength, a = r ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: d,
      table: s,
      tableCell: c,
      tableRow: n
    }
  };
  function s(h, f, g, m) {
    return u(l(h, g, m), h.align);
  }
  function n(h, f, g, m) {
    const v = p(h, g, m), y = u([v]);
    return y.slice(0, y.indexOf(`
`));
  }
  function c(h, f, g, m) {
    const v = g.enter("tableCell"), y = g.enter("phrasing"), S = g.containerPhrasing(h, {
      ...m,
      before: a,
      after: a
    });
    return y(), v(), S;
  }
  function u(h, f) {
    return Ey(h, {
      align: f,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: o,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function l(h, f, g) {
    const m = h.children;
    let v = -1;
    const y = [], S = f.enter("table");
    for (; ++v < m.length; )
      y[v] = p(m[v], f, g);
    return S(), y;
  }
  function p(h, f, g) {
    const m = h.children;
    let v = -1;
    const y = [], S = f.enter("tableRow");
    for (; ++v < m.length; )
      y[v] = c(m[v], h, f, g);
    return S(), y;
  }
  function d(h, f, g) {
    let m = $f.inlineCode(h, f, g);
    return g.stack.includes("tableCell") && (m = m.replace(/\|/g, "\\$&")), m;
  }
}
function vS() {
  return {
    exit: {
      taskListCheckValueChecked: Dc,
      taskListCheckValueUnchecked: Dc,
      paragraph: mS
    }
  };
}
function gS() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: yS }
  };
}
function Dc(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function mS(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const r = this.stack[this.stack.length - 1];
    r.type;
    const o = r.children[0];
    if (o && o.type === "text") {
      const i = t.children;
      let a = -1, s;
      for (; ++a < i.length; ) {
        const n = i[a];
        if (n.type === "paragraph") {
          s = n;
          break;
        }
      }
      s === r && (o.value = o.value.slice(1), o.value.length === 0 ? r.children.shift() : r.position && o.position && typeof o.position.start.offset == "number" && (o.position.start.column++, o.position.start.offset++, r.position.start = Object.assign({}, o.position.start)));
    }
  }
  this.exit(e);
}
function yS(e, t, r, o) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", n = r.createTracker(o);
  a && n.move(s);
  let c = $f.listItem(e, t, r, {
    ...o,
    ...n.current()
  });
  return a && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
  function u(l) {
    return l + s;
  }
}
function SS() {
  return [
    Jm(),
    vy(),
    Sy(),
    cS(),
    vS()
  ];
}
function CS(e) {
  return {
    extensions: [
      Gm(),
      gy(e),
      Cy(),
      fS(e),
      gS()
    ]
  };
}
function Ds(e, t, r, o) {
  const i = e.length;
  let a = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, r = r > 0 ? r : 0, o.length < 1e4)
    s = Array.from(o), s.unshift(t, r), e.splice(...s);
  else
    for (r && e.splice(t, r); a < o.length; )
      s = o.slice(a, a + 1e4), s.unshift(t, 0), e.splice(...s), a += 1e4, t += 1e4;
}
const Nc = {}.hasOwnProperty;
function RS(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    PS(t, e[r]);
  return t;
}
function PS(e, t) {
  let r;
  for (r in t) {
    const i = (Nc.call(e, r) ? e[r] : void 0) || (e[r] = {}), a = t[r];
    let s;
    if (a)
      for (s in a) {
        Nc.call(i, s) || (i[s] = []);
        const n = a[s];
        bS(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(n) ? n : n ? [n] : []
        );
      }
  }
}
function bS(e, t) {
  let r = -1;
  const o = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : o).push(t[r]);
  Ds(e, 0, 0, o);
}
const wS = {
  tokenize: kS,
  partial: !0
}, Vf = {
  tokenize: OS,
  partial: !0
}, Wf = {
  tokenize: MS,
  partial: !0
}, Hf = {
  tokenize: DS,
  partial: !0
}, ES = {
  tokenize: NS,
  partial: !0
}, Kf = {
  name: "wwwAutolink",
  tokenize: TS,
  previous: Gf
}, Jf = {
  name: "protocolAutolink",
  tokenize: _S,
  previous: Qf
}, We = {
  name: "emailAutolink",
  tokenize: AS,
  previous: Yf
}, Me = {};
function IS() {
  return {
    text: Me
  };
}
let ut = 48;
for (; ut < 123; )
  Me[ut] = We, ut++, ut === 58 ? ut = 65 : ut === 91 && (ut = 97);
Me[43] = We;
Me[45] = We;
Me[46] = We;
Me[95] = We;
Me[72] = [We, Jf];
Me[104] = [We, Jf];
Me[87] = [We, Kf];
Me[119] = [We, Kf];
function AS(e, t, r) {
  const o = this;
  let i, a;
  return s;
  function s(p) {
    return !Ua(p) || !Yf.call(o, o.previous) || cc(o.events) ? r(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), n(p));
  }
  function n(p) {
    return Ua(p) ? (e.consume(p), n) : p === 64 ? (e.consume(p), c) : r(p);
  }
  function c(p) {
    return p === 46 ? e.check(ES, l, u)(p) : p === 45 || p === 95 || sc(p) ? (a = !0, e.consume(p), c) : l(p);
  }
  function u(p) {
    return e.consume(p), i = !0, c;
  }
  function l(p) {
    return a && i && hs(o.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : r(p);
  }
}
function TS(e, t, r) {
  const o = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !Gf.call(o, o.previous) || cc(o.events) ? r(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(wS, e.attempt(Vf, e.attempt(Wf, a), r), r)(s));
  }
  function a(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function _S(e, t, r) {
  const o = this;
  let i = "", a = !1;
  return s;
  function s(p) {
    return (p === 72 || p === 104) && Qf.call(o, o.previous) && !cc(o.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(p), e.consume(p), n) : r(p);
  }
  function n(p) {
    if (hs(p) && i.length < 5)
      return i += String.fromCodePoint(p), e.consume(p), n;
    if (p === 58) {
      const d = i.toLowerCase();
      if (d === "http" || d === "https")
        return e.consume(p), c;
    }
    return r(p);
  }
  function c(p) {
    return p === 47 ? (e.consume(p), a ? u : (a = !0, c)) : r(p);
  }
  function u(p) {
    return p === null || Nm(p) || de(p) || zt(p) || Hs(p) ? r(p) : e.attempt(Vf, e.attempt(Wf, l), r)(p);
  }
  function l(p) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
  }
}
function kS(e, t, r) {
  let o = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && o < 3 ? (o++, e.consume(s), i) : s === 46 && o === 3 ? (e.consume(s), a) : r(s);
  }
  function a(s) {
    return s === null ? r(s) : t(s);
  }
}
function OS(e, t, r) {
  let o, i, a;
  return s;
  function s(u) {
    return u === 46 || u === 95 ? e.check(Hf, c, n)(u) : u === null || de(u) || zt(u) || u !== 45 && Hs(u) ? c(u) : (a = !0, e.consume(u), s);
  }
  function n(u) {
    return u === 95 ? o = !0 : (i = o, o = void 0), e.consume(u), s;
  }
  function c(u) {
    return i || o || !a ? r(u) : t(u);
  }
}
function MS(e, t) {
  let r = 0, o = 0;
  return i;
  function i(s) {
    return s === 40 ? (r++, e.consume(s), i) : s === 41 && o < r ? a(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(Hf, t, a)(s) : s === null || de(s) || zt(s) ? t(s) : (e.consume(s), i);
  }
  function a(s) {
    return s === 41 && o++, e.consume(s), i;
  }
}
function DS(e, t, r) {
  return o;
  function o(n) {
    return n === 33 || n === 34 || n === 39 || n === 41 || n === 42 || n === 44 || n === 46 || n === 58 || n === 59 || n === 63 || n === 95 || n === 126 ? (e.consume(n), o) : n === 38 ? (e.consume(n), a) : n === 93 ? (e.consume(n), i) : (
      // `<` is an end.
      n === 60 || // So is whitespace.
      n === null || de(n) || zt(n) ? t(n) : r(n)
    );
  }
  function i(n) {
    return n === null || n === 40 || n === 91 || de(n) || zt(n) ? t(n) : o(n);
  }
  function a(n) {
    return hs(n) ? s(n) : r(n);
  }
  function s(n) {
    return n === 59 ? (e.consume(n), o) : hs(n) ? (e.consume(n), s) : r(n);
  }
}
function NS(e, t, r) {
  return o;
  function o(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return sc(a) ? r(a) : t(a);
  }
}
function Gf(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || de(e);
}
function Qf(e) {
  return !hs(e);
}
function Yf(e) {
  return !(e === 47 || Ua(e));
}
function Ua(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || sc(e);
}
function cc(e) {
  let t = e.length, r = !1;
  for (; t--; ) {
    const o = e[t][1];
    if ((o.type === "labelLink" || o.type === "labelImage") && !o._balanced) {
      r = !0;
      break;
    }
    if (o._gfmAutolinkLiteralWalkedInto) {
      r = !1;
      break;
    }
  }
  return e.length > 0 && !r && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), r;
}
function xS(e, t, r) {
  const o = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !o.includes(a) && (t = a(t, r), o.push(a));
  }
  return t;
}
function $e(e, t, r, o) {
  const i = o ? o - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return s;
  function s(c) {
    return Ue(c) ? (e.enter(r), n(c)) : t(c);
  }
  function n(c) {
    return Ue(c) && a++ < i ? (e.consume(c), n) : (e.exit(r), t(c));
  }
}
const zS = {
  partial: !0,
  tokenize: LS
};
function LS(e, t, r) {
  return o;
  function o(a) {
    return Ue(a) ? $e(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || Vt(a) ? t(a) : r(a);
  }
}
const jS = {
  tokenize: HS,
  partial: !0
};
function qS() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: $S,
        continuation: {
          tokenize: VS
        },
        exit: WS
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: US
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: FS,
        resolveTo: BS
      }
    }
  };
}
function FS(e, t, r) {
  const o = this;
  let i = o.events.length;
  const a = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const c = o.events[i][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return n;
  function n(c) {
    if (!s || !s._balanced)
      return r(c);
    const u = Ss(o.sliceSerialize({
      start: s.end,
      end: o.now()
    }));
    return u.codePointAt(0) !== 94 || !a.includes(u.slice(1)) ? r(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function BS(e, t) {
  let r = e.length;
  for (; r--; )
    if (e[r][1].type === "labelImage" && e[r][0] === "enter") {
      e[r][1];
      break;
    }
  e[r + 1][1].type = "data", e[r + 3][1].type = "gfmFootnoteCallLabelMarker";
  const o = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[r + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[r + 3][1].end),
    end: Object.assign({}, e[r + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, n = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[r + 1],
    e[r + 2],
    ["enter", o, t],
    // The `[`
    e[r + 3],
    e[r + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", o, t]
  ];
  return e.splice(r, e.length - r + 1, ...n), e;
}
function US(e, t, r) {
  const o = this, i = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let a = 0, s;
  return n;
  function n(p) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(p) {
    return p !== 94 ? r(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(p) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      p === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || de(p)
    )
      return r(p);
    if (p === 93) {
      e.exit("chunkString");
      const d = e.exit("gfmFootnoteCallString");
      return i.includes(Ss(o.sliceSerialize(d))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : r(p);
    }
    return de(p) || (s = !0), a++, e.consume(p), p === 92 ? l : u;
  }
  function l(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, u) : u(p);
  }
}
function $S(e, t, r) {
  const o = this, i = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let a, s = 0, n;
  return c;
  function c(f) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(f) {
    return f === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", l) : r(f);
  }
  function l(f) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      f === 93 && !n || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || de(f)
    )
      return r(f);
    if (f === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteDefinitionLabelString");
      return a = Ss(o.sliceSerialize(g)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), d;
    }
    return de(f) || (n = !0), s++, e.consume(f), f === 92 ? p : l;
  }
  function p(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), s++, l) : l(f);
  }
  function d(f) {
    return f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), i.includes(a) || i.push(a), $e(e, h, "gfmFootnoteDefinitionWhitespace")) : r(f);
  }
  function h(f) {
    return t(f);
  }
}
function VS(e, t, r) {
  return e.check(zS, t, e.attempt(jS, t, r));
}
function WS(e) {
  e.exit("gfmFootnoteDefinition");
}
function HS(e, t, r) {
  const o = this;
  return $e(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const s = o.events[o.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(a) : r(a);
  }
}
function KS(e) {
  let r = (e || {}).singleTilde;
  const o = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return r == null && (r = !0), {
    text: {
      126: o
    },
    insideSpan: {
      null: [o]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, n) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let u = c;
        for (; u--; )
          if (s[u][0] === "exit" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[u][1].end.offset - s[u][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[u][1].type = "strikethroughSequence";
            const l = {
              type: "strikethrough",
              start: Object.assign({}, s[u][1].start),
              end: Object.assign({}, s[c][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, s[u][1].end),
              end: Object.assign({}, s[c][1].start)
            }, d = [["enter", l, n], ["enter", s[u][1], n], ["exit", s[u][1], n], ["enter", p, n]], h = n.parser.constructs.insideSpan.null;
            h && Ds(d, d.length, 0, xS(h, s.slice(u + 1, c), n)), Ds(d, d.length, 0, [["exit", p, n], ["enter", s[c][1], n], ["exit", s[c][1], n], ["exit", l, n]]), Ds(s, u - 1, c - u + 3, d), c = u + d.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function a(s, n, c) {
    const u = this.previous, l = this.events;
    let p = 0;
    return d;
    function d(f) {
      return u === 126 && l[l.length - 1][1].type !== "characterEscape" ? c(f) : (s.enter("strikethroughSequenceTemporary"), h(f));
    }
    function h(f) {
      const g = Ls(u);
      if (f === 126)
        return p > 1 ? c(f) : (s.consume(f), p++, h);
      if (p < 2 && !r) return c(f);
      const m = s.exit("strikethroughSequenceTemporary"), v = Ls(f);
      return m._open = !v || v === 2 && !!g, m._close = !g || g === 2 && !!v, n(f);
    }
  }
}
class JS {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, r, o) {
    GS(this, t, r, o);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, s) {
      return a[0] - s[0];
    }), this.map.length === 0)
      return;
    let r = this.map.length;
    const o = [];
    for (; r > 0; )
      r -= 1, o.push(t.slice(this.map[r][0] + this.map[r][1]), this.map[r][2]), t.length = this.map[r][0];
    o.push(t.slice()), t.length = 0;
    let i = o.pop();
    for (; i; ) {
      for (const a of i)
        t.push(a);
      i = o.pop();
    }
    this.map.length = 0;
  }
}
function GS(e, t, r, o) {
  let i = 0;
  if (!(r === 0 && o.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += r, e.map[i][2].push(...o);
        return;
      }
      i += 1;
    }
    e.map.push([t, r, o]);
  }
}
function QS(e, t) {
  let r = !1;
  const o = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (r) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && o.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = o.length - 1;
          o[a] = o[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (r = !0);
    t += 1;
  }
  return o;
}
function YS() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: ZS,
        resolveAll: XS
      }
    }
  };
}
function ZS(e, t, r) {
  const o = this;
  let i = 0, a = 0, s;
  return n;
  function n(R) {
    let M = o.events.length - 1;
    for (; M > -1; ) {
      const U = o.events[M][1].type;
      if (U === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      U === "linePrefix") M--;
      else break;
    }
    const T = M > -1 ? o.events[M][1].type : null, L = T === "tableHead" || T === "tableRow" ? w : c;
    return L === w && o.parser.lazy[o.now().line] ? r(R) : L(R);
  }
  function c(R) {
    return e.enter("tableHead"), e.enter("tableRow"), u(R);
  }
  function u(R) {
    return R === 124 || (s = !0, a += 1), l(R);
  }
  function l(R) {
    return R === null ? r(R) : Vt(R) ? a > 1 ? (a = 0, o.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), h) : r(R) : Ue(R) ? $e(e, l, "whitespace")(R) : (a += 1, s && (s = !1, i += 1), R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), s = !0, l) : (e.enter("data"), p(R)));
  }
  function p(R) {
    return R === null || R === 124 || de(R) ? (e.exit("data"), l(R)) : (e.consume(R), R === 92 ? d : p);
  }
  function d(R) {
    return R === 92 || R === 124 ? (e.consume(R), p) : p(R);
  }
  function h(R) {
    return o.interrupt = !1, o.parser.lazy[o.now().line] ? r(R) : (e.enter("tableDelimiterRow"), s = !1, Ue(R) ? $e(e, f, "linePrefix", o.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : f(R));
  }
  function f(R) {
    return R === 45 || R === 58 ? m(R) : R === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), g) : b(R);
  }
  function g(R) {
    return Ue(R) ? $e(e, m, "whitespace")(R) : m(R);
  }
  function m(R) {
    return R === 58 ? (a += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), v) : R === 45 ? (a += 1, v(R)) : R === null || Vt(R) ? C(R) : b(R);
  }
  function v(R) {
    return R === 45 ? (e.enter("tableDelimiterFiller"), y(R)) : b(R);
  }
  function y(R) {
    return R === 45 ? (e.consume(R), y) : R === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), S) : (e.exit("tableDelimiterFiller"), S(R));
  }
  function S(R) {
    return Ue(R) ? $e(e, C, "whitespace")(R) : C(R);
  }
  function C(R) {
    return R === 124 ? f(R) : R === null || Vt(R) ? !s || i !== a ? b(R) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(R)) : b(R);
  }
  function b(R) {
    return r(R);
  }
  function w(R) {
    return e.enter("tableRow"), I(R);
  }
  function I(R) {
    return R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), I) : R === null || Vt(R) ? (e.exit("tableRow"), t(R)) : Ue(R) ? $e(e, I, "whitespace")(R) : (e.enter("data"), E(R));
  }
  function E(R) {
    return R === null || R === 124 || de(R) ? (e.exit("data"), I(R)) : (e.consume(R), R === 92 ? N : E);
  }
  function N(R) {
    return R === 92 || R === 124 ? (e.consume(R), E) : E(R);
  }
}
function XS(e, t) {
  let r = -1, o = !0, i = 0, a = [0, 0, 0, 0], s = [0, 0, 0, 0], n = !1, c = 0, u, l, p;
  const d = new JS();
  for (; ++r < e.length; ) {
    const h = e[r], f = h[1];
    h[0] === "enter" ? f.type === "tableHead" ? (n = !1, c !== 0 && (xc(d, t, c, u, l), l = void 0, c = 0), u = {
      type: "table",
      start: Object.assign({}, f.start),
      // Note: correct end is set later.
      end: Object.assign({}, f.end)
    }, d.add(r, 0, [["enter", u, t]])) : f.type === "tableRow" || f.type === "tableDelimiterRow" ? (o = !0, p = void 0, a = [0, 0, 0, 0], s = [0, r + 1, 0, 0], n && (n = !1, l = {
      type: "tableBody",
      start: Object.assign({}, f.start),
      // Note: correct end is set later.
      end: Object.assign({}, f.end)
    }, d.add(r, 0, [["enter", l, t]])), i = f.type === "tableDelimiterRow" ? 2 : l ? 3 : 1) : i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") ? (o = !1, s[2] === 0 && (a[1] !== 0 && (s[0] = s[1], p = _s(d, t, a, i, void 0, p), a = [0, 0, 0, 0]), s[2] = r)) : f.type === "tableCellDivider" && (o ? o = !1 : (a[1] !== 0 && (s[0] = s[1], p = _s(d, t, a, i, void 0, p)), a = s, s = [a[1], r, 0, 0])) : f.type === "tableHead" ? (n = !0, c = r) : f.type === "tableRow" || f.type === "tableDelimiterRow" ? (c = r, a[1] !== 0 ? (s[0] = s[1], p = _s(d, t, a, i, r, p)) : s[1] !== 0 && (p = _s(d, t, s, i, r, p)), i = 0) : i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") && (s[3] = r);
  }
  for (c !== 0 && xc(d, t, c, u, l), d.consume(t.events), r = -1; ++r < t.events.length; ) {
    const h = t.events[r];
    h[0] === "enter" && h[1].type === "table" && (h[1]._align = QS(t.events, r));
  }
  return e;
}
function _s(e, t, r, o, i, a) {
  const s = o === 1 ? "tableHeader" : o === 2 ? "tableDelimiter" : "tableData", n = "tableContent";
  r[0] !== 0 && (a.end = Object.assign({}, $t(t.events, r[0])), e.add(r[0], 0, [["exit", a, t]]));
  const c = $t(t.events, r[1]);
  if (a = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(r[1], 0, [["enter", a, t]]), r[2] !== 0) {
    const u = $t(t.events, r[2]), l = $t(t.events, r[3]), p = {
      type: n,
      start: Object.assign({}, u),
      end: Object.assign({}, l)
    };
    if (e.add(r[2], 0, [["enter", p, t]]), o !== 2) {
      const d = t.events[r[2]], h = t.events[r[3]];
      if (d[1].end = Object.assign({}, h[1].end), d[1].type = "chunkText", d[1].contentType = "text", r[3] > r[2] + 1) {
        const f = r[2] + 1, g = r[3] - r[2] - 1;
        e.add(f, g, []);
      }
    }
    e.add(r[3] + 1, 0, [["exit", p, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, $t(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function xc(e, t, r, o, i) {
  const a = [], s = $t(t.events, r);
  i && (i.end = Object.assign({}, s), a.push(["exit", i, t])), o.end = Object.assign({}, s), a.push(["exit", o, t]), e.add(r + 1, 0, a);
}
function $t(e, t) {
  const r = e[t], o = r[0] === "enter" ? "start" : "end";
  return r[1][o];
}
const eC = {
  name: "tasklistCheck",
  tokenize: rC
};
function tC() {
  return {
    text: {
      91: eC
    }
  };
}
function rC(e, t, r) {
  const o = this;
  return i;
  function i(c) {
    return (
      // Exit if theres stuff before.
      o.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !o._gfmTasklistFirstContentOfListItem ? r(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(c) {
    return de(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : r(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), n) : r(c);
  }
  function n(c) {
    return Vt(c) ? t(c) : Ue(c) ? e.check({
      tokenize: nC
    }, t, r)(c) : r(c);
  }
}
function nC(e, t, r) {
  return $e(e, o, "whitespace");
  function o(i) {
    return i === null ? r(i) : t(i);
  }
}
function iC(e) {
  return RS([
    IS(),
    qS(),
    KS(e),
    YS(),
    tC()
  ]);
}
const sC = {};
function $a(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), r = e || sC, o = t.data(), i = o.micromarkExtensions || (o.micromarkExtensions = []), a = o.fromMarkdownExtensions || (o.fromMarkdownExtensions = []), s = o.toMarkdownExtensions || (o.toMarkdownExtensions = []);
  i.push(iC(r)), a.push(SS()), s.push(CS(r));
}
const Qs = async (e, t, r = "en", o, i, a) => {
  try {
    const n = `${i.replace(/\/+$/, "")}/translate?api-version=3.0&from=${r}&to=${t}`, c = await fetch(
      n,
      {
        method: "POST",
        headers: {
          "Ocp-Apim-Subscription-Key": o,
          "Ocp-Apim-Subscription-Region": a,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(e.map((l) => ({ Text: l })))
      }
    );
    if (!c.ok)
      throw new Error(`Translation failed: ${c.statusText}`);
    return (await c.json()).map((l) => l.translations?.[0]?.text || "");
  } catch (s) {
    return console.error("Batch translation error:", s), e;
  }
};
function oC({
  messages: e,
  welcomeMessage: t,
  onSendMessage: r,
  className: o = "",
  isLoading: i = !1,
  rightElement: a,
  suggestedPrompts: s,
  renderMessage: n,
  showRetryButton: c = !1,
  handleRetry: u,
  setInterruptReplica: l,
  language: p,
  config: d
}) {
  const [h, f] = D(""), g = Ve(null), [m, v] = D(!0), y = Ve(null), S = Ve(null), [C, b] = D({ insufficientCredits: "Insufficient Credits", insufficientCreditsDescription: "Please purchase more credits to continue.", placeholder: "Type your message...", suggestedPrompts: "Suggested Prompts", thinking: "Thinking...", retry: "Retry" });
  B(() => {
    setTimeout(() => {
      if (g.current) {
        const R = g.current.closest("[data-radix-scroll-area-viewport]") || y.current;
        R && (R.scrollTop = R.scrollHeight);
      }
    }, 0);
  }, [e, i]), B(() => {
    setTimeout(() => {
      if (g.current) {
        const R = g.current.closest("[data-radix-scroll-area-viewport]") || y.current;
        R && (R.scrollTop = R.scrollHeight);
      }
    }, 0);
  }, []), B(() => {
    (async () => {
      if (p !== "en" && S.current !== p) {
        const [M, T, L, U, Q, ee] = await Qs(["Insufficient Credits", "Please purchase more credits to continue.", "Type your message...", "Suggested Prompts", "Thinking...", "Retry", "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload any lab test or medical report. If you dont have one, lets just talk."], p, "en", d?.azureTranslatorKey || "", d?.azureTranslatorEndpoint || "", d?.azureTranslatorRegion || "");
        b({ insufficientCredits: M, insufficientCreditsDescription: T, placeholder: L, suggestedPrompts: U, thinking: Q, retry: ee }), S.current = p;
      }
      p === "en" && S.current !== "en" && (b({ insufficientCredits: "Insufficient Credits", insufficientCreditsDescription: "Please purchase more credits to continue.", placeholder: "Type your message...", suggestedPrompts: "Suggested Prompts", thinking: "Thinking...", retry: "Retry" }), S.current = "en");
    })();
  }, [p, d]);
  const w = () => {
    h.trim() === "" || i || (r(h), f(""));
  }, I = (R) => {
    R.key === "Enter" && !R.shiftKey && (R.preventDefault(), w());
  }, E = (R) => {
    f(R);
  }, N = () => {
    v(!m);
  };
  return /* @__PURE__ */ k(
    "div",
    {
      className: `flex flex-col h-full bg-white rounded-lg border border-primary/20 overflow-hidden ${o}`,
      children: [
        /* @__PURE__ */ P("div", { ref: y, className: "flex-1 overflow-y-auto p-3 bg-white/80", children: /* @__PURE__ */ k("div", { className: "space-y-3", children: [
          e?.length === 0 ? /* @__PURE__ */ k("div", { className: "flex items-start", children: [
            /* @__PURE__ */ P("div", { className: "w-8 h-8 rounded-full bg-primary flex items-center justify-center text-white flex-shrink-0", children: /* @__PURE__ */ P(Cc, { size: 14 }) }),
            /* @__PURE__ */ P("div", { className: "ml-2 px-3 py-2 rounded-lg bg-secondary/10", children: /* @__PURE__ */ P("div", { className: "text-sm text-secondary", children: t }) })
          ] }) : e?.map((R, M) => {
            const L = M === e.length - 1 && R.sender === "ai", U = c && L && u && R.sender === "ai";
            return /* @__PURE__ */ P(
              "div",
              {
                className: ps(
                  "flex",
                  R.sender === "user" ? "justify-end" : "justify-start",
                  "mb-4"
                ),
                children: /* @__PURE__ */ k(
                  "div",
                  {
                    className: ps(
                      "max-w-[80%] rounded-lg p-3",
                      R.sender === "user" ? "bg-primary text-white" : "bg-light text-secondary"
                    ),
                    children: [
                      n ? n(R, M) : R.sender === "user" ? /* @__PURE__ */ P("div", { className: "text-sm", children: R.text }) : /* @__PURE__ */ P("div", { className: "text-sm", children: /* @__PURE__ */ P(qa, { remarkPlugins: [$a], children: R.text }) }),
                      U && /* @__PURE__ */ P("div", { className: "mt-2 flex justify-end", children: /* @__PURE__ */ k(
                        ke,
                        {
                          variant: "ghost",
                          size: "sm",
                          onClick: u,
                          className: "h-6 px-2 text-xs hover:bg-secondary/20",
                          children: [
                            /* @__PURE__ */ P(Pg, { className: "h-3 w-3 mr-1" }),
                            C.retry
                          ]
                        }
                      ) })
                    ]
                  }
                )
              },
              R.id
            );
          }),
          i && /* @__PURE__ */ k("div", { className: "flex items-start", children: [
            /* @__PURE__ */ P("div", { className: "w-8 h-8 rounded-full bg-primary flex items-center justify-center text-white flex-shrink-0", children: /* @__PURE__ */ P(Cc, { size: 14 }) }),
            /* @__PURE__ */ k("div", { className: "ml-2 px-3 py-2 rounded-lg bg-secondary/10 flex items-center", children: [
              /* @__PURE__ */ P(ja, { className: "h-4 w-4 animate-spin mr-2 text-primary" }),
              /* @__PURE__ */ P("span", { className: "text-sm text-secondary", children: C.thinking })
            ] })
          ] }),
          /* @__PURE__ */ P("div", { ref: g })
        ] }) }),
        /* @__PURE__ */ k("div", { className: "p-3 border-t border-light bg-white flex-shrink-0", children: [
          s && s?.length > 0 && /* @__PURE__ */ k("div", { className: "bg-white border-b border-light flex-shrink-0", children: [
            /* @__PURE__ */ k(
              "button",
              {
                onClick: N,
                className: "w-full p-2 flex items-center justify-center hover:bg-secondary/10 transition-colors",
                children: [
                  /* @__PURE__ */ P("span", { className: "text-sm font-medium text-secondary", children: C.suggestedPrompts }),
                  m ? /* @__PURE__ */ P(bg, { className: "h-4 w-4 text-secondary" }) : /* @__PURE__ */ P(wg, { className: "h-4 w-4 text-secondary" })
                ]
              }
            ),
            !m && /* @__PURE__ */ P("div", { className: "p-3 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2", children: s.map(({ id: R, text: M, icon: T }) => /* @__PURE__ */ k(
              ke,
              {
                variant: "outline",
                className: ps(
                  "w-full justify-start text-left text-sm h-auto min-h-[40px] py-2 px-3",
                  "whitespace-normal break-words"
                ),
                onClick: () => E(M),
                children: [
                  /* @__PURE__ */ P(T, { className: "h-4 w-4 mr-2 text-primary flex-shrink-0" }),
                  /* @__PURE__ */ P("span", { className: "text-left", children: M })
                ]
              },
              R
            )) })
          ] }),
          /* @__PURE__ */ k("div", { className: "flex items-end", children: [
            /* @__PURE__ */ P(
              "textarea",
              {
                value: h,
                onChange: (R) => {
                  f(R.target.value), l(!0), R.target.style.height = "auto", R.target.style.height = Math.min(R.target.scrollHeight, 120) + "px";
                },
                onKeyDown: I,
                placeholder: C.placeholder,
                className: "flex-1 rounded-l-lg rounded-r-none focus-visible:ring-0 focus-visible:ring-offset-0 border-r-0 resize-none min-h-[40px] max-h-[120px] p-3 text-sm border border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
                disabled: i || !1,
                rows: 1
              }
            ),
            /* @__PURE__ */ P(
              ke,
              {
                onClick: w,
                className: "rounded-l-none bg-primary hover:bg-secondary h-[40px]",
                disabled: h.trim() === "" || i,
                children: i ? /* @__PURE__ */ P(ja, { className: "h-5 w-5 animate-spin" }) : /* @__PURE__ */ P(Eg, { size: 18 })
              }
            ),
            a && /* @__PURE__ */ P("div", { className: "ml-2", children: a })
          ] })
        ] })
      ]
    }
  );
}
function aC(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function o() {
      var i = !1;
      try {
        i = this instanceof o;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(o) {
    var i = Object.getOwnPropertyDescriptor(e, o);
    Object.defineProperty(r, o, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[o];
      }
    });
  }), r;
}
var lt = {}, pt = {}, rr = {}, dt = {}, Y = {}, So = {}, ht = {}, Co = {}, nr = {}, ks = {}, zc;
function Zf() {
  if (zc) return ks;
  zc = 1, Object.defineProperty(ks, "__esModule", {
    value: !0
  }), ks.default = r;
  let e;
  const t = new Uint8Array(16);
  function r() {
    if (!e && (e = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !e))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return e(t);
  }
  return ks;
}
var Ft = {}, ir = {}, sr = {}, Lc;
function cC() {
  if (Lc) return sr;
  Lc = 1, Object.defineProperty(sr, "__esModule", {
    value: !0
  }), sr.default = void 0;
  var e = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  return sr.default = e, sr;
}
var jc;
function Ys() {
  if (jc) return ir;
  jc = 1, Object.defineProperty(ir, "__esModule", {
    value: !0
  }), ir.default = void 0;
  var e = t(/* @__PURE__ */ cC());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    return typeof i == "string" && e.default.test(i);
  }
  var o = r;
  return ir.default = o, ir;
}
var qc;
function Zs() {
  if (qc) return Ft;
  qc = 1, Object.defineProperty(Ft, "__esModule", {
    value: !0
  }), Ft.default = void 0, Ft.unsafeStringify = o;
  var e = t(/* @__PURE__ */ Ys());
  function t(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = [];
  for (let s = 0; s < 256; ++s)
    r.push((s + 256).toString(16).slice(1));
  function o(s, n = 0) {
    return r[s[n + 0]] + r[s[n + 1]] + r[s[n + 2]] + r[s[n + 3]] + "-" + r[s[n + 4]] + r[s[n + 5]] + "-" + r[s[n + 6]] + r[s[n + 7]] + "-" + r[s[n + 8]] + r[s[n + 9]] + "-" + r[s[n + 10]] + r[s[n + 11]] + r[s[n + 12]] + r[s[n + 13]] + r[s[n + 14]] + r[s[n + 15]];
  }
  function i(s, n = 0) {
    const c = o(s, n);
    if (!(0, e.default)(c))
      throw TypeError("Stringified UUID is invalid");
    return c;
  }
  var a = i;
  return Ft.default = a, Ft;
}
var Fc;
function uC() {
  if (Fc) return nr;
  Fc = 1, Object.defineProperty(nr, "__esModule", {
    value: !0
  }), nr.default = void 0;
  var e = r(/* @__PURE__ */ Zf()), t = /* @__PURE__ */ Zs();
  function r(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let o, i, a = 0, s = 0;
  function n(u, l, p) {
    let d = l && p || 0;
    const h = l || new Array(16);
    u = u || {};
    let f = u.node || o, g = u.clockseq !== void 0 ? u.clockseq : i;
    if (f == null || g == null) {
      const b = u.random || (u.rng || e.default)();
      f == null && (f = o = [b[0] | 1, b[1], b[2], b[3], b[4], b[5]]), g == null && (g = i = (b[6] << 8 | b[7]) & 16383);
    }
    let m = u.msecs !== void 0 ? u.msecs : Date.now(), v = u.nsecs !== void 0 ? u.nsecs : s + 1;
    const y = m - a + (v - s) / 1e4;
    if (y < 0 && u.clockseq === void 0 && (g = g + 1 & 16383), (y < 0 || m > a) && u.nsecs === void 0 && (v = 0), v >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    a = m, s = v, i = g, m += 122192928e5;
    const S = ((m & 268435455) * 1e4 + v) % 4294967296;
    h[d++] = S >>> 24 & 255, h[d++] = S >>> 16 & 255, h[d++] = S >>> 8 & 255, h[d++] = S & 255;
    const C = m / 4294967296 * 1e4 & 268435455;
    h[d++] = C >>> 8 & 255, h[d++] = C & 255, h[d++] = C >>> 24 & 15 | 16, h[d++] = C >>> 16 & 255, h[d++] = g >>> 8 | 128, h[d++] = g & 255;
    for (let b = 0; b < 6; ++b)
      h[d + b] = f[b];
    return l || (0, t.unsafeStringify)(h);
  }
  var c = n;
  return nr.default = c, nr;
}
var or = {}, Xe = {}, ar = {}, Bc;
function Xf() {
  if (Bc) return ar;
  Bc = 1, Object.defineProperty(ar, "__esModule", {
    value: !0
  }), ar.default = void 0;
  var e = t(/* @__PURE__ */ Ys());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    if (!(0, e.default)(i))
      throw TypeError("Invalid UUID");
    let a;
    const s = new Uint8Array(16);
    return s[0] = (a = parseInt(i.slice(0, 8), 16)) >>> 24, s[1] = a >>> 16 & 255, s[2] = a >>> 8 & 255, s[3] = a & 255, s[4] = (a = parseInt(i.slice(9, 13), 16)) >>> 8, s[5] = a & 255, s[6] = (a = parseInt(i.slice(14, 18), 16)) >>> 8, s[7] = a & 255, s[8] = (a = parseInt(i.slice(19, 23), 16)) >>> 8, s[9] = a & 255, s[10] = (a = parseInt(i.slice(24, 36), 16)) / 1099511627776 & 255, s[11] = a / 4294967296 & 255, s[12] = a >>> 24 & 255, s[13] = a >>> 16 & 255, s[14] = a >>> 8 & 255, s[15] = a & 255, s;
  }
  var o = r;
  return ar.default = o, ar;
}
var Uc;
function ev() {
  if (Uc) return Xe;
  Uc = 1, Object.defineProperty(Xe, "__esModule", {
    value: !0
  }), Xe.URL = Xe.DNS = void 0, Xe.default = s;
  var e = /* @__PURE__ */ Zs(), t = r(/* @__PURE__ */ Xf());
  function r(n) {
    return n && n.__esModule ? n : { default: n };
  }
  function o(n) {
    n = unescape(encodeURIComponent(n));
    const c = [];
    for (let u = 0; u < n.length; ++u)
      c.push(n.charCodeAt(u));
    return c;
  }
  const i = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  Xe.DNS = i;
  const a = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  Xe.URL = a;
  function s(n, c, u) {
    function l(p, d, h, f) {
      var g;
      if (typeof p == "string" && (p = o(p)), typeof d == "string" && (d = (0, t.default)(d)), ((g = d) === null || g === void 0 ? void 0 : g.length) !== 16)
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let m = new Uint8Array(16 + p.length);
      if (m.set(d), m.set(p, d.length), m = u(m), m[6] = m[6] & 15 | c, m[8] = m[8] & 63 | 128, h) {
        f = f || 0;
        for (let v = 0; v < 16; ++v)
          h[f + v] = m[v];
        return h;
      }
      return (0, e.unsafeStringify)(m);
    }
    try {
      l.name = n;
    } catch {
    }
    return l.DNS = i, l.URL = a, l;
  }
  return Xe;
}
var cr = {}, $c;
function lC() {
  if ($c) return cr;
  $c = 1, Object.defineProperty(cr, "__esModule", {
    value: !0
  }), cr.default = void 0;
  function e(h) {
    if (typeof h == "string") {
      const f = unescape(encodeURIComponent(h));
      h = new Uint8Array(f.length);
      for (let g = 0; g < f.length; ++g)
        h[g] = f.charCodeAt(g);
    }
    return t(o(i(h), h.length * 8));
  }
  function t(h) {
    const f = [], g = h.length * 32, m = "0123456789abcdef";
    for (let v = 0; v < g; v += 8) {
      const y = h[v >> 5] >>> v % 32 & 255, S = parseInt(m.charAt(y >>> 4 & 15) + m.charAt(y & 15), 16);
      f.push(S);
    }
    return f;
  }
  function r(h) {
    return (h + 64 >>> 9 << 4) + 14 + 1;
  }
  function o(h, f) {
    h[f >> 5] |= 128 << f % 32, h[r(f) - 1] = f;
    let g = 1732584193, m = -271733879, v = -1732584194, y = 271733878;
    for (let S = 0; S < h.length; S += 16) {
      const C = g, b = m, w = v, I = y;
      g = c(g, m, v, y, h[S], 7, -680876936), y = c(y, g, m, v, h[S + 1], 12, -389564586), v = c(v, y, g, m, h[S + 2], 17, 606105819), m = c(m, v, y, g, h[S + 3], 22, -1044525330), g = c(g, m, v, y, h[S + 4], 7, -176418897), y = c(y, g, m, v, h[S + 5], 12, 1200080426), v = c(v, y, g, m, h[S + 6], 17, -1473231341), m = c(m, v, y, g, h[S + 7], 22, -45705983), g = c(g, m, v, y, h[S + 8], 7, 1770035416), y = c(y, g, m, v, h[S + 9], 12, -1958414417), v = c(v, y, g, m, h[S + 10], 17, -42063), m = c(m, v, y, g, h[S + 11], 22, -1990404162), g = c(g, m, v, y, h[S + 12], 7, 1804603682), y = c(y, g, m, v, h[S + 13], 12, -40341101), v = c(v, y, g, m, h[S + 14], 17, -1502002290), m = c(m, v, y, g, h[S + 15], 22, 1236535329), g = u(g, m, v, y, h[S + 1], 5, -165796510), y = u(y, g, m, v, h[S + 6], 9, -1069501632), v = u(v, y, g, m, h[S + 11], 14, 643717713), m = u(m, v, y, g, h[S], 20, -373897302), g = u(g, m, v, y, h[S + 5], 5, -701558691), y = u(y, g, m, v, h[S + 10], 9, 38016083), v = u(v, y, g, m, h[S + 15], 14, -660478335), m = u(m, v, y, g, h[S + 4], 20, -405537848), g = u(g, m, v, y, h[S + 9], 5, 568446438), y = u(y, g, m, v, h[S + 14], 9, -1019803690), v = u(v, y, g, m, h[S + 3], 14, -187363961), m = u(m, v, y, g, h[S + 8], 20, 1163531501), g = u(g, m, v, y, h[S + 13], 5, -1444681467), y = u(y, g, m, v, h[S + 2], 9, -51403784), v = u(v, y, g, m, h[S + 7], 14, 1735328473), m = u(m, v, y, g, h[S + 12], 20, -1926607734), g = l(g, m, v, y, h[S + 5], 4, -378558), y = l(y, g, m, v, h[S + 8], 11, -2022574463), v = l(v, y, g, m, h[S + 11], 16, 1839030562), m = l(m, v, y, g, h[S + 14], 23, -35309556), g = l(g, m, v, y, h[S + 1], 4, -1530992060), y = l(y, g, m, v, h[S + 4], 11, 1272893353), v = l(v, y, g, m, h[S + 7], 16, -155497632), m = l(m, v, y, g, h[S + 10], 23, -1094730640), g = l(g, m, v, y, h[S + 13], 4, 681279174), y = l(y, g, m, v, h[S], 11, -358537222), v = l(v, y, g, m, h[S + 3], 16, -722521979), m = l(m, v, y, g, h[S + 6], 23, 76029189), g = l(g, m, v, y, h[S + 9], 4, -640364487), y = l(y, g, m, v, h[S + 12], 11, -421815835), v = l(v, y, g, m, h[S + 15], 16, 530742520), m = l(m, v, y, g, h[S + 2], 23, -995338651), g = p(g, m, v, y, h[S], 6, -198630844), y = p(y, g, m, v, h[S + 7], 10, 1126891415), v = p(v, y, g, m, h[S + 14], 15, -1416354905), m = p(m, v, y, g, h[S + 5], 21, -57434055), g = p(g, m, v, y, h[S + 12], 6, 1700485571), y = p(y, g, m, v, h[S + 3], 10, -1894986606), v = p(v, y, g, m, h[S + 10], 15, -1051523), m = p(m, v, y, g, h[S + 1], 21, -2054922799), g = p(g, m, v, y, h[S + 8], 6, 1873313359), y = p(y, g, m, v, h[S + 15], 10, -30611744), v = p(v, y, g, m, h[S + 6], 15, -1560198380), m = p(m, v, y, g, h[S + 13], 21, 1309151649), g = p(g, m, v, y, h[S + 4], 6, -145523070), y = p(y, g, m, v, h[S + 11], 10, -1120210379), v = p(v, y, g, m, h[S + 2], 15, 718787259), m = p(m, v, y, g, h[S + 9], 21, -343485551), g = a(g, C), m = a(m, b), v = a(v, w), y = a(y, I);
    }
    return [g, m, v, y];
  }
  function i(h) {
    if (h.length === 0)
      return [];
    const f = h.length * 8, g = new Uint32Array(r(f));
    for (let m = 0; m < f; m += 8)
      g[m >> 5] |= (h[m / 8] & 255) << m % 32;
    return g;
  }
  function a(h, f) {
    const g = (h & 65535) + (f & 65535);
    return (h >> 16) + (f >> 16) + (g >> 16) << 16 | g & 65535;
  }
  function s(h, f) {
    return h << f | h >>> 32 - f;
  }
  function n(h, f, g, m, v, y) {
    return a(s(a(a(f, h), a(m, y)), v), g);
  }
  function c(h, f, g, m, v, y, S) {
    return n(f & g | ~f & m, h, f, v, y, S);
  }
  function u(h, f, g, m, v, y, S) {
    return n(f & m | g & ~m, h, f, v, y, S);
  }
  function l(h, f, g, m, v, y, S) {
    return n(f ^ g ^ m, h, f, v, y, S);
  }
  function p(h, f, g, m, v, y, S) {
    return n(g ^ (f | ~m), h, f, v, y, S);
  }
  var d = e;
  return cr.default = d, cr;
}
var Vc;
function pC() {
  if (Vc) return or;
  Vc = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.default = void 0;
  var e = r(/* @__PURE__ */ ev()), t = r(/* @__PURE__ */ lC());
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = (0, e.default)("v3", 48, t.default);
  return or.default = i, or;
}
var ur = {}, lr = {}, Wc;
function dC() {
  if (Wc) return lr;
  Wc = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.default = void 0;
  var t = {
    randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  };
  return lr.default = t, lr;
}
var Hc;
function hC() {
  if (Hc) return ur;
  Hc = 1, Object.defineProperty(ur, "__esModule", {
    value: !0
  }), ur.default = void 0;
  var e = o(/* @__PURE__ */ dC()), t = o(/* @__PURE__ */ Zf()), r = /* @__PURE__ */ Zs();
  function o(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s, n, c) {
    if (e.default.randomUUID && !n && !s)
      return e.default.randomUUID();
    s = s || {};
    const u = s.random || (s.rng || t.default)();
    if (u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, n) {
      c = c || 0;
      for (let l = 0; l < 16; ++l)
        n[c + l] = u[l];
      return n;
    }
    return (0, r.unsafeStringify)(u);
  }
  var a = i;
  return ur.default = a, ur;
}
var pr = {}, dr = {}, Kc;
function fC() {
  if (Kc) return dr;
  Kc = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.default = void 0;
  function e(i, a, s, n) {
    switch (i) {
      case 0:
        return a & s ^ ~a & n;
      case 1:
        return a ^ s ^ n;
      case 2:
        return a & s ^ a & n ^ s & n;
      case 3:
        return a ^ s ^ n;
    }
  }
  function t(i, a) {
    return i << a | i >>> 32 - a;
  }
  function r(i) {
    const a = [1518500249, 1859775393, 2400959708, 3395469782], s = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof i == "string") {
      const l = unescape(encodeURIComponent(i));
      i = [];
      for (let p = 0; p < l.length; ++p)
        i.push(l.charCodeAt(p));
    } else Array.isArray(i) || (i = Array.prototype.slice.call(i));
    i.push(128);
    const n = i.length / 4 + 2, c = Math.ceil(n / 16), u = new Array(c);
    for (let l = 0; l < c; ++l) {
      const p = new Uint32Array(16);
      for (let d = 0; d < 16; ++d)
        p[d] = i[l * 64 + d * 4] << 24 | i[l * 64 + d * 4 + 1] << 16 | i[l * 64 + d * 4 + 2] << 8 | i[l * 64 + d * 4 + 3];
      u[l] = p;
    }
    u[c - 1][14] = (i.length - 1) * 8 / Math.pow(2, 32), u[c - 1][14] = Math.floor(u[c - 1][14]), u[c - 1][15] = (i.length - 1) * 8 & 4294967295;
    for (let l = 0; l < c; ++l) {
      const p = new Uint32Array(80);
      for (let v = 0; v < 16; ++v)
        p[v] = u[l][v];
      for (let v = 16; v < 80; ++v)
        p[v] = t(p[v - 3] ^ p[v - 8] ^ p[v - 14] ^ p[v - 16], 1);
      let d = s[0], h = s[1], f = s[2], g = s[3], m = s[4];
      for (let v = 0; v < 80; ++v) {
        const y = Math.floor(v / 20), S = t(d, 5) + e(y, h, f, g) + m + a[y] + p[v] >>> 0;
        m = g, g = f, f = t(h, 30) >>> 0, h = d, d = S;
      }
      s[0] = s[0] + d >>> 0, s[1] = s[1] + h >>> 0, s[2] = s[2] + f >>> 0, s[3] = s[3] + g >>> 0, s[4] = s[4] + m >>> 0;
    }
    return [s[0] >> 24 & 255, s[0] >> 16 & 255, s[0] >> 8 & 255, s[0] & 255, s[1] >> 24 & 255, s[1] >> 16 & 255, s[1] >> 8 & 255, s[1] & 255, s[2] >> 24 & 255, s[2] >> 16 & 255, s[2] >> 8 & 255, s[2] & 255, s[3] >> 24 & 255, s[3] >> 16 & 255, s[3] >> 8 & 255, s[3] & 255, s[4] >> 24 & 255, s[4] >> 16 & 255, s[4] >> 8 & 255, s[4] & 255];
  }
  var o = r;
  return dr.default = o, dr;
}
var Jc;
function vC() {
  if (Jc) return pr;
  Jc = 1, Object.defineProperty(pr, "__esModule", {
    value: !0
  }), pr.default = void 0;
  var e = r(/* @__PURE__ */ ev()), t = r(/* @__PURE__ */ fC());
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = (0, e.default)("v5", 80, t.default);
  return pr.default = i, pr;
}
var hr = {}, Gc;
function gC() {
  if (Gc) return hr;
  Gc = 1, Object.defineProperty(hr, "__esModule", {
    value: !0
  }), hr.default = void 0;
  var e = "00000000-0000-0000-0000-000000000000";
  return hr.default = e, hr;
}
var fr = {}, Qc;
function mC() {
  if (Qc) return fr;
  Qc = 1, Object.defineProperty(fr, "__esModule", {
    value: !0
  }), fr.default = void 0;
  var e = t(/* @__PURE__ */ Ys());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    if (!(0, e.default)(i))
      throw TypeError("Invalid UUID");
    return parseInt(i.slice(14, 15), 16);
  }
  var o = r;
  return fr.default = o, fr;
}
var Yc;
function yC() {
  return Yc || (Yc = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "NIL", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(e, "v1", {
      enumerable: !0,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(e, "v3", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "v4", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "v5", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    });
    var t = l(/* @__PURE__ */ uC()), r = l(/* @__PURE__ */ pC()), o = l(/* @__PURE__ */ hC()), i = l(/* @__PURE__ */ vC()), a = l(/* @__PURE__ */ gC()), s = l(/* @__PURE__ */ mC()), n = l(/* @__PURE__ */ Ys()), c = l(/* @__PURE__ */ Zs()), u = l(/* @__PURE__ */ Xf());
    function l(p) {
      return p && p.__esModule ? p : { default: p };
    }
  }(Co)), Co;
}
var Zc;
function Lt() {
  if (Zc) return ht;
  Zc = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.createNoDashGuid = ht.createGuid = void 0;
  const e = /* @__PURE__ */ yC(), t = () => (0, e.v4)();
  ht.createGuid = t;
  const r = () => t().replace(new RegExp("-", "g"), "").toUpperCase();
  return ht.createNoDashGuid = r, ht;
}
var Xc;
function Cs() {
  return Xc || (Xc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PlatformEvent = e.EventType = void 0;
    const t = /* @__PURE__ */ Lt();
    (function(o) {
      o[o.Debug = 0] = "Debug", o[o.Info = 1] = "Info", o[o.Warning = 2] = "Warning", o[o.Error = 3] = "Error", o[o.None = 4] = "None";
    })(e.EventType || (e.EventType = {}));
    class r {
      constructor(i, a) {
        this.privName = i, this.privEventId = (0, t.createNoDashGuid)(), this.privEventTime = (/* @__PURE__ */ new Date()).toISOString(), this.privEventType = a, this.privMetadata = {};
      }
      get name() {
        return this.privName;
      }
      get eventId() {
        return this.privEventId;
      }
      get eventTime() {
        return this.privEventTime;
      }
      get eventType() {
        return this.privEventType;
      }
      get metadata() {
        return this.privMetadata;
      }
    }
    e.PlatformEvent = r;
  }(So)), So;
}
var eu;
function SC() {
  if (eu) return Y;
  eu = 1, Object.defineProperty(Y, "__esModule", { value: !0 }), Y.AudioStreamNodeErrorEvent = Y.AudioStreamNodeDetachedEvent = Y.AudioStreamNodeAttachedEvent = Y.AudioStreamNodeAttachingEvent = Y.AudioStreamNodeEvent = Y.AudioSourceErrorEvent = Y.AudioSourceOffEvent = Y.AudioSourceReadyEvent = Y.AudioSourceInitializingEvent = Y.AudioSourceEvent = void 0;
  const e = /* @__PURE__ */ Cs();
  class t extends e.PlatformEvent {
    constructor(d, h, f = e.EventType.Info) {
      super(d, f), this.privAudioSourceId = h;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
  }
  Y.AudioSourceEvent = t;
  class r extends t {
    constructor(d) {
      super("AudioSourceInitializingEvent", d);
    }
  }
  Y.AudioSourceInitializingEvent = r;
  class o extends t {
    constructor(d) {
      super("AudioSourceReadyEvent", d);
    }
  }
  Y.AudioSourceReadyEvent = o;
  class i extends t {
    constructor(d) {
      super("AudioSourceOffEvent", d);
    }
  }
  Y.AudioSourceOffEvent = i;
  class a extends t {
    constructor(d, h) {
      super("AudioSourceErrorEvent", d, e.EventType.Error), this.privError = h;
    }
    get error() {
      return this.privError;
    }
  }
  Y.AudioSourceErrorEvent = a;
  class s extends t {
    constructor(d, h, f) {
      super(d, h), this.privAudioNodeId = f;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  Y.AudioStreamNodeEvent = s;
  class n extends s {
    constructor(d, h) {
      super("AudioStreamNodeAttachingEvent", d, h);
    }
  }
  Y.AudioStreamNodeAttachingEvent = n;
  class c extends s {
    constructor(d, h) {
      super("AudioStreamNodeAttachedEvent", d, h);
    }
  }
  Y.AudioStreamNodeAttachedEvent = c;
  class u extends s {
    constructor(d, h) {
      super("AudioStreamNodeDetachedEvent", d, h);
    }
  }
  Y.AudioStreamNodeDetachedEvent = u;
  class l extends s {
    constructor(d, h, f) {
      super("AudioStreamNodeErrorEvent", d, h), this.privError = f;
    }
    get error() {
      return this.privError;
    }
  }
  return Y.AudioStreamNodeErrorEvent = l, Y;
}
var Z = {}, tu;
function CC() {
  if (tu) return Z;
  tu = 1, Object.defineProperty(Z, "__esModule", { value: !0 }), Z.ConnectionRedirectEvent = Z.ConnectionMessageSentEvent = Z.ConnectionMessageReceivedEvent = Z.ConnectionEstablishErrorEvent = Z.ConnectionErrorEvent = Z.ConnectionClosedEvent = Z.ConnectionEstablishedEvent = Z.ConnectionStartEvent = Z.ConnectionEvent = Z.ServiceEvent = void 0;
  const e = /* @__PURE__ */ Cs();
  class t extends e.PlatformEvent {
    constructor(d, h, f = e.EventType.Info) {
      super(d, f), this.privJsonResult = h;
    }
    get jsonString() {
      return this.privJsonResult;
    }
  }
  Z.ServiceEvent = t;
  class r extends e.PlatformEvent {
    constructor(d, h, f = e.EventType.Info) {
      super(d, f), this.privConnectionId = h;
    }
    get connectionId() {
      return this.privConnectionId;
    }
  }
  Z.ConnectionEvent = r;
  class o extends r {
    constructor(d, h, f) {
      super("ConnectionStartEvent", d), this.privUri = h, this.privHeaders = f;
    }
    get uri() {
      return this.privUri;
    }
    get headers() {
      return this.privHeaders;
    }
  }
  Z.ConnectionStartEvent = o;
  class i extends r {
    constructor(d) {
      super("ConnectionEstablishedEvent", d);
    }
  }
  Z.ConnectionEstablishedEvent = i;
  class a extends r {
    constructor(d, h, f) {
      super("ConnectionClosedEvent", d, e.EventType.Debug), this.privReason = f, this.privStatusCode = h;
    }
    get reason() {
      return this.privReason;
    }
    get statusCode() {
      return this.privStatusCode;
    }
  }
  Z.ConnectionClosedEvent = a;
  class s extends r {
    constructor(d, h, f) {
      super("ConnectionErrorEvent", d, e.EventType.Debug), this.privMessage = h, this.privType = f;
    }
    get message() {
      return this.privMessage;
    }
    get type() {
      return this.privType;
    }
  }
  Z.ConnectionErrorEvent = s;
  class n extends r {
    constructor(d, h, f) {
      super("ConnectionEstablishErrorEvent", d, e.EventType.Error), this.privStatusCode = h, this.privReason = f;
    }
    get reason() {
      return this.privReason;
    }
    get statusCode() {
      return this.privStatusCode;
    }
  }
  Z.ConnectionEstablishErrorEvent = n;
  class c extends r {
    constructor(d, h, f) {
      super("ConnectionMessageReceivedEvent", d), this.privNetworkReceivedTime = h, this.privMessage = f;
    }
    get networkReceivedTime() {
      return this.privNetworkReceivedTime;
    }
    get message() {
      return this.privMessage;
    }
  }
  Z.ConnectionMessageReceivedEvent = c;
  class u extends r {
    constructor(d, h, f) {
      super("ConnectionMessageSentEvent", d), this.privNetworkSentTime = h, this.privMessage = f;
    }
    get networkSentTime() {
      return this.privNetworkSentTime;
    }
    get message() {
      return this.privMessage;
    }
  }
  Z.ConnectionMessageSentEvent = u;
  class l extends r {
    constructor(d, h, f, g) {
      super("ConnectionRedirectEvent", d, e.EventType.Info), this.privRedirectUrl = h, this.privOriginalUrl = f, this.privContext = g;
    }
    get redirectUrl() {
      return this.privRedirectUrl;
    }
    get originalUrl() {
      return this.privOriginalUrl;
    }
    get context() {
      return this.privContext;
    }
  }
  return Z.ConnectionRedirectEvent = l, Z;
}
var Ro = {}, je = {}, ru;
function De() {
  if (ru) return je;
  ru = 1, Object.defineProperty(je, "__esModule", { value: !0 }), je.ObjectDisposedError = je.InvalidOperationError = je.ArgumentNullError = void 0;
  class e extends Error {
    /**
     * Creates an instance of ArgumentNullError.
     *
     * @param {string} argumentName - Name of the argument that is null
     *
     * @memberOf ArgumentNullError
     */
    constructor(i) {
      super(i), this.name = "ArgumentNull", this.message = i;
    }
  }
  je.ArgumentNullError = e;
  class t extends Error {
    /**
     * Creates an instance of InvalidOperationError.
     *
     * @param {string} error - The error
     *
     * @memberOf InvalidOperationError
     */
    constructor(i) {
      super(i), this.name = "InvalidOperation", this.message = i;
    }
  }
  je.InvalidOperationError = t;
  class r extends Error {
    /**
     * Creates an instance of ObjectDisposedError.
     *
     * @param {string} objectName - The object that is disposed
     * @param {string} error - The error
     *
     * @memberOf ObjectDisposedError
     */
    constructor(i, a) {
      super(a), this.name = i + "ObjectDisposed", this.message = a;
    }
  }
  return je.ObjectDisposedError = r, je;
}
var nu;
function tv() {
  return nu || (nu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionMessage = e.MessageType = void 0;
    const t = /* @__PURE__ */ De(), r = /* @__PURE__ */ Lt();
    var o;
    (function(a) {
      a[a.Text = 0] = "Text", a[a.Binary = 1] = "Binary";
    })(o = e.MessageType || (e.MessageType = {}));
    class i {
      constructor(s, n, c, u) {
        if (this.privBody = null, s === o.Text && n && typeof n != "string")
          throw new t.InvalidOperationError("Payload must be a string");
        if (s === o.Binary && n && !(n instanceof ArrayBuffer))
          throw new t.InvalidOperationError("Payload must be ArrayBuffer");
        switch (this.privMessageType = s, this.privBody = n, this.privHeaders = c || {}, this.privId = u || (0, r.createNoDashGuid)(), this.messageType) {
          case o.Binary:
            this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
            break;
          case o.Text:
            this.privSize = this.textBody.length;
        }
      }
      get messageType() {
        return this.privMessageType;
      }
      get headers() {
        return this.privHeaders;
      }
      get body() {
        return this.privBody;
      }
      get textBody() {
        if (this.privMessageType === o.Binary)
          throw new t.InvalidOperationError("Not supported for binary message");
        return this.privBody;
      }
      get binaryBody() {
        if (this.privMessageType === o.Text)
          throw new t.InvalidOperationError("Not supported for text message");
        return this.privBody;
      }
      get id() {
        return this.privId;
      }
    }
    e.ConnectionMessage = i;
  }(Ro)), Ro;
}
var vr = {}, iu;
function RC() {
  if (iu) return vr;
  iu = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.ConnectionOpenResponse = void 0;
  let e = class {
    constructor(r, o) {
      this.privStatusCode = r, this.privReason = o;
    }
    get statusCode() {
      return this.privStatusCode;
    }
    get reason() {
      return this.privReason;
    }
  };
  return vr.ConnectionOpenResponse = e, vr;
}
var gr = {}, su;
function PC() {
  if (su) return gr;
  su = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.DeferralMap = void 0;
  let e = class {
    constructor() {
      this.privMap = {};
    }
    add(r, o) {
      this.privMap[r] = o;
    }
    getId(r) {
      return this.privMap[r];
    }
    complete(r, o) {
      try {
        this.privMap[r].resolve(o);
      } catch (i) {
        this.privMap[r].reject(i);
      } finally {
        this.privMap[r] = void 0;
      }
    }
  };
  return gr.DeferralMap = e, gr;
}
var ft = {}, ou;
function rv() {
  if (ou) return ft;
  ou = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.SendingAgentContextMessageEvent = ft.DialogEvent = void 0;
  const e = /* @__PURE__ */ Cs();
  class t extends e.PlatformEvent {
    constructor(i, a = e.EventType.Info) {
      super(i, a);
    }
  }
  ft.DialogEvent = t;
  class r extends t {
    constructor(i) {
      super("SendingAgentContextMessageEvent"), this.privAgentConfig = i;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
  }
  return ft.SendingAgentContextMessageEvent = r, ft;
}
var mr = {}, yr = {}, au;
function nv() {
  if (au) return yr;
  au = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.EventSource = void 0;
  const e = /* @__PURE__ */ De(), t = /* @__PURE__ */ Lt();
  let r = class {
    constructor(i) {
      this.privEventListeners = {}, this.privIsDisposed = !1, this.privConsoleListener = void 0, this.privMetadata = i;
    }
    onEvent(i) {
      if (this.isDisposed())
        throw new e.ObjectDisposedError("EventSource");
      if (this.metadata)
        for (const a in this.metadata)
          a && i.metadata && (i.metadata[a] || (i.metadata[a] = this.metadata[a]));
      for (const a in this.privEventListeners)
        a && this.privEventListeners[a] && this.privEventListeners[a](i);
    }
    attach(i) {
      const a = (0, t.createNoDashGuid)();
      return this.privEventListeners[a] = i, {
        detach: () => (delete this.privEventListeners[a], Promise.resolve())
      };
    }
    attachListener(i) {
      return this.attach((a) => i.onEvent(a));
    }
    attachConsoleListener(i) {
      return this.privConsoleListener && this.privConsoleListener.detach(), this.privConsoleListener = this.attach((a) => i.onEvent(a)), this.privConsoleListener;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.privEventListeners = null, this.privIsDisposed = !0;
    }
    get metadata() {
      return this.privMetadata;
    }
  };
  return yr.EventSource = r, yr;
}
var cu;
function bC() {
  if (cu) return mr;
  cu = 1, Object.defineProperty(mr, "__esModule", { value: !0 }), mr.Events = void 0;
  const e = /* @__PURE__ */ De(), t = /* @__PURE__ */ nv();
  let r = class Va {
    static setEventSource(i) {
      if (!i)
        throw new e.ArgumentNullError("eventSource");
      Va.privInstance = i;
    }
    static get instance() {
      return Va.privInstance;
    }
  };
  return mr.Events = r, r.privInstance = new t.EventSource(), mr;
}
var Po = {}, uu;
function wC() {
  return uu || (uu = 1, Object.defineProperty(Po, "__esModule", { value: !0 })), Po;
}
var bo = {}, lu;
function EC() {
  return lu || (lu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionState = void 0, function(t) {
      t[t.None = 0] = "None", t[t.Connected = 1] = "Connected", t[t.Connecting = 2] = "Connecting", t[t.Disconnected = 3] = "Disconnected";
    }(e.ConnectionState || (e.ConnectionState = {}));
  }(bo)), bo;
}
var wo = {}, pu;
function IC() {
  return pu || (pu = 1, Object.defineProperty(wo, "__esModule", { value: !0 })), wo;
}
var Eo = {}, du;
function AC() {
  return du || (du = 1, Object.defineProperty(Eo, "__esModule", { value: !0 })), Eo;
}
var Io = {}, hu;
function TC() {
  return hu || (hu = 1, Object.defineProperty(Io, "__esModule", { value: !0 })), Io;
}
var Ao = {}, fu;
function _C() {
  return fu || (fu = 1, Object.defineProperty(Ao, "__esModule", { value: !0 })), Ao;
}
var To = {}, vu;
function kC() {
  return vu || (vu = 1, Object.defineProperty(To, "__esModule", { value: !0 })), To;
}
var _o = {}, gu;
function OC() {
  return gu || (gu = 1, Object.defineProperty(_o, "__esModule", { value: !0 })), _o;
}
var ko = {}, mu;
function MC() {
  return mu || (mu = 1, Object.defineProperty(ko, "__esModule", { value: !0 })), ko;
}
var Oo = {}, yu;
function DC() {
  return yu || (yu = 1, Object.defineProperty(Oo, "__esModule", { value: !0 })), Oo;
}
var Sr = {}, Su;
function iv() {
  if (Su) return Sr;
  Su = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.List = void 0;
  const e = /* @__PURE__ */ De();
  let t = class Dt {
    constructor(o) {
      if (this.privSubscriptionIdCounter = 0, this.privAddSubscriptions = {}, this.privRemoveSubscriptions = {}, this.privDisposedSubscriptions = {}, this.privDisposeReason = null, this.privList = [], o)
        for (const i of o)
          this.privList.push(i);
    }
    get(o) {
      return this.throwIfDisposed(), this.privList[o];
    }
    first() {
      return this.get(0);
    }
    last() {
      return this.get(this.length() - 1);
    }
    add(o) {
      this.throwIfDisposed(), this.insertAt(this.privList.length, o);
    }
    insertAt(o, i) {
      this.throwIfDisposed(), o === 0 ? this.privList.unshift(i) : o === this.privList.length ? this.privList.push(i) : this.privList.splice(o, 0, i), this.triggerSubscriptions(this.privAddSubscriptions);
    }
    removeFirst() {
      return this.throwIfDisposed(), this.removeAt(0);
    }
    removeLast() {
      return this.throwIfDisposed(), this.removeAt(this.length() - 1);
    }
    removeAt(o) {
      return this.throwIfDisposed(), this.remove(o, 1)[0];
    }
    remove(o, i) {
      this.throwIfDisposed();
      const a = this.privList.splice(o, i);
      return this.triggerSubscriptions(this.privRemoveSubscriptions), a;
    }
    clear() {
      this.throwIfDisposed(), this.remove(0, this.length());
    }
    length() {
      return this.throwIfDisposed(), this.privList.length;
    }
    onAdded(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privAddSubscriptions[i] = o, {
        detach: () => (delete this.privAddSubscriptions[i], Promise.resolve())
      };
    }
    onRemoved(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privRemoveSubscriptions[i] = o, {
        detach: () => (delete this.privRemoveSubscriptions[i], Promise.resolve())
      };
    }
    onDisposed(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privDisposedSubscriptions[i] = o, {
        detach: () => (delete this.privDisposedSubscriptions[i], Promise.resolve())
      };
    }
    join(o) {
      return this.throwIfDisposed(), this.privList.join(o);
    }
    toArray() {
      const o = Array();
      return this.privList.forEach((i) => {
        o.push(i);
      }), o;
    }
    any(o) {
      return this.throwIfDisposed(), o ? this.where(o).length() > 0 : this.length() > 0;
    }
    all(o) {
      return this.throwIfDisposed(), this.where(o).length() === this.length();
    }
    forEach(o) {
      this.throwIfDisposed();
      for (let i = 0; i < this.length(); i++)
        o(this.privList[i], i);
    }
    select(o) {
      this.throwIfDisposed();
      const i = [];
      for (let a = 0; a < this.privList.length; a++)
        i.push(o(this.privList[a], a));
      return new Dt(i);
    }
    where(o) {
      this.throwIfDisposed();
      const i = new Dt();
      for (let a = 0; a < this.privList.length; a++)
        o(this.privList[a], a) && i.add(this.privList[a]);
      return i;
    }
    orderBy(o) {
      this.throwIfDisposed();
      const a = this.toArray().sort(o);
      return new Dt(a);
    }
    orderByDesc(o) {
      return this.throwIfDisposed(), this.orderBy((i, a) => o(a, i));
    }
    clone() {
      return this.throwIfDisposed(), new Dt(this.toArray());
    }
    concat(o) {
      return this.throwIfDisposed(), new Dt(this.privList.concat(o.toArray()));
    }
    concatArray(o) {
      return this.throwIfDisposed(), new Dt(this.privList.concat(o));
    }
    isDisposed() {
      return this.privList == null;
    }
    dispose(o) {
      this.isDisposed() || (this.privDisposeReason = o, this.privList = null, this.privAddSubscriptions = null, this.privRemoveSubscriptions = null, this.triggerSubscriptions(this.privDisposedSubscriptions));
    }
    throwIfDisposed() {
      if (this.isDisposed())
        throw new e.ObjectDisposedError("List", this.privDisposeReason);
    }
    triggerSubscriptions(o) {
      if (o)
        for (const i in o)
          i && o[i]();
    }
  };
  return Sr.List = t, Sr;
}
var Mo = {}, Cu;
function sv() {
  return Cu || (Cu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.marshalPromiseToCallbacks = e.Sink = e.Deferred = e.PromiseResultEventSource = e.PromiseResult = e.PromiseState = void 0;
    var t;
    (function(n) {
      n[n.None = 0] = "None", n[n.Resolved = 1] = "Resolved", n[n.Rejected = 2] = "Rejected";
    })(t = e.PromiseState || (e.PromiseState = {}));
    class r {
      constructor(c) {
        this.throwIfError = () => {
          if (this.isError)
            throw this.error;
        }, c.on((u) => {
          this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !1, this.privResult = u);
        }, (u) => {
          this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !0, this.privError = u);
        });
      }
      get isCompleted() {
        return this.privIsCompleted;
      }
      get isError() {
        return this.privIsError;
      }
      get error() {
        return this.privError;
      }
      get result() {
        return this.privResult;
      }
    }
    e.PromiseResult = r;
    class o {
      constructor() {
        this.setResult = (c) => {
          this.privOnSetResult(c);
        }, this.setError = (c) => {
          this.privOnSetError(c);
        }, this.on = (c, u) => {
          this.privOnSetResult = c, this.privOnSetError = u;
        };
      }
    }
    e.PromiseResultEventSource = o;
    class i {
      constructor() {
        this.resolve = (c) => (this.privResolve(c), this), this.reject = (c) => (this.privReject(c), this), this.privPromise = new Promise((c, u) => {
          this.privResolve = c, this.privReject = u;
        });
      }
      get promise() {
        return this.privPromise;
      }
    }
    e.Deferred = i;
    class a {
      constructor() {
        this.privState = t.None, this.privPromiseResult = null, this.privPromiseResultEvents = null, this.privSuccessHandlers = [], this.privErrorHandlers = [], this.privPromiseResultEvents = new o(), this.privPromiseResult = new r(this.privPromiseResultEvents);
      }
      get state() {
        return this.privState;
      }
      get result() {
        return this.privPromiseResult;
      }
      resolve(c) {
        if (this.privState !== t.None)
          throw new Error("'Cannot resolve a completed promise'");
        this.privState = t.Resolved, this.privPromiseResultEvents.setResult(c);
        for (let u = 0; u < this.privSuccessHandlers.length; u++)
          this.executeSuccessCallback(c, this.privSuccessHandlers[u], this.privErrorHandlers[u]);
        this.detachHandlers();
      }
      reject(c) {
        if (this.privState !== t.None)
          throw new Error("'Cannot reject a completed promise'");
        this.privState = t.Rejected, this.privPromiseResultEvents.setError(c);
        for (const u of this.privErrorHandlers)
          this.executeErrorCallback(c, u);
        this.detachHandlers();
      }
      on(c, u) {
        c == null && (c = () => {
        }), this.privState === t.None ? (this.privSuccessHandlers.push(c), this.privErrorHandlers.push(u)) : (this.privState === t.Resolved ? this.executeSuccessCallback(this.privPromiseResult.result, c, u) : this.privState === t.Rejected && this.executeErrorCallback(this.privPromiseResult.error, u), this.detachHandlers());
      }
      executeSuccessCallback(c, u, l) {
        try {
          u(c);
        } catch (p) {
          this.executeErrorCallback(`'Unhandled callback error: ${p}'`, l);
        }
      }
      executeErrorCallback(c, u) {
        if (u)
          try {
            u(c);
          } catch (l) {
            throw new Error(`'Unhandled callback error: ${l}. InnerError: ${c}'`);
          }
        else
          throw new Error(`'Unhandled error: ${c}'`);
      }
      detachHandlers() {
        this.privErrorHandlers = [], this.privSuccessHandlers = [];
      }
    }
    e.Sink = a;
    function s(n, c, u) {
      n.then((l) => {
        try {
          c && c(l);
        } catch (p) {
          if (u)
            try {
              if (p instanceof Error) {
                const d = p;
                u(d.name + ": " + d.message);
              } else
                u(p);
            } catch {
            }
        }
      }, (l) => {
        if (u)
          try {
            if (l instanceof Error) {
              const p = l;
              u(p.name + ": " + p.message);
            } else
              u(l);
          } catch {
          }
      });
    }
    e.marshalPromiseToCallbacks = s;
  }(Mo)), Mo;
}
var Cr = {}, Ru;
function ov() {
  if (Ru) return Cr;
  Ru = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.Queue = void 0;
  const e = /* @__PURE__ */ De(), t = /* @__PURE__ */ iv(), r = /* @__PURE__ */ sv();
  var o;
  (function(a) {
    a[a.Dequeue = 0] = "Dequeue", a[a.Peek = 1] = "Peek";
  })(o || (o = {}));
  let i = class {
    constructor(s) {
      this.privPromiseStore = new t.List(), this.privIsDrainInProgress = !1, this.privIsDisposing = !1, this.privDisposeReason = null, this.privList = s || new t.List(), this.privDetachables = [], this.privSubscribers = new t.List(), this.privDetachables.push(this.privList.onAdded(() => this.drain()));
    }
    enqueue(s) {
      this.throwIfDispose(), this.enqueueFromPromise(new Promise((n) => n(s)));
    }
    enqueueFromPromise(s) {
      this.throwIfDispose(), s.then((n) => {
        this.privList.add(n);
      }, () => {
      });
    }
    dequeue() {
      this.throwIfDispose();
      const s = new r.Deferred();
      return this.privSubscribers && (this.privSubscribers.add({ deferral: s, type: o.Dequeue }), this.drain()), s.promise;
    }
    peek() {
      this.throwIfDispose();
      const s = new r.Deferred();
      return this.privSubscribers && (this.privSubscribers.add({ deferral: s, type: o.Peek }), this.drain()), s.promise;
    }
    length() {
      return this.throwIfDispose(), this.privList.length();
    }
    isDisposed() {
      return this.privSubscribers == null;
    }
    async drainAndDispose(s, n) {
      if (!this.isDisposed() && !this.privIsDisposing) {
        this.privDisposeReason = n, this.privIsDisposing = !0;
        const c = this.privSubscribers;
        if (c) {
          for (; c.length() > 0; )
            c.removeFirst().deferral.resolve(void 0);
          this.privSubscribers === c && (this.privSubscribers = c);
        }
        for (const u of this.privDetachables)
          await u.detach();
        if (this.privPromiseStore.length() > 0 && s) {
          const u = [];
          return this.privPromiseStore.toArray().forEach((l) => {
            u.push(l);
          }), Promise.all(u).finally(() => {
            this.privSubscribers = null, this.privList.forEach((l) => {
              s(l);
            }), this.privList = null;
          }).then();
        } else
          this.privSubscribers = null, this.privList = null;
      }
    }
    async dispose(s) {
      await this.drainAndDispose(null, s);
    }
    drain() {
      if (!this.privIsDrainInProgress && !this.privIsDisposing) {
        this.privIsDrainInProgress = !0;
        const s = this.privSubscribers, n = this.privList;
        if (s && n) {
          for (; n.length() > 0 && s.length() > 0 && !this.privIsDisposing; ) {
            const c = s.removeFirst();
            if (c.type === o.Peek)
              c.deferral.resolve(n.first());
            else {
              const u = n.removeFirst();
              c.deferral.resolve(u);
            }
          }
          this.privSubscribers === s && (this.privSubscribers = s), this.privList === n && (this.privList = n);
        }
        this.privIsDrainInProgress = !1;
      }
    }
    throwIfDispose() {
      if (this.isDisposed())
        throw this.privDisposeReason ? new e.InvalidOperationError(this.privDisposeReason) : new e.ObjectDisposedError("Queue");
      if (this.privIsDisposing)
        throw new e.InvalidOperationError("Queue disposing");
    }
  };
  return Cr.Queue = i, Cr;
}
var Rr = {}, Pu;
function NC() {
  if (Pu) return Rr;
  Pu = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.RawWebsocketMessage = void 0;
  const e = /* @__PURE__ */ tv(), t = /* @__PURE__ */ De(), r = /* @__PURE__ */ Lt();
  let o = class {
    constructor(a, s, n) {
      if (this.privPayload = null, !s)
        throw new t.ArgumentNullError("payload");
      if (a === e.MessageType.Binary && Object.getPrototypeOf(s).constructor.name !== "ArrayBuffer")
        throw new t.InvalidOperationError("Payload must be ArrayBuffer");
      if (a === e.MessageType.Text && typeof s != "string")
        throw new t.InvalidOperationError("Payload must be a string");
      this.privMessageType = a, this.privPayload = s, this.privId = n || (0, r.createNoDashGuid)();
    }
    get messageType() {
      return this.privMessageType;
    }
    get payload() {
      return this.privPayload;
    }
    get textContent() {
      if (this.privMessageType === e.MessageType.Binary)
        throw new t.InvalidOperationError("Not supported for binary message");
      return this.privPayload;
    }
    get binaryContent() {
      if (this.privMessageType === e.MessageType.Text)
        throw new t.InvalidOperationError("Not supported for text message");
      return this.privPayload;
    }
    get id() {
      return this.privId;
    }
  };
  return Rr.RawWebsocketMessage = o, Rr;
}
var Pr = {}, bu;
function xC() {
  if (bu) return Pr;
  bu = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.RiffPcmEncoder = void 0;
  let e = class {
    constructor(r, o) {
      this.privActualSampleRate = r, this.privDesiredSampleRate = o;
    }
    encode(r) {
      const o = this.downSampleAudioFrame(r, this.privActualSampleRate, this.privDesiredSampleRate);
      if (!o)
        return null;
      const i = o.length * 2, a = new ArrayBuffer(i), s = new DataView(a);
      return this.floatTo16BitPCM(s, 0, o), a;
    }
    setString(r, o, i) {
      for (let a = 0; a < i.length; a++)
        r.setUint8(o + a, i.charCodeAt(a));
    }
    floatTo16BitPCM(r, o, i) {
      for (let a = 0; a < i.length; a++, o += 2) {
        const s = Math.max(-1, Math.min(1, i[a]));
        r.setInt16(o, s < 0 ? s * 32768 : s * 32767, !0);
      }
    }
    downSampleAudioFrame(r, o, i) {
      if (!r)
        return null;
      if (i === o || i > o)
        return r;
      const a = o / i, s = Math.round(r.length / a), n = new Float32Array(s);
      let c = 0, u = 0;
      for (; u < s; ) {
        const l = Math.round((u + 1) * a);
        let p = 0, d = 0;
        for (; c < l && c < r.length; )
          p += r[c++], d++;
        n[u++] = p / d;
      }
      return n;
    }
  };
  return Pr.RiffPcmEncoder = e, Pr;
}
var br = {}, wu;
function zC() {
  if (wu) return br;
  wu = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.Stream = void 0;
  const e = /* @__PURE__ */ De(), t = /* @__PURE__ */ Lt(), r = /* @__PURE__ */ ov();
  let o = class {
    constructor(a) {
      this.privIsWriteEnded = !1, this.privIsReadEnded = !1, this.privId = a || (0, t.createNoDashGuid)(), this.privReaderQueue = new r.Queue();
    }
    get isClosed() {
      return this.privIsWriteEnded;
    }
    get isReadEnded() {
      return this.privIsReadEnded;
    }
    get id() {
      return this.privId;
    }
    close() {
      this.privIsWriteEnded || (this.writeStreamChunk({
        buffer: null,
        isEnd: !0,
        timeReceived: Date.now()
      }), this.privIsWriteEnded = !0);
    }
    writeStreamChunk(a) {
      if (this.throwIfClosed(), !this.privReaderQueue.isDisposed())
        try {
          this.privReaderQueue.enqueue(a);
        } catch {
        }
    }
    read() {
      if (this.privIsReadEnded)
        throw new e.InvalidOperationError("Stream read has already finished");
      return this.privReaderQueue.dequeue().then(async (a) => ((a === void 0 || a.isEnd) && await this.privReaderQueue.dispose("End of stream reached"), a));
    }
    readEnded() {
      this.privIsReadEnded || (this.privIsReadEnded = !0, this.privReaderQueue = new r.Queue());
    }
    throwIfClosed() {
      if (this.privIsWriteEnded)
        throw new e.InvalidOperationError("Stream closed");
    }
  };
  return br.Stream = o, br;
}
var Do = {}, Eu;
function uc() {
  return Eu || (Eu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TranslationStatus = void 0, function(t) {
      t[t.Success = 0] = "Success", t[t.Error = 1] = "Error";
    }(e.TranslationStatus || (e.TranslationStatus = {}));
  }(Do)), Do;
}
var wr = {}, Iu;
function LC() {
  if (Iu) return wr;
  Iu = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.ChunkedArrayBufferStream = void 0;
  const e = /* @__PURE__ */ O();
  let t = class extends e.Stream {
    constructor(o, i) {
      super(i), this.privTargetChunkSize = Math.round(o), this.privNextBufferReadyBytes = 0;
    }
    writeStreamChunk(o) {
      if (o.isEnd || this.privNextBufferReadyBytes === 0 && o.buffer.byteLength === this.privTargetChunkSize) {
        super.writeStreamChunk(o);
        return;
      }
      let i = 0;
      for (; i < o.buffer.byteLength; ) {
        this.privNextBufferToWrite === void 0 && (this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize), this.privNextBufferStartTime = o.timeReceived);
        const a = Math.min(o.buffer.byteLength - i, this.privTargetChunkSize - this.privNextBufferReadyBytes), s = new Uint8Array(this.privNextBufferToWrite), n = new Uint8Array(o.buffer.slice(i, a + i));
        s.set(n, this.privNextBufferReadyBytes), this.privNextBufferReadyBytes += a, i += a, this.privNextBufferReadyBytes === this.privTargetChunkSize && (super.writeStreamChunk({
          buffer: this.privNextBufferToWrite,
          isEnd: !1,
          timeReceived: this.privNextBufferStartTime
        }), this.privNextBufferReadyBytes = 0, this.privNextBufferToWrite = void 0);
      }
    }
    close() {
      this.privNextBufferReadyBytes !== 0 && !this.isClosed && super.writeStreamChunk({
        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
        isEnd: !1,
        timeReceived: this.privNextBufferStartTime
      }), super.close();
    }
  };
  return wr.ChunkedArrayBufferStream = t, wr;
}
var No = {}, Au;
function jC() {
  return Au || (Au = 1, Object.defineProperty(No, "__esModule", { value: !0 })), No;
}
var Er = {}, Tu;
function qC() {
  if (Tu) return Er;
  Tu = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.Timeout = void 0;
  let e = class et {
    static load() {
      const r = /* @__PURE__ */ new Map([[0, () => {
      }]]), o = /* @__PURE__ */ new Map(), a = "data:text/javascript;base64," + btoa(`!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id "'.concat(e,'".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error('The given method "'.concat(e.method,'" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`), s = new Worker(a);
      return s.addEventListener("message", ({ data: u }) => {
        if (et.isCallNotification(u)) {
          const { params: { timerId: l } } = u, p = r.get(l);
          if (typeof p == "number") {
            const d = o.get(p);
            if (d === void 0 || d !== l)
              throw new Error("The timer is in an undefined state.");
          } else if (typeof p < "u")
            p(), r.delete(l);
          else
            throw new Error("The timer is in an undefined state.");
        } else if (et.isClearResponse(u)) {
          const { id: l } = u, p = o.get(l);
          if (p === void 0)
            throw new Error("The timer is in an undefined state.");
          o.delete(l), r.delete(p);
        } else {
          const { error: { message: l } } = u;
          throw new Error(l);
        }
      }), {
        clearTimeout: (u) => {
          const l = Math.random();
          o.set(l, u), r.set(u, l), s.postMessage({
            id: l,
            method: "clear",
            params: { timerId: u }
          });
        },
        setTimeout: (u, l) => {
          const p = Math.random();
          return r.set(p, u), s.postMessage({
            id: null,
            method: "set",
            params: {
              delay: l,
              now: performance.now(),
              timerId: p
            }
          }), p;
        }
      };
    }
    static loadWorkerTimers() {
      return () => (et.workerTimers !== null || (et.workerTimers = et.load()), et.workerTimers);
    }
    static isCallNotification(r) {
      return r.method !== void 0 && r.method === "call";
    }
    static isClearResponse(r) {
      return r.error === null && typeof r.id == "number";
    }
  };
  return Er.Timeout = e, e.workerTimers = null, e.clearTimeout = (t) => e.timers().clearTimeout(t), e.setTimeout = (t, r) => e.timers().setTimeout(t, r), e.timers = e.loadWorkerTimers(), Er;
}
var q = {}, _u;
function FC() {
  if (_u) return q;
  _u = 1, Object.defineProperty(q, "__esModule", { value: !0 }), q.OCSPCacheUpdateErrorEvent = q.OCSPResponseRetrievedEvent = q.OCSPCacheFetchErrorEvent = q.OCSPVerificationFailedEvent = q.OCSPCacheHitEvent = q.OCSPCacheEntryNeedsRefreshEvent = q.OCSPCacheEntryExpiredEvent = q.OCSPWSUpgradeStartedEvent = q.OCSPStapleReceivedEvent = q.OCSPCacheUpdateCompleteEvent = q.OCSPDiskCacheStoreEvent = q.OCSPMemoryCacheStoreEvent = q.OCSPCacheUpdateNeededEvent = q.OCSPDiskCacheHitEvent = q.OCSPCacheMissEvent = q.OCSPMemoryCacheHitEvent = q.OCSPEvent = void 0;
  const e = /* @__PURE__ */ Cs();
  class t extends e.PlatformEvent {
    constructor(S, C, b) {
      super(S, C), this.privSignature = b;
    }
  }
  q.OCSPEvent = t;
  class r extends t {
    constructor(S) {
      super("OCSPMemoryCacheHitEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPMemoryCacheHitEvent = r;
  class o extends t {
    constructor(S) {
      super("OCSPCacheMissEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPCacheMissEvent = o;
  class i extends t {
    constructor(S) {
      super("OCSPDiskCacheHitEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPDiskCacheHitEvent = i;
  class a extends t {
    constructor(S) {
      super("OCSPCacheUpdateNeededEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPCacheUpdateNeededEvent = a;
  class s extends t {
    constructor(S) {
      super("OCSPMemoryCacheStoreEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPMemoryCacheStoreEvent = s;
  class n extends t {
    constructor(S) {
      super("OCSPDiskCacheStoreEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPDiskCacheStoreEvent = n;
  class c extends t {
    constructor(S) {
      super("OCSPCacheUpdateCompleteEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPCacheUpdateCompleteEvent = c;
  class u extends t {
    constructor() {
      super("OCSPStapleReceivedEvent", e.EventType.Debug, "");
    }
  }
  q.OCSPStapleReceivedEvent = u;
  class l extends t {
    constructor(S) {
      super("OCSPWSUpgradeStartedEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPWSUpgradeStartedEvent = l;
  class p extends t {
    constructor(S, C) {
      super("OCSPCacheEntryExpiredEvent", e.EventType.Debug, S), this.privExpireTime = C;
    }
  }
  q.OCSPCacheEntryExpiredEvent = p;
  class d extends t {
    constructor(S, C, b) {
      super("OCSPCacheEntryNeedsRefreshEvent", e.EventType.Debug, S), this.privExpireTime = b, this.privStartTime = C;
    }
  }
  q.OCSPCacheEntryNeedsRefreshEvent = d;
  class h extends t {
    constructor(S, C, b) {
      super("OCSPCacheHitEvent", e.EventType.Debug, S), this.privExpireTime = b, this.privExpireTimeString = new Date(b).toLocaleDateString(), this.privStartTime = C, this.privStartTimeString = new Date(C).toLocaleTimeString();
    }
  }
  q.OCSPCacheHitEvent = h;
  class f extends t {
    constructor(S, C) {
      super("OCSPVerificationFailedEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  q.OCSPVerificationFailedEvent = f;
  class g extends t {
    constructor(S, C) {
      super("OCSPCacheFetchErrorEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  q.OCSPCacheFetchErrorEvent = g;
  class m extends t {
    constructor(S) {
      super("OCSPResponseRetrievedEvent", e.EventType.Debug, S);
    }
  }
  q.OCSPResponseRetrievedEvent = m;
  class v extends t {
    constructor(S, C) {
      super("OCSPCacheUpdateErrorEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  return q.OCSPCacheUpdateErrorEvent = v, q;
}
var Ir = {}, ku;
function BC() {
  if (ku) return Ir;
  ku = 1, Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.BackgroundEvent = void 0;
  const e = /* @__PURE__ */ O();
  class t extends e.PlatformEvent {
    constructor(o) {
      super("BackgroundEvent", e.EventType.Error), this.privError = o;
    }
    get error() {
      return this.privError;
    }
  }
  return Ir.BackgroundEvent = t, Ir;
}
var Ou;
function O() {
  return Ou || (Ou = 1, function(e) {
    var t = dt && dt.__createBinding || (Object.create ? function(i, a, s, n) {
      n === void 0 && (n = s), Object.defineProperty(i, n, { enumerable: !0, get: function() {
        return a[s];
      } });
    } : function(i, a, s, n) {
      n === void 0 && (n = s), i[n] = a[s];
    }), r = dt && dt.__exportStar || function(i, a) {
      for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(a, s) && t(a, i, s);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TranslationStatus = void 0, r(/* @__PURE__ */ SC(), e), r(/* @__PURE__ */ CC(), e), r(/* @__PURE__ */ tv(), e), r(/* @__PURE__ */ RC(), e), r(/* @__PURE__ */ PC(), e), r(/* @__PURE__ */ rv(), e), r(/* @__PURE__ */ De(), e), r(/* @__PURE__ */ bC(), e), r(/* @__PURE__ */ nv(), e), r(/* @__PURE__ */ Lt(), e), r(/* @__PURE__ */ wC(), e), r(/* @__PURE__ */ EC(), e), r(/* @__PURE__ */ IC(), e), r(/* @__PURE__ */ AC(), e), r(/* @__PURE__ */ TC(), e), r(/* @__PURE__ */ _C(), e), r(/* @__PURE__ */ kC(), e), r(/* @__PURE__ */ OC(), e), r(/* @__PURE__ */ MC(), e), r(/* @__PURE__ */ DC(), e), r(/* @__PURE__ */ iv(), e), r(/* @__PURE__ */ Cs(), e), r(/* @__PURE__ */ sv(), e), r(/* @__PURE__ */ ov(), e), r(/* @__PURE__ */ NC(), e), r(/* @__PURE__ */ xC(), e), r(/* @__PURE__ */ zC(), e);
    var o = /* @__PURE__ */ uc();
    Object.defineProperty(e, "TranslationStatus", { enumerable: !0, get: function() {
      return o.TranslationStatus;
    } }), r(/* @__PURE__ */ LC(), e), r(/* @__PURE__ */ jC(), e), r(/* @__PURE__ */ qC(), e), r(/* @__PURE__ */ FC(), e), r(/* @__PURE__ */ BC(), e);
  }(dt)), dt;
}
var Ar = {}, Mu;
function pe() {
  if (Mu) return Ar;
  Mu = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.HeaderNames = void 0;
  let e = class {
  };
  return Ar.HeaderNames = e, e.AuthKey = "Ocp-Apim-Subscription-Key", e.Authorization = "Authorization", e.SpIDAuthKey = "Apim-Subscription-Id", e.ConnectionId = "X-ConnectionId", e.ContentType = "Content-Type", e.CustomCommandsAppId = "X-CommandsAppId", e.Path = "Path", e.RequestId = "X-RequestId", e.RequestStreamId = "X-StreamId", e.RequestTimestamp = "X-Timestamp", Ar;
}
var Tr = {}, Du;
function lc() {
  if (Du) return Tr;
  Du = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.AuthInfo = void 0;
  class e {
    constructor(r, o) {
      this.privHeaderName = r, this.privToken = o;
    }
    get headerName() {
      return this.privHeaderName;
    }
    get token() {
      return this.privToken;
    }
  }
  return Tr.AuthInfo = e, Tr;
}
var Nu;
function UC() {
  if (Nu) return rr;
  Nu = 1, Object.defineProperty(rr, "__esModule", { value: !0 }), rr.CognitiveSubscriptionKeyAuthentication = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ pe(), r = /* @__PURE__ */ lc();
  let o = class {
    /**
     * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
     * @constructor
     * @param {string} subscriptionKey - The subscription key
     */
    constructor(a) {
      if (!a)
        throw new e.ArgumentNullError("subscriptionKey");
      this.privAuthInfo = new r.AuthInfo(t.HeaderNames.AuthKey, a);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fetch(a) {
      return Promise.resolve(this.privAuthInfo);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fetchOnExpiry(a) {
      return Promise.resolve(this.privAuthInfo);
    }
  };
  return rr.CognitiveSubscriptionKeyAuthentication = o, rr;
}
var _r = {}, xu;
function $C() {
  if (xu) return _r;
  xu = 1, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.CognitiveTokenAuthentication = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ lc(), r = /* @__PURE__ */ pe();
  let o = class Wa {
    constructor(a, s) {
      if (!a)
        throw new e.ArgumentNullError("fetchCallback");
      if (!s)
        throw new e.ArgumentNullError("fetchOnExpiryCallback");
      this.privFetchCallback = a, this.privFetchOnExpiryCallback = s;
    }
    fetch(a) {
      return this.privFetchCallback(a).then((s) => new t.AuthInfo(r.HeaderNames.Authorization, s === void 0 ? void 0 : Wa.privTokenPrefix + s));
    }
    fetchOnExpiry(a) {
      return this.privFetchOnExpiryCallback(a).then((s) => new t.AuthInfo(r.HeaderNames.Authorization, s === void 0 ? void 0 : Wa.privTokenPrefix + s));
    }
  };
  return _r.CognitiveTokenAuthentication = o, o.privTokenPrefix = "Bearer ", _r;
}
var xo = {}, zu;
function VC() {
  return zu || (zu = 1, Object.defineProperty(xo, "__esModule", { value: !0 })), xo;
}
var zo = {}, Lu;
function WC() {
  return Lu || (Lu = 1, Object.defineProperty(zo, "__esModule", { value: !0 })), zo;
}
var kr = {}, vt = {}, we = {};
const HC = {}, KC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: HC
}, Symbol.toStringTag, { value: "Module" })), xt = /* @__PURE__ */ aC(KC);
var Lo = {}, ju;
function av() {
  return ju || (ju = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LogLevel = void 0;
    const t = /* @__PURE__ */ O();
    Object.defineProperty(e, "LogLevel", { enumerable: !0, get: function() {
      return t.EventType;
    } });
  }(Lo)), Lo;
}
var Or = {}, qu;
function z() {
  if (qu) return Or;
  qu = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.Contracts = void 0;
  let e = class Nt {
    static throwIfNullOrUndefined(r, o) {
      if (r == null)
        throw new Error("throwIfNullOrUndefined:" + o);
    }
    static throwIfNull(r, o) {
      if (r === null)
        throw new Error("throwIfNull:" + o);
    }
    static throwIfNullOrWhitespace(r, o) {
      if (Nt.throwIfNullOrUndefined(r, o), ("" + r).trim().length < 1)
        throw new Error("throwIfNullOrWhitespace:" + o);
    }
    static throwIfNullOrTooLong(r, o, i) {
      if (Nt.throwIfNullOrUndefined(r, o), ("" + r).length > i)
        throw new Error("throwIfNullOrTooLong:" + o + " (more than " + i.toString() + " characters)");
    }
    static throwIfNullOrTooShort(r, o, i) {
      if (Nt.throwIfNullOrUndefined(r, o), ("" + r).length < i)
        throw new Error("throwIfNullOrTooShort:" + o + " (less than " + i.toString() + " characters)");
    }
    static throwIfDisposed(r) {
      if (r)
        throw new Error("the object is already disposed");
    }
    static throwIfArrayEmptyOrWhitespace(r, o) {
      if (Nt.throwIfNullOrUndefined(r, o), r.length === 0)
        throw new Error("throwIfArrayEmptyOrWhitespace:" + o);
      for (const i of r)
        Nt.throwIfNullOrWhitespace(i, o);
    }
    static throwIfFileDoesNotExist(r, o) {
      Nt.throwIfNullOrWhitespace(r, o);
    }
    static throwIfNotUndefined(r, o) {
      if (r !== void 0)
        throw new Error("throwIfNotUndefined:" + o);
    }
  };
  return Or.Contracts = e, Or;
}
var Fu;
function JC() {
  if (Fu) return we;
  Fu = 1;
  var e = we && we.__createBinding || (Object.create ? function(n, c, u, l) {
    l === void 0 && (l = u), Object.defineProperty(n, l, { enumerable: !0, get: function() {
      return c[u];
    } });
  } : function(n, c, u, l) {
    l === void 0 && (l = u), n[l] = c[u];
  }), t = we && we.__setModuleDefault || (Object.create ? function(n, c) {
    Object.defineProperty(n, "default", { enumerable: !0, value: c });
  } : function(n, c) {
    n.default = c;
  }), r = we && we.__importStar || function(n) {
    if (n && n.__esModule) return n;
    var c = {};
    if (n != null) for (var u in n) u !== "default" && Object.prototype.hasOwnProperty.call(n, u) && e(c, n, u);
    return t(c, n), c;
  };
  Object.defineProperty(we, "__esModule", { value: !0 }), we.ConsoleLoggingListener = void 0;
  const o = r(xt), i = /* @__PURE__ */ av(), a = /* @__PURE__ */ z();
  let s = class {
    constructor(c = i.LogLevel.None) {
      this.privLogPath = void 0, this.privEnableConsoleOutput = !0, this.privLogLevelFilter = c;
    }
    set logPath(c) {
      a.Contracts.throwIfNullOrUndefined(o.openSync, `
File System access not available`), this.privLogPath = c;
    }
    set enableConsoleOutput(c) {
      this.privEnableConsoleOutput = c;
    }
    onEvent(c) {
      if (c.eventType >= this.privLogLevelFilter) {
        const u = this.toString(c);
        if (this.logCallback && this.logCallback(u), this.privLogPath && o.writeFileSync(this.privLogPath, u + `
`, { flag: "a+" }), this.privEnableConsoleOutput)
          switch (c.eventType) {
            case i.LogLevel.Debug:
              console.debug(u);
              break;
            case i.LogLevel.Info:
              console.info(u);
              break;
            case i.LogLevel.Warning:
              console.warn(u);
              break;
            case i.LogLevel.Error:
              console.error(u);
              break;
            default:
              console.log(u);
              break;
          }
      }
    }
    toString(c) {
      const u = [
        `${c.eventTime}`,
        `${c.name}`
      ], l = c;
      for (const p in l)
        if (p && c.hasOwnProperty(p) && p !== "eventTime" && p !== "eventType" && p !== "eventId" && p !== "name" && p !== "constructor") {
          const d = l[p];
          let h = "<NULL>";
          d != null && (typeof d == "number" || typeof d == "string" ? h = d.toString() : h = JSON.stringify(d)), u.push(`${p}: ${h}`);
        }
      return u.join(" | ");
    }
  };
  return we.ConsoleLoggingListener = s, we;
}
var jo = {}, Bu;
function GC() {
  return Bu || (Bu = 1, Object.defineProperty(jo, "__esModule", { value: !0 })), jo;
}
var qo = {}, Fo = {}, Uu;
function jt() {
  return Uu || (Uu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AudioStreamFormatImpl = e.AudioStreamFormat = e.AudioFormatTag = void 0;
    var t;
    (function(i) {
      i[i.PCM = 1] = "PCM", i[i.MuLaw = 2] = "MuLaw", i[i.Siren = 3] = "Siren", i[i.MP3 = 4] = "MP3", i[i.SILKSkype = 5] = "SILKSkype", i[i.OGG_OPUS = 6] = "OGG_OPUS", i[i.WEBM_OPUS = 7] = "WEBM_OPUS", i[i.ALaw = 8] = "ALaw", i[i.FLAC = 9] = "FLAC", i[i.OPUS = 10] = "OPUS", i[i.AMR_WB = 11] = "AMR_WB", i[i.G722 = 12] = "G722";
    })(t = e.AudioFormatTag || (e.AudioFormatTag = {}));
    class r {
      /**
       * Creates an audio stream format object representing the default audio stream
       * format (16KHz 16bit mono PCM).
       * @member AudioStreamFormat.getDefaultInputFormat
       * @function
       * @public
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getDefaultInputFormat() {
        return o.getDefaultInputFormat();
      }
      /**
       * Creates an audio stream format object with the specified format characteristics.
       * @member AudioStreamFormat.getWaveFormat
       * @function
       * @public
       * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
       * @param {number} bitsPerSample - Bits per sample, typically 16.
       * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
       * uses one channel and stereo data uses two channels.
       * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getWaveFormat(a, s, n, c) {
        return new o(a, s, n, c);
      }
      /**
       * Creates an audio stream format object with the specified pcm waveformat characteristics.
       * @member AudioStreamFormat.getWaveFormatPCM
       * @function
       * @public
       * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
       * @param {number} bitsPerSample - Bits per sample, typically 16.
       * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
       * uses one channel and stereo data uses two channels.
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getWaveFormatPCM(a, s, n) {
        return new o(a, s, n);
      }
    }
    e.AudioStreamFormat = r;
    class o extends r {
      /**
       * Creates an instance with the given values.
       * @constructor
       * @param {number} samplesPerSec - Samples per second.
       * @param {number} bitsPerSample - Bits per sample.
       * @param {number} channels - Number of channels.
       * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
       */
      constructor(a = 16e3, s = 16, n = 1, c = t.PCM) {
        super();
        let u = !0;
        switch (c) {
          case t.PCM:
            this.formatTag = 1;
            break;
          case t.ALaw:
            this.formatTag = 6;
            break;
          case t.MuLaw:
            this.formatTag = 7;
            break;
          default:
            u = !1;
        }
        if (this.bitsPerSample = s, this.samplesPerSec = a, this.channels = n, this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8), this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8), u) {
          this.privHeader = new ArrayBuffer(44);
          const l = new DataView(this.privHeader);
          this.setString(l, 0, "RIFF"), l.setUint32(4, 0, !0), this.setString(l, 8, "WAVEfmt "), l.setUint32(16, 16, !0), l.setUint16(20, this.formatTag, !0), l.setUint16(22, this.channels, !0), l.setUint32(24, this.samplesPerSec, !0), l.setUint32(28, this.avgBytesPerSec, !0), l.setUint16(32, this.channels * (this.bitsPerSample / 8), !0), l.setUint16(34, this.bitsPerSample, !0), this.setString(l, 36, "data"), l.setUint32(40, 0, !0);
        }
      }
      /**
       * Retrieves the default input format.
       * @member AudioStreamFormatImpl.getDefaultInputFormat
       * @function
       * @public
       * @returns {AudioStreamFormatImpl} The default input format.
       */
      static getDefaultInputFormat() {
        return new o();
      }
      /**
       * Creates an audio context appropriate to current browser
       * @member AudioStreamFormatImpl.getAudioContext
       * @function
       * @public
       * @returns {AudioContext} An audio context instance
       */
      /* eslint-disable */
      static getAudioContext(a) {
        const s = window.AudioContext || window.webkitAudioContext || !1;
        if (s)
          return a !== void 0 && navigator.mediaDevices.getSupportedConstraints().sampleRate ? new s({ sampleRate: a }) : new s();
        throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
      }
      /* eslint-enable */
      /**
       * Closes the configuration object.
       * @member AudioStreamFormatImpl.prototype.close
       * @function
       * @public
       */
      close() {
      }
      get header() {
        return this.privHeader;
      }
      setString(a, s, n) {
        for (let c = 0; c < n.length; c++)
          a.setUint8(s + c, n.charCodeAt(c));
      }
    }
    e.AudioStreamFormatImpl = o;
  }(Fo)), Fo;
}
var $u;
function QC() {
  return $u || ($u = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MicAudioSource = e.AudioWorkletSourceURLPropertyName = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ O(), o = /* @__PURE__ */ jt();
    e.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
    class i {
      constructor(s, n, c, u) {
        this.privRecorder = s, this.deviceId = n, this.privStreams = {}, this.privOutputChunkSize = i.AUDIOFORMAT.avgBytesPerSec / 10, this.privId = c || (0, r.createNoDashGuid)(), this.privEvents = new r.EventSource(), this.privMediaStream = u || null, this.privIsClosing = !1;
      }
      get format() {
        return Promise.resolve(i.AUDIOFORMAT);
      }
      turnOn() {
        if (this.privInitializeDeferral)
          return this.privInitializeDeferral.promise;
        this.privInitializeDeferral = new r.Deferred();
        try {
          this.createAudioContext();
        } catch (c) {
          if (c instanceof Error) {
            const u = c;
            this.privInitializeDeferral.reject(u.name + ": " + u.message);
          } else
            this.privInitializeDeferral.reject(c);
          return this.privInitializeDeferral.promise;
        }
        const s = window.navigator;
        let n = (
          // eslint-disable-next-line
          s.getUserMedia || s.webkitGetUserMedia || s.mozGetUserMedia || s.msGetUserMedia
        );
        if (s.mediaDevices && (n = (c, u, l) => {
          s.mediaDevices.getUserMedia(c).then(u).catch(l);
        }), n) {
          const c = () => {
            this.onEvent(new r.AudioSourceInitializingEvent(this.privId)), this.privMediaStream && this.privMediaStream.active ? (this.onEvent(new r.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve()) : n({ audio: this.deviceId ? { deviceId: this.deviceId } : !0, video: !1 }, (u) => {
              this.privMediaStream = u, this.onEvent(new r.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve();
            }, (u) => {
              const l = `Error occurred during microphone initialization: ${u}`;
              this.privInitializeDeferral.reject(l), this.onEvent(new r.AudioSourceErrorEvent(this.privId, l));
            });
          };
          this.privContext.state === "suspended" ? this.privContext.resume().then(c).catch((u) => {
            this.privInitializeDeferral.reject(`Failed to initialize audio context: ${u}`);
          }) : c();
        } else {
          const c = "Browser does not support getUserMedia.";
          this.privInitializeDeferral.reject(c), this.onEvent(new r.AudioSourceErrorEvent(c, ""));
        }
        return this.privInitializeDeferral.promise;
      }
      id() {
        return this.privId;
      }
      attach(s) {
        return this.onEvent(new r.AudioStreamNodeAttachingEvent(this.privId, s)), this.listen(s).then((n) => (this.onEvent(new r.AudioStreamNodeAttachedEvent(this.privId, s)), {
          detach: async () => (n.readEnded(), delete this.privStreams[s], this.onEvent(new r.AudioStreamNodeDetachedEvent(this.privId, s)), this.turnOff()),
          id: () => s,
          read: () => n.read()
        }));
      }
      detach(s) {
        s && this.privStreams[s] && (this.privStreams[s].close(), delete this.privStreams[s], this.onEvent(new r.AudioStreamNodeDetachedEvent(this.privId, s)));
      }
      async turnOff() {
        for (const s in this.privStreams)
          if (s) {
            const n = this.privStreams[s];
            n && n.close();
          }
        this.onEvent(new r.AudioSourceOffEvent(this.privId)), this.privInitializeDeferral && (await this.privInitializeDeferral, this.privInitializeDeferral = null), await this.destroyAudioContext();
      }
      get events() {
        return this.privEvents;
      }
      get deviceInfo() {
        return this.getMicrophoneLabel().then((s) => ({
          bitspersample: i.AUDIOFORMAT.bitsPerSample,
          channelcount: i.AUDIOFORMAT.channels,
          connectivity: t.connectivity.Unknown,
          manufacturer: "Speech SDK",
          model: s,
          samplerate: i.AUDIOFORMAT.samplesPerSec,
          type: t.type.Microphones
        }));
      }
      setProperty(s, n) {
        if (s === e.AudioWorkletSourceURLPropertyName)
          this.privRecorder.setWorkletUrl(n);
        else
          throw new Error("Property '" + s + "' is not supported on Microphone.");
      }
      getMicrophoneLabel() {
        const s = "microphone";
        if (this.privMicrophoneLabel !== void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        if (this.privMediaStream === void 0 || !this.privMediaStream.active)
          return Promise.resolve(s);
        this.privMicrophoneLabel = s;
        const n = this.privMediaStream.getTracks()[0].getSettings().deviceId;
        if (n === void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        const c = new r.Deferred();
        return navigator.mediaDevices.enumerateDevices().then((u) => {
          for (const l of u)
            if (l.deviceId === n) {
              this.privMicrophoneLabel = l.label;
              break;
            }
          c.resolve(this.privMicrophoneLabel);
        }, () => c.resolve(this.privMicrophoneLabel)), c.promise;
      }
      async listen(s) {
        await this.turnOn();
        const n = new r.ChunkedArrayBufferStream(this.privOutputChunkSize, s);
        this.privStreams[s] = n;
        try {
          this.privRecorder.record(this.privContext, this.privMediaStream, n);
        } catch (u) {
          throw this.onEvent(new r.AudioStreamNodeErrorEvent(this.privId, s, u)), u;
        }
        return n;
      }
      onEvent(s) {
        this.privEvents.onEvent(s), r.Events.instance.onEvent(s);
      }
      createAudioContext() {
        this.privContext || (this.privContext = o.AudioStreamFormatImpl.getAudioContext(i.AUDIOFORMAT.samplesPerSec));
      }
      async destroyAudioContext() {
        if (!this.privContext)
          return;
        this.privRecorder.releaseMediaResources(this.privContext);
        let s = !1;
        "close" in this.privContext && (s = !0), s ? this.privIsClosing || (this.privIsClosing = !0, await this.privContext.close(), this.privContext = null, this.privIsClosing = !1) : this.privContext !== null && this.privContext.state === "running" && await this.privContext.suspend();
      }
    }
    e.MicAudioSource = i, i.AUDIOFORMAT = o.AudioStreamFormat.getDefaultInputFormat();
  }(qo)), qo;
}
var Mr = {}, Vu;
function YC() {
  if (Vu) return Mr;
  Vu = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.FileAudioSource = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ jt();
  let o = class {
    constructor(a, s, n) {
      this.privStreams = {}, this.privHeaderEnd = 44, this.privId = n || (0, t.createNoDashGuid)(), this.privEvents = new t.EventSource(), this.privSource = a, typeof window < "u" && typeof Blob < "u" && this.privSource instanceof Blob ? this.privFilename = a.name : this.privFilename = s || "unknown.wav", this.privAudioFormatPromise = this.readHeader();
    }
    get format() {
      return this.privAudioFormatPromise;
    }
    turnOn() {
      if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
        const a = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
        return this.onEvent(new t.AudioSourceErrorEvent(a, "")), Promise.reject(a);
      }
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    id() {
      return this.privId;
    }
    async attach(a) {
      this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, a));
      const s = await this.upload(a);
      return this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, a)), Promise.resolve({
        detach: async () => {
          s.readEnded(), delete this.privStreams[a], this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, a)), await this.turnOff();
        },
        id: () => a,
        read: () => s.read()
      });
    }
    detach(a) {
      a && this.privStreams[a] && (this.privStreams[a].close(), delete this.privStreams[a], this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, a)));
    }
    turnOff() {
      for (const a in this.privStreams)
        if (a) {
          const s = this.privStreams[a];
          s && !s.isClosed && s.close();
        }
      return this.onEvent(new t.AudioSourceOffEvent(this.privId)), Promise.resolve();
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return this.privAudioFormatPromise.then((a) => Promise.resolve({
        bitspersample: a.bitsPerSample,
        channelcount: a.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "File",
        samplerate: a.samplesPerSec,
        type: e.type.File
      }));
    }
    readHeader() {
      const s = this.privSource.slice(0, 4296), n = new t.Deferred(), c = (u) => {
        const l = new DataView(u), p = (v) => String.fromCharCode(l.getUint8(v), l.getUint8(v + 1), l.getUint8(v + 2), l.getUint8(v + 3));
        if (p(0) !== "RIFF") {
          n.reject("Invalid WAV header in file, RIFF was not found");
          return;
        }
        if (p(8) !== "WAVE" || p(12) !== "fmt ") {
          n.reject("Invalid WAV header in file, WAVEfmt was not found");
          return;
        }
        const d = l.getInt32(16, !0), h = l.getUint16(22, !0), f = l.getUint32(24, !0), g = l.getUint16(34, !0);
        let m = 36 + Math.max(d - 16, 0);
        for (; p(m) !== "data"; m += 2)
          if (m > 4288) {
            n.reject("Invalid WAV header in file, data block was not found");
            return;
          }
        this.privHeaderEnd = m + 8, n.resolve(r.AudioStreamFormat.getWaveFormatPCM(f, g, h));
      };
      if (typeof window < "u" && typeof Blob < "u" && s instanceof Blob) {
        const u = new FileReader();
        u.onload = (l) => {
          const p = l.target.result;
          c(p);
        }, u.readAsArrayBuffer(s);
      } else {
        const u = s;
        c(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
      }
      return n.promise;
    }
    async upload(a) {
      const s = (n) => {
        const c = `Error occurred while processing '${this.privFilename}'. ${n}`;
        throw this.onEvent(new t.AudioStreamNodeErrorEvent(this.privId, a, c)), new Error(c);
      };
      try {
        await this.turnOn();
        const n = await this.privAudioFormatPromise, c = new t.ChunkedArrayBufferStream(n.avgBytesPerSec / 10, a);
        this.privStreams[a] = c;
        const u = this.privSource.slice(this.privHeaderEnd), l = (p) => {
          c.isClosed || (c.writeStreamChunk({
            buffer: p,
            isEnd: !1,
            timeReceived: Date.now()
          }), c.close());
        };
        if (typeof window < "u" && typeof Blob < "u" && u instanceof Blob) {
          const p = new FileReader();
          p.onerror = (d) => s(d.toString()), p.onload = (d) => {
            const h = d.target.result;
            l(h);
          }, p.readAsArrayBuffer(u);
        } else {
          const p = u;
          l(p.buffer.slice(p.byteOffset, p.byteOffset + p.byteLength));
        }
        return c;
      } catch (n) {
        s(n);
      }
    }
    onEvent(a) {
      this.privEvents.onEvent(a), t.Events.instance.onEvent(a);
    }
  };
  return Mr.FileAudioSource = o, Mr;
}
var Dr = {}, Wu;
function ZC() {
  if (Wu) return Dr;
  Wu = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.PcmRecorder = void 0;
  const e = /* @__PURE__ */ O();
  class t {
    constructor(o) {
      this.privStopInputOnRelease = o;
    }
    record(o, i, a) {
      const n = new e.RiffPcmEncoder(o.sampleRate, 16e3), c = o.createMediaStreamSource(i), u = () => {
        const p = (() => {
          let d = 0;
          try {
            return o.createScriptProcessor(d, 1, 1);
          } catch {
            d = 2048;
            let f = o.sampleRate;
            for (; d < 16384 && f >= 32e3; )
              d <<= 1, f >>= 1;
            return o.createScriptProcessor(d, 1, 1);
          }
        })();
        p.onaudioprocess = (d) => {
          const h = d.inputBuffer.getChannelData(0);
          if (a && !a.isClosed) {
            const f = n.encode(h);
            f && a.writeStreamChunk({
              buffer: f,
              isEnd: !1,
              timeReceived: Date.now()
            });
          }
        }, c.connect(p), p.connect(o.destination), this.privMediaResources = {
          scriptProcessorNode: p,
          source: c,
          stream: i
        };
      }, l = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === "ignore";
      if (o.audioWorklet && !l) {
        if (!this.privSpeechProcessorScript) {
          const p = `class SP extends AudioWorkletProcessor {
                    constructor(options) {
                      super(options);
                    }
                    process(inputs, outputs) {
                      const input = inputs[0];
                      const output = [];
                      for (let channel = 0; channel < input.length; channel += 1) {
                        output[channel] = input[channel];
                      }
                      this.port.postMessage(output[0]);
                      return true;
                    }
                  }
                  registerProcessor('speech-processor', SP);`, d = new Blob([p], { type: "application/javascript; charset=utf-8" });
          this.privSpeechProcessorScript = URL.createObjectURL(d);
        }
        o.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {
          const p = new AudioWorkletNode(o, "speech-processor");
          p.port.onmessage = (d) => {
            const h = d.data;
            if (a && !a.isClosed) {
              const f = n.encode(h);
              f && a.writeStreamChunk({
                buffer: f,
                isEnd: !1,
                timeReceived: Date.now()
              });
            }
          }, c.connect(p), p.connect(o.destination), this.privMediaResources = {
            scriptProcessorNode: p,
            source: c,
            stream: i
          };
        }).catch(() => {
          u();
        });
      } else
        try {
          u();
        } catch (p) {
          throw new Error(`Unable to start audio worklet node for PCMRecorder: ${p}`);
        }
    }
    releaseMediaResources(o) {
      this.privMediaResources && (this.privMediaResources.scriptProcessorNode && (this.privMediaResources.scriptProcessorNode.disconnect(o.destination), this.privMediaResources.scriptProcessorNode = null), this.privMediaResources.source && (this.privMediaResources.source.disconnect(), this.privStopInputOnRelease && this.privMediaResources.stream.getTracks().forEach((i) => i.stop()), this.privMediaResources.source = null));
    }
    setWorkletUrl(o) {
      this.privSpeechProcessorScript = o;
    }
  }
  return Dr.PcmRecorder = t, Dr;
}
var Nr = {}, ge = {}, Hu;
function cv() {
  if (Hu) return ge;
  Hu = 1;
  var e = ge && ge.__createBinding || (Object.create ? function(d, h, f, g) {
    g === void 0 && (g = f), Object.defineProperty(d, g, { enumerable: !0, get: function() {
      return h[f];
    } });
  } : function(d, h, f, g) {
    g === void 0 && (g = f), d[g] = h[f];
  }), t = ge && ge.__setModuleDefault || (Object.create ? function(d, h) {
    Object.defineProperty(d, "default", { enumerable: !0, value: h });
  } : function(d, h) {
    d.default = h;
  }), r = ge && ge.__importStar || function(d) {
    if (d && d.__esModule) return d;
    var h = {};
    if (d != null) for (var f in d) f !== "default" && Object.prototype.hasOwnProperty.call(d, f) && e(h, d, f);
    return t(h, d), h;
  }, o = ge && ge.__importDefault || function(d) {
    return d && d.__esModule ? d : { default: d };
  };
  Object.defineProperty(ge, "__esModule", { value: !0 }), ge.WebsocketMessageAdapter = void 0;
  const i = r(xt), a = r(xt), s = o(xt), n = o(xt), c = o(xt), u = /* @__PURE__ */ pe(), l = /* @__PURE__ */ O();
  let p = class Ha {
    constructor(h, f, g, m, v, y) {
      if (!h)
        throw new l.ArgumentNullError("uri");
      if (!g)
        throw new l.ArgumentNullError("messageFormatter");
      this.proxyInfo = m, this.privConnectionEvents = new l.EventSource(), this.privConnectionId = f, this.privMessageFormatter = g, this.privConnectionState = l.ConnectionState.None, this.privUri = h, this.privHeaders = v, this.privEnableCompression = y, this.privHeaders[u.HeaderNames.ConnectionId] = this.privConnectionId, this.privHeaders.connectionId = this.privConnectionId, this.privLastErrorReceived = "";
    }
    get state() {
      return this.privConnectionState;
    }
    open() {
      if (this.privConnectionState === l.ConnectionState.Disconnected)
        return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
      if (this.privConnectionEstablishDeferral)
        return this.privConnectionEstablishDeferral.promise;
      this.privConnectionEstablishDeferral = new l.Deferred(), this.privCertificateValidatedDeferral = new l.Deferred(), this.privConnectionState = l.ConnectionState.Connecting;
      try {
        if (typeof WebSocket < "u" && !Ha.forceNpmWebSocket)
          this.privCertificateValidatedDeferral.resolve(), this.privWebsocketClient = new WebSocket(this.privUri);
        else {
          let f = new URL(this.privUri).protocol;
          f?.toLocaleLowerCase() === "wss:" ? f = "https:" : f?.toLocaleLowerCase() === "ws:" && (f = "http:");
          const g = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression, followRedirects: f.toLocaleLowerCase() === "https:" };
          this.privCertificateValidatedDeferral.resolve(), g.agent = this.getAgent(), g.agent.protocol = f, this.privWebsocketClient = new c.default(this.privUri, g), this.privWebsocketClient.on("redirect", (m) => {
            const v = new l.ConnectionRedirectEvent(this.privConnectionId, m, this.privUri, `Getting redirect URL from endpoint ${this.privUri} with redirect URL '${m}'`);
            l.Events.instance.onEvent(v);
          });
        }
        this.privWebsocketClient.binaryType = "arraybuffer", this.privReceivingMessageQueue = new l.Queue(), this.privDisconnectDeferral = new l.Deferred(), this.privSendMessageQueue = new l.Queue(), this.processSendQueue().catch((h) => {
          l.Events.instance.onEvent(new l.BackgroundEvent(h));
        });
      } catch (h) {
        return this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(500, h)), this.privConnectionEstablishDeferral.promise;
      }
      return this.onEvent(new l.ConnectionStartEvent(this.privConnectionId, this.privUri)), this.privWebsocketClient.onopen = () => {
        this.privCertificateValidatedDeferral.promise.then(() => {
          this.privConnectionState = l.ConnectionState.Connected, this.onEvent(new l.ConnectionEstablishedEvent(this.privConnectionId)), this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(200, ""));
        }, (h) => {
          this.privConnectionEstablishDeferral.reject(h);
        });
      }, this.privWebsocketClient.onerror = (h) => {
        this.onEvent(new l.ConnectionErrorEvent(this.privConnectionId, h.message, h.type)), this.privLastErrorReceived = h.message;
      }, this.privWebsocketClient.onclose = (h) => {
        this.privConnectionState === l.ConnectionState.Connecting ? (this.privConnectionState = l.ConnectionState.Disconnected, this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(h.code, h.reason + " " + this.privLastErrorReceived))) : (this.privConnectionState = l.ConnectionState.Disconnected, this.privWebsocketClient = null, this.onEvent(new l.ConnectionClosedEvent(this.privConnectionId, h.code, h.reason))), this.onClose(h.code, h.reason).catch((f) => {
          l.Events.instance.onEvent(new l.BackgroundEvent(f));
        });
      }, this.privWebsocketClient.onmessage = (h) => {
        const f = (/* @__PURE__ */ new Date()).toISOString();
        if (this.privConnectionState === l.ConnectionState.Connected) {
          const g = new l.Deferred();
          if (this.privReceivingMessageQueue.enqueueFromPromise(g.promise), h.data instanceof ArrayBuffer) {
            const m = new l.RawWebsocketMessage(l.MessageType.Binary, h.data);
            this.privMessageFormatter.toConnectionMessage(m).then((v) => {
              this.onEvent(new l.ConnectionMessageReceivedEvent(this.privConnectionId, f, v)), g.resolve(v);
            }, (v) => {
              g.reject(`Invalid binary message format. Error: ${v}`);
            });
          } else {
            const m = new l.RawWebsocketMessage(l.MessageType.Text, h.data);
            this.privMessageFormatter.toConnectionMessage(m).then((v) => {
              this.onEvent(new l.ConnectionMessageReceivedEvent(this.privConnectionId, f, v)), g.resolve(v);
            }, (v) => {
              g.reject(`Invalid text message format. Error: ${v}`);
            });
          }
        }
      }, this.privConnectionEstablishDeferral.promise;
    }
    send(h) {
      if (this.privConnectionState !== l.ConnectionState.Connected)
        return Promise.reject(`Cannot send on connection that is in ${l.ConnectionState[this.privConnectionState]} state`);
      const f = new l.Deferred(), g = new l.Deferred();
      return this.privSendMessageQueue.enqueueFromPromise(g.promise), this.privMessageFormatter.fromConnectionMessage(h).then((m) => {
        g.resolve({
          Message: h,
          RawWebsocketMessage: m,
          sendStatusDeferral: f
        });
      }, (m) => {
        g.reject(`Error formatting the message. ${m}`);
      }), f.promise;
    }
    read() {
      return this.privConnectionState !== l.ConnectionState.Connected ? Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`) : this.privReceivingMessageQueue.dequeue();
    }
    close(h) {
      if (this.privWebsocketClient)
        this.privConnectionState !== l.ConnectionState.Disconnected && this.privWebsocketClient.close(1e3, h || "Normal closure by client");
      else
        return Promise.resolve();
      return this.privDisconnectDeferral.promise;
    }
    get events() {
      return this.privConnectionEvents;
    }
    sendRawMessage(h) {
      try {
        if (!h)
          return Promise.resolve();
        if (this.onEvent(new l.ConnectionMessageSentEvent(this.privConnectionId, (/* @__PURE__ */ new Date()).toISOString(), h.Message)), this.isWebsocketOpen)
          this.privWebsocketClient.send(h.RawWebsocketMessage.payload);
        else
          return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + h.Message.id + " " + new Error().stack);
        return Promise.resolve();
      } catch (f) {
        return Promise.reject(`websocket send error: ${f}`);
      }
    }
    async onClose(h, f) {
      const g = `Connection closed. ${h}: ${f}`;
      this.privConnectionState = l.ConnectionState.Disconnected, this.privDisconnectDeferral.resolve(), await this.privReceivingMessageQueue.drainAndDispose(() => {
      }, g), await this.privSendMessageQueue.drainAndDispose((m) => {
        m.sendStatusDeferral.reject(g);
      }, g);
    }
    async processSendQueue() {
      for (; ; ) {
        const f = await this.privSendMessageQueue.dequeue();
        if (!f)
          return;
        try {
          await this.sendRawMessage(f), f.sendStatusDeferral.resolve();
        } catch (g) {
          f.sendStatusDeferral.reject(g);
        }
      }
    }
    onEvent(h) {
      this.privConnectionEvents.onEvent(h), l.Events.instance.onEvent(h);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAgent() {
      const h = new s.default.Agent(this.createConnection);
      return this.proxyInfo !== void 0 && this.proxyInfo.HostName !== void 0 && this.proxyInfo.Port > 0 && (h.proxyInfo = this.proxyInfo), h;
    }
    static GetProxyAgent(h) {
      const f = {
        host: h.HostName,
        port: h.Port
      };
      return h.UserName ? f.headers = {
        "Proxy-Authentication": "Basic " + new Buffer(`${h.UserName}:${h.Password === void 0 ? "" : h.Password}`).toString("base64")
      } : f.headers = {}, f.headers.requestOCSP = "true", new n.default(f);
    }
    createConnection(h, f) {
      let g;
      if (f = {
        ...f,
        requestOCSP: !0,
        servername: f.host
      }, this.proxyInfo) {
        const v = Ha.GetProxyAgent(this.proxyInfo);
        g = new Promise((y, S) => {
          v.callback(h, f, (C, b) => {
            C ? S(C) : y(b);
          });
        });
      } else
        f.secureEndpoint ? g = Promise.resolve(a.connect(f)) : g = Promise.resolve(i.connect(f));
      return g;
    }
    get isWebsocketOpen() {
      return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
    }
  };
  return ge.WebsocketMessageAdapter = p, p.forceNpmWebSocket = !1, ge;
}
var Ku;
function XC() {
  if (Ku) return Nr;
  Ku = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.WebsocketConnection = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ cv();
  let r = class {
    constructor(i, a, s, n, c, u = !1, l) {
      if (this.privIsDisposed = !1, !i)
        throw new e.ArgumentNullError("uri");
      if (!n)
        throw new e.ArgumentNullError("messageFormatter");
      this.privMessageFormatter = n;
      let p = "", d = 0;
      if (a) {
        for (const h in a)
          if (h) {
            p += d === 0 && i.indexOf("?") === -1 ? "?" : "&";
            const f = encodeURIComponent(h);
            p += f;
            let g = a[h];
            g && (g = encodeURIComponent(g), p += `=${g}`), d++;
          }
      }
      if (s) {
        for (const h in s)
          if (h) {
            p += d === 0 && i.indexOf("?") === -1 ? "?" : "&";
            const f = encodeURIComponent(s[h]);
            p += `${h}=${f}`, d++;
          }
      }
      this.privUri = i + p, this.privId = l || (0, e.createNoDashGuid)(), this.privConnectionMessageAdapter = new t.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, c, s, u);
    }
    async dispose() {
      this.privIsDisposed = !0, this.privConnectionMessageAdapter && await this.privConnectionMessageAdapter.close();
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    get id() {
      return this.privId;
    }
    get uri() {
      return this.privUri;
    }
    state() {
      return this.privConnectionMessageAdapter.state;
    }
    open() {
      return this.privConnectionMessageAdapter.open();
    }
    send(i) {
      return this.privConnectionMessageAdapter.send(i);
    }
    read() {
      return this.privConnectionMessageAdapter.read();
    }
    get events() {
      return this.privConnectionMessageAdapter.events;
    }
  };
  return Nr.WebsocketConnection = r, Nr;
}
var xr = {}, Ju;
function eR() {
  if (Ju) return xr;
  Ju = 1, Object.defineProperty(xr, "__esModule", { value: !0 }), xr.ReplayableAudioNode = void 0;
  let e = class {
    constructor(o, i) {
      this.privBuffers = [], this.privReplayOffset = 0, this.privLastShrinkOffset = 0, this.privBufferStartOffset = 0, this.privBufferSerial = 0, this.privBufferedBytes = 0, this.privReplay = !1, this.privLastChunkAcquiredTime = 0, this.privAudioNode = o, this.privBytesPerSecond = i;
    }
    id() {
      return this.privAudioNode.id();
    }
    // Reads and returns the next chunk of audio buffer.
    // If replay of existing buffers are needed, read() will first seek and replay
    // existing content, and upoin completion it will read new content from the underlying
    // audio node, saving that content into the replayable buffers.
    read() {
      if (this.privReplay && this.privBuffers.length !== 0) {
        const o = this.privReplayOffset - this.privBufferStartOffset;
        let i = Math.round(o * this.privBytesPerSecond * 1e-7);
        i % 2 !== 0 && i++;
        let a = 0;
        for (; a < this.privBuffers.length && i >= this.privBuffers[a].chunk.buffer.byteLength; )
          i -= this.privBuffers[a++].chunk.buffer.byteLength;
        if (a < this.privBuffers.length) {
          const s = this.privBuffers[a].chunk.buffer.slice(i);
          return this.privReplayOffset += s.byteLength / this.privBytesPerSecond * 1e7, a === this.privBuffers.length - 1 && (this.privReplay = !1), Promise.resolve({
            buffer: s,
            isEnd: !1,
            timeReceived: this.privBuffers[a].chunk.timeReceived
          });
        }
      }
      return this.privAudioNode.read().then((o) => (o && o.buffer && this.privBuffers && (this.privBuffers.push(new t(o, this.privBufferSerial++, this.privBufferedBytes)), this.privBufferedBytes += o.buffer.byteLength), o));
    }
    detach() {
      return this.privBuffers = void 0, this.privAudioNode.detach();
    }
    replay() {
      this.privBuffers && this.privBuffers.length !== 0 && (this.privReplay = !0, this.privReplayOffset = this.privLastShrinkOffset);
    }
    // Shrinks the existing audio buffers to start at the new offset, or at the
    // beginning of the buffer closest to the requested offset.
    // A replay request will start from the last shrink point.
    shrinkBuffers(o) {
      if (this.privBuffers === void 0 || this.privBuffers.length === 0)
        return;
      this.privLastShrinkOffset = o;
      const i = o - this.privBufferStartOffset;
      let a = Math.round(i * this.privBytesPerSecond * 1e-7), s = 0;
      for (; s < this.privBuffers.length && a >= this.privBuffers[s].chunk.buffer.byteLength; )
        a -= this.privBuffers[s++].chunk.buffer.byteLength;
      this.privBufferStartOffset = Math.round(o - a / this.privBytesPerSecond * 1e7), this.privBuffers = this.privBuffers.slice(s);
    }
    // Finds the time a buffer of audio was first seen by offset.
    findTimeAtOffset(o) {
      if (o < this.privBufferStartOffset || this.privBuffers === void 0)
        return 0;
      for (const i of this.privBuffers) {
        const a = i.byteOffset / this.privBytesPerSecond * 1e7, s = a + i.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
        if (o >= a && o <= s)
          return i.chunk.timeReceived;
      }
      return 0;
    }
  };
  xr.ReplayableAudioNode = e;
  class t {
    constructor(o, i, a) {
      this.chunk = o, this.serial = i, this.byteOffset = a;
    }
  }
  return xr;
}
var zr = {}, Bo = {}, qe = {}, Ee = {}, Gu;
function uv() {
  if (Gu) return Ee;
  Gu = 1;
  var e = Ee && Ee.__createBinding || (Object.create ? function(s, n, c, u) {
    u === void 0 && (u = c), Object.defineProperty(s, u, { enumerable: !0, get: function() {
      return n[c];
    } });
  } : function(s, n, c, u) {
    u === void 0 && (u = c), s[u] = n[c];
  }), t = Ee && Ee.__setModuleDefault || (Object.create ? function(s, n) {
    Object.defineProperty(s, "default", { enumerable: !0, value: n });
  } : function(s, n) {
    s.default = n;
  }), r = Ee && Ee.__importStar || function(s) {
    if (s && s.__esModule) return s;
    var n = {};
    if (s != null) for (var c in s) c !== "default" && Object.prototype.hasOwnProperty.call(s, c) && e(n, s, c);
    return t(n, s), n;
  };
  Object.defineProperty(Ee, "__esModule", { value: !0 }), Ee.AudioFileWriter = void 0;
  const o = r(xt), i = /* @__PURE__ */ z();
  let a = class {
    constructor(n) {
      i.Contracts.throwIfNullOrUndefined(o.openSync, `
File System access not available, please use Push or PullAudioOutputStream`), this.privFd = o.openSync(n, "w");
    }
    set format(n) {
      i.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set"), this.privAudioFormat = n;
      let c = 0;
      this.privAudioFormat.hasHeader && (c = this.privAudioFormat.header.byteLength), this.privFd !== void 0 && (this.privWriteStream = o.createWriteStream("", { fd: this.privFd, start: c, autoClose: !1 }));
    }
    write(n) {
      i.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing."), this.privWriteStream !== void 0 && this.privWriteStream.write(new Uint8Array(n.slice(0)));
    }
    close() {
      this.privFd !== void 0 && (this.privWriteStream.on("finish", () => {
        this.privAudioFormat.hasHeader && (this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten), o.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0)), o.closeSync(this.privFd), this.privFd = void 0;
      }), this.privWriteStream.end());
    }
    id() {
      return this.privId;
    }
  };
  return Ee.AudioFileWriter = a, Ee;
}
var me = {}, Qu;
function lv() {
  if (Qu) return me;
  Qu = 1, Object.defineProperty(me, "__esModule", { value: !0 }), me.PullAudioInputStreamImpl = me.PullAudioInputStream = me.PushAudioInputStreamImpl = me.PushAudioInputStream = me.AudioInputStream = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ Lt(), o = /* @__PURE__ */ A(), i = /* @__PURE__ */ jt();
  let a = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member AudioInputStream.createPushStream
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The audio input stream being created.
     */
    static createPushStream(p) {
      return s.create(p);
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
     * and close() methods.
     * @member AudioInputStream.createPullStream
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
     * PullAudioInputStreamCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The audio input stream being created.
     */
    static createPullStream(p, d) {
      return c.create(p, d);
    }
  };
  me.AudioInputStream = a;
  class s extends a {
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member PushAudioInputStream.create
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The push audio input stream being created.
     */
    static create(p) {
      return new n(p);
    }
  }
  me.PushAudioInputStream = s;
  class n extends s {
    /**
     * Creates and initalizes an instance with the given values.
     * @constructor
     * @param {AudioStreamFormat} format - The audio stream format.
     */
    constructor(p) {
      super(), p === void 0 ? this.privFormat = i.AudioStreamFormatImpl.getDefaultInputFormat() : this.privFormat = p, this.privEvents = new t.EventSource(), this.privId = (0, r.createNoDashGuid)(), this.privStream = new t.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PushAudioInputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(p) {
      this.privStream.writeStreamChunk({
        buffer: p,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PushAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    async attach(p) {
      this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, p)), await this.turnOn();
      const d = this.privStream;
      return this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, p)), {
        detach: async () => (this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p)), this.turnOff()),
        id: () => p,
        read: () => d.read()
      };
    }
    detach(p) {
      this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PushStream",
        samplerate: this.privFormat.samplesPerSec,
        type: e.type.Stream
      });
    }
    onEvent(p) {
      this.privEvents.onEvent(p), t.Events.instance.onEvent(p);
    }
    toBuffer(p) {
      const d = Buffer.alloc(p.byteLength), h = new Uint8Array(p);
      for (let f = 0; f < d.length; ++f)
        d[f] = h[f];
      return d;
    }
  }
  me.PushAudioInputStreamImpl = n;
  class c extends a {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @member PullAudioInputStream.create
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The push audio input stream being created.
     */
    static create(p, d) {
      return new u(p, d);
    }
  }
  me.PullAudioInputStream = c;
  class u extends c {
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @constructor
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     */
    constructor(p, d) {
      super(), d === void 0 ? this.privFormat = o.AudioStreamFormat.getDefaultInputFormat() : this.privFormat = d, this.privEvents = new t.EventSource(), this.privId = (0, r.createNoDashGuid)(), this.privCallback = p, this.privIsClosed = !1, this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Closes the stream.
     * @member PullAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privIsClosed = !0, this.privCallback.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    async attach(p) {
      return this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, p)), await this.turnOn(), this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, p)), {
        detach: () => (this.privCallback.close(), this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p)), this.turnOff()),
        id: () => p,
        read: () => {
          let d = 0, h;
          for (; d < this.privBufferSize; ) {
            const f = new ArrayBuffer(this.privBufferSize - d), g = this.privCallback.read(f);
            if (h === void 0 ? h = f : new Int8Array(h).set(new Int8Array(f), d), g === 0)
              break;
            d += g;
          }
          return Promise.resolve({
            buffer: h.slice(0, d),
            isEnd: this.privIsClosed || d === 0,
            timeReceived: Date.now()
          });
        }
      };
    }
    detach(p) {
      this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PullStream",
        samplerate: this.privFormat.samplesPerSec,
        type: e.type.Stream
      });
    }
    onEvent(p) {
      this.privEvents.onEvent(p), t.Events.instance.onEvent(p);
    }
  }
  return me.PullAudioInputStreamImpl = u, me;
}
var ye = {}, Lr = {}, Uo = {}, Yu;
function pv() {
  return Yu || (Yu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeechSynthesisOutputFormat = void 0, function(t) {
      t[t.Raw8Khz8BitMonoMULaw = 0] = "Raw8Khz8BitMonoMULaw", t[t.Riff16Khz16KbpsMonoSiren = 1] = "Riff16Khz16KbpsMonoSiren", t[t.Audio16Khz16KbpsMonoSiren = 2] = "Audio16Khz16KbpsMonoSiren", t[t.Audio16Khz32KBitRateMonoMp3 = 3] = "Audio16Khz32KBitRateMonoMp3", t[t.Audio16Khz128KBitRateMonoMp3 = 4] = "Audio16Khz128KBitRateMonoMp3", t[t.Audio16Khz64KBitRateMonoMp3 = 5] = "Audio16Khz64KBitRateMonoMp3", t[t.Audio24Khz48KBitRateMonoMp3 = 6] = "Audio24Khz48KBitRateMonoMp3", t[t.Audio24Khz96KBitRateMonoMp3 = 7] = "Audio24Khz96KBitRateMonoMp3", t[t.Audio24Khz160KBitRateMonoMp3 = 8] = "Audio24Khz160KBitRateMonoMp3", t[t.Raw16Khz16BitMonoTrueSilk = 9] = "Raw16Khz16BitMonoTrueSilk", t[t.Riff16Khz16BitMonoPcm = 10] = "Riff16Khz16BitMonoPcm", t[t.Riff8Khz16BitMonoPcm = 11] = "Riff8Khz16BitMonoPcm", t[t.Riff24Khz16BitMonoPcm = 12] = "Riff24Khz16BitMonoPcm", t[t.Riff8Khz8BitMonoMULaw = 13] = "Riff8Khz8BitMonoMULaw", t[t.Raw16Khz16BitMonoPcm = 14] = "Raw16Khz16BitMonoPcm", t[t.Raw24Khz16BitMonoPcm = 15] = "Raw24Khz16BitMonoPcm", t[t.Raw8Khz16BitMonoPcm = 16] = "Raw8Khz16BitMonoPcm", t[t.Ogg16Khz16BitMonoOpus = 17] = "Ogg16Khz16BitMonoOpus", t[t.Ogg24Khz16BitMonoOpus = 18] = "Ogg24Khz16BitMonoOpus", t[t.Raw48Khz16BitMonoPcm = 19] = "Raw48Khz16BitMonoPcm", t[t.Riff48Khz16BitMonoPcm = 20] = "Riff48Khz16BitMonoPcm", t[t.Audio48Khz96KBitRateMonoMp3 = 21] = "Audio48Khz96KBitRateMonoMp3", t[t.Audio48Khz192KBitRateMonoMp3 = 22] = "Audio48Khz192KBitRateMonoMp3", t[t.Ogg48Khz16BitMonoOpus = 23] = "Ogg48Khz16BitMonoOpus", t[t.Webm16Khz16BitMonoOpus = 24] = "Webm16Khz16BitMonoOpus", t[t.Webm24Khz16BitMonoOpus = 25] = "Webm24Khz16BitMonoOpus", t[t.Raw24Khz16BitMonoTrueSilk = 26] = "Raw24Khz16BitMonoTrueSilk", t[t.Raw8Khz8BitMonoALaw = 27] = "Raw8Khz8BitMonoALaw", t[t.Riff8Khz8BitMonoALaw = 28] = "Riff8Khz8BitMonoALaw", t[t.Webm24Khz16Bit24KbpsMonoOpus = 29] = "Webm24Khz16Bit24KbpsMonoOpus", t[t.Audio16Khz16Bit32KbpsMonoOpus = 30] = "Audio16Khz16Bit32KbpsMonoOpus", t[t.Audio24Khz16Bit48KbpsMonoOpus = 31] = "Audio24Khz16Bit48KbpsMonoOpus", t[t.Audio24Khz16Bit24KbpsMonoOpus = 32] = "Audio24Khz16Bit24KbpsMonoOpus", t[t.Raw22050Hz16BitMonoPcm = 33] = "Raw22050Hz16BitMonoPcm", t[t.Riff22050Hz16BitMonoPcm = 34] = "Riff22050Hz16BitMonoPcm", t[t.Raw44100Hz16BitMonoPcm = 35] = "Raw44100Hz16BitMonoPcm", t[t.Riff44100Hz16BitMonoPcm = 36] = "Riff44100Hz16BitMonoPcm", t[t.AmrWb16000Hz = 37] = "AmrWb16000Hz", t[t.G72216Khz64Kbps = 38] = "G72216Khz64Kbps";
    }(e.SpeechSynthesisOutputFormat || (e.SpeechSynthesisOutputFormat = {}));
  }(Uo)), Uo;
}
var Zu;
function Rs() {
  if (Zu) return Lr;
  Zu = 1, Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.AudioOutputFormatImpl = void 0;
  const e = /* @__PURE__ */ pv(), t = /* @__PURE__ */ jt();
  class r extends t.AudioStreamFormatImpl {
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param formatTag
     * @param {number} channels - Number of channels.
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} avgBytesPerSec - Average bytes per second.
     * @param {number} blockAlign - Block alignment.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {string} audioFormatString - Audio format string
     * @param {string} requestAudioFormatString - Audio format string sent to service.
     * @param {boolean} hasHeader - If the format has header or not.
     */
    constructor(i, a, s, n, c, u, l, p, d) {
      super(s, u, a, i), this.formatTag = i, this.avgBytesPerSec = n, this.blockAlign = c, this.priAudioFormatString = l, this.priRequestAudioFormatString = p, this.priHasHeader = d;
    }
    static fromSpeechSynthesisOutputFormat(i) {
      return i === void 0 ? r.getDefaultOutputFormat() : r.fromSpeechSynthesisOutputFormatString(r.SpeechSynthesisOutputFormatToString[i]);
    }
    static fromSpeechSynthesisOutputFormatString(i) {
      switch (i) {
        case "raw-8khz-8bit-mono-mulaw":
          return new r(t.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, i, i, !1);
        case "riff-16khz-16kbps-mono-siren":
          return new r(t.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, i, "audio-16khz-16kbps-mono-siren", !0);
        case "audio-16khz-16kbps-mono-siren":
          return new r(t.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, i, i, !1);
        case "audio-16khz-32kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 4096, 2, 16, i, i, !1);
        case "audio-16khz-128kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 16384, 2, 16, i, i, !1);
        case "audio-16khz-64kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 8192, 2, 16, i, i, !1);
        case "audio-24khz-48kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 6144, 2, 16, i, i, !1);
        case "audio-24khz-96kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 12288, 2, 16, i, i, !1);
        case "audio-24khz-160kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 20480, 2, 16, i, i, !1);
        case "raw-16khz-16bit-mono-truesilk":
          return new r(t.AudioFormatTag.SILKSkype, 1, 16e3, 32e3, 2, 16, i, i, !1);
        case "riff-8khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, i, "raw-8khz-16bit-mono-pcm", !0);
        case "riff-24khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, i, "raw-24khz-16bit-mono-pcm", !0);
        case "riff-8khz-8bit-mono-mulaw":
          return new r(t.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, i, "raw-8khz-8bit-mono-mulaw", !0);
        case "raw-16khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, i, "raw-16khz-16bit-mono-pcm", !1);
        case "raw-24khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, i, "raw-24khz-16bit-mono-pcm", !1);
        case "raw-8khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, i, "raw-8khz-16bit-mono-pcm", !1);
        case "ogg-16khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 16e3, 8192, 2, 16, i, i, !1);
        case "ogg-24khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 24e3, 8192, 2, 16, i, i, !1);
        case "raw-48khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, i, "raw-48khz-16bit-mono-pcm", !1);
        case "riff-48khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, i, "raw-48khz-16bit-mono-pcm", !0);
        case "audio-48khz-96kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 48e3, 12288, 2, 16, i, i, !1);
        case "audio-48khz-192kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 48e3, 24576, 2, 16, i, i, !1);
        case "ogg-48khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 48e3, 12e3, 2, 16, i, i, !1);
        case "webm-16khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 16e3, 4e3, 2, 16, i, i, !1);
        case "webm-24khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 24e3, 6e3, 2, 16, i, i, !1);
        case "webm-24khz-16bit-24kbps-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 24e3, 3e3, 2, 16, i, i, !1);
        case "audio-16khz-16bit-32kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 16e3, 4e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-48kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 24e3, 6e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-24kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 24e3, 3e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-mono-flac":
          return new r(t.AudioFormatTag.FLAC, 1, 24e3, 24e3, 2, 16, i, i, !1);
        case "audio-48khz-16bit-mono-flac":
          return new r(t.AudioFormatTag.FLAC, 1, 48e3, 3e4, 2, 16, i, i, !1);
        case "raw-24khz-16bit-mono-truesilk":
          return new r(t.AudioFormatTag.SILKSkype, 1, 24e3, 48e3, 2, 16, i, i, !1);
        case "raw-8khz-8bit-mono-alaw":
          return new r(t.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, i, i, !1);
        case "riff-8khz-8bit-mono-alaw":
          return new r(t.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, i, "raw-8khz-8bit-mono-alaw", !0);
        case "raw-22050hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, i, i, !1);
        case "riff-22050hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, i, "raw-22050hz-16bit-mono-pcm", !0);
        case "raw-44100hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, i, i, !1);
        case "riff-44100hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, i, "raw-44100hz-16bit-mono-pcm", !0);
        case "amr-wb-16000h":
          return new r(t.AudioFormatTag.AMR_WB, 1, 16e3, 3052, 2, 16, i, i, !1);
        case "g722-16khz-64kbps":
          return new r(t.AudioFormatTag.G722, 1, 16e3, 8e3, 2, 16, i, i, !1);
        case "riff-16khz-16bit-mono-pcm":
        default:
          return new r(t.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", !0);
      }
    }
    static getDefaultOutputFormat() {
      return r.fromSpeechSynthesisOutputFormatString(typeof window < "u" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
    }
    /**
     * Specifies if this audio output format has a header
     * @boolean AudioOutputFormatImpl.prototype.hasHeader
     * @function
     * @public
     */
    get hasHeader() {
      return this.priHasHeader;
    }
    /**
     * Specifies the header of this format
     * @ArrayBuffer AudioOutputFormatImpl.prototype.header
     * @function
     * @public
     */
    get header() {
      if (this.hasHeader)
        return this.privHeader;
    }
    /**
     * Updates the header based on the audio length
     * @member AudioOutputFormatImpl.updateHeader
     * @function
     * @public
     * @param {number} audioLength - the audio length
     */
    updateHeader(i) {
      if (this.priHasHeader) {
        const a = new DataView(this.privHeader);
        a.setUint32(4, i + this.privHeader.byteLength - 8, !0), a.setUint32(40, i, !0);
      }
    }
    /**
     * Specifies the audio format string to be sent to the service
     * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
     * @function
     * @public
     */
    get requestAudioFormatString() {
      return this.priRequestAudioFormatString;
    }
    /**
     * Adds audio header
     * @param audio the raw audio without header
     * @returns the audio with header if applicable
     */
    addHeader(i) {
      if (!this.hasHeader)
        return i;
      this.updateHeader(i.byteLength);
      const a = new Uint8Array(i.byteLength + this.header.byteLength);
      return a.set(new Uint8Array(this.header), 0), a.set(new Uint8Array(i), this.header.byteLength), a.buffer;
    }
  }
  return Lr.AudioOutputFormatImpl = r, r.SpeechSynthesisOutputFormatToString = {
    [e.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
    [e.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
    [e.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
    [e.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
    [e.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
    [e.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
    [e.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
    [e.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
    [e.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.AmrWb16000Hz]: "amr-wb-16000hz",
    [e.SpeechSynthesisOutputFormat.G72216Khz64Kbps]: "g722-16khz-64kbps"
  }, Lr;
}
var Xu;
function Kt() {
  if (Xu) return ye;
  Xu = 1, Object.defineProperty(ye, "__esModule", { value: !0 }), ye.PushAudioOutputStreamImpl = ye.PushAudioOutputStream = ye.PullAudioOutputStreamImpl = ye.PullAudioOutputStream = ye.AudioOutputStream = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ Rs();
  let o = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member AudioOutputStream.createPullStream
     * @function
     * @public
     * @returns {PullAudioOutputStream} The audio output stream being created.
     */
    static createPullStream() {
      return i.create();
    }
  };
  ye.AudioOutputStream = o;
  class i extends o {
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member PullAudioOutputStream.create
     * @function
     * @public
     * @returns {PullAudioOutputStream} The push audio output stream being created.
     */
    static create() {
      return new a();
    }
  }
  ye.PullAudioOutputStream = i;
  class a extends i {
    /**
     * Creates and initializes an instance with the given values.
     * @constructor
     */
    constructor() {
      super(), this.privId = (0, e.createNoDashGuid)(), this.privStream = new e.Stream();
    }
    /**
     * Sets the format information to the stream. For internal use only.
     * @param {AudioStreamFormat} format - the format to be set.
     */
    set format(u) {
      u == null && (this.privFormat = r.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privFormat = u;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privFormat;
    }
    /**
     * Checks if the stream is closed
     * @member PullAudioOutputStreamImpl.prototype.isClosed
     * @property
     * @public
     */
    get isClosed() {
      return this.privStream.isClosed;
    }
    /**
     * Gets the id of the stream
     * @member PullAudioOutputStreamImpl.prototype.id
     * @property
     * @public
     */
    id() {
      return this.privId;
    }
    /**
     * Reads audio data from the internal buffer.
     * @member PullAudioOutputStreamImpl.prototype.read
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
     * @returns {Promise<number>} - Audio buffer length has been read.
     */
    async read(u) {
      const l = new Int8Array(u);
      let p = 0;
      if (this.privLastChunkView !== void 0) {
        if (this.privLastChunkView.length > u.byteLength)
          return l.set(this.privLastChunkView.slice(0, u.byteLength)), this.privLastChunkView = this.privLastChunkView.slice(u.byteLength), Promise.resolve(u.byteLength);
        l.set(this.privLastChunkView), p = this.privLastChunkView.length, this.privLastChunkView = void 0;
      }
      for (; p < u.byteLength && !this.privStream.isReadEnded; ) {
        const d = await this.privStream.read();
        if (d !== void 0 && !d.isEnd) {
          let h;
          d.buffer.byteLength > u.byteLength - p ? (h = d.buffer.slice(0, u.byteLength - p), this.privLastChunkView = new Int8Array(d.buffer.slice(u.byteLength - p))) : h = d.buffer, l.set(new Int8Array(h), p), p += h.byteLength;
        } else
          this.privStream.readEnded();
      }
      return p;
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PullAudioOutputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(u) {
      t.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing"), this.privStream.writeStreamChunk({
        buffer: u,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PullAudioOutputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
  }
  ye.PullAudioOutputStreamImpl = a;
  class s extends o {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * write() and close() methods.
     * @member PushAudioOutputStream.create
     * @function
     * @public
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     * @returns {PushAudioOutputStream} The push audio output stream being created.
     */
    static create(u) {
      return new n(u);
    }
  }
  ye.PushAudioOutputStream = s;
  class n extends s {
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * read() and close() methods.
     * @constructor
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     */
    constructor(u) {
      super(), this.privId = (0, e.createNoDashGuid)(), this.privCallback = u;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set format(u) {
    }
    write(u) {
      this.privCallback.write && this.privCallback.write(u);
    }
    close() {
      this.privCallback.close && this.privCallback.close();
    }
    id() {
      return this.privId;
    }
  }
  return ye.PushAudioOutputStreamImpl = n, ye;
}
var el;
function hv() {
  if (el) return qe;
  el = 1, Object.defineProperty(qe, "__esModule", { value: !0 }), qe.AudioOutputConfigImpl = qe.AudioConfigImpl = qe.AudioConfig = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ uv(), i = /* @__PURE__ */ lv(), a = /* @__PURE__ */ Kt();
  let s = class dv {
    /**
     * Creates an AudioConfig object representing the default microphone on the system.
     * @member AudioConfig.fromDefaultMicrophoneInput
     * @function
     * @public
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromDefaultMicrophoneInput() {
      const l = new e.PcmRecorder(!0);
      return new n(new e.MicAudioSource(l));
    }
    /**
     * Creates an AudioConfig object representing a microphone with the specified device ID.
     * @member AudioConfig.fromMicrophoneInput
     * @function
     * @public
     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
     * Default microphone is used the value is omitted.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromMicrophoneInput(l) {
      const p = new e.PcmRecorder(!0);
      return new n(new e.MicAudioSource(p, l));
    }
    /**
     * Creates an AudioConfig object representing the specified file.
     * @member AudioConfig.fromWavFileInput
     * @function
     * @public
     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromWavFileInput(l, p = "unnamedBuffer.wav") {
      return new n(new e.FileAudioSource(l, p));
    }
    /**
     * Creates an AudioConfig object representing the specified stream.
     * @member AudioConfig.fromStreamInput
     * @function
     * @public
     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
     * stream. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromStreamInput(l) {
      if (l instanceof r.PullAudioInputStreamCallback)
        return new n(new i.PullAudioInputStreamImpl(l));
      if (l instanceof r.AudioInputStream)
        return new n(l);
      if (typeof MediaStream < "u" && l instanceof MediaStream) {
        const p = new e.PcmRecorder(!1);
        return new n(new e.MicAudioSource(p, null, null, l));
      }
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing the default speaker.
     * @member AudioConfig.fromDefaultSpeakerOutput
     * @function
     * @public
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromDefaultSpeakerOutput() {
      return new c(new r.SpeakerAudioDestination());
    }
    /**
     * Creates an AudioConfig object representing the custom IPlayer object.
     * You can use the IPlayer object to control pause, resume, etc.
     * @member AudioConfig.fromSpeakerOutput
     * @function
     * @public
     * @param {IPlayer} player - the IPlayer object for playback.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.12.0
     */
    static fromSpeakerOutput(l) {
      if (l === void 0)
        return dv.fromDefaultSpeakerOutput();
      if (l instanceof r.SpeakerAudioDestination)
        return new c(l);
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing a specified output audio file
     * @member AudioConfig.fromAudioFileOutput
     * @function
     * @public
     * @param {PathLike} filename - the filename of the output audio file
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromAudioFileOutput(l) {
      return new c(new o.AudioFileWriter(l));
    }
    /**
     * Creates an AudioConfig object representing a specified audio output stream
     * @member AudioConfig.fromStreamOutput
     * @function
     * @public
     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
     * stream.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromStreamOutput(l) {
      if (l instanceof r.PushAudioOutputStreamCallback)
        return new c(new a.PushAudioOutputStreamImpl(l));
      if (l instanceof r.PushAudioOutputStream)
        return new c(l);
      if (l instanceof r.PullAudioOutputStream)
        return new c(l);
      throw new Error("Not Supported Type");
    }
  };
  qe.AudioConfig = s;
  class n extends s {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioSource} source - An audio source.
     */
    constructor(l) {
      super(), this.privSource = l;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privSource.format;
    }
    /**
     * @member AudioConfigImpl.prototype.close
     * @function
     * @public
     */
    close(l, p) {
      this.privSource.turnOff().then(() => {
        l && l();
      }, (d) => {
        p && p(d);
      });
    }
    /**
     * @member AudioConfigImpl.prototype.id
     * @function
     * @public
     */
    id() {
      return this.privSource.id();
    }
    /**
     * @member AudioConfigImpl.prototype.turnOn
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOn() {
      return this.privSource.turnOn();
    }
    /**
     * @member AudioConfigImpl.prototype.attach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     * @returns {Promise<IAudioStreamNode>} A promise.
     */
    attach(l) {
      return this.privSource.attach(l);
    }
    /**
     * @member AudioConfigImpl.prototype.detach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     */
    detach(l) {
      return this.privSource.detach(l);
    }
    /**
     * @member AudioConfigImpl.prototype.turnOff
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOff() {
      return this.privSource.turnOff();
    }
    /**
     * @member AudioConfigImpl.prototype.events
     * @function
     * @public
     * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
     */
    get events() {
      return this.privSource.events;
    }
    setProperty(l, p) {
      if (t.Contracts.throwIfNull(p, "value"), this.privSource.setProperty !== void 0)
        this.privSource.setProperty(l, p);
      else
        throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty(l, p) {
      if (this.privSource.getProperty !== void 0)
        return this.privSource.getProperty(l, p);
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
    get deviceInfo() {
      return this.privSource.deviceInfo;
    }
  }
  qe.AudioConfigImpl = n;
  class c extends s {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioDestination} destination - An audio destination.
     */
    constructor(l) {
      super(), this.privDestination = l;
    }
    set format(l) {
      this.privDestination.format = l;
    }
    write(l) {
      this.privDestination.write(l);
    }
    close() {
      this.privDestination.close();
    }
    id() {
      return this.privDestination.id();
    }
    setProperty() {
      throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty() {
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
  }
  return qe.AudioOutputConfigImpl = c, qe;
}
var $o = {}, tl;
function tR() {
  return tl || (tl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationReason = void 0, function(t) {
      t[t.Error = 0] = "Error", t[t.EndOfStream = 1] = "EndOfStream";
    }(e.CancellationReason || (e.CancellationReason = {}));
  }($o)), $o;
}
var jr = {}, rl;
function rR() {
  if (rl) return jr;
  rl = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.PullAudioInputStreamCallback = void 0;
  let e = class {
  };
  return jr.PullAudioInputStreamCallback = e, jr;
}
var qr = {}, nl;
function nR() {
  if (nl) return qr;
  nl = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.PushAudioOutputStreamCallback = void 0;
  let e = class {
  };
  return qr.PushAudioOutputStreamCallback = e, qr;
}
var Fr = {}, il;
function iR() {
  if (il) return Fr;
  il = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.KeywordRecognitionModel = void 0;
  const e = /* @__PURE__ */ z();
  let t = class {
    /**
     * Create and initializes a new instance.
     * @constructor
     */
    constructor() {
      this.privDisposed = !1;
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromFile
     * @function
     * @public
     * @param {string} fileName - A string that represents file name for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model
     * will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */
    static fromFile(o) {
      throw e.Contracts.throwIfFileDoesNotExist(o, "fileName"), new Error("Not yet implemented.");
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromStream
     * @function
     * @public
     * @param {string} file - A File that represents file for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */
    static fromStream(o) {
      throw e.Contracts.throwIfNull(o, "file"), new Error("Not yet implemented.");
    }
    /**
     * Dispose of associated resources.
     * @member KeywordRecognitionModel.prototype.close
     * @function
     * @public
     */
    close() {
      this.privDisposed || (this.privDisposed = !0);
    }
  };
  return Fr.KeywordRecognitionModel = t, Fr;
}
var Br = {}, sl;
function sR() {
  if (sl) return Br;
  sl = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.SessionEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionId - The session id.
     */
    constructor(r) {
      this.privSessionId = r;
    }
    /**
     * Represents the session identifier.
     * @member SessionEventArgs.prototype.sessionId
     * @function
     * @public
     * @returns {string} Represents the session identifier.
     */
    get sessionId() {
      return this.privSessionId;
    }
  };
  return Br.SessionEventArgs = e, Br;
}
var Ur = {}, ol;
function oR() {
  if (ol) return Ur;
  ol = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.RecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i) {
      super(i), this.privOffset = o;
    }
    /**
     * Represents the message offset
     * @member RecognitionEventArgs.prototype.offset
     * @function
     * @public
     */
    get offset() {
      return this.privOffset;
    }
  };
  return Ur.RecognitionEventArgs = t, Ur;
}
var Vo = {}, al;
function aR() {
  return al || (al = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OutputFormat = void 0, function(t) {
      t[t.Simple = 0] = "Simple", t[t.Detailed = 1] = "Detailed";
    }(e.OutputFormat || (e.OutputFormat = {}));
  }(Vo)), Vo;
}
var $r = {}, cl;
function cR() {
  if (cl) return $r;
  cl = 1, Object.defineProperty($r, "__esModule", { value: !0 }), $r.IntentRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param result - The result of the intent recognition.
     * @param offset - The offset.
     * @param sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Represents the intent recognition result.
     * @member IntentRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {IntentRecognitionResult} Represents the intent recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return $r.IntentRecognitionEventArgs = t, $r;
}
var Vr = {}, ul;
function uR() {
  if (ul) return Vr;
  ul = 1, Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.RecognitionResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, o, i, a, s, n, c, u, l, p) {
      this.privResultId = r, this.privReason = o, this.privText = i, this.privDuration = a, this.privOffset = s, this.privLanguage = n, this.privLanguageDetectionConfidence = c, this.privErrorDetails = u, this.privJson = l, this.privProperties = p;
    }
    /**
     * Specifies the result identifier.
     * @member RecognitionResult.prototype.resultId
     * @function
     * @public
     * @returns {string} Specifies the result identifier.
     */
    get resultId() {
      return this.privResultId;
    }
    /**
     * Specifies status of the result.
     * @member RecognitionResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} Specifies status of the result.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * Presents the recognized text in the result.
     * @member RecognitionResult.prototype.text
     * @function
     * @public
     * @returns {string} Presents the recognized text in the result.
     */
    get text() {
      return this.privText;
    }
    /**
     * Duration of recognized speech in 100 nano second increments.
     * @member RecognitionResult.prototype.duration
     * @function
     * @public
     * @returns {number} Duration of recognized speech in 100 nano second increments.
     */
    get duration() {
      return this.privDuration;
    }
    /**
     * Offset of recognized speech in 100 nano second increments.
     * @member RecognitionResult.prototype.offset
     * @function
     * @public
     * @returns {number} Offset of recognized speech in 100 nano second increments.
     */
    get offset() {
      return this.privOffset;
    }
    /**
     * Primary Language detected.
     * @member RecognitionResult.prototype.language
     * @function
     * @public
     * @returns {string} language detected.
     */
    get language() {
      return this.privLanguage;
    }
    /**
     * Primary Language detection confidence (Unknown, Low, Medium, High).
     * @member RecognitionResult.prototype.languageDetectionConfidence
     * @function
     * @public
     * @returns {string} detection confidence strength.
     */
    get languageDetectionConfidence() {
      return this.privLanguageDetectionConfidence;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member RecognitionResult.prototype.errorDetails
     * @function
     * @public
     * @returns {string} a brief description of an error.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * A string containing Json serialized recognition result as it was received from the service.
     * @member RecognitionResult.prototype.json
     * @function
     * @private
     * @returns {string} Json serialized representation of the result.
     */
    get json() {
      return this.privJson;
    }
    /**
     * The set of properties exposed in the result.
     * @member RecognitionResult.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The set of properties exposed in the result.
     */
    get properties() {
      return this.privProperties;
    }
  };
  return Vr.RecognitionResult = e, Vr;
}
var Wr = {}, ll;
function lR() {
  if (ll) return Wr;
  ll = 1, Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.SpeechRecognitionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription, if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, d, h) {
      super(o, i, a, s, n, c, u, p, d, h), this.privSpeakerId = l;
    }
    /**
     * speaker id from conversation transcription/id scenarios
     * @member SpeechRecognitionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return Wr.SpeechRecognitionResult = t, Wr;
}
var Hr = {}, pl;
function pR() {
  if (pl) return Hr;
  pl = 1, Object.defineProperty(Hr, "__esModule", { value: !0 }), Hr.IntentRecognitionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param intentId - The intent id.
     * @param resultId - The result id.
     * @param reason - The reason.
     * @param text - The recognized text.
     * @param duration - The duration.
     * @param offset - The offset into the stream.
     * @param language - Primary Language detected, if provided.
     * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param errorDetails - Error details, if provided.
     * @param json - Additional Json, if provided.
     * @param properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, d, h) {
      super(i, a, s, n, c, u, l, void 0, p, d, h), this.privIntentId = o;
    }
    /**
     * A String that represents the intent identifier being recognized.
     * @member IntentRecognitionResult.prototype.intentId
     * @function
     * @public
     * @returns {string} A String that represents the intent identifier being recognized.
     */
    get intentId() {
      return this.privIntentId;
    }
  };
  return Hr.IntentRecognitionResult = t, Hr;
}
var gt = {}, dl;
function dR() {
  if (dl) return gt;
  dl = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.LanguageUnderstandingModelImpl = gt.LanguageUnderstandingModel = void 0;
  const e = /* @__PURE__ */ z();
  let t = class {
    /**
     * Creates and initializes a new instance
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates an language understanding model using the specified endpoint.
     * @member LanguageUnderstandingModel.fromEndpoint
     * @function
     * @public
     * @param {URL} uri - A String that represents the endpoint of the language understanding model.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromEndpoint(i) {
      e.Contracts.throwIfNull(i, "uri"), e.Contracts.throwIfNullOrWhitespace(i.hostname, "uri");
      const a = new r(), s = i.host.indexOf(".");
      if (s === -1)
        throw new Error("Could not determine region from endpoint");
      a.region = i.host.substr(0, s);
      const n = i.pathname.lastIndexOf("/") + 1;
      if (n === -1)
        throw new Error("Could not determine appId from endpoint");
      if (a.appId = i.pathname.substr(n), a.subscriptionKey = i.searchParams.get("subscription-key"), a.subscriptionKey === void 0)
        throw new Error("Could not determine subscription key from endpoint");
      return a;
    }
    /**
     * Creates an language understanding model using the application id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromAppId
     * @function
     * @public
     * @param {string} appId - A String that represents the application id of Language Understanding service.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromAppId(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "appId");
      const a = new r();
      return a.appId = i, a;
    }
    /**
     * Creates a language understanding model using hostname, subscription key and application
     * id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - A String that represents the subscription key of
     * Language Understanding service.
     * @param {string} appId - A String that represents the application id of Language
     * Understanding service.
     * @param {LanguageUnderstandingModel} region - A String that represents the region
     * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromSubscription(i, a, s) {
      e.Contracts.throwIfNullOrWhitespace(i, "subscriptionKey"), e.Contracts.throwIfNullOrWhitespace(a, "appId"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const n = new r();
      return n.appId = a, n.region = s, n.subscriptionKey = i, n;
    }
  };
  gt.LanguageUnderstandingModel = t;
  class r extends t {
  }
  return gt.LanguageUnderstandingModelImpl = r, gt;
}
var Fe = {}, hl;
function hR() {
  if (hl) return Fe;
  hl = 1, Object.defineProperty(Fe, "__esModule", { value: !0 }), Fe.MeetingTranscriptionEventArgs = Fe.ConversationTranscriptionEventArgs = Fe.SpeechRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechRecognitionResult} result - The speech recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(a, s, n) {
      super(s, n), this.privResult = a;
    }
    /**
     * Specifies the recognition result.
     * @member SpeechRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  Fe.SpeechRecognitionEventArgs = t;
  class r extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranscriptionResult} result - The conversation transcription result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(a, s, n) {
      super(s, n), this.privResult = a;
    }
    /**
     * Specifies the transcription result.
     * @member ConversationTranscription1EventArgs.prototype.result
     * @function
     * @public
     * @returns {ConversationTranscriptionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  }
  Fe.ConversationTranscriptionEventArgs = r;
  class o extends t {
  }
  return Fe.MeetingTranscriptionEventArgs = o, Fe;
}
var Kr = {}, Jr = {}, fl;
function Ps() {
  if (fl) return Jr;
  fl = 1, Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.CancellationEventArgsBase = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a, s, n) {
      super(s, n), this.privReason = o, this.privErrorDetails = i, this.privErrorCode = a;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationEventArgsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful operation.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful operation, provides details of the occurred error.
     * @member CancellationEventArgsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return Jr.CancellationEventArgsBase = t, Jr;
}
var vl;
function fR() {
  if (vl) return Kr;
  vl = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.SpeechRecognitionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Ps();
  let t = class extends e.CancellationEventArgsBase {
  };
  return Kr.SpeechRecognitionCanceledEventArgs = t, Kr;
}
var Gr = {}, gl;
function vR() {
  if (gl) return Gr;
  gl = 1, Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.TranslationRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationRecognitionResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Gr.TranslationRecognitionEventArgs = t, Gr;
}
var Qr = {}, ml;
function gR() {
  if (ml) return Qr;
  ml = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.TranslationSynthesisEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationSynthesisResult} result - The translation synthesis result.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i) {
      super(i), this.privResult = o;
    }
    /**
     * Specifies the translation synthesis result.
     * @member TranslationSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Qr.TranslationSynthesisEventArgs = t, Qr;
}
var Yr = {}, yl;
function vv() {
  if (yl) return Yr;
  yl = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.TranslationRecognitionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class fv extends e.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {Translations} translations - The translations.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, d, h) {
      super(i, a, s, n, c, u, l, void 0, p, d, h), this.privTranslations = o;
    }
    static fromSpeechRecognitionResult(o) {
      return new fv(void 0, o.resultId, o.reason, o.text, o.duration, o.offset, o.language, o.languageDetectionConfidence, o.errorDetails, o.json, o.properties);
    }
    /**
     * Presents the translation results. Each item in the dictionary represents
     * a translation result in one of target languages, where the key is the name
     * of the target language, in BCP-47 format, and the value is the translation
     * text in the specified language.
     * @member TranslationRecognitionResult.prototype.translations
     * @function
     * @public
     * @returns {Translations} the current translation map that holds all translations requested.
     */
    get translations() {
      return this.privTranslations;
    }
  };
  return Yr.TranslationRecognitionResult = t, Yr;
}
var Zr = {}, Sl;
function mR() {
  if (Sl) return Zr;
  Sl = 1, Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.TranslationSynthesisResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ResultReason} reason - The synthesis reason.
     * @param {ArrayBuffer} audio - The audio data.
     */
    constructor(r, o) {
      this.privReason = r, this.privAudio = o;
    }
    /**
     * Translated text in the target language.
     * @member TranslationSynthesisResult.prototype.audio
     * @function
     * @public
     * @returns {ArrayBuffer} Translated audio in the target language.
     */
    get audio() {
      return this.privAudio;
    }
    /**
     * The synthesis status.
     * @member TranslationSynthesisResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} The synthesis status.
     */
    get reason() {
      return this.privReason;
    }
  };
  return Zr.TranslationSynthesisResult = e, Zr;
}
var Wo = {}, Cl;
function yR() {
  return Cl || (Cl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ResultReason = void 0, function(t) {
      t[t.NoMatch = 0] = "NoMatch", t[t.Canceled = 1] = "Canceled", t[t.RecognizingSpeech = 2] = "RecognizingSpeech", t[t.RecognizedSpeech = 3] = "RecognizedSpeech", t[t.RecognizedKeyword = 4] = "RecognizedKeyword", t[t.RecognizingIntent = 5] = "RecognizingIntent", t[t.RecognizedIntent = 6] = "RecognizedIntent", t[t.TranslatingSpeech = 7] = "TranslatingSpeech", t[t.TranslatedSpeech = 8] = "TranslatedSpeech", t[t.SynthesizingAudio = 9] = "SynthesizingAudio", t[t.SynthesizingAudioCompleted = 10] = "SynthesizingAudioCompleted", t[t.SynthesizingAudioStarted = 11] = "SynthesizingAudioStarted", t[t.EnrollingVoiceProfile = 12] = "EnrollingVoiceProfile", t[t.EnrolledVoiceProfile = 13] = "EnrolledVoiceProfile", t[t.RecognizedSpeakers = 14] = "RecognizedSpeakers", t[t.RecognizedSpeaker = 15] = "RecognizedSpeaker", t[t.ResetVoiceProfile = 16] = "ResetVoiceProfile", t[t.DeletedVoiceProfile = 17] = "DeletedVoiceProfile", t[t.VoicesListRetrieved = 18] = "VoicesListRetrieved", t[t.TranslatingParticipantSpeech = 19] = "TranslatingParticipantSpeech", t[t.TranslatedParticipantSpeech = 20] = "TranslatedParticipantSpeech", t[t.TranslatedInstantMessage = 21] = "TranslatedInstantMessage", t[t.TranslatedParticipantInstantMessage = 22] = "TranslatedParticipantInstantMessage";
    }(e.ResultReason || (e.ResultReason = {}));
  }(Wo)), Wo;
}
var mt = {}, Rl;
function SR() {
  if (Rl) return mt;
  Rl = 1, Object.defineProperty(mt, "__esModule", { value: !0 }), mt.SpeechConfigImpl = mt.SpeechConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A();
  let o = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * @member SpeechConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} The speech factory
     */
    static fromSubscription(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "subscriptionKey"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c.setProperty(r.PropertyId.SpeechServiceConnection_IntentRegion, n), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c;
    }
    /**
     * Internal implementation of fromEndpoint() overloads. Accepts either a subscription key or a TokenCredential.
     * @private
     */
    static fromEndpoint(s, n) {
      t.Contracts.throwIfNull(s, "endpoint");
      const c = typeof n == "string" && n.trim().length > 0, u = typeof n == "object" && n !== null && typeof n.getToken == "function";
      if (n !== void 0 && !c && !u)
        throw new Error("Invalid 'auth' parameter: must be a non-empty key string or a valid TokenCredential object.");
      const l = typeof n == "object" ? new i(n) : new i();
      return l.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, s.href), typeof n == "string" && n.trim().length > 0 && l.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), l;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(s, n) {
      t.Contracts.throwIfNull(s, "hostName");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Host, s.protocol + "//" + s.hostname + (s.port === "" ? "" : ":" + s.port)), c.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), n !== void 0 && c.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), c;
    }
    /**
     * Creates an instance of the speech factory with specified initial authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
     * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
     * the new token value will not apply to recognizers that have already been created. For recognizers
     * that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The initial authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromAuthorizationToken(s, n) {
      t.Contracts.throwIfNull(s, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c.setProperty(r.PropertyId.SpeechServiceConnection_IntentRegion, n), c.authorizationToken = s, c;
    }
    /**
     * Closes the configuration.
     * @member SpeechConfig.prototype.close
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    close() {
    }
  };
  mt.SpeechConfig = o;
  class i extends o {
    constructor(s) {
      super(), this.privProperties = new r.PropertyCollection(), this.speechRecognitionLanguage = "en-US", this.outputFormat = r.OutputFormat.Simple, this.privTokenCredential = s;
    }
    get properties() {
      return this.privProperties;
    }
    get endPoint() {
      return new URL(this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint));
    }
    get subscriptionKey() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Key);
    }
    get region() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Region);
    }
    get authorizationToken() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    get speechRecognitionLanguage() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    set speechRecognitionLanguage(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, s);
    }
    get autoDetectSourceLanguages() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
    }
    set autoDetectSourceLanguages(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, s);
    }
    get outputFormat() {
      return r.OutputFormat[this.privProperties.getProperty(e.OutputFormatPropertyName, void 0)];
    }
    set outputFormat(s) {
      this.privProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[s]);
    }
    get endpointId() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId);
    }
    set endpointId(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_EndpointId, s);
    }
    get tokenCredential() {
      return this.privTokenCredential;
    }
    setProperty(s, n) {
      t.Contracts.throwIfNull(n, "value"), this.privProperties.setProperty(s, n);
    }
    getProperty(s, n) {
      return this.privProperties.getProperty(s, n);
    }
    setProxy(s, n, c, u) {
      this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyHostName], s), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPort], n), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    setServiceProperty(s, n) {
      const c = JSON.parse(this.privProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
      c[s] = n, this.privProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_ProfanityOption, r.ProfanityOption[s]);
    }
    enableAudioLogging() {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true"), this.privProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Detailed]);
    }
    enableDictation() {
      this.privProperties.setProperty(e.ForceDictationPropertyName, "true");
    }
    clone() {
      const s = new i(this.tokenCredential);
      return s.privProperties = this.privProperties.clone(), s;
    }
    get speechSynthesisLanguage() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, s);
    }
    get speechSynthesisVoiceName() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, s);
    }
    get speechSynthesisOutputFormat() {
      return r.SpeechSynthesisOutputFormat[this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, r.SpeechSynthesisOutputFormat[s]);
    }
  }
  return mt.SpeechConfigImpl = i, mt;
}
var yt = {}, Pl;
function CR() {
  if (Pl) return yt;
  Pl = 1, Object.defineProperty(yt, "__esModule", { value: !0 }), yt.SpeechTranslationConfigImpl = yt.SpeechTranslationConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A();
  let o = class extends r.SpeechConfig {
    /**
     * Creates an instance of recognizer config.
     */
    constructor() {
      super();
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
     * @member SpeechTranslationConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromSubscription(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "subscriptionKey"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by setting the property authorizationToken with a new
     * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
     * will encounter errors during recognition.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply
     * to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechTranslationConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromAuthorizationToken(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s), c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(s, n) {
      t.Contracts.throwIfNull(s, "hostName");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Host, s.protocol + "//" + s.hostname + (s.port === "" ? "" : ":" + s.port)), n !== void 0 && c.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), c;
    }
    /**
     * Internal implementation of fromEndpoint() overloads. Accepts either a subscription key or a TokenCredential.
     * @private
     */
    static fromEndpoint(s, n) {
      t.Contracts.throwIfNull(s, "endpoint");
      const c = typeof n == "string" && n.trim().length > 0, u = typeof n == "object" && n !== null && typeof n.getToken == "function";
      if (n !== void 0 && !c && !u)
        throw new Error("Invalid 'auth' parameter: must be a non-empty key string or a valid TokenCredential object.");
      const l = typeof n == "object" ? new i(n) : new i();
      return l.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, s.href), typeof n == "string" && n.trim().length > 0 && l.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), l;
    }
  };
  yt.SpeechTranslationConfig = o;
  class i extends o {
    constructor(s) {
      super(), this.privSpeechProperties = new r.PropertyCollection(), this.outputFormat = r.OutputFormat.Simple, this.privTokenCredential = s;
    }
    /**
     * Gets/Sets the authorization token.
     * If this is set, subscription key is ignored.
     * User needs to make sure the provided authorization token is valid and not expired.
     * @member SpeechTranslationConfigImpl.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set authorizationToken(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    /**
     * Sets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set speechRecognitionLanguage(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, s);
    }
    /**
     * Gets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @return {string} The speechRecognitionLanguage.
     */
    get speechRecognitionLanguage() {
      return this.privSpeechProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
     * @function
     * @public
     */
    get subscriptionKey() {
      return this.privSpeechProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_Key]);
    }
    /**
     * Gets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    get outputFormat() {
      return r.OutputFormat[this.privSpeechProperties.getProperty(e.OutputFormatPropertyName, void 0)];
    }
    /**
     * Gets/Sets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    set outputFormat(s) {
      this.privSpeechProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[s]);
    }
    /**
     * Gets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    get endpointId() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId);
    }
    /**
     * Gets/Sets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    set endpointId(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_EndpointId, s);
    }
    /**
     * Add a (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    addTargetLanguage(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value");
      const n = this.targetLanguages;
      n.includes(s) || (n.push(s), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, n.join(",")));
    }
    /**
     * Gets the (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.targetLanguages
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    get targetLanguages() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",") : [];
    }
    /**
     * Gets the voice name.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     */
    get voiceName() {
      return this.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_TranslationVoice]);
    }
    /**
     * Gets/Sets the voice of the translated language, enable voice synthesis output.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     * @param {string} value - The name of the voice.
     */
    set voiceName(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, s);
    }
    /**
     * Provides the region.
     * @member SpeechTranslationConfigImpl.prototype.region
     * @function
     * @public
     * @returns {string} The region.
     */
    get region() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_Region);
    }
    get tokenCredential() {
      return this.privTokenCredential;
    }
    setProxy(s, n, c, u) {
      this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyHostName], s), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPort], n), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    /**
     * Gets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {string} name - The name of the property.
     * @param {string} def - The default value of the property in case it is not set.
     * @returns {string} The value of the property.
     */
    getProperty(s, n) {
      return this.privSpeechProperties.getProperty(s, n);
    }
    /**
     * Gets/Sets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {string | PropertyId} name - The name of the property to set.
     * @param {string} value - The value of the property.
     */
    setProperty(s, n) {
      this.privSpeechProperties.setProperty(s, n);
    }
    /**
     * Provides access to custom properties.
     * @member SpeechTranslationConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechProperties;
    }
    /**
     * Dispose of associated resources.
     * @member SpeechTranslationConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
    setServiceProperty(s, n) {
      const c = JSON.parse(this.privSpeechProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
      c[s] = n, this.privSpeechProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceResponse_ProfanityOption, r.ProfanityOption[s]);
    }
    enableAudioLogging() {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    }
    enableDictation() {
      this.privSpeechProperties.setProperty(e.ForceDictationPropertyName, "true");
    }
    get speechSynthesisLanguage() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, s);
    }
    get speechSynthesisVoiceName() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, s);
    }
    get speechSynthesisOutputFormat() {
      return r.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, r.SpeechSynthesisOutputFormat[s]);
    }
  }
  return yt.SpeechTranslationConfigImpl = i, yt;
}
var Xr = {}, bl;
function mv() {
  if (bl) return Xr;
  bl = 1, Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.PropertyCollection = void 0;
  const e = /* @__PURE__ */ A();
  let t = class gv {
    constructor() {
      this.privKeys = [], this.privValues = [];
    }
    /**
     * Returns the property value in type String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member PropertyCollection.prototype.getProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string | number | boolean} def - The default value which is returned if the parameter
     * is not available in the collection.
     * @returns {string} value of the parameter.
     */
    getProperty(o, i) {
      let a;
      typeof o == "string" ? a = o : a = e.PropertyId[o];
      for (let s = 0; s < this.privKeys.length; s++)
        if (this.privKeys[s] === a)
          return this.privValues[s];
      if (i !== void 0)
        return String(i);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member PropertyCollection.prototype.setProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    setProperty(o, i) {
      let a;
      typeof o == "string" ? a = o : a = e.PropertyId[o];
      for (let s = 0; s < this.privKeys.length; s++)
        if (this.privKeys[s] === a) {
          this.privValues[s] = i;
          return;
        }
      this.privKeys.push(a), this.privValues.push(i);
    }
    /**
     * Clones the collection.
     * @member PropertyCollection.prototype.clone
     * @function
     * @public
     * @returns {PropertyCollection} A copy of the collection.
     */
    clone() {
      const o = new gv();
      for (let i = 0; i < this.privKeys.length; i++)
        o.privKeys.push(this.privKeys[i]), o.privValues.push(this.privValues[i]);
      return o;
    }
    /**
     * Merges this set of properties into another, no overwrites.
     * @member PropertyCollection.prototype.mergeTo
     * @function
     * @public
     * @param {PropertyCollection}  destinationCollection - The collection to merge into.
     */
    mergeTo(o) {
      this.privKeys.forEach((i) => {
        if (o.getProperty(i, void 0) === void 0) {
          const a = this.getProperty(i);
          o.setProperty(i, a);
        }
      });
    }
    /**
     * Get the keys in Property Collection.
     * @member PropertyCollection.prototype.keys
     * @function
     * @public
     * @returns {string []} Keys in the collection.
     */
    get keys() {
      return this.privKeys;
    }
  };
  return Xr.PropertyCollection = t, Xr;
}
var Ho = {}, wl;
function pc() {
  return wl || (wl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PropertyId = void 0, function(t) {
      t[t.SpeechServiceConnection_Key = 0] = "SpeechServiceConnection_Key", t[t.SpeechServiceConnection_Endpoint = 1] = "SpeechServiceConnection_Endpoint", t[t.SpeechServiceConnection_Region = 2] = "SpeechServiceConnection_Region", t[t.SpeechServiceAuthorization_Token = 3] = "SpeechServiceAuthorization_Token", t[t.SpeechServiceAuthorization_Type = 4] = "SpeechServiceAuthorization_Type", t[t.SpeechServiceConnection_EndpointId = 5] = "SpeechServiceConnection_EndpointId", t[t.SpeechServiceConnection_TranslationToLanguages = 6] = "SpeechServiceConnection_TranslationToLanguages", t[t.SpeechServiceConnection_TranslationVoice = 7] = "SpeechServiceConnection_TranslationVoice", t[t.SpeechServiceConnection_TranslationFeatures = 8] = "SpeechServiceConnection_TranslationFeatures", t[t.SpeechServiceConnection_TranslationCategoryId = 9] = "SpeechServiceConnection_TranslationCategoryId", t[t.SpeechServiceConnection_IntentRegion = 10] = "SpeechServiceConnection_IntentRegion", t[t.SpeechServiceConnection_ProxyHostName = 11] = "SpeechServiceConnection_ProxyHostName", t[t.SpeechServiceConnection_ProxyPort = 12] = "SpeechServiceConnection_ProxyPort", t[t.SpeechServiceConnection_ProxyUserName = 13] = "SpeechServiceConnection_ProxyUserName", t[t.SpeechServiceConnection_ProxyPassword = 14] = "SpeechServiceConnection_ProxyPassword", t[t.SpeechServiceConnection_RecoMode = 15] = "SpeechServiceConnection_RecoMode", t[t.SpeechServiceConnection_RecoLanguage = 16] = "SpeechServiceConnection_RecoLanguage", t[t.Speech_SessionId = 17] = "Speech_SessionId", t[t.SpeechServiceConnection_SynthLanguage = 18] = "SpeechServiceConnection_SynthLanguage", t[t.SpeechServiceConnection_SynthVoice = 19] = "SpeechServiceConnection_SynthVoice", t[t.SpeechServiceConnection_SynthOutputFormat = 20] = "SpeechServiceConnection_SynthOutputFormat", t[t.SpeechServiceConnection_AutoDetectSourceLanguages = 21] = "SpeechServiceConnection_AutoDetectSourceLanguages", t[t.SpeechServiceResponse_RequestDetailedResultTrueFalse = 22] = "SpeechServiceResponse_RequestDetailedResultTrueFalse", t[t.SpeechServiceResponse_RequestProfanityFilterTrueFalse = 23] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse", t[t.SpeechServiceResponse_JsonResult = 24] = "SpeechServiceResponse_JsonResult", t[t.SpeechServiceResponse_JsonErrorDetails = 25] = "SpeechServiceResponse_JsonErrorDetails", t[t.CancellationDetails_Reason = 26] = "CancellationDetails_Reason", t[t.CancellationDetails_ReasonText = 27] = "CancellationDetails_ReasonText", t[t.CancellationDetails_ReasonDetailedText = 28] = "CancellationDetails_ReasonDetailedText", t[t.LanguageUnderstandingServiceResponse_JsonResult = 29] = "LanguageUnderstandingServiceResponse_JsonResult", t[t.SpeechServiceConnection_Url = 30] = "SpeechServiceConnection_Url", t[t.SpeechServiceConnection_InitialSilenceTimeoutMs = 31] = "SpeechServiceConnection_InitialSilenceTimeoutMs", t[t.SpeechServiceConnection_EndSilenceTimeoutMs = 32] = "SpeechServiceConnection_EndSilenceTimeoutMs", t[t.Speech_SegmentationSilenceTimeoutMs = 33] = "Speech_SegmentationSilenceTimeoutMs", t[t.Speech_SegmentationMaximumTimeMs = 34] = "Speech_SegmentationMaximumTimeMs", t[t.Speech_SegmentationStrategy = 35] = "Speech_SegmentationStrategy", t[t.SpeechServiceConnection_EnableAudioLogging = 36] = "SpeechServiceConnection_EnableAudioLogging", t[t.SpeechServiceConnection_LanguageIdMode = 37] = "SpeechServiceConnection_LanguageIdMode", t[t.SpeechServiceConnection_RecognitionEndpointVersion = 38] = "SpeechServiceConnection_RecognitionEndpointVersion", t[t.SpeechServiceConnection_SpeakerIdMode = 39] = "SpeechServiceConnection_SpeakerIdMode", t[t.SpeechServiceResponse_ProfanityOption = 40] = "SpeechServiceResponse_ProfanityOption", t[t.SpeechServiceResponse_PostProcessingOption = 41] = "SpeechServiceResponse_PostProcessingOption", t[t.SpeechServiceResponse_RequestWordLevelTimestamps = 42] = "SpeechServiceResponse_RequestWordLevelTimestamps", t[t.SpeechServiceResponse_StablePartialResultThreshold = 43] = "SpeechServiceResponse_StablePartialResultThreshold", t[t.SpeechServiceResponse_OutputFormatOption = 44] = "SpeechServiceResponse_OutputFormatOption", t[t.SpeechServiceResponse_TranslationRequestStablePartialResult = 45] = "SpeechServiceResponse_TranslationRequestStablePartialResult", t[t.SpeechServiceResponse_RequestWordBoundary = 46] = "SpeechServiceResponse_RequestWordBoundary", t[t.SpeechServiceResponse_RequestPunctuationBoundary = 47] = "SpeechServiceResponse_RequestPunctuationBoundary", t[t.SpeechServiceResponse_RequestSentenceBoundary = 48] = "SpeechServiceResponse_RequestSentenceBoundary", t[t.SpeechServiceResponse_DiarizeIntermediateResults = 49] = "SpeechServiceResponse_DiarizeIntermediateResults", t[t.Conversation_ApplicationId = 50] = "Conversation_ApplicationId", t[t.Conversation_DialogType = 51] = "Conversation_DialogType", t[t.Conversation_Initial_Silence_Timeout = 52] = "Conversation_Initial_Silence_Timeout", t[t.Conversation_From_Id = 53] = "Conversation_From_Id", t[t.Conversation_Conversation_Id = 54] = "Conversation_Conversation_Id", t[t.Conversation_Custom_Voice_Deployment_Ids = 55] = "Conversation_Custom_Voice_Deployment_Ids", t[t.Conversation_Speech_Activity_Template = 56] = "Conversation_Speech_Activity_Template", t[t.Conversation_Request_Bot_Status_Messages = 57] = "Conversation_Request_Bot_Status_Messages", t[t.Conversation_Agent_Connection_Id = 58] = "Conversation_Agent_Connection_Id", t[t.SpeechServiceConnection_Host = 59] = "SpeechServiceConnection_Host", t[t.ConversationTranslator_Host = 60] = "ConversationTranslator_Host", t[t.ConversationTranslator_Name = 61] = "ConversationTranslator_Name", t[t.ConversationTranslator_CorrelationId = 62] = "ConversationTranslator_CorrelationId", t[t.ConversationTranslator_Token = 63] = "ConversationTranslator_Token", t[t.PronunciationAssessment_ReferenceText = 64] = "PronunciationAssessment_ReferenceText", t[t.PronunciationAssessment_GradingSystem = 65] = "PronunciationAssessment_GradingSystem", t[t.PronunciationAssessment_Granularity = 66] = "PronunciationAssessment_Granularity", t[t.PronunciationAssessment_EnableMiscue = 67] = "PronunciationAssessment_EnableMiscue", t[t.PronunciationAssessment_Json = 68] = "PronunciationAssessment_Json", t[t.PronunciationAssessment_Params = 69] = "PronunciationAssessment_Params", t[t.SpeakerRecognition_Api_Version = 70] = "SpeakerRecognition_Api_Version", t[t.WebWorkerLoadType = 71] = "WebWorkerLoadType", t[t.TalkingAvatarService_WebRTC_SDP = 72] = "TalkingAvatarService_WebRTC_SDP";
    }(e.PropertyId || (e.PropertyId = {}));
  }(Ho)), Ho;
}
var en = {}, El;
function RR() {
  if (El) return en;
  El = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.Recognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A();
  let i = class yv {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     * @param {PropertyCollection} properties - A set of properties to set on the recognizer
     * @param {IConnectionFactory} connectionFactory - The factory class used to create a custom IConnection for the recognizer
     */
    constructor(s, n, c, u) {
      this.audioConfig = s !== void 0 ? s : o.AudioConfig.fromDefaultMicrophoneInput(), this.privDisposed = !1, this.privProperties = n.clone(), this.privConnectionFactory = c, this.tokenCredential = u, this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */
    close(s, n) {
      r.Contracts.throwIfDisposed(this.privDisposed), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), s, n);
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privReco;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(s) {
      this.privDisposed || (this.privDisposed = !0, s && this.privReco && (await this.privReco.audioSource.turnOff(), await this.privReco.dispose()));
    }
    /**
     * This method returns the current state of the telemetry setting.
     * @member Recognizer.prototype.telemetryEnabled
     * @function
     * @public
     * @returns true if the telemetry is enabled, false otherwise.
     */
    static get telemetryEnabled() {
      return e.ServiceRecognizerBase.telemetryDataEnabled;
    }
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */
    static enableTelemetry(s) {
      e.ServiceRecognizerBase.telemetryDataEnabled = s;
    }
    // Does the generic recognizer setup that is common across all recognizer types.
    implCommonRecognizerSetup() {
      let s = typeof window < "u" ? "Browser" : "Node", n = "unknown", c = "unknown";
      typeof navigator < "u" && (s = s + "/" + navigator.platform, n = navigator.userAgent, c = navigator.appVersion);
      const u = this.createRecognizerConfig(new e.SpeechServiceConfig(new e.Context(new e.OS(s, n, c))));
      this.privReco = this.createServiceRecognizer(yv.getAuth(this.privProperties, this.tokenCredential), this.privConnectionFactory, this.audioConfig, u);
    }
    async recognizeOnceAsyncImpl(s) {
      r.Contracts.throwIfDisposed(this.privDisposed);
      const n = new t.Deferred();
      await this.implRecognizerStop(), await this.privReco.recognize(s, n.resolve, n.reject);
      const c = await n.promise;
      return await this.implRecognizerStop(), c;
    }
    async startContinuousRecognitionAsyncImpl(s) {
      r.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop(), await this.privReco.recognize(s, void 0, void 0);
    }
    async stopContinuousRecognitionAsyncImpl() {
      r.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop();
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    static getAuth(s, n) {
      const c = s.getProperty(o.PropertyId.SpeechServiceConnection_Key, void 0);
      return c && c !== "" ? new e.CognitiveSubscriptionKeyAuthentication(c) : n ? new e.CognitiveTokenAuthentication(async () => {
        try {
          return (await n.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (u) {
          throw u;
        }
      }, async () => {
        try {
          return (await n.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (u) {
          throw u;
        }
      }) : new e.CognitiveTokenAuthentication(() => {
        const u = s.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      }, () => {
        const u = s.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      });
    }
  };
  return en.Recognizer = i, en;
}
var tn = {}, Ko = {}, Il;
function Re() {
  return Il || (Il = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionMode = void 0, function(t) {
      t.Interactive = "Interactive", t.Dictation = "Dictation", t.Conversation = "Conversation", t.None = "None";
    }(e.RecognitionMode || (e.RecognitionMode = {}));
  }(Ko)), Ko;
}
var Al;
function PR() {
  if (Al) return tn;
  Al = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.SpeechRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ Re(), r = /* @__PURE__ */ O(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ A();
  let a = class Sv extends i.Recognizer {
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      o.Contracts.throwIfNull(u, "speechConfig"), o.Contracts.throwIfNullOrWhitespace(u.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new e.SpeechConnectionFactory(), n.tokenCredential), this.privDisposedRecognizer = !1;
    }
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(n, c, u) {
      const l = n;
      return c.properties.mergeTo(l.properties), new Sv(n, u);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for speech recognition.
     * @member SpeechRecognizer.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      o.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * Gets the spoken language of recognition.
     * @member SpeechRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of recognition.
     * @member SpeechRecognizer.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of recognition.
     */
    get outputFormat() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(e.OutputFormatPropertyName, i.OutputFormat[i.OutputFormat.Simple]) === i.OutputFormat[i.OutputFormat.Simple] ? i.OutputFormat.Simple : i.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this SpeechRecognizer.
     * @member SpeechRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts speech recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition
     * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member SpeechRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the SpeechRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), n, c);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(this.properties.getProperty(e.ForceDictationPropertyName, void 0) === void 0 ? t.RecognitionMode.Conversation : t.RecognitionMode.Dictation), n, c);
    }
    /**
     * Stops continuous speech recognition.
     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * Starts speech recognition with keyword spotting, until
     * stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model The keyword recognition model that
     * specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(n, c, u) {
      o.Contracts.throwIfNull(n, "model"), u && u("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(n) {
      n && n();
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member SpeechRecognizer.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new e.SpeechServiceRecognizer(n, c, p, l, this);
    }
  };
  return tn.SpeechRecognizer = a, tn;
}
var rn = {}, Tl;
function bR() {
  if (Tl) return rn;
  Tl = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.IntentRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ Re(), r = /* @__PURE__ */ O(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ A();
  let a = class extends i.Recognizer {
    /**
     * Initializes an instance of the IntentRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(n, c) {
      o.Contracts.throwIfNullOrUndefined(n, "speechConfig");
      const u = n;
      o.Contracts.throwIfNullOrUndefined(u, "speechConfig"), super(c, u.properties, new e.IntentConnectionFactory()), this.privAddedIntents = [], this.privAddedLmIntents = {}, this.privDisposedIntentRecognizer = !1, this.privProperties = u.properties, o.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * Gets the spoken language of recognition.
     * @member IntentRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} the spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(n) {
      this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * The collection of properties and their values defined for this IntentRecognizer.
     * @member IntentRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their
     * values defined for this IntentRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts intent recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text and intent as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition like command or query.
     * For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member IntentRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(n, c) {
      if (o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const u = this.buildSpeechContext();
        this.privReco.speechContext.getContext().intent = u.Intent, this.privReco.dynamicGrammar.addReferenceGrammar(u.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), n, c);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(n, c) {
      if (Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const u = this.buildSpeechContext();
        this.privReco.speechContext.getContext().intent = u.Intent, this.privReco.dynamicGrammar.addReferenceGrammar(u.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), n, c);
    }
    /**
     * Stops continuous intent recognition.
     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(n, c, u) {
      o.Contracts.throwIfNull(n, "model"), u && u("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(n, c) {
      if (n)
        try {
          n();
        } catch (u) {
          c && c(u);
        }
    }
    /**
     * Adds a phrase that should be recognized as intent.
     * @member IntentRecognizer.prototype.addIntent
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
     * @param {string} phrase - A String that specifies the phrase representing the intent.
     */
    addIntent(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), o.Contracts.throwIfNullOrWhitespace(c, "intentId"), o.Contracts.throwIfNullOrWhitespace(n, "simplePhrase"), this.privAddedIntents.push([c, n]);
    }
    /**
     * Adds an intent from Language Understanding service for recognition.
     * @member IntentRecognizer.prototype.addIntentWithLanguageModel
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent
     * to be recognized. Ignored if intentName is empty.
     * @param {string} model - The intent model from Language Understanding service.
     * @param {string} intentName - The intent name defined in the intent model. If it
     * is empty, all intent names defined in the model will be added.
     */
    addIntentWithLanguageModel(n, c, u) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), o.Contracts.throwIfNullOrWhitespace(n, "intentId"), o.Contracts.throwIfNull(c, "model");
      const l = c;
      o.Contracts.throwIfNullOrWhitespace(l.appId, "model.appId"), this.privAddedLmIntents[n] = new e.AddedLmIntent(l, u);
    }
    /**
     * @summary Adds all intents from the specified Language Understanding Model.
     * @member IntentRecognizer.prototype.addAllIntents
     * @function
     * @public
     * @function
     * @public
     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
     */
    addAllIntents(n, c) {
      o.Contracts.throwIfNull(n, "model");
      const u = n;
      o.Contracts.throwIfNullOrWhitespace(u.appId, "model.appId"), this.privUmbrellaIntent = new e.AddedLmIntent(u, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member IntentRecognizer.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new e.IntentServiceRecognizer(n, c, p, l, this);
    }
    async dispose(n) {
      this.privDisposedIntentRecognizer || n && (this.privDisposedIntentRecognizer = !0, await super.dispose(n));
    }
    buildSpeechContext() {
      let n, c, u;
      const l = [];
      this.privUmbrellaIntent !== void 0 && (n = this.privUmbrellaIntent.modelImpl.appId, c = this.privUmbrellaIntent.modelImpl.region, u = this.privUmbrellaIntent.modelImpl.subscriptionKey);
      for (const p of Object.keys(this.privAddedLmIntents)) {
        const d = this.privAddedLmIntents[p];
        if (n === void 0)
          n = d.modelImpl.appId;
        else if (n !== d.modelImpl.appId)
          throw new Error("Intents must all be from the same LUIS model");
        if (c === void 0)
          c = d.modelImpl.region;
        else if (c !== d.modelImpl.region)
          throw new Error("Intents must all be from the same LUIS model in a single region");
        if (u === void 0)
          u = d.modelImpl.subscriptionKey;
        else if (u !== d.modelImpl.subscriptionKey)
          throw new Error("Intents must all use the same subscription key");
        const h = "luis/" + n + "-PRODUCTION#" + p;
        l.push(h);
      }
      return {
        Intent: {
          id: n,
          key: u === void 0 ? this.privProperties.getProperty(i.PropertyId[i.PropertyId.SpeechServiceConnection_Key]) : u,
          provider: "LUIS"
        },
        ReferenceGrammars: this.privUmbrellaIntent === void 0 ? l : ["luis/" + n + "-PRODUCTION"]
      };
    }
  };
  return rn.IntentRecognizer = a, rn;
}
var Jo = {}, _l;
function wR() {
  return _l || (_l = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.VoiceProfileType = void 0, function(t) {
      t[t.TextIndependentIdentification = 0] = "TextIndependentIdentification", t[t.TextDependentVerification = 1] = "TextDependentVerification", t[t.TextIndependentVerification = 2] = "TextIndependentVerification";
    }(e.VoiceProfileType || (e.VoiceProfileType = {}));
  }(Jo)), Jo;
}
var nn = {}, sn = {}, St = {}, kl;
function Cv() {
  if (kl) return St;
  kl = 1, Object.defineProperty(St, "__esModule", { value: !0 }), St.ConnectionMessageImpl = St.ConnectionMessage = void 0;
  const e = /* @__PURE__ */ pe(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ mv(), o = /* @__PURE__ */ pc();
  let i = class {
  };
  St.ConnectionMessage = i;
  class a {
    constructor(n) {
      this.privConnectionMessage = n, this.privProperties = new r.PropertyCollection(), this.privConnectionMessage.headers[e.HeaderNames.ConnectionId] && this.privProperties.setProperty(o.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[e.HeaderNames.ConnectionId]), Object.keys(this.privConnectionMessage.headers).forEach((c) => {
        this.privProperties.setProperty(c, this.privConnectionMessage.headers[c]);
      });
    }
    /**
     * The message path.
     */
    get path() {
      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((n) => n.toLowerCase() === "path".toLowerCase())];
    }
    /**
     * Checks to see if the ConnectionMessage is a text message.
     * See also IsBinaryMessage().
     */
    get isTextMessage() {
      return this.privConnectionMessage.messageType === t.MessageType.Text;
    }
    /**
     * Checks to see if the ConnectionMessage is a binary message.
     * See also GetBinaryMessage().
     */
    get isBinaryMessage() {
      return this.privConnectionMessage.messageType === t.MessageType.Binary;
    }
    /**
     * Gets the text message payload. Typically the text message content-type is
     * application/json. To determine other content-types use
     * Properties.GetProperty("Content-Type").
     */
    get TextMessage() {
      return this.privConnectionMessage.textBody;
    }
    /**
     * Gets the binary message payload.
     */
    get binaryMessage() {
      return this.privConnectionMessage.binaryBody;
    }
    /**
     * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
     * Message headers can be accessed via this collection (e.g. "Content-Type").
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Returns a string that represents the connection message.
     */
    toString() {
      return "";
    }
  }
  return St.ConnectionMessageImpl = a, St;
}
var Ol;
function Rv() {
  if (Ol) return sn;
  Ol = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.Connection = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ Cv(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ A();
  let a = class Ka {
    /**
     * Gets the Connection instance from the specified recognizer.
     * @param recognizer The recognizer associated with the connection.
     * @return The Connection instance of the recognizer.
     */
    static fromRecognizer(n) {
      const c = n.internalData, u = new Ka();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Gets the Connection instance from the specified synthesizer.
     * @param synthesizer The synthesizer associated with the connection.
     * @return The Connection instance of the synthesizer.
     */
    static fromSynthesizer(n) {
      const c = n.internalData, u = new Ka();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Starts to set up connection to the service.
     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     */
    openConnection(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.connect(), n, c);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
     *
     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
     */
    closeConnection(n, c) {
      if (this.privInternalData instanceof e.SynthesisAdapterBase)
        throw new Error("Disconnecting a synthesizer's connection is currently not supported");
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.disconnect(), n, c);
    }
    /**
     * Appends a parameter in a message to service.
     * Added in version 1.12.1.
     * @param path The path of the network message.
     * @param propertyName Name of the property
     * @param propertyValue Value of the property. This is a json string.
     */
    setMessageProperty(n, c, u) {
      if (o.Contracts.throwIfNullOrWhitespace(c, "propertyName"), this.privInternalData instanceof e.ServiceRecognizerBase) {
        if (n.toLowerCase() !== "speech.context")
          throw new Error("Only speech.context message property sets are currently supported for recognizer");
        {
          const l = this.privInternalData.speechContext.getContext();
          l[c] = u;
        }
      } else if (this.privInternalData instanceof e.SynthesisAdapterBase) {
        if (n.toLowerCase() !== "synthesis.context")
          throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
        this.privInternalData.synthesisContext.setSection(c, u);
      }
    }
    /**
     * Sends a message to the speech service.
     * Added in version 1.13.0.
     * @param path The WebSocket path of the message
     * @param payload The payload of the message. This is a json string or a ArrayBuffer.
     * @param success A callback to indicate success.
     * @param error A callback to indicate an error.
     */
    sendMessageAsync(n, c, u, l) {
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.sendNetworkMessage(n, c), u, l);
    }
    /**
     * Dispose of associated resources.
     */
    close() {
    }
    setupEvents() {
      this.privEventListener = this.privInternalData.connectionEvents.attach((n) => {
        n.name === "ConnectionEstablishedEvent" ? this.connected && this.connected(new i.ConnectionEventArgs(n.connectionId)) : n.name === "ConnectionClosedEvent" ? this.disconnected && this.disconnected(new i.ConnectionEventArgs(n.connectionId)) : n.name === "ConnectionMessageSentEvent" ? this.messageSent && this.messageSent(new i.ConnectionMessageEventArgs(new r.ConnectionMessageImpl(n.message))) : n.name === "ConnectionMessageReceivedEvent" && this.messageReceived && this.messageReceived(new i.ConnectionMessageEventArgs(new r.ConnectionMessageImpl(n.message)));
      }), this.privServiceEventListener = this.privInternalData.serviceEvents.attach((n) => {
        this.receivedServiceMessage && this.receivedServiceMessage(new i.ServiceEventArgs(n.jsonString, n.name));
      });
    }
  };
  return sn.Connection = a, sn;
}
var Ml;
function ER() {
  if (Ml) return nn;
  Ml = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.TranslationRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ Re(), r = /* @__PURE__ */ O(), o = /* @__PURE__ */ Rv(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ A();
  let s = class Pv extends a.Recognizer {
    /**
     * Initializes an instance of the TranslationRecognizer.
     * @constructor
     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
     */
    constructor(c, u, l) {
      const p = c;
      i.Contracts.throwIfNull(p, "speechConfig"), super(u, p.properties, l || new e.TranslationConnectionFactory(), c.tokenCredential), this.privDisposedTranslationRecognizer = !1, this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice), a.PropertyId[a.PropertyId.SpeechServiceConnection_TranslationVoice]), i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages), a.PropertyId[a.PropertyId.SpeechServiceConnection_TranslationToLanguages]), i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage), a.PropertyId[a.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * TranslationRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(c, u, l) {
      const p = c;
      return u.properties.mergeTo(p.properties), u.properties.getProperty(a.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0) === e.AutoDetectSourceLanguagesOpenRangeOptionName && p.properties.setProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), new Pv(c, l);
    }
    /**
     * Gets the language name that was set when the recognizer was created.
     * @member TranslationRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} Gets the language name that was set when the recognizer was created.
     */
    get speechRecognitionLanguage() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets target languages for translation that were set when the recognizer was created.
     * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
     * @member TranslationRecognizer.prototype.targetLanguages
     * @function
     * @public
     * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
     */
    get targetLanguages() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
    }
    /**
     * Gets the name of output voice.
     * @member TranslationRecognizer.prototype.voiceName
     * @function
     * @public
     * @returns {string} the name of output voice.
     */
    get voiceName() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
    }
    /**
     * The collection of properties and their values defined for this TranslationRecognizer.
     * @member TranslationRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(a.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(c) {
      this.properties.setProperty(a.PropertyId.SpeechServiceAuthorization_Token, c);
    }
    /**
     * Starts recognition and translation, and stops after the first utterance is recognized.
     * The task returns the translation text as result.
     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
     * for single shot recognition like command or query. For long-running recognition,
     * use startContinuousRecognitionAsync() instead.
     * @member TranslationRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the translation has completed.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(c, u) {
      i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), c, u);
    }
    /**
     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive translation results.
     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(c, u) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), c, u);
    }
    /**
     * Stops continuous recognition and translation.
     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(c, u) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), c, u);
    }
    /**
     * dynamically remove a language from list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.removeTargetLanguage
     * @function
     * @param lang - language to be removed
     * @public
     */
    removeTargetLanguage(c) {
      if (i.Contracts.throwIfNullOrUndefined(c, "language to be removed"), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        const u = this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), l = u.indexOf(c);
        l > -1 && (u.splice(l, 1), this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, u.join(",")), this.updateLanguages(u));
      }
    }
    /**
     * dynamically add a language to list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.addTargetLanguage
     * @function
     * @param lang - language to be added
     * @public
     */
    addTargetLanguage(c) {
      i.Contracts.throwIfNullOrUndefined(c, "language to be added");
      let u = [];
      this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? (u = this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), u.includes(c) || (u.push(c), this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, u.join(",")))) : (this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, c), u = [c]), this.updateLanguages(u);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member TranslationRecognizer.prototype.close
     * @function
     * @public
     */
    close(c, u) {
      i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), c, u);
    }
    /**
     * handles ConnectionEstablishedEvent for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onConnection
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onConnection() {
    }
    async dispose(c) {
      this.privDisposedTranslationRecognizer || (this.privDisposedTranslationRecognizer = !0, c && (await this.implRecognizerStop(), await super.dispose(c)));
    }
    createRecognizerConfig(c) {
      return new e.RecognizerConfig(c, this.privProperties);
    }
    createServiceRecognizer(c, u, l, p) {
      const d = l;
      return new e.TranslationServiceRecognizer(c, u, d, p, this);
    }
    updateLanguages(c) {
      const u = o.Connection.fromRecognizer(this);
      u && (u.setMessageProperty("speech.context", "translationcontext", { to: c }), u.sendMessageAsync("event", JSON.stringify({
        id: "translation",
        name: "updateLanguage",
        to: c
      })));
    }
  };
  return nn.TranslationRecognizer = s, nn;
}
var on = {}, Dl;
function IR() {
  if (Dl) return on;
  Dl = 1, Object.defineProperty(on, "__esModule", { value: !0 }), on.Translations = void 0;
  const e = /* @__PURE__ */ A();
  let t = class {
    constructor() {
      this.privMap = new e.PropertyCollection();
    }
    /**
     * Get the languages in the object in a String array.
     * @member Translations.prototype.languages
     * @function
     * @public
     * @returns {string[]} languages in translations object.
     */
    get languages() {
      return this.privMap.keys;
    }
    /**
     * Returns the parameter value in type String. The parameter must have the same type as String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member Translations.prototype.get
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} def - The default value which is returned if the parameter is not available in the collection.
     * @returns {string} value of the parameter.
     */
    get(o, i) {
      return this.privMap.getProperty(o, i);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member Translations.prototype.set
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    set(o, i) {
      this.privMap.setProperty(o, i);
    }
  };
  return on.Translations = t, on;
}
var Go = {}, Nl;
function AR() {
  return Nl || (Nl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NoMatchReason = void 0, function(t) {
      t[t.NotRecognized = 0] = "NotRecognized", t[t.InitialSilenceTimeout = 1] = "InitialSilenceTimeout", t[t.InitialBabbleTimeout = 2] = "InitialBabbleTimeout";
    }(e.NoMatchReason || (e.NoMatchReason = {}));
  }(Go)), Go;
}
var an = {}, xl;
function TR() {
  if (xl) return an;
  xl = 1, Object.defineProperty(an, "__esModule", { value: !0 }), an.NoMatchDetails = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ A();
  let r = class bv {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {NoMatchReason} reason - The no-match reason.
     */
    constructor(i) {
      this.privReason = i;
    }
    /**
     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
     * @member NoMatchDetails.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
     * result - The recognition result that was not recognized.
     * @returns {NoMatchDetails} The no match details object being created.
     */
    static fromResult(i) {
      const a = e.SimpleSpeechPhrase.fromJSON(i.json, 0);
      let s = t.NoMatchReason.NotRecognized;
      switch (a.RecognitionStatus) {
        case e.RecognitionStatus.BabbleTimeout:
          s = t.NoMatchReason.InitialBabbleTimeout;
          break;
        case e.RecognitionStatus.InitialSilenceTimeout:
          s = t.NoMatchReason.InitialSilenceTimeout;
          break;
        default:
          s = t.NoMatchReason.NotRecognized;
          break;
      }
      return new bv(s);
    }
    /**
     * The reason the recognition was canceled.
     * @member NoMatchDetails.prototype.reason
     * @function
     * @public
     * @returns {NoMatchReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
  };
  return an.NoMatchDetails = r, an;
}
var cn = {}, zl;
function _R() {
  if (zl) return cn;
  zl = 1, Object.defineProperty(cn, "__esModule", { value: !0 }), cn.TranslationRecognitionCanceledEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionid - The session id.
     * @param {CancellationReason} cancellationReason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {TranslationRecognitionResult} result - The result.
     */
    constructor(r, o, i, a, s) {
      this.privCancelReason = o, this.privErrorDetails = i, this.privResult = s, this.privSessionId = r, this.privErrorCode = a;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionCanceledEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
    /**
     * Specifies the session identifier.
     * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
     * @function
     * @public
     * @returns {string} the session identifier.
     */
    get sessionId() {
      return this.privSessionId;
    }
    /**
     * The reason the recognition was canceled.
     * @member TranslationRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privCancelReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return cn.TranslationRecognitionCanceledEventArgs = e, cn;
}
var un = {}, Ll;
function kR() {
  if (Ll) return un;
  Ll = 1, Object.defineProperty(un, "__esModule", { value: !0 }), un.IntentRecognitionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.IntentRecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} result - The result of the intent recognition.
     * @param {string} offset - The offset.
     * @param {IntentRecognitionResult} sessionId - The session id.
     */
    constructor(o, i, a, s, n, c) {
      super(s, n, c), this.privReason = o, this.privErrorDetails = i, this.privErrorCode = a;
    }
    /**
     * The reason the recognition was canceled.
     * @member IntentRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return un.IntentRecognitionCanceledEventArgs = t, un;
}
var ln = {}, jl;
function wv() {
  if (jl) return ln;
  jl = 1, Object.defineProperty(ln, "__esModule", { value: !0 }), ln.CancellationDetailsBase = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - The error details, if provided.
     */
    constructor(r, o, i) {
      this.privReason = r, this.privErrorDetails = o, this.privErrorCode = i;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationDetailsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member CancellationDetailsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get ErrorCode() {
      return this.privErrorCode;
    }
  };
  return ln.CancellationDetailsBase = e, ln;
}
var pn = {}, ql;
function OR() {
  if (ql) return pn;
  ql = 1, Object.defineProperty(pn, "__esModule", { value: !0 }), pn.CancellationDetails = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ wv(), r = /* @__PURE__ */ A();
  let o = class Ev extends t.CancellationDetailsBase {
    constructor(a, s, n) {
      super(a, s, n);
    }
    /**
     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
     * @member CancellationDetails.fromResult
     * @function
     * @public
     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
     * @returns {CancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      let s = r.CancellationReason.Error, n = r.CancellationErrorCode.NoError;
      if (a instanceof r.RecognitionResult && a.json) {
        const c = e.SimpleSpeechPhrase.fromJSON(a.json, 0);
        s = e.EnumTranslation.implTranslateCancelResult(c.RecognitionStatus);
      }
      return a.properties && (n = r.CancellationErrorCode[a.properties.getProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new Ev(s, a.errorDetails || e.EnumTranslation.implTranslateErrorDetails(n), n);
    }
  };
  return pn.CancellationDetails = o, pn;
}
var Qo = {}, Fl;
function MR() {
  return Fl || (Fl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationErrorCode = void 0, function(t) {
      t[t.NoError = 0] = "NoError", t[t.AuthenticationFailure = 1] = "AuthenticationFailure", t[t.BadRequestParameters = 2] = "BadRequestParameters", t[t.TooManyRequests = 3] = "TooManyRequests", t[t.ConnectionFailure = 4] = "ConnectionFailure", t[t.ServiceTimeout = 5] = "ServiceTimeout", t[t.ServiceError = 6] = "ServiceError", t[t.RuntimeError = 7] = "RuntimeError", t[t.Forbidden = 8] = "Forbidden";
    }(e.CancellationErrorCode || (e.CancellationErrorCode = {}));
  }(Qo)), Qo;
}
var dn = {}, Bl;
function DR() {
  if (Bl) return dn;
  Bl = 1, Object.defineProperty(dn, "__esModule", { value: !0 }), dn.ConnectionEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
  };
  return dn.ConnectionEventArgs = t, dn;
}
var hn = {}, Ul;
function NR() {
  if (Ul) return hn;
  Ul = 1, Object.defineProperty(hn, "__esModule", { value: !0 }), hn.ServiceEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} json - json payload of the USP message.
     */
    constructor(o, i, a) {
      super(a), this.privJsonResult = o, this.privEventName = i;
    }
    get jsonString() {
      return this.privJsonResult;
    }
    get eventName() {
      return this.privEventName;
    }
  };
  return hn.ServiceEventArgs = t, hn;
}
var fn = {}, $l;
function xR() {
  if ($l) return fn;
  $l = 1, Object.defineProperty(fn, "__esModule", { value: !0 }), fn.PhraseListGrammar = void 0;
  let e = class Iv {
    constructor(r) {
      this.privGrammerBuilder = r.dynamicGrammar;
    }
    /**
     * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
     * @param recognizer The recognizer to add phrase lists to.
     */
    static fromRecognizer(r) {
      const o = r.internalData;
      return new Iv(o);
    }
    /**
     * Adds a single phrase to the current recognizer.
     * @param phrase Phrase to add.
     */
    addPhrase(r) {
      this.privGrammerBuilder.addPhrase(r);
    }
    /**
     * Adds multiple phrases to the current recognizer.
     * @param phrases Array of phrases to add.
     */
    addPhrases(r) {
      this.privGrammerBuilder.addPhrase(r);
    }
    /**
     * Clears all phrases added to the current recognizer.
     */
    clear() {
      this.privGrammerBuilder.clearPhrases();
    }
  };
  return fn.PhraseListGrammar = e, fn;
}
var Ct = {}, Vl;
function dc() {
  if (Vl) return Ct;
  Vl = 1, Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.DialogServiceConfigImpl = Ct.DialogServiceConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class {
    /**
     * Creates an instance of DialogService config.
     * @constructor
     */
    constructor() {
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member DialogServiceConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set applicationId(a) {
    }
    static get DialogTypes() {
      return {
        BotFramework: "bot_framework",
        CustomCommands: "custom_commands"
      };
    }
  };
  Ct.DialogServiceConfig = r;
  class o extends r {
    /**
     * Creates an instance of dialogService config.
     */
    constructor() {
      super(), this.privSpeechConfig = new t.SpeechConfigImpl();
    }
    /**
     * Provides access to custom properties.
     * @member DialogServiceConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechConfig.properties;
    }
    /**
     * Gets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     */
    get speechRecognitionLanguage() {
      return this.privSpeechConfig.speechRecognitionLanguage;
    }
    /**
     * Sets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The language to set.
     */
    set speechRecognitionLanguage(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechConfig.speechRecognitionLanguage = a;
    }
    get outputFormat() {
      return this.privSpeechConfig.outputFormat;
    }
    set outputFormat(a) {
      this.privSpeechConfig.outputFormat = a;
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to set.
     * @param {string} value - The value.
     */
    setProperty(a, s) {
      this.privSpeechConfig.setProperty(a, s);
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to get.
     * @param {string} def - The default value to return in case the property is not known.
     * @returns {string} The current value, or provided default, of the given property.
     */
    getProperty(a, s) {
      return this.privSpeechConfig.getProperty(a);
    }
    /**
     * Sets the proxy configuration.
     * Only relevant in Node.js environments.
     * Added in version 1.4.0.
     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
     * @param proxyPort The port number of the proxy server.
     * @param proxyUserName The user name of the proxy server.
     * @param proxyPassword The password of the proxy server.
     */
    setProxy(a, s, n, c) {
      this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyHostName, a), this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyPort, `${s}`), n && this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyUserName, n), c && this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyPassword, c);
    }
    setServiceProperty(a, s, n) {
      this.privSpeechConfig.setServiceProperty(a, s);
    }
    /**
     * Dispose of associated resources.
     * @member DialogServiceConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
  }
  return Ct.DialogServiceConfigImpl = o, Ct;
}
var vn = {}, Wl;
function zR() {
  if (Wl) return vn;
  Wl = 1, Object.defineProperty(vn, "__esModule", { value: !0 }), vn.BotFrameworkConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ dc(), r = /* @__PURE__ */ A();
  let o = class extends t.DialogServiceConfigImpl {
    /**
     * Creates an instance of BotFrameworkConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates a bot framework configuration instance with the provided subscription information.
     * @member BotFrameworkConfig.fromSubscription
     * @function
     * @public
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromSubscription(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "subscription"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, s), n && c.setProperty(r.PropertyId.Conversation_ApplicationId, n), c;
    }
    /**
     * Creates a bot framework configuration instance for the specified authorization token and region.
     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
     * caller must refresh it by setting the authorizationToken property on the corresponding
     * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
     * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
     * original configuration's authorization token. Create a new configuration instance or set the
     * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
     * further DialogServiceConnectors.
     * @member BotFrameworkConfig.fromAuthorizationToken
     * @function
     * @public
     * @param authorizationToken The authorization token associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromAuthorizationToken(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, s), n && c.setProperty(r.PropertyId.Conversation_ApplicationId, n), c;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-default service host. The standard resource path will be
     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
     * property on the created BotFrameworkConfig instance.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromHost
     * @function
     * @public
     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
     * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
     * wss://{host}.convai.speech.azure.us.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromHost(a, s, n) {
      e.Contracts.throwIfNullOrUndefined(a, "host");
      const c = a instanceof URL ? a : new URL(`wss://${a}.convai.speech.azure.us`);
      e.Contracts.throwIfNullOrUndefined(c, "resolvedHost");
      const u = new t.DialogServiceConfigImpl();
      return u.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), u.setProperty(r.PropertyId.SpeechServiceConnection_Host, c.toString()), s !== void 0 && u.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), u;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
     * use the authorization token.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
     */
    static fromEndpoint(a, s) {
      e.Contracts.throwIfNull(a, "endpoint");
      const n = new t.DialogServiceConfigImpl();
      return n.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), n.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, a.toString()), s !== void 0 && n.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), n;
    }
  };
  return vn.BotFrameworkConfig = o, vn;
}
var gn = {}, Hl;
function LR() {
  if (Hl) return gn;
  Hl = 1, Object.defineProperty(gn, "__esModule", { value: !0 }), gn.CustomCommandsConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ dc(), r = /* @__PURE__ */ A();
  let o = class extends t.DialogServiceConfigImpl {
    /**
     * Creates an instance of CustomCommandsConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates an instance of the bot framework config with the specified subscription and region.
     * @member CustomCommandsConfig.fromSubscription
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new bot framework config.
     */
    static fromSubscription(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "applicationId"), e.Contracts.throwIfNullOrWhitespace(s, "subscription"), e.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(r.PropertyId.Conversation_ApplicationId, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member CustomCommandsConfig.fromAuthorizationToken
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param authorizationToken The authorization token associated with the application.
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new speech commands config.
     */
    static fromAuthorizationToken(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "applicationId"), e.Contracts.throwIfNullOrWhitespace(s, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(r.PropertyId.Conversation_ApplicationId, a), c.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    set applicationId(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.setProperty(r.PropertyId.Conversation_ApplicationId, a);
    }
    /**
     * Gets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to get.
     */
    get applicationId() {
      return this.getProperty(r.PropertyId.Conversation_ApplicationId);
    }
  };
  return gn.CustomCommandsConfig = o, gn;
}
var mn = {}, yn = {}, Sn = {}, Cn = {}, Kl;
function rt() {
  if (Kl) return Cn;
  Kl = 1, Object.defineProperty(Cn, "__esModule", { value: !0 }), Cn.QueryParameterNames = void 0;
  let e = class {
  };
  return Cn.QueryParameterNames = e, e.BotId = "botid", e.CustomSpeechDeploymentId = "cid", e.CustomVoiceDeploymentId = "deploymentId", e.EnableAudioLogging = "storeAudio", e.EnableLanguageId = "lidEnabled", e.EnableWordLevelTimestamps = "wordLevelTimestamps", e.EndSilenceTimeoutMs = "endSilenceTimeoutMs", e.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs", e.SegmentationMaximumTimeMs = "segmentationMaximumTimeMs", e.SegmentationStrategy = "segmentationStrategy", e.Format = "format", e.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs", e.Language = "language", e.Profanity = "profanity", e.RequestBotStatusMessages = "enableBotMessageStatus", e.StableIntermediateThreshold = "stableIntermediateThreshold", e.StableTranslation = "stableTranslation", e.TestHooks = "testhooks", e.Postprocessing = "postprocessing", e.CtsMeetingId = "meetingId", e.CtsDeviceId = "deviceId", e.CtsIsParticipant = "isParticipant", e.EnableAvatar = "enableTalkingAvatar", Cn;
}
var Jl;
function Te() {
  if (Jl) return Sn;
  Jl = 1, Object.defineProperty(Sn, "__esModule", { value: !0 }), Sn.ConnectionFactoryBase = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ rt();
  let i = class {
    static getHostSuffix(s) {
      if (s) {
        if (s.toLowerCase().startsWith("china"))
          return ".azure.cn";
        if (s.toLowerCase().startsWith("usgov"))
          return ".azure.us";
      }
      return ".microsoft.com";
    }
    setCommonUrlParams(s, n, c) {
      (/* @__PURE__ */ new Map([
        [r.PropertyId.Speech_SegmentationSilenceTimeoutMs, o.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceConnection_EnableAudioLogging, o.QueryParameterNames.EnableAudioLogging],
        [r.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, o.QueryParameterNames.EndSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, o.QueryParameterNames.InitialSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceResponse_PostProcessingOption, o.QueryParameterNames.Postprocessing],
        [r.PropertyId.SpeechServiceResponse_ProfanityOption, o.QueryParameterNames.Profanity],
        [r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, o.QueryParameterNames.EnableWordLevelTimestamps],
        [r.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, o.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((p, d) => {
        this.setUrlParameter(d, p, s, n, c);
      });
      const l = JSON.parse(s.parameters.getProperty(e.ServicePropertiesPropertyName, "{}"));
      Object.keys(l).forEach((p) => {
        n[p] = l[p];
      });
    }
    setUrlParameter(s, n, c, u, l) {
      const p = c.parameters.getProperty(s, void 0);
      p && (!l || l.search(n) === -1) && (u[n] = p.toLocaleLowerCase());
    }
    static async getRedirectUrlFromEndpoint(s) {
      let n;
      if (typeof window < "u" && typeof window.fetch < "u") {
        const c = new URL(s);
        c.protocol = "https:", c.port = "443", c.searchParams.append("GenerateRedirectResponse", "true");
        const l = c.toString();
        t.Events.instance.onEvent(new t.ConnectionRedirectEvent("", l, void 0, "ConnectionFactoryBase: redirectUrl request"));
        const p = await fetch(l);
        if (p.status !== 200)
          return s;
        n = await p.text();
      } else
        n = s;
      t.Events.instance.onEvent(new t.ConnectionRedirectEvent("", n, s, "ConnectionFactoryBase: redirectUrlString"));
      try {
        return new URL(n.trim()).toString();
      } catch {
        return s;
      }
    }
  };
  return Sn.ConnectionFactoryBase = i, Sn;
}
var Gl;
function jR() {
  if (Gl) return yn;
  Gl = 1, Object.defineProperty(yn, "__esModule", { value: !0 }), yn.DialogConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ Te(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ pe(), s = /* @__PURE__ */ rt();
  class n extends o.ConnectionFactoryBase {
    create(u, l, p) {
      const d = u.parameters.getProperty(r.PropertyId.Conversation_ApplicationId, ""), h = u.parameters.getProperty(r.PropertyId.Conversation_DialogType), f = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region), g = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), m = u.parameters.getProperty(r.PropertyId.Conversation_Request_Bot_Status_Messages, "true"), v = {};
      v[a.HeaderNames.ConnectionId] = p, v[s.QueryParameterNames.Format] = u.parameters.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase(), v[s.QueryParameterNames.Language] = g, v[s.QueryParameterNames.RequestBotStatusMessages] = m, d && (v[s.QueryParameterNames.BotId] = d, h === r.DialogServiceConfig.DialogTypes.CustomCommands && (v[a.HeaderNames.CustomCommandsAppId] = d));
      const y = h === r.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "", S = h === r.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : h === r.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0", C = {};
      l.token != null && l.token !== "" && (C[l.headerName] = l.token);
      let b = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, "");
      if (!b) {
        const I = o.ConnectionFactoryBase.getHostSuffix(f), E = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, `wss://${f}.${n.BaseUrl}${I}`);
        b = `${E.endsWith("/") ? E : E + "/"}${y}${n.ApiKey}/${S}`;
      }
      this.setCommonUrlParams(u, v, b);
      const w = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(b, v, C, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), w, p));
    }
  }
  return yn.DialogConnectionFactory = n, n.ApiKey = "api", n.BaseUrl = "convai.speech", yn;
}
var Ql;
function qR() {
  if (Ql) return mn;
  Ql = 1, Object.defineProperty(mn, "__esModule", { value: !0 }), mn.DialogServiceConnector = void 0;
  const e = /* @__PURE__ */ jR(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ Re(), o = /* @__PURE__ */ O(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ A(), s = /* @__PURE__ */ pc();
  let n = class extends a.Recognizer {
    /**
     * Initializes an instance of the DialogServiceConnector.
     * @constructor
     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     */
    constructor(u, l) {
      const p = u;
      i.Contracts.throwIfNull(u, "dialogConfig"), super(l, p.properties, new e.DialogConnectionFactory()), this.isTurnComplete = !0, this.privIsDisposed = !1, this.privProperties = p.properties.clone();
      const d = this.buildAgentConfig();
      this.privReco.agentConfig.set(d);
    }
    /**
     * Starts a connection to the service.
     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     * @member DialogServiceConnector.prototype.connect
     * @function
     * @public
     */
    connect(u, l) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.connect(), u, l);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
     *
     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
     */
    disconnect(u, l) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.disconnect(), u, l);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Sets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(u) {
      i.Contracts.throwIfNullOrWhitespace(u, "token"), this.properties.setProperty(s.PropertyId.SpeechServiceAuthorization_Token, u);
    }
    /**
     * The collection of properties and their values defined for this DialogServiceConnector.
     * @member DialogServiceConnector.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
     */
    get properties() {
      return this.privProperties;
    }
    /** Gets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be empty
     */
    get speechActivityTemplate() {
      return this.properties.getProperty(s.PropertyId.Conversation_Speech_Activity_Template);
    }
    /** Sets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be null or empty.
     * Note: it has to be a valid Json object.
     */
    set speechActivityTemplate(u) {
      this.properties.setProperty(s.PropertyId.Conversation_Speech_Activity_Template, u);
    }
    /**
     * Starts recognition and stops after the first utterance is recognized.
     * @member DialogServiceConnector.prototype.listenOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the reco has completed.
     * @param err - Callback invoked in case of an error.
     */
    listenOnceAsync(u, l) {
      if (this.isTurnComplete) {
        i.Contracts.throwIfDisposed(this.privIsDisposed);
        const d = (async () => {
          await this.privReco.connect(), await this.implRecognizerStop(), this.isTurnComplete = !1;
          const h = new o.Deferred();
          await this.privReco.recognize(r.RecognitionMode.Conversation, h.resolve, h.reject);
          const f = await h.promise;
          return await this.implRecognizerStop(), f;
        })();
        d.catch(() => {
          this.dispose(!0).catch(() => {
          });
        }), (0, o.marshalPromiseToCallbacks)(d.finally(() => {
          this.isTurnComplete = !0;
        }), u, l);
      }
    }
    sendActivityAsync(u, l, p) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.sendMessage(u), l, p);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member DialogServiceConnector.prototype.close
     * @function
     * @public
     */
    close(u, l) {
      i.Contracts.throwIfDisposed(this.privIsDisposed), (0, o.marshalPromiseToCallbacks)(this.dispose(!0), u, l);
    }
    async dispose(u) {
      this.privIsDisposed || u && (this.privIsDisposed = !0, await this.implRecognizerStop(), await super.dispose(u));
    }
    createRecognizerConfig(u) {
      return new t.RecognizerConfig(u, this.privProperties);
    }
    createServiceRecognizer(u, l, p, d) {
      const h = p;
      return new t.DialogServiceAdapter(u, l, h, d, this);
    }
    buildAgentConfig() {
      return {
        botInfo: {
          commType: this.properties.getProperty("Conversation_Communication_Type", "Default"),
          commandsCulture: void 0,
          connectionId: this.properties.getProperty(s.PropertyId.Conversation_Agent_Connection_Id),
          conversationId: this.properties.getProperty(s.PropertyId.Conversation_Conversation_Id, void 0),
          fromId: this.properties.getProperty(s.PropertyId.Conversation_From_Id, void 0),
          ttsAudioFormat: this.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)
        },
        version: 0.2
      };
    }
  };
  return mn.DialogServiceConnector = n, mn;
}
var Rn = {}, Yl;
function FR() {
  if (Yl) return Rn;
  Yl = 1, Object.defineProperty(Rn, "__esModule", { value: !0 }), Rn.ActivityReceivedEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {any} activity - The activity..
     */
    constructor(r, o) {
      this.privActivity = r, this.privAudioStream = o;
    }
    /**
     * Gets the received activity
     * @member ActivityReceivedEventArgs.prototype.activity
     * @function
     * @public
     * @returns {any} the received activity.
     */
    get activity() {
      return this.privActivity;
    }
    get audioStream() {
      return this.privAudioStream;
    }
  };
  return Rn.ActivityReceivedEventArgs = e, Rn;
}
var Pn = {}, bn = {}, Zl;
function BR() {
  if (Zl) return bn;
  Zl = 1, Object.defineProperty(bn, "__esModule", { value: !0 }), bn.TurnStatusResponsePayload = void 0;
  class e {
    constructor(r) {
      this.privMessageStatusResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new e(r);
    }
    get interactionId() {
      return this.privMessageStatusResponse.interactionId;
    }
    get conversationId() {
      return this.privMessageStatusResponse.conversationId;
    }
    get statusCode() {
      switch (this.privMessageStatusResponse.statusCode) {
        case "Success":
          return 200;
        case "Failed":
          return 400;
        case "TimedOut":
          return 429;
        default:
          return this.privMessageStatusResponse.statusCode;
      }
    }
  }
  return bn.TurnStatusResponsePayload = e, bn;
}
var Xl;
function UR() {
  if (Xl) return Pn;
  Xl = 1, Object.defineProperty(Pn, "__esModule", { value: !0 }), Pn.TurnStatusReceivedEventArgs = void 0;
  const e = /* @__PURE__ */ BR();
  let t = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} turnStatus - The JSON-encoded turn status message.
     */
    constructor(o) {
      this.privTurnStatus = e.TurnStatusResponsePayload.fromJSON(o);
    }
    /**
     * Gets the interaction identifier associated with this turn status event.
     * @member TurnStatusReceivedEventArgs.prototype.interactionId
     * @function
     * @public
     * @returns {any} the received interaction id.
     */
    get interactionId() {
      return this.privTurnStatus.interactionId;
    }
    /**
     * Gets the conversation identifier associated with this turn status event.
     * @member TurnStatusReceivedEventArgs.prototype.conversationId
     * @function
     * @public
     * @returns {any} the received conversation id.
     */
    get conversationId() {
      return this.privTurnStatus.conversationId;
    }
    /**
     * Gets the received turn status code.
     * @member TurnStatusReceivedEventArgs.prototype.statusCode
     * @function
     * @public
     * @returns {number} the received turn status.
     */
    get statusCode() {
      return this.privTurnStatus.statusCode;
    }
  };
  return Pn.TurnStatusReceivedEventArgs = t, Pn;
}
var Yo = {}, ep;
function $R() {
  return ep || (ep = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ServicePropertyChannel = void 0, function(t) {
      t[t.UriQueryParameter = 0] = "UriQueryParameter";
    }(e.ServicePropertyChannel || (e.ServicePropertyChannel = {}));
  }(Yo)), Yo;
}
var Zo = {}, tp;
function VR() {
  return tp || (tp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ProfanityOption = void 0, function(t) {
      t[t.Masked = 0] = "Masked", t[t.Removed = 1] = "Removed", t[t.Raw = 2] = "Raw";
    }(e.ProfanityOption || (e.ProfanityOption = {}));
  }(Zo)), Zo;
}
var wn = {}, rp;
function WR() {
  if (rp) return wn;
  rp = 1, Object.defineProperty(wn, "__esModule", { value: !0 }), wn.BaseAudioPlayer = void 0;
  const e = /* @__PURE__ */ De(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ jt();
  let o = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
     */
    constructor(a) {
      this.audioContext = null, this.gainNode = null, this.autoUpdateBufferTimer = 0, a === void 0 && (a = t.AudioStreamFormat.getDefaultInputFormat()), this.init(a);
    }
    /**
     * play Audio sample
     * @param newAudioData audio data to be played.
     */
    playAudioSample(a, s, n) {
      try {
        this.ensureInitializedContext();
        const c = this.formatAudioData(a), u = new Float32Array(this.samples.length + c.length);
        u.set(this.samples, 0), u.set(c, this.samples.length), this.samples = u, s && s();
      } catch (c) {
        n && n(c);
      }
    }
    /**
     * stops audio and clears the buffers
     */
    stopAudio(a, s) {
      this.audioContext !== null && (this.samples = new Float32Array(), clearInterval(this.autoUpdateBufferTimer), this.audioContext.close().then(() => {
        a && a();
      }, (n) => {
        s && s(n);
      }), this.audioContext = null);
    }
    init(a) {
      this.audioFormat = a, this.samples = new Float32Array();
    }
    ensureInitializedContext() {
      if (this.audioContext === null) {
        this.createAudioContext();
        const a = 200;
        this.autoUpdateBufferTimer = setInterval(() => {
          this.updateAudioBuffer();
        }, a);
      }
    }
    createAudioContext() {
      this.audioContext = r.AudioStreamFormatImpl.getAudioContext(), this.gainNode = this.audioContext.createGain(), this.gainNode.gain.value = 1, this.gainNode.connect(this.audioContext.destination), this.startTime = this.audioContext.currentTime;
    }
    formatAudioData(a) {
      switch (this.audioFormat.bitsPerSample) {
        case 8:
          return this.formatArrayBuffer(new Int8Array(a), 128);
        case 16:
          return this.formatArrayBuffer(new Int16Array(a), 32768);
        case 32:
          return this.formatArrayBuffer(new Int32Array(a), 2147483648);
        default:
          throw new e.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
      }
    }
    formatArrayBuffer(a, s) {
      const n = new Float32Array(a.length);
      for (let c = 0; c < a.length; c++)
        n[c] = a[c] / s;
      return n;
    }
    updateAudioBuffer() {
      if (this.samples.length === 0)
        return;
      const a = this.audioFormat.channels, s = this.audioContext.createBufferSource(), n = this.samples.length / a, c = this.audioContext.createBuffer(a, n, this.audioFormat.samplesPerSec);
      for (let u = 0; u < a; u++) {
        let l = u;
        const p = c.getChannelData(u);
        for (let d = 0; d < this.samples.length; d++, l += a)
          p[d] = this.samples[l];
      }
      this.startTime < this.audioContext.currentTime && (this.startTime = this.audioContext.currentTime), s.buffer = c, s.connect(this.gainNode), s.start(this.startTime), this.startTime += c.duration, this.samples = new Float32Array();
    }
    async playAudio(a) {
      this.audioContext === null && this.createAudioContext();
      const s = this.audioContext.createBufferSource(), n = this.audioContext.destination;
      await this.audioContext.decodeAudioData(a, (c) => {
        s.buffer = c, s.connect(n), s.start(0);
      });
    }
  };
  return wn.BaseAudioPlayer = o, wn;
}
var En = {}, np;
function HR() {
  if (np) return En;
  np = 1, Object.defineProperty(En, "__esModule", { value: !0 }), En.ConnectionMessageEventArgs = void 0;
  let e = class {
    constructor(r) {
      this.privConnectionMessage = r;
    }
    /**
     * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
     */
    get message() {
      return this.privConnectionMessage;
    }
    /**
     * Returns a string that represents the connection message event.
     */
    toString() {
      return "Message: " + this.privConnectionMessage.toString();
    }
  };
  return En.ConnectionMessageEventArgs = e, En;
}
var In = {}, ip;
function KR() {
  if (ip) return In;
  ip = 1, Object.defineProperty(In, "__esModule", { value: !0 }), In.VoiceProfile = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} profileId - profileId of this Voice Profile.
     * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
     */
    constructor(r, o) {
      this.privId = r, this.privProfileType = o;
    }
    /**
     * profileId of this Voice Profile instance
     * @member VoiceProfile.prototype.profileId
     * @function
     * @public
     * @returns {string} profileId of this Voice Profile instance.
     */
    get profileId() {
      return this.privId;
    }
    /**
     * profileType of this Voice Profile instance
     * @member VoiceProfile.prototype.profileType
     * @function
     * @public
     * @returns {VoiceProfileType} profile type of this Voice Profile instance.
     */
    get profileType() {
      return this.privProfileType;
    }
  };
  return In.VoiceProfile = e, In;
}
var Rt = {}, sp;
function JR() {
  if (sp) return Rt;
  sp = 1, Object.defineProperty(Rt, "__esModule", { value: !0 }), Rt.VoiceProfileEnrollmentCancellationDetails = Rt.VoiceProfileEnrollmentResult = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ A();
  let r = class Ja {
    constructor(a, s, n) {
      this.privReason = a, this.privProperties = new t.PropertyCollection(), this.privReason !== t.ResultReason.Canceled ? s && (this.privDetails = JSON.parse(s), this.privDetails.enrollmentStatus.toLowerCase() === "enrolling" && (this.privReason = t.ResultReason.EnrollingVoiceProfile)) : (this.privErrorDetails = n, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[t.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get enrollmentsCount() {
      return this.privDetails.enrollmentsCount;
    }
    get enrollmentsLength() {
      return this.privDetails.enrollmentsLength;
    }
    get properties() {
      return this.privProperties;
    }
    get enrollmentResultDetails() {
      return this.privDetails;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
    static FromIdentificationProfileList(a) {
      const s = [];
      for (const n of a.value) {
        const c = n.enrollmentStatus.toLowerCase() === "enrolling" ? t.ResultReason.EnrollingVoiceProfile : n.enrollmentStatus.toLowerCase() === "enrolled" ? t.ResultReason.EnrolledVoiceProfile : t.ResultReason.Canceled, u = new Ja(c, null, null);
        u.privDetails = this.getIdentificationDetails(n), s.push(u);
      }
      return s;
    }
    static FromVerificationProfileList(a) {
      const s = [];
      for (const n of a.value) {
        const c = n.enrollmentStatus.toLowerCase() === "enrolling" ? t.ResultReason.EnrollingVoiceProfile : n.enrollmentStatus.toLowerCase() === "enrolled" ? t.ResultReason.EnrolledVoiceProfile : t.ResultReason.Canceled, u = new Ja(c, null, null);
        u.privDetails = this.getVerificationDetails(n), s.push(u);
      }
      return s;
    }
    static getIdentificationDetails(a) {
      return {
        audioLength: a.audioLength ? parseFloat(a.audioLength) : 0,
        audioSpeechLength: a.audioSpeechLength ? parseFloat(a.audioSpeechLength) : 0,
        enrollmentStatus: a.enrollmentStatus,
        enrollmentsCount: a.enrollmentsCount || 0,
        enrollmentsLength: a.enrollmentsLength ? parseFloat(a.enrollmentsLength) : 0,
        enrollmentsSpeechLength: a.enrollmentsSpeechLength ? parseFloat(a.enrollmentsSpeechLength) : 0,
        profileId: a.profileId || a.identificationProfileId,
        remainingEnrollmentsSpeechLength: a.remainingEnrollmentsSpeechLength ? parseFloat(a.remainingEnrollmentsSpeechLength) : 0
      };
    }
    static getVerificationDetails(a) {
      return {
        audioLength: a.audioLength ? parseFloat(a.audioLength) : 0,
        audioSpeechLength: a.audioSpeechLength ? parseFloat(a.audioSpeechLength) : 0,
        enrollmentStatus: a.enrollmentStatus,
        enrollmentsCount: a.enrollmentsCount,
        enrollmentsLength: a.enrollmentsLength ? parseFloat(a.enrollmentsLength) : 0,
        enrollmentsSpeechLength: a.enrollmentsSpeechLength ? parseFloat(a.enrollmentsSpeechLength) : 0,
        profileId: a.profileId || a.verificationProfileId,
        remainingEnrollmentsCount: a.remainingEnrollments || a.remainingEnrollmentsCount,
        remainingEnrollmentsSpeechLength: a.remainingEnrollmentsSpeechLength ? parseFloat(a.remainingEnrollmentsSpeechLength) : 0
      };
    }
  };
  Rt.VoiceProfileEnrollmentResult = r;
  class o extends t.CancellationDetailsBase {
    constructor(a, s, n) {
      super(a, s, n);
    }
    /**
     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
     * @member VoiceProfileEnrollmentCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      const s = t.CancellationReason.Error;
      let n = t.CancellationErrorCode.NoError;
      return a.properties && (n = t.CancellationErrorCode[a.properties.getProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[t.CancellationErrorCode.NoError])]), new o(s, a.errorDetails, n);
    }
  }
  return Rt.VoiceProfileEnrollmentCancellationDetails = o, Rt;
}
var Pt = {}, op;
function GR() {
  if (op) return Pt;
  op = 1, Object.defineProperty(Pt, "__esModule", { value: !0 }), Pt.VoiceProfileCancellationDetails = Pt.VoiceProfileResult = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A();
  let o = class {
    constructor(s, n) {
      this.privReason = s, this.privProperties = new r.PropertyCollection(), s === r.ResultReason.Canceled && (t.Contracts.throwIfNullOrUndefined(n, "statusText"), this.privErrorDetails = n, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get properties() {
      return this.privProperties;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  Pt.VoiceProfileResult = o;
  class i extends r.CancellationDetailsBase {
    constructor(s, n, c) {
      super(s, n, c);
    }
    /**
     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
     * @member VoiceProfileCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileResult} result - The result that was canceled.
     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
     */
    static fromResult(s) {
      const n = r.CancellationReason.Error;
      let c = r.CancellationErrorCode.NoError;
      return s.properties && (c = r.CancellationErrorCode[s.properties.getProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new i(n, s.errorDetails, c);
    }
  }
  return Pt.VoiceProfileCancellationDetails = i, Pt;
}
var An = {}, ap;
function QR() {
  if (ap) return An;
  ap = 1, Object.defineProperty(An, "__esModule", { value: !0 }), An.VoiceProfilePhraseResult = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class extends t.VoiceProfileResult {
    constructor(i, a, s, n) {
      super(i, a), this.privPhrases = [], e.Contracts.throwIfNullOrUndefined(n, "phrase array"), this.privType = s, n && n[0] && (this.privPhrases = n);
    }
    get phrases() {
      return this.privPhrases;
    }
    get type() {
      return this.privType;
    }
  };
  return An.VoiceProfilePhraseResult = r, An;
}
var Tn = {}, cp;
function YR() {
  if (cp) return Tn;
  cp = 1, Object.defineProperty(Tn, "__esModule", { value: !0 }), Tn.VoiceProfileClient = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ hv(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A();
  let i = class extends o.Recognizer {
    /**
     * VoiceProfileClient constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
     */
    constructor(s) {
      r.Contracts.throwIfNullOrUndefined(s, "speechConfig");
      const n = s;
      r.Contracts.throwIfNull(n, "speechConfig"), super(t.AudioConfig.fromStreamInput(o.AudioInputStream.createPushStream()), n.properties, new e.VoiceProfileConnectionFactory()), this.privProperties = n.properties.clone(), this.privVoiceAdapter = this.privReco, this.privDisposedVoiceAdapter = !1;
    }
    /**
     * The collection of properties and their values defined for this VoiceProfileClient.
     * @member VoiceProfileClient.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(s) {
      r.Contracts.throwIfNullOrWhitespace(s, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.createProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Type of Voice Profile to be created
     * @param {string} lang Language string (locale) for Voice Profile
     * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
     */
    async createProfileAsync(s, n) {
      const c = await this.privVoiceAdapter.createProfile(s, n);
      return new o.VoiceProfile(c[0], s);
    }
    /**
     * Get current information of a voice profile
     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to retrieve info for
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async retrieveEnrollmentResultAsync(s) {
      return this.privVoiceAdapter.retrieveEnrollmentResult(s);
    }
    /**
     * Get all voice profiles on account with given voice profile type
     * @member VoiceProfileClient.prototype.getAllProfilesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
     * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
     */
    async getAllProfilesAsync(s) {
      return this.privVoiceAdapter.getAllProfiles(s);
    }
    /**
     * Get valid authorization phrases for voice profile enrollment
     * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
     * @param {string} lang Language string (locale) for Voice Profile
     */
    async getActivationPhrasesAsync(s, n) {
      return this.privVoiceAdapter.getActivationPhrases(s, n);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.enrollProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to create enrollment for
     * @param {AudioConfig} audioConfig source info from which to create enrollment
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async enrollProfileAsync(s, n) {
      const c = n;
      return r.Contracts.throwIfNullOrUndefined(c, "audioConfig"), this.audioConfig = n, this.privVoiceAdapter.SpeakerAudioSource = c, this.privVoiceAdapter.enrollProfile(s);
    }
    /**
     * Delete a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.deleteProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be deleted
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async deleteProfileAsync(s) {
      return this.privVoiceAdapter.deleteProfile(s);
    }
    /**
     * Remove all enrollments for a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.resetProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be reset
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async resetProfileAsync(s) {
      return this.privVoiceAdapter.resetProfile(s);
    }
    /**
     * Clean up object and close underlying connection
     * @member VoiceProfileClient.prototype.close
     * @function
     * @async
     * @public
     */
    async close() {
      await this.dispose(!0);
    }
    createServiceRecognizer(s, n, c, u) {
      const l = c;
      return new e.VoiceServiceRecognizer(s, n, l, u, this);
    }
    async dispose(s) {
      this.privDisposedVoiceAdapter || (this.privDisposedVoiceAdapter = !0, s && await super.dispose(s));
    }
    createRecognizerConfig(s) {
      return new e.RecognizerConfig(s, this.properties);
    }
    getResult(s, n) {
      return new o.VoiceProfileResult(s.ok ? n : o.ResultReason.Canceled, s.statusText);
    }
  };
  return Tn.VoiceProfileClient = i, Tn;
}
var _n = {}, up;
function ZR() {
  if (up) return _n;
  up = 1, Object.defineProperty(_n, "__esModule", { value: !0 }), _n.SpeakerRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A();
  let o = class extends r.Recognizer {
    /**
     * Initializes an instance of the SpeakerRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(a, s) {
      t.Contracts.throwIfNullOrUndefined(a, "speechConfig");
      const n = a;
      t.Contracts.throwIfNullOrUndefined(n, "speechConfig"), super(s, n.properties, new e.SpeakerRecognitionConnectionFactory()), this.privAudioConfigImpl = s, t.Contracts.throwIfNull(this.privAudioConfigImpl, "audioConfig"), this.privDisposedSpeakerRecognizer = !1, this.privProperties = n.properties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      t.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * The collection of properties and their values defined for this SpeakerRecognizer.
     * @member SpeakerRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Get recognition result for model using given audio
     * @member SpeakerRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @async
     * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
     * @param cb - Callback invoked once result is returned.
     * @param err - Callback invoked in case of an error.
     */
    async recognizeOnceAsync(a) {
      return t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), this.recognizeSpeakerOnceAsyncImpl(a);
    }
    /**
     * Included for compatibility
     * @member SpeakerRecognizer.prototype.close
     * @function
     * @public
     * @async
     */
    async close() {
      t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.dispose(!0);
    }
    async recognizeSpeakerOnceAsyncImpl(a) {
      t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.implRecognizerStop();
      const s = await this.privReco.recognizeSpeaker(a);
      return await this.implRecognizerStop(), s;
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    createRecognizerConfig(a) {
      return new e.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, s, n, c) {
      const u = n;
      return new e.SpeakerServiceRecognizer(a, s, u, c, this);
    }
    async dispose(a) {
      this.privDisposedSpeakerRecognizer || a && (this.privDisposedSpeakerRecognizer = !0, await super.dispose(a));
    }
  };
  return _n.SpeakerRecognizer = o, _n;
}
var kn = {}, lp;
function XR() {
  if (lp) return kn;
  lp = 1, Object.defineProperty(kn, "__esModule", { value: !0 }), kn.SpeakerIdentificationModel = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class Av {
    constructor(i) {
      if (this.privVoiceProfiles = [], this.privProfileIds = [], e.Contracts.throwIfNullOrUndefined(i, "VoiceProfiles"), i.length === 0)
        throw new Error("Empty Voice Profiles array");
      for (const a of i) {
        if (a.profileType !== t.VoiceProfileType.TextIndependentIdentification)
          throw new Error("Identification model can only be created from Identification profile: " + a.profileId);
        this.privVoiceProfiles.push(a), this.privProfileIds.push(a.profileId);
      }
    }
    static fromProfiles(i) {
      return new Av(i);
    }
    get voiceProfileIds() {
      return this.privProfileIds.join(",");
    }
    get profileIds() {
      return this.privProfileIds;
    }
    get scenario() {
      return "TextIndependentIdentification";
    }
  };
  return kn.SpeakerIdentificationModel = r, kn;
}
var On = {}, pp;
function eP() {
  if (pp) return On;
  pp = 1, Object.defineProperty(On, "__esModule", { value: !0 }), On.SpeakerVerificationModel = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class Tv {
    constructor(i) {
      if (e.Contracts.throwIfNullOrUndefined(i, "VoiceProfile"), i.profileType === t.VoiceProfileType.TextIndependentIdentification)
        throw new Error("Verification model cannot be created from Identification profile");
      this.privVoiceProfile = i;
    }
    static fromProfile(i) {
      return new Tv(i);
    }
    get voiceProfile() {
      return this.privVoiceProfile;
    }
    get profileIds() {
      return [this.voiceProfile.profileId];
    }
    get scenario() {
      return this.voiceProfile.profileType === t.VoiceProfileType.TextDependentVerification ? "TextDependentVerification" : "TextIndependentVerification";
    }
  };
  return On.SpeakerVerificationModel = r, On;
}
var Mn = {}, Xo = {}, dp;
function _v() {
  return dp || (dp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LanguageIdMode = void 0, function(t) {
      t[t.AtStart = 0] = "AtStart", t[t.Continuous = 1] = "Continuous";
    }(e.LanguageIdMode || (e.LanguageIdMode = {}));
  }(Xo)), Xo;
}
var hp;
function tP() {
  if (hp) return Mn;
  hp = 1, Object.defineProperty(Mn, "__esModule", { value: !0 }), Mn.AutoDetectSourceLanguageConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ _v();
  let i = class Ns {
    constructor() {
      this.privProperties = new r.PropertyCollection(), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart"), this.privLanguageIdMode = o.LanguageIdMode.AtStart;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromOpenRange
     * @function
     * @public
     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
     */
    static fromOpenRange() {
      const s = new Ns();
      return s.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, e.AutoDetectSourceLanguagesOpenRangeOptionName), s.properties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), s;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromLanguages
     * @function
     * @public
     * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
     */
    static fromLanguages(s) {
      t.Contracts.throwIfArrayEmptyOrWhitespace(s, "languages");
      const n = new Ns();
      return n.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, s.join()), n;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
     * @function
     * @public
     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
     */
    static fromSourceLanguageConfigs(s) {
      if (s.length < 1)
        throw new Error("Expected non-empty SourceLanguageConfig array.");
      const n = new Ns(), c = [];
      return s.forEach((u) => {
        if (c.push(u.language), u.endpointId !== void 0 && u.endpointId !== "") {
          const l = u.language + r.PropertyId.SpeechServiceConnection_EndpointId.toString();
          n.properties.setProperty(l, u.endpointId);
        }
      }), n.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, c.join()), n;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets an auto detected language config properties
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.mode
     * @function
     * @public
     * @param {LanguageIdMode} mode LID mode desired.
     * @summary Sets LID operation to desired mode
     */
    set mode(s) {
      s === o.LanguageIdMode.Continuous ? (this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous")) : (this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart")), this.privLanguageIdMode = s;
    }
  };
  return Mn.AutoDetectSourceLanguageConfig = i, Mn;
}
var Dn = {}, fp;
function rP() {
  if (fp) return Dn;
  fp = 1, Object.defineProperty(Dn, "__esModule", { value: !0 }), Dn.AutoDetectSourceLanguageResult = void 0;
  const e = /* @__PURE__ */ z();
  let t = class Ga {
    constructor(o, i) {
      e.Contracts.throwIfNullOrUndefined(o, "language"), e.Contracts.throwIfNullOrUndefined(i, "languageDetectionConfidence"), this.privLanguage = o, this.privLanguageDetectionConfidence = i;
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
     * @member AutoDetectSourceLanguageResult.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult} result - The recognition result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */
    static fromResult(o) {
      return new Ga(o.language, o.languageDetectionConfidence);
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
     * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
     * @function
     * @public
     * @param {ConversationTranscriptionResult} result - The transcription result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */
    static fromConversationTranscriptionResult(o) {
      return new Ga(o.language, o.languageDetectionConfidence);
    }
    get language() {
      return this.privLanguage;
    }
    get languageDetectionConfidence() {
      return this.privLanguageDetectionConfidence;
    }
  };
  return Dn.AutoDetectSourceLanguageResult = t, Dn;
}
var Nn = {}, vp;
function nP() {
  if (vp) return Nn;
  vp = 1, Object.defineProperty(Nn, "__esModule", { value: !0 }), Nn.SourceLanguageConfig = void 0;
  const e = /* @__PURE__ */ z();
  let t = class kv {
    constructor(o, i) {
      e.Contracts.throwIfNullOrUndefined(o, "language"), this.privLanguage = o, this.privEndpointId = i;
    }
    /**
     * @member SourceLanguageConfig.fromLanguage
     * @function
     * @public
     * @param {string} language language (eg. "en-US") value of config.
     * @param {string?} endpointId endpointId of model bound to given language of config.
     * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
     * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
     * Added in version 1.13.0.
     */
    static fromLanguage(o, i) {
      return new kv(o, i);
    }
    get language() {
      return this.privLanguage;
    }
    get endpointId() {
      return this.privEndpointId;
    }
  };
  return Nn.SourceLanguageConfig = t, Nn;
}
var ea = {}, gp;
function iP() {
  return gp || (gp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeakerRecognitionCancellationDetails = e.SpeakerRecognitionResult = e.SpeakerRecognitionResultType = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ A();
    var o;
    (function(s) {
      s[s.Verify = 0] = "Verify", s[s.Identify = 1] = "Identify";
    })(o = e.SpeakerRecognitionResultType || (e.SpeakerRecognitionResultType = {}));
    class i {
      constructor(n, c = r.ResultReason.RecognizedSpeaker, u = r.CancellationErrorCode.NoError, l = "") {
        this.privProperties = new r.PropertyCollection();
        const p = n.scenario === "TextIndependentIdentification" ? o.Identify : o.Verify;
        this.privReason = c, this.privReason !== r.ResultReason.Canceled ? p === o.Identify ? (this.privProfileId = n.identificationResult.identifiedProfile.profileId, this.privScore = n.identificationResult.identifiedProfile.score, this.privReason = r.ResultReason.RecognizedSpeakers) : (this.privScore = n.verificationResult.score, n.verificationResult.recognitionResult.toLowerCase() !== "accept" && (this.privReason = r.ResultReason.NoMatch), n.verificationResult.profileId !== void 0 && n.verificationResult.profileId !== "" && (this.privProfileId = n.verificationResult.profileId)) : (this.privErrorDetails = l, this.privProperties.setProperty(t.CancellationErrorCodePropertyName, r.CancellationErrorCode[u])), this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(n));
      }
      get properties() {
        return this.privProperties;
      }
      get reason() {
        return this.privReason;
      }
      get profileId() {
        return this.privProfileId;
      }
      get errorDetails() {
        return this.privErrorDetails;
      }
      get score() {
        return this.privScore;
      }
    }
    e.SpeakerRecognitionResult = i;
    class a extends r.CancellationDetailsBase {
      constructor(n, c, u) {
        super(n, c, u);
      }
      /**
       * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
       * @member SpeakerRecognitionCancellationDetails.fromResult
       * @function
       * @public
       * @param {SpeakerRecognitionResult} result - The result that was canceled.
       * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
       */
      static fromResult(n) {
        const c = r.CancellationReason.Error;
        let u = r.CancellationErrorCode.NoError;
        return n.properties && (u = r.CancellationErrorCode[n.properties.getProperty(t.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new a(c, n.errorDetails, u);
      }
    }
    e.SpeakerRecognitionCancellationDetails = a;
  }(ea)), ea;
}
var ta = {}, bt = {}, mp;
function Ov() {
  if (mp) return bt;
  mp = 1, Object.defineProperty(bt, "__esModule", { value: !0 }), bt.ConversationImpl = bt.Conversation = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A();
  let i = class {
    constructor() {
    }
    /**
     * Create a conversation
     * @param speechConfig
     * @param cb
     * @param err
     */
    static createConversationAsync(n, c, u, l) {
      r.Contracts.throwIfNullOrUndefined(n, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), r.Contracts.throwIfNullOrUndefined(n.region, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), !n.subscriptionKey && !n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceAuthorization_Token]) && r.Contracts.throwIfNullOrUndefined(n.subscriptionKey, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      let p, d, h;
      return typeof c == "string" ? (p = new a(n, c), (0, t.marshalPromiseToCallbacks)((async () => {
      })(), u, l)) : (p = new a(n), d = c, h = u, p.createConversationAsync(() => {
        d && d();
      }, (f) => {
        h && h(f);
      })), p;
    }
  };
  bt.Conversation = i;
  class a extends i {
    /**
     * Create a conversation impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(n, c) {
      if (super(), this.privErrors = e.ConversationConnectionConfig.restErrors, this.onConnected = (p) => {
        this.privIsConnected = !0;
        try {
          this.privConversationTranslator?.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, p);
        } catch {
        }
      }, this.onDisconnected = (p) => {
        try {
          this.privConversationTranslator?.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, p);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (p, d) => {
        try {
          this.privConversationTranslator?.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, d);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.getParticipant(d.id);
          if (h !== void 0) {
            switch (d.key) {
              case e.ConversationTranslatorCommandTypes.changeNickname:
                h.displayName = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setUseTTS:
                h.isUsingTts = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setProfanityFiltering:
                h.profanity = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setMute:
                h.isMuted = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                h.translateToLanguages = d.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(h), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, [this.toParticipant(h)], d.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (p, d) => {
        try {
          this.privParticipants.participants.forEach((h) => h.isMuted = h.isHost ? !1 : d.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, this.toParticipants(!1), d.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.addOrUpdateParticipant(d.participant);
          h !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, [this.toParticipant(h)], d.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.getParticipant(d.participant.id);
          h !== void 0 && (this.privParticipants.deleteParticipant(d.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.LeftConversation, [this.toParticipant(h)], d.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (p, d) => {
        try {
          switch (d.command) {
            case e.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new o.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new o.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new o.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (p, d) => {
        try {
          if (d.sessionToken !== void 0 && d.sessionToken !== null && (this.privRoom.token = d.sessionToken), this.privParticipants.participants = [...d.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), d.sessionId)), this.me.isHost) {
            const h = this.privConversationTranslator?.properties.getProperty(o.PropertyId.ConversationTranslator_Name);
            h !== void 0 && h.length > 0 && h !== this.me.displayName && this.changeNicknameAsync(h);
          }
        } catch {
        }
      }, this.onConversationExpiration = (p, d) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, d);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new o.PropertyCollection(), this.privManager = new e.ConversationManager(), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]) || n.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage], e.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]), c)
        this.privConversationId = c;
      else {
        n.targetLanguages.length === 0 && n.addTargetLanguage(this.privLanguage), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceResponse_ProfanityOption]) || n.setProfanity(o.ProfanityOption.Masked);
        let d = n.getProperty(o.PropertyId[o.PropertyId.ConversationTranslator_Name]);
        d == null && (d = "Host"), r.Contracts.throwIfNullOrTooLong(d, "nickname", 50), r.Contracts.throwIfNullOrTooShort(d, "nickname", 2), n.setProperty(o.PropertyId[o.PropertyId.ConversationTranslator_Name], d);
      }
      this.privConfig = n;
      const l = n;
      r.Contracts.throwIfNull(l, "speechConfig"), this.privProperties = l.properties.clone(), this.privIsConnected = !1, this.privParticipants = new e.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the conversation Id
    get conversationId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      return this.privParticipants.me?.isHost ? !1 : this.privParticipants.me?.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get conversationInfo() {
      const n = this.conversationId, c = this.participants.map((p) => ({
        id: p.id,
        preferredLanguage: p.preferredLanguage,
        voice: p.voice
      })), u = {};
      for (const p of e.ConversationConnectionConfig.transcriptionEventKeys) {
        const d = this.properties.getProperty(p, "");
        d !== "" && (u[p] = d);
      }
      return { id: n, participants: c, conversationProperties: u };
    }
    get canSend() {
      return this.privIsConnected && !this.privParticipants.me?.isMuted;
    }
    get canSendAsHost() {
      return this.privIsConnected && this.privParticipants.me?.isHost;
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "authorizationToken"), this.privToken = n;
    }
    set conversationTranslator(n) {
      this.privConversationTranslator = n;
    }
    onToken(n) {
      this.privConversationTranslator.onToken(n);
    }
    /**
     * Create a new conversation as Host
     * @param cb
     * @param err
     */
    createConversationAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new conversation as host.
     * @param cb
     * @param err
     */
    startConversationAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer = e.ConversationRecognizerFactory.fromConfig(this, this.privConfig), this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a conversation as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(n, c, u) {
      r.Contracts.throwIfNullOrUndefined(n, "Participant"), (0, t.marshalPromiseToCallbacks)(this.addParticipantImplAsync(n), c, u);
    }
    /**
     * Join a conversation as a participant.
     * @param conversation
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinConversationAsync(n, c, u, l, p) {
      try {
        r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), r.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, n, (d) => {
          r.Contracts.throwIfNullOrUndefined(d, this.privErrors.permissionDeniedConnect), this.privRoom = d, this.privConfig.authorizationToken = d.cognitiveSpeechAuthToken, l && l(d.cognitiveSpeechAuthToken);
        }, (d) => {
          this.handleError(d, p);
        });
      } catch (d) {
        this.handleError(d, p);
      }
    }
    /**
     * Deletes a conversation
     * @param cb
     * @param err
     */
    deleteConversationAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.deleteConversationImplAsync(), n, c);
    }
    async deleteConversationImplAsync() {
      r.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), r.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endConversationAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.endConversationImplAsync(), n, c);
    }
    endConversationImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockConversationAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the conversation
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !0), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(n, c, u) {
      try {
        if (r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && n.hasOwnProperty("id"))
          (0, t.marshalPromiseToCallbacks)(this.removeParticipantImplAsync(n), c, u);
        else {
          r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let l = "";
          typeof n == "string" ? l = n : n.hasOwnProperty("id") ? l = n.id : n.hasOwnProperty("userId") && (l = n.userId), r.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((d) => d.id === l) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(l), () => {
            this.handleCallback(c, u);
          }, (d) => {
            this.handleError(d, u);
          });
        }
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to unlock the conversation
     * @param cb
     * @param err
     */
    unlockConversationAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the conversation
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !1), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "message")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), n.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfArrayEmptyOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "languages")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(n) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await n.enforceAudioGating(), this.privTranscriberRecognizer = n, this.privTranscriberRecognizer.conversation = this;
    }
    getKeepAlive() {
      const n = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: n,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(n) {
      if (this.privParticipants.addOrUpdateParticipant(n) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.conversationInfo;
        return u.participants = [n], this.privTranscriberRecognizer.pushConversationEvent(u, "join");
      }
    }
    removeParticipantImplAsync(n) {
      this.privParticipants.deleteParticipant(n.id);
      const c = this.conversationInfo;
      return c.participants = [n], this.privTranscriberRecognizer.pushConversationEvent(c, "leave");
    }
    async close(n) {
      try {
        this.privIsConnected = !1, await this.privConversationRecognizer?.close(), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (c) {
        throw c;
      }
      n && this.dispose();
    }
    /** Helpers */
    handleCallback(n, c) {
      if (n) {
        try {
          n();
        } catch (u) {
          c && c(u);
        }
        n = void 0;
      }
    }
    handleError(n, c) {
      if (c)
        if (n instanceof Error) {
          const u = n;
          c(u.name + ": " + u.message);
        } else
          c(n);
    }
    /** Participant Helpers */
    toParticipants(n) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return n ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(n) {
      return new o.Participant(n.id, n.avatar, n.displayName, n.isHost, n.isMuted, n.isUsingTts, n.preferredLanguage, n.voice);
    }
    getMuteAllCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMuteCommand(n, c) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getEjectCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getChangeNicknameCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "nickname"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.changeNickname,
        nickname: n,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMessageCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), r.Contracts.throwIfNullOrWhitespace(n, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: n,
        type: e.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return bt.ConversationImpl = a, bt;
}
var xn = {}, yp;
function sP() {
  if (yp) return xn;
  yp = 1, Object.defineProperty(xn, "__esModule", { value: !0 }), xn.ConversationCommon = void 0;
  let e = class {
    constructor(r) {
      this.privAudioConfig = r;
    }
    handleCallback(r, o) {
      if (r) {
        try {
          r();
        } catch (i) {
          o && o(i);
        }
        r = void 0;
      }
    }
    handleError(r, o) {
      if (o)
        if (r instanceof Error) {
          const i = r;
          o(i.name + ": " + i.message);
        } else
          o(r);
    }
  };
  return xn.ConversationCommon = e, xn;
}
var zn = {}, Sp;
function oP() {
  if (Sp) return zn;
  Sp = 1, Object.defineProperty(zn, "__esModule", { value: !0 }), zn.ConversationExpirationEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    constructor(o, i) {
      super(i), this.privExpirationTime = o;
    }
    /** How much longer until the conversation expires (in minutes). */
    get expirationTime() {
      return this.privExpirationTime;
    }
  };
  return zn.ConversationExpirationEventArgs = t, zn;
}
var Ln = {}, Cp;
function aP() {
  if (Cp) return Ln;
  Cp = 1, Object.defineProperty(Ln, "__esModule", { value: !0 }), Ln.ConversationParticipantsChangedEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SessionEventArgs {
    constructor(o, i, a) {
      super(a), this.privReason = o, this.privParticipant = i;
    }
    get reason() {
      return this.privReason;
    }
    get participants() {
      return this.privParticipant;
    }
  };
  return Ln.ConversationParticipantsChangedEventArgs = t, Ln;
}
var jn = {}, Rp;
function cP() {
  if (Rp) return jn;
  Rp = 1, Object.defineProperty(jn, "__esModule", { value: !0 }), jn.ConversationTranslationCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Ps();
  let t = class extends e.CancellationEventArgsBase {
  };
  return jn.ConversationTranslationCanceledEventArgs = t, jn;
}
var qn = {}, Pp;
function uP() {
  if (Pp) return qn;
  Pp = 1, Object.defineProperty(qn, "__esModule", { value: !0 }), qn.ConversationTranslationEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranslationResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Specifies the recognition result.
     * @returns {ConversationTranslationResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return qn.ConversationTranslationEventArgs = t, qn;
}
var Fn = {}, bp;
function lP() {
  if (bp) return Fn;
  bp = 1, Object.defineProperty(Fn, "__esModule", { value: !0 }), Fn.ConversationTranslationResult = void 0;
  const e = /* @__PURE__ */ vv();
  let t = class extends e.TranslationRecognitionResult {
    constructor(o, i, a, s, n, c, u, l, p, d, h) {
      super(i, s, n, c, u, l, void 0, void 0, p, d, h), this.privId = o, this.privOrigLang = a;
    }
    /**
     * The unique identifier for the participant this result is for.
     */
    get participantId() {
      return this.privId;
    }
    /**
     * The original language this result was in.
     */
    get originalLang() {
      return this.privOrigLang;
    }
  };
  return Fn.ConversationTranslationResult = t, Fn;
}
var ra = {}, Bn = {}, Un = {}, wp;
function Mv() {
  if (wp) return Un;
  wp = 1, Object.defineProperty(Un, "__esModule", { value: !0 }), Un.StringUtils = void 0;
  let e = class {
    /**
     * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
     * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
     * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
     * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
     * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
     */
    static formatString(r, o) {
      if (!r)
        return "";
      if (!o)
        return r;
      let i = "", a = "";
      const s = (u) => {
        i += u;
      }, n = (u) => {
        a += u;
      };
      let c = s;
      for (let u = 0; u < r.length; u++) {
        const l = r[u], p = u + 1 < r.length ? r[u + 1] : "";
        switch (l) {
          case "{":
            p === "{" ? (c("{"), u++) : c = n;
            break;
          case "}":
            p === "}" ? (c("}"), u++) : (o.hasOwnProperty(a) && (i += o[a]), c = s, a = "");
            break;
          default:
            c(l);
            break;
        }
      }
      return i;
    }
  };
  return Un.StringUtils = e, Un;
}
var Ep;
function pP() {
  if (Ep) return Bn;
  Ep = 1, Object.defineProperty(Bn, "__esModule", { value: !0 }), Bn.ConversationTranslatorConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ Mv(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A(), i = /* @__PURE__ */ pe(), a = /* @__PURE__ */ rt(), s = /* @__PURE__ */ Te(), n = /* @__PURE__ */ _();
  let c = class Dv extends s.ConnectionFactoryBase {
    constructor(l) {
      super(), r.Contracts.throwIfNullOrUndefined(l, "convGetter"), this.privConvGetter = l;
    }
    create(l, p, d) {
      const h = l.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE", f = this.privConvGetter().room, g = f.cognitiveSpeechRegion || l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Region, ""), m = {
        hostSuffix: s.ConnectionFactoryBase.getHostSuffix(g),
        path: Dv.CTS_VIRT_MIC_PATH,
        region: encodeURIComponent(g)
      };
      m[a.QueryParameterNames.Language] = encodeURIComponent(l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_RecoLanguage, "")), m[a.QueryParameterNames.CtsMeetingId] = encodeURIComponent(f.roomId), m[a.QueryParameterNames.CtsDeviceId] = encodeURIComponent(f.participantId), m[a.QueryParameterNames.CtsIsParticipant] = f.isHost ? "" : "&" + a.QueryParameterNames.CtsIsParticipant;
      let v = "";
      const y = {}, S = {};
      if (h) {
        v = l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Endpoint), v || (v = "wss://" + l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}") + "{path}"), v = t.StringUtils.formatString(v, m);
        const b = new URL(v);
        b.searchParams.forEach((I, E) => {
          y[E] = I;
        }), new n.TranscriberConnectionFactory().setQueryParams(y, l, v), y[a.QueryParameterNames.CtsMeetingId] = m[a.QueryParameterNames.CtsMeetingId], y[a.QueryParameterNames.CtsDeviceId] = m[a.QueryParameterNames.CtsDeviceId], f.isHost || (y[a.QueryParameterNames.CtsIsParticipant] = ""), a.QueryParameterNames.Format in y || (y[a.QueryParameterNames.Format] = "simple"), b.searchParams.forEach((I, E) => {
          b.searchParams.set(E, y[E]), delete y[E];
        }), v = b.toString();
      } else {
        const b = new n.TranslationConnectionFactory();
        v = b.getEndpointUrl(l, !0), v = t.StringUtils.formatString(v, m), b.setQueryParams(y, l, v);
      }
      S[i.HeaderNames.ConnectionId] = d, S[e.RestConfigBase.configParams.token] = f.token, p.token && (S[p.headerName] = p.token);
      const C = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
      return Promise.resolve(new e.WebsocketConnection(v, y, S, new n.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), C, d));
    }
  };
  return Bn.ConversationTranslatorConnectionFactory = c, c.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio", Bn;
}
var Ip;
function dP() {
  return Ip || (Ip = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConversationTranslator = e.SpeechState = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ pP(), o = /* @__PURE__ */ O(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ A(), s = /* @__PURE__ */ Ov(), n = /* @__PURE__ */ hc();
    var c;
    (function(p) {
      p[p.Inactive = 0] = "Inactive", p[p.Connecting = 1] = "Connecting", p[p.Connected = 2] = "Connected";
    })(c = e.SpeechState || (e.SpeechState = {}));
    class u extends a.TranslationRecognizer {
      constructor(d, h, f, g) {
        super(d, h, new r.ConversationTranslatorConnectionFactory(g)), this.privSpeechState = c.Inactive, f && (this.privTranslator = f, this.sessionStarted = () => {
          this.privSpeechState = c.Connected;
        }, this.sessionStopped = () => {
          this.privSpeechState = c.Inactive;
        }, this.recognizing = (m, v) => {
          this.privTranslator.recognizing && this.privTranslator.recognizing(this.privTranslator, v);
        }, this.recognized = async (m, v) => {
          v.result?.errorDetails ? (await this.cancelSpeech(), this.fireCancelEvent(v.result.errorDetails)) : this.privTranslator.recognized && this.privTranslator.recognized(this.privTranslator, v);
        }, this.canceled = async () => {
          if (this.privSpeechState !== c.Inactive)
            try {
              await this.cancelSpeech();
            } catch {
              this.privSpeechState = c.Inactive;
            }
        });
      }
      get state() {
        return this.privSpeechState;
      }
      set state(d) {
        this.privSpeechState = d;
      }
      set authentication(d) {
        this.privReco.authentication = d;
      }
      onConnection() {
        this.privSpeechState = c.Connected;
      }
      async onCancelSpeech() {
        this.privSpeechState = c.Inactive, await this.cancelSpeech();
      }
      /**
       * Fire a cancel event
       * @param error
       */
      fireCancelEvent(d) {
        try {
          if (this.privTranslator.canceled) {
            const h = new n.ConversationTranslationCanceledEventArgs(a.CancellationReason.Error, d, a.CancellationErrorCode.RuntimeError);
            this.privTranslator.canceled(this.privTranslator, h);
          }
        } catch {
        }
      }
      async cancelSpeech() {
        try {
          this.stopContinuousRecognitionAsync(), await this.privReco?.disconnect(), this.privSpeechState = c.Inactive;
        } catch {
        }
      }
    }
    class l extends n.ConversationCommon {
      constructor(d) {
        super(d), this.privErrors = t.ConversationConnectionConfig.restErrors, this.privIsDisposed = !1, this.privIsSpeaking = !1, this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345", this.privPlaceholderRegion = "westus", this.privProperties = new a.PropertyCollection();
      }
      get properties() {
        return this.privProperties;
      }
      get speechRecognitionLanguage() {
        return this.privSpeechRecognitionLanguage;
      }
      get participants() {
        return this.privConversation?.participants;
      }
      get canSpeak() {
        return !(!this.privConversation.isConnected || !this.privCTRecognizer || this.privIsSpeaking || this.privCTRecognizer.state === c.Connected || this.privCTRecognizer.state === c.Connecting || this.privConversation.isMutedByHost);
      }
      onToken(d) {
        this.privCTRecognizer.authentication = d;
      }
      setServiceProperty(d, h) {
        const f = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
        f[d] = h, this.privProperties.setProperty(t.ServicePropertiesPropertyName, JSON.stringify(f));
      }
      joinConversationAsync(d, h, f, g, m) {
        try {
          if (typeof d == "string") {
            i.Contracts.throwIfNullOrUndefined(d, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), i.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privConversation && this.handleError(new Error(this.privErrors.permissionDeniedStart), m);
            let v = f;
            (v == null || v === "") && (v = t.ConversationConnectionConfig.defaultLanguageCode), this.privSpeechTranslationConfig = a.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion), this.privSpeechTranslationConfig.setProfanity(a.ProfanityOption.Masked), this.privSpeechTranslationConfig.addTargetLanguage(v), this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_RecoLanguage], v), this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.ConversationTranslator_Name], h);
            const y = [
              a.PropertyId.SpeechServiceConnection_Host,
              a.PropertyId.ConversationTranslator_Host,
              a.PropertyId.SpeechServiceConnection_Endpoint,
              a.PropertyId.SpeechServiceConnection_ProxyHostName,
              a.PropertyId.SpeechServiceConnection_ProxyPassword,
              a.PropertyId.SpeechServiceConnection_ProxyPort,
              a.PropertyId.SpeechServiceConnection_ProxyUserName,
              "ConversationTranslator_MultiChannelAudio",
              "ConversationTranslator_Region"
            ];
            for (const C of y) {
              const b = this.privProperties.getProperty(C);
              if (b) {
                const w = typeof C == "string" ? C : a.PropertyId[C];
                this.privSpeechTranslationConfig.setProperty(w, b);
              }
            }
            const S = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
            for (const C of Object.keys(S))
              this.privSpeechTranslationConfig.setServiceProperty(C, S[C], a.ServicePropertyChannel.UriQueryParameter);
            this.privConversation = new s.ConversationImpl(this.privSpeechTranslationConfig), this.privConversation.conversationTranslator = this, this.privConversation.joinConversationAsync(d, h, v, (C) => {
              C || this.handleError(new Error(this.privErrors.permissionDeniedConnect), m), this.privSpeechTranslationConfig.authorizationToken = C, this.privConversation.room.isHost = !1, this.privConversation.startConversationAsync(() => {
                this.handleCallback(g, m);
              }, (b) => {
                this.handleError(b, m);
              });
            }, (C) => {
              this.handleError(C, m);
            });
          } else typeof d == "object" ? (i.Contracts.throwIfNullOrUndefined(d, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), i.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privProperties.setProperty(a.PropertyId.ConversationTranslator_Name, h), this.privConversation = d, this.privConversation.conversationTranslator = this, this.privConversation.room.isHost = !0, i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect), i.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privSpeechTranslationConfig = d.config, this.handleCallback(f, g)) : this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), g);
        } catch (v) {
          this.handleError(v, typeof f == "string" ? m : g);
        }
      }
      /**
       * Leave the conversation
       * @param cb
       * @param err
       */
      leaveConversationAsync(d, h) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          await this.cancelSpeech(), await this.privConversation.endConversationImplAsync(), await this.privConversation.deleteConversationImplAsync(), this.dispose();
        })(), d, h);
      }
      /**
       * Send a text message
       * @param message
       * @param cb
       * @param err
       */
      sendTextMessageAsync(d, h, f) {
        try {
          i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), i.Contracts.throwIfNullOrWhitespace(d, this.privErrors.invalidArgs.replace("{arg}", d)), this.privConversation.sendTextMessageAsync(d, h, f);
        } catch (g) {
          this.handleError(g, f);
        }
      }
      /**
       * Start speaking
       * @param cb
       * @param err
       */
      startTranscribingAsync(d, h) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          try {
            i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), i.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privCTRecognizer === void 0 && await this.connectTranslatorRecognizer(), i.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend), this.canSpeak || this.handleError(new Error(this.privErrors.permissionDeniedSend), h), await this.startContinuousRecognition(), this.privIsSpeaking = !0;
          } catch (f) {
            throw this.privIsSpeaking = !1, await this.cancelSpeech(), f;
          }
        })(), d, h);
      }
      /**
       * Stop speaking
       * @param cb
       * @param err
       */
      stopTranscribingAsync(d, h) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          try {
            if (!this.privIsSpeaking) {
              await this.cancelSpeech();
              return;
            }
            this.privIsSpeaking = !1, await new Promise((f, g) => {
              this.privCTRecognizer.stopContinuousRecognitionAsync(f, g);
            });
          } catch {
            await this.cancelSpeech();
          }
        })(), d, h);
      }
      isDisposed() {
        return this.privIsDisposed;
      }
      dispose(d, h, f) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          this.isDisposed && !this.privIsSpeaking || (await this.cancelSpeech(), this.privIsDisposed = !0, this.privSpeechTranslationConfig.close(), this.privSpeechRecognitionLanguage = void 0, this.privProperties = void 0, this.privAudioConfig = void 0, this.privSpeechTranslationConfig = void 0, this.privConversation.dispose(), this.privConversation = void 0);
        })(), h, f);
      }
      /**
       * Cancel the speech websocket
       */
      async cancelSpeech() {
        try {
          this.privIsSpeaking = !1, await this.privCTRecognizer?.onCancelSpeech(), this.privCTRecognizer = void 0;
        } catch {
        }
      }
      /**
       * Connect to the speech translation recognizer.
       * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
       * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
       * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
       */
      async connectTranslatorRecognizer() {
        try {
          this.privAudioConfig === void 0 && (this.privAudioConfig = a.AudioConfig.fromDefaultMicrophoneInput()), this.privSpeechTranslationConfig.getProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey && this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_Key], "");
          const d = () => this.privConversation;
          this.privCTRecognizer = new u(this.privSpeechTranslationConfig, this.privAudioConfig, this, d);
        } catch (d) {
          throw await this.cancelSpeech(), d;
        }
      }
      /**
       * Handle the start speaking request
       */
      startContinuousRecognition() {
        return new Promise((d, h) => {
          this.privCTRecognizer.startContinuousRecognitionAsync(d, h);
        });
      }
    }
    e.ConversationTranslator = l;
  }(ra)), ra;
}
var $n = {}, Ap;
function hP() {
  if (Ap) return $n;
  Ap = 1, Object.defineProperty($n, "__esModule", { value: !0 }), $n.ConversationTranscriber = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ Re(), r = /* @__PURE__ */ O(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ A();
  let a = class Nv extends i.Recognizer {
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      o.Contracts.throwIfNull(u, "speechConfig"), o.Contracts.throwIfNullOrWhitespace(u.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new e.ConversationTranscriberConnectionFactory(), n.tokenCredential), this.privProperties.setProperty(i.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privDisposedRecognizer = !1;
    }
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(n, c, u) {
      const l = n;
      return c.properties.mergeTo(l.properties), new Nv(n, u);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for transcription.
     * @member ConversationTranscriber.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      o.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * Gets the spoken language of transcription.
     * @member ConversationTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of transcription.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of transcription.
     * @member ConversationTranscriber.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of transcription.
     */
    get outputFormat() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(e.OutputFormatPropertyName, i.OutputFormat[i.OutputFormat.Simple]) === i.OutputFormat[i.OutputFormat.Simple] ? i.OutputFormat.Simple : i.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this conversation transcriber.
     * @member ConversationTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts conversation transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member ConversationTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), n, c);
    }
    /**
     * Stops conversation transcription.
     * @member ConversationTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member ConversationTranscriber.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return l.isSpeakerDiarizationEnabled = !0, new e.ConversationTranscriptionServiceRecognizer(n, c, p, l, this);
    }
  };
  return $n.ConversationTranscriber = a, $n;
}
var wt = {}, Tp;
function fP() {
  if (Tp) return wt;
  Tp = 1, Object.defineProperty(wt, "__esModule", { value: !0 }), wt.Participant = wt.User = void 0;
  const e = /* @__PURE__ */ A();
  class t {
    constructor(i) {
      this.privUserId = i;
    }
    get userId() {
      return this.privUserId;
    }
  }
  wt.User = t;
  class r {
    constructor(i, a, s, n, c, u, l, p) {
      this.privId = i, this.privAvatar = a, this.privDisplayName = s, this.privIsHost = n, this.privIsMuted = c, this.privIsUsingTts = u, this.privPreferredLanguage = l, this.privVoice = p, this.privProperties = new e.PropertyCollection();
    }
    get avatar() {
      return this.privAvatar;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get id() {
      return this.privId;
    }
    get preferredLanguage() {
      return this.privPreferredLanguage;
    }
    get isHost() {
      return this.privIsHost;
    }
    get isMuted() {
      return this.privIsMuted;
    }
    get isUsingTts() {
      return this.privIsUsingTts;
    }
    get voice() {
      return this.privVoice;
    }
    get properties() {
      return this.privProperties;
    }
    static From(i, a, s) {
      return new r(i, "", i, !1, !1, !1, a, s);
    }
  }
  return wt.Participant = r, wt;
}
var na = {}, _p;
function vP() {
  return _p || (_p = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ParticipantChangedReason = void 0, function(t) {
      t[t.JoinedConversation = 0] = "JoinedConversation", t[t.LeftConversation = 1] = "LeftConversation", t[t.Updated = 2] = "Updated";
    }(e.ParticipantChangedReason || (e.ParticipantChangedReason = {}));
  }(na)), na;
}
var Et = {}, kp;
function gP() {
  if (kp) return Et;
  kp = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.MeetingImpl = Et.Meeting = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A();
  let i = class {
    constructor() {
    }
    /**
     * Create a meeting
     * @param speechConfig
     * @param meetingId
     * @param cb
     * @param err
     */
    static createMeetingAsync(n, c, u, l) {
      if (r.Contracts.throwIfNullOrUndefined(n, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), r.Contracts.throwIfNullOrUndefined(n.region, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), r.Contracts.throwIfNull(c, "meetingId"), c.length === 0)
        throw new Error("meetingId cannot be empty");
      !n.subscriptionKey && !n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceAuthorization_Token]) && r.Contracts.throwIfNullOrUndefined(n.subscriptionKey, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      const p = new a(n, c);
      return (0, t.marshalPromiseToCallbacks)((async () => {
      })(), u, l), p;
    }
  };
  Et.Meeting = i;
  class a extends i {
    /**
     * Create a Meeting impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(n, c) {
      super(), this.privErrors = e.ConversationConnectionConfig.restErrors, this.onConnected = (p) => {
        this.privIsConnected = !0;
        try {
          this.privConversationTranslator?.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, p);
        } catch {
        }
      }, this.onDisconnected = (p) => {
        try {
          this.privConversationTranslator?.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, p);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (p, d) => {
        try {
          this.privConversationTranslator?.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, d);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.getParticipant(d.id);
          if (h !== void 0) {
            switch (d.key) {
              case e.ConversationTranslatorCommandTypes.changeNickname:
                h.displayName = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setUseTTS:
                h.isUsingTts = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setProfanityFiltering:
                h.profanity = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setMute:
                h.isMuted = d.value;
                break;
              case e.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                h.translateToLanguages = d.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(h), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, [this.toParticipant(h)], d.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (p, d) => {
        try {
          this.privParticipants.participants.forEach((h) => h.isMuted = h.isHost ? !1 : d.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, this.toParticipants(!1), d.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.addOrUpdateParticipant(d.participant);
          h !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, [this.toParticipant(h)], d.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (p, d) => {
        try {
          const h = this.privParticipants.getParticipant(d.participant.id);
          h !== void 0 && (this.privParticipants.deleteParticipant(d.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.LeftConversation, [this.toParticipant(h)], d.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (p, d) => {
        try {
          switch (d.command) {
            case e.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new o.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new o.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new o.ConversationTranslationEventArgs(d.payload, void 0, d.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (p, d) => {
        try {
          if (d.sessionToken !== void 0 && d.sessionToken !== null && (this.privRoom.token = d.sessionToken), this.privParticipants.participants = [...d.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), d.sessionId)), this.me.isHost) {
            const h = this.privConversationTranslator?.properties.getProperty(o.PropertyId.ConversationTranslator_Name);
            h !== void 0 && h.length > 0 && h !== this.me.displayName && this.changeNicknameAsync(h);
          }
        } catch {
        }
      }, this.onConversationExpiration = (p, d) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, d);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new o.PropertyCollection(), this.privManager = new e.ConversationManager(), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]) || n.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage], e.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]), this.privConversationId = c, this.privConfig = n;
      const l = n;
      r.Contracts.throwIfNull(l, "speechConfig"), this.privProperties = l.properties.clone(), this.privIsConnected = !1, this.privParticipants = new e.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the meeting Id
    get meetingId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      return this.privParticipants.me?.isHost ? !1 : this.privParticipants.me?.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get meetingInfo() {
      const n = this.meetingId, c = this.participants.map((p) => ({
        id: p.id,
        preferredLanguage: p.preferredLanguage,
        voice: p.voice
      })), u = {};
      for (const p of e.ConversationConnectionConfig.transcriptionEventKeys) {
        const d = this.properties.getProperty(p, "");
        d !== "" && (u[p] = d);
      }
      return { id: n, participants: c, meetingProperties: u };
    }
    get canSend() {
      return this.privIsConnected && !this.privParticipants.me?.isMuted;
    }
    get canSendAsHost() {
      return this.privIsConnected && this.privParticipants.me?.isHost;
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "authorizationToken"), this.privToken = n;
    }
    /**
     * Create a new meeting as Host
     * @param cb
     * @param err
     */
    createMeetingAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new meeting as host.
     * @param cb
     * @param err
     */
    startMeetingAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a meeting as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(n, c, u) {
      r.Contracts.throwIfNullOrUndefined(n, "Participant"), (0, t.marshalPromiseToCallbacks)(this.addParticipantImplAsync(n), c, u);
    }
    /**
     * Join a meeting as a participant.
     * @param meeting
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinMeetingAsync(n, c, u, l, p) {
      try {
        r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), r.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, n, (d) => {
          r.Contracts.throwIfNullOrUndefined(d, this.privErrors.permissionDeniedConnect), this.privRoom = d, this.privConfig.authorizationToken = d.cognitiveSpeechAuthToken, l && l(d.cognitiveSpeechAuthToken);
        }, (d) => {
          this.handleError(d, p);
        });
      } catch (d) {
        this.handleError(d, p);
      }
    }
    /**
     * Deletes a meeting
     * @param cb
     * @param err
     */
    deleteMeetingAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.deleteMeetingImplAsync(), n, c);
    }
    async deleteMeetingImplAsync() {
      r.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), r.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endMeetingAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.endMeetingImplAsync(), n, c);
    }
    endMeetingImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockMeetingAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the meeting
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !0), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(n, c, u) {
      try {
        if (r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && n.hasOwnProperty("id"))
          (0, t.marshalPromiseToCallbacks)(this.removeParticipantImplAsync(n), c, u);
        else {
          r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let l = "";
          typeof n == "string" ? l = n : n.hasOwnProperty("id") ? l = n.id : n.hasOwnProperty("userId") && (l = n.userId), r.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((d) => d.id === l) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(l), () => {
            this.handleCallback(c, u);
          }, (d) => {
            this.handleError(d, u);
          });
        }
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to unlock the meeting
     * @param cb
     * @param err
     */
    unlockMeetingAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the meeting
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !1), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "message")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), n.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfArrayEmptyOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "languages")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(n) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await n.enforceAudioGating(), this.privTranscriberRecognizer = n, this.privTranscriberRecognizer.meeting = this;
    }
    getKeepAlive() {
      const n = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: n,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(n) {
      if (this.privParticipants.addOrUpdateParticipant(n) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.meetingInfo;
        return u.participants = [n], this.privTranscriberRecognizer.pushMeetingEvent(u, "join");
      }
    }
    removeParticipantImplAsync(n) {
      this.privParticipants.deleteParticipant(n.id);
      const c = this.meetingInfo;
      return c.participants = [n], this.privTranscriberRecognizer.pushMeetingEvent(c, "leave");
    }
    async close(n) {
      try {
        this.privIsConnected = !1, await this.privConversationRecognizer?.close(), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (c) {
        throw c;
      }
      n && this.dispose();
    }
    /** Helpers */
    handleCallback(n, c) {
      if (n) {
        try {
          n();
        } catch (u) {
          c && c(u);
        }
        n = void 0;
      }
    }
    handleError(n, c) {
      if (c)
        if (n instanceof Error) {
          const u = n;
          c(u.name + ": " + u.message);
        } else
          c(n);
    }
    /** Participant Helpers */
    toParticipants(n) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return n ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(n) {
      return new o.Participant(n.id, n.avatar, n.displayName, n.isHost, n.isMuted, n.isUsingTts, n.preferredLanguage, n.voice);
    }
    getMuteAllCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMuteCommand(n, c) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getEjectCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getChangeNicknameCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(n, "nickname"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.changeNickname,
        nickname: n,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMessageCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), r.Contracts.throwIfNullOrWhitespace(n, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: n,
        type: e.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return Et.MeetingImpl = a, Et;
}
var Vn = {}, Op;
function mP() {
  if (Op) return Vn;
  Op = 1, Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.MeetingTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Ps();
  class t extends e.CancellationEventArgsBase {
  }
  return Vn.MeetingTranscriptionCanceledEventArgs = t, Vn;
}
var Wn = {}, Mp;
function yP() {
  if (Mp) return Wn;
  Mp = 1, Object.defineProperty(Wn, "__esModule", { value: !0 }), Wn.MeetingTranscriber = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A(), i = /* @__PURE__ */ hc();
  let a = class {
    /**
     * MeetingTranscriber constructor.
     * @constructor
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n) {
      this.privAudioConfig = n, this.privProperties = new o.PropertyCollection(), this.privRecognizer = void 0, this.privDisposedRecognizer = !1;
    }
    /**
     * Gets the spoken language of recognition.
     * @member MeetingTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return r.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(o.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * The collection of properties and their values defined for this MeetingTranscriber.
     * @member MeetingTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privRecognizer.internalData;
    }
    /**
     * @Deprecated
     * @Obsolete
     * Please use the Connection.fromRecognizer pattern to obtain a connection object
     */
    get connection() {
      return o.Connection.fromRecognizer(this.privRecognizer);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * @param {Meeting} meeting - meeting to be recognized
     */
    joinMeetingAsync(n, c, u) {
      const l = n;
      r.Contracts.throwIfNullOrUndefined(i.MeetingImpl, "Meeting"), this.privRecognizer = new e.TranscriberRecognizer(n.config, this.privAudioConfig), r.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer"), this.privRecognizer.connectMeetingCallbacks(this), (0, t.marshalPromiseToCallbacks)(l.connectTranscriberRecognizer(this.privRecognizer), c, u);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(n, c) {
      this.privRecognizer.startContinuousRecognitionAsync(n, c);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(n, c) {
      this.privRecognizer.stopContinuousRecognitionAsync(n, c);
    }
    /**
     * Leave the current meeting. After this is called, you will no longer receive any events.
     */
    leaveMeetingAsync(n, c) {
      this.privRecognizer.disconnectCallbacks(), (0, t.marshalPromiseToCallbacks)((async () => {
      })(), n, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member MeetingTranscriber.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      r.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member MeetingTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (this.privRecognizer && (await this.privRecognizer.close(), this.privRecognizer = void 0), n && (this.privDisposedRecognizer = !0));
    }
  };
  return Wn.MeetingTranscriber = a, Wn;
}
var Hn = {}, Dp;
function SP() {
  if (Dp) return Hn;
  Dp = 1, Object.defineProperty(Hn, "__esModule", { value: !0 }), Hn.ConversationTranscriptionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, d, h) {
      super(o, i, a, s, n, c, u, p, d, h), this.privSpeakerId = l;
    }
    /**
     * speaker id
     * @member ConversationTranscriptionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return Hn.ConversationTranscriptionResult = t, Hn;
}
var Np;
function hc() {
  return Np || (Np = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConversationTranscriptionResult = e.MeetingTranscriber = e.MeetingTranscriptionCanceledEventArgs = e.MeetingImpl = e.Meeting = e.ParticipantChangedReason = e.User = e.Participant = e.ConversationTranscriber = e.ConversationTranslator = e.ConversationTranslationResult = e.ConversationTranslationEventArgs = e.ConversationTranslationCanceledEventArgs = e.ConversationParticipantsChangedEventArgs = e.ConversationExpirationEventArgs = e.ConversationCommon = e.ConversationImpl = e.Conversation = void 0;
    var t = /* @__PURE__ */ Ov();
    Object.defineProperty(e, "Conversation", { enumerable: !0, get: function() {
      return t.Conversation;
    } }), Object.defineProperty(e, "ConversationImpl", { enumerable: !0, get: function() {
      return t.ConversationImpl;
    } });
    var r = /* @__PURE__ */ sP();
    Object.defineProperty(e, "ConversationCommon", { enumerable: !0, get: function() {
      return r.ConversationCommon;
    } });
    var o = /* @__PURE__ */ oP();
    Object.defineProperty(e, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return o.ConversationExpirationEventArgs;
    } });
    var i = /* @__PURE__ */ aP();
    Object.defineProperty(e, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return i.ConversationParticipantsChangedEventArgs;
    } });
    var a = /* @__PURE__ */ cP();
    Object.defineProperty(e, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return a.ConversationTranslationCanceledEventArgs;
    } });
    var s = /* @__PURE__ */ uP();
    Object.defineProperty(e, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return s.ConversationTranslationEventArgs;
    } });
    var n = /* @__PURE__ */ lP();
    Object.defineProperty(e, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return n.ConversationTranslationResult;
    } });
    var c = /* @__PURE__ */ dP();
    Object.defineProperty(e, "ConversationTranslator", { enumerable: !0, get: function() {
      return c.ConversationTranslator;
    } });
    var u = /* @__PURE__ */ hP();
    Object.defineProperty(e, "ConversationTranscriber", { enumerable: !0, get: function() {
      return u.ConversationTranscriber;
    } });
    var l = /* @__PURE__ */ fP();
    Object.defineProperty(e, "Participant", { enumerable: !0, get: function() {
      return l.Participant;
    } }), Object.defineProperty(e, "User", { enumerable: !0, get: function() {
      return l.User;
    } });
    var p = /* @__PURE__ */ vP();
    Object.defineProperty(e, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return p.ParticipantChangedReason;
    } });
    var d = /* @__PURE__ */ gP();
    Object.defineProperty(e, "Meeting", { enumerable: !0, get: function() {
      return d.Meeting;
    } }), Object.defineProperty(e, "MeetingImpl", { enumerable: !0, get: function() {
      return d.MeetingImpl;
    } });
    var h = /* @__PURE__ */ mP();
    Object.defineProperty(e, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return h.MeetingTranscriptionCanceledEventArgs;
    } });
    var f = /* @__PURE__ */ yP();
    Object.defineProperty(e, "MeetingTranscriber", { enumerable: !0, get: function() {
      return f.MeetingTranscriber;
    } });
    var g = /* @__PURE__ */ SP();
    Object.defineProperty(e, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return g.ConversationTranscriptionResult;
    } });
  }(ta)), ta;
}
var It = {}, xp;
function fc() {
  if (xp) return It;
  xp = 1, Object.defineProperty(It, "__esModule", { value: !0 }), It.SynthesisRequest = It.Synthesizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A();
  let i = class xv {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config to initialize the synthesizer.
     */
    constructor(n) {
      const c = n;
      r.Contracts.throwIfNull(c, "speechConfig"), this.privProperties = c.properties.clone(), this.privDisposed = !1, this.privSynthesizing = !1, this.synthesisRequestQueue = new t.Queue(), this.tokenCredential = n.tokenCredential;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * The collection of properties and their values defined for this Synthesizer.
     * @member Synthesizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Indicates if auto detect source language is enabled
     * @member Synthesizer.prototype.autoDetectSourceLanguage
     * @function
     * @public
     * @returns {boolean} if auto detect source language is enabled
     */
    get autoDetectSourceLanguage() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === e.AutoDetectSourceLanguagesOpenRangeOptionName;
    }
    buildSsml(n) {
      const c = {
        "af-ZA": "af-ZA-AdriNeural",
        "am-ET": "am-ET-AmehaNeural",
        "ar-AE": "ar-AE-FatimaNeural",
        "ar-BH": "ar-BH-AliNeural",
        "ar-DZ": "ar-DZ-AminaNeural",
        "ar-EG": "ar-EG-SalmaNeural",
        "ar-IQ": "ar-IQ-BasselNeural",
        "ar-JO": "ar-JO-SanaNeural",
        "ar-KW": "ar-KW-FahedNeural",
        "ar-LY": "ar-LY-ImanNeural",
        "ar-MA": "ar-MA-JamalNeural",
        "ar-QA": "ar-QA-AmalNeural",
        "ar-SA": "ar-SA-HamedNeural",
        "ar-SY": "ar-SY-AmanyNeural",
        "ar-TN": "ar-TN-HediNeural",
        "ar-YE": "ar-YE-MaryamNeural",
        "bg-BG": "bg-BG-BorislavNeural",
        "bn-BD": "bn-BD-NabanitaNeural",
        "bn-IN": "bn-IN-BashkarNeural",
        "ca-ES": "ca-ES-JoanaNeural",
        "cs-CZ": "cs-CZ-AntoninNeural",
        "cy-GB": "cy-GB-AledNeural",
        "da-DK": "da-DK-ChristelNeural",
        "de-AT": "de-AT-IngridNeural",
        "de-CH": "de-CH-JanNeural",
        "de-DE": "de-DE-KatjaNeural",
        "el-GR": "el-GR-AthinaNeural",
        "en-AU": "en-AU-NatashaNeural",
        "en-CA": "en-CA-ClaraNeural",
        "en-GB": "en-GB-LibbyNeural",
        "en-HK": "en-HK-SamNeural",
        "en-IE": "en-IE-ConnorNeural",
        "en-IN": "en-IN-NeerjaNeural",
        "en-KE": "en-KE-AsiliaNeural",
        "en-NG": "en-NG-AbeoNeural",
        "en-NZ": "en-NZ-MitchellNeural",
        "en-PH": "en-PH-JamesNeural",
        "en-SG": "en-SG-LunaNeural",
        "en-TZ": "en-TZ-ElimuNeural",
        "en-US": "en-US-AvaMultilingualNeural",
        "en-ZA": "en-ZA-LeahNeural",
        "es-AR": "es-AR-ElenaNeural",
        "es-BO": "es-BO-MarceloNeural",
        "es-CL": "es-CL-CatalinaNeural",
        "es-CO": "es-CO-GonzaloNeural",
        "es-CR": "es-CR-JuanNeural",
        "es-CU": "es-CU-BelkysNeural",
        "es-DO": "es-DO-EmilioNeural",
        "es-EC": "es-EC-AndreaNeural",
        "es-ES": "es-ES-AlvaroNeural",
        "es-GQ": "es-GQ-JavierNeural",
        "es-GT": "es-GT-AndresNeural",
        "es-HN": "es-HN-CarlosNeural",
        "es-MX": "es-MX-DaliaNeural",
        "es-NI": "es-NI-FedericoNeural",
        "es-PA": "es-PA-MargaritaNeural",
        "es-PE": "es-PE-AlexNeural",
        "es-PR": "es-PR-KarinaNeural",
        "es-PY": "es-PY-MarioNeural",
        "es-SV": "es-SV-LorenaNeural",
        "es-US": "es-US-AlonsoNeural",
        "es-UY": "es-UY-MateoNeural",
        "es-VE": "es-VE-PaolaNeural",
        "et-EE": "et-EE-AnuNeural",
        "fa-IR": "fa-IR-DilaraNeural",
        "fi-FI": "fi-FI-SelmaNeural",
        "fil-PH": "fil-PH-AngeloNeural",
        "fr-BE": "fr-BE-CharlineNeural",
        "fr-CA": "fr-CA-SylvieNeural",
        "fr-CH": "fr-CH-ArianeNeural",
        "fr-FR": "fr-FR-DeniseNeural",
        "ga-IE": "ga-IE-ColmNeural",
        "gl-ES": "gl-ES-RoiNeural",
        "gu-IN": "gu-IN-DhwaniNeural",
        "he-IL": "he-IL-AvriNeural",
        "hi-IN": "hi-IN-MadhurNeural",
        "hr-HR": "hr-HR-GabrijelaNeural",
        "hu-HU": "hu-HU-NoemiNeural",
        "id-ID": "id-ID-ArdiNeural",
        "is-IS": "is-IS-GudrunNeural",
        "it-IT": "it-IT-IsabellaNeural",
        "ja-JP": "ja-JP-NanamiNeural",
        "jv-ID": "jv-ID-DimasNeural",
        "kk-KZ": "kk-KZ-AigulNeural",
        "km-KH": "km-KH-PisethNeural",
        "kn-IN": "kn-IN-GaganNeural",
        "ko-KR": "ko-KR-SunHiNeural",
        "lo-LA": "lo-LA-ChanthavongNeural",
        "lt-LT": "lt-LT-LeonasNeural",
        "lv-LV": "lv-LV-EveritaNeural",
        "mk-MK": "mk-MK-AleksandarNeural",
        "ml-IN": "ml-IN-MidhunNeural",
        "mr-IN": "mr-IN-AarohiNeural",
        "ms-MY": "ms-MY-OsmanNeural",
        "mt-MT": "mt-MT-GraceNeural",
        "my-MM": "my-MM-NilarNeural",
        "nb-NO": "nb-NO-PernilleNeural",
        "nl-BE": "nl-BE-ArnaudNeural",
        "nl-NL": "nl-NL-ColetteNeural",
        "pl-PL": "pl-PL-AgnieszkaNeural",
        "ps-AF": "ps-AF-GulNawazNeural",
        "pt-BR": "pt-BR-FranciscaNeural",
        "pt-PT": "pt-PT-DuarteNeural",
        "ro-RO": "ro-RO-AlinaNeural",
        "ru-RU": "ru-RU-SvetlanaNeural",
        "si-LK": "si-LK-SameeraNeural",
        "sk-SK": "sk-SK-LukasNeural",
        "sl-SI": "sl-SI-PetraNeural",
        "so-SO": "so-SO-MuuseNeural",
        "sr-RS": "sr-RS-NicholasNeural",
        "su-ID": "su-ID-JajangNeural",
        "sv-SE": "sv-SE-SofieNeural",
        "sw-KE": "sw-KE-RafikiNeural",
        "sw-TZ": "sw-TZ-DaudiNeural",
        "ta-IN": "ta-IN-PallaviNeural",
        "ta-LK": "ta-LK-KumarNeural",
        "ta-SG": "ta-SG-AnbuNeural",
        "te-IN": "te-IN-MohanNeural",
        "th-TH": "th-TH-PremwadeeNeural",
        "tr-TR": "tr-TR-AhmetNeural",
        "uk-UA": "uk-UA-OstapNeural",
        "ur-IN": "ur-IN-GulNeural",
        "ur-PK": "ur-PK-AsadNeural",
        "uz-UZ": "uz-UZ-MadinaNeural",
        "vi-VN": "vi-VN-HoaiMyNeural",
        "zh-CN": "zh-CN-XiaoxiaoNeural",
        "zh-HK": "zh-HK-HiuMaanNeural",
        "zh-TW": "zh-TW-HsiaoChenNeural",
        "zu-ZA": "zu-ZA-ThandoNeural"
      };
      let u = this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US"), l = this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthVoice, ""), p = xv.XMLEncode(n);
      return this.autoDetectSourceLanguage ? u = "en-US" : l = l || c[u], l && (p = `<voice name='${l}'>${p}</voice>`), p = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${u}'>${p}</speak>`, p;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Synthesizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(n) {
      this.privDisposed || (n && this.privAdapter && await this.privAdapter.dispose(), this.privDisposed = !0);
    }
    async adapterSpeak() {
      if (!this.privDisposed && !this.privSynthesizing) {
        this.privSynthesizing = !0;
        const n = await this.synthesisRequestQueue.dequeue();
        return this.privAdapter.Speak(n.text, n.isSSML, n.requestId, n.cb, n.err, n.dataStream);
      }
    }
    createSynthesizerConfig(n) {
      return new e.SynthesizerConfig(n, this.privProperties);
    }
    // Does the generic synthesizer setup that is common across all synthesizer types.
    implCommonSynthesizeSetup() {
      let n = typeof window < "u" ? "Browser" : "Node", c = "unknown", u = "unknown";
      typeof navigator < "u" && (n = n + "/" + navigator.platform, c = navigator.userAgent, u = navigator.appVersion);
      const l = this.createSynthesizerConfig(new e.SpeechServiceConfig(new e.Context(new e.OS(n, c, u)))), p = this.privProperties.getProperty(o.PropertyId.SpeechServiceConnection_Key, void 0), d = p && p !== "" ? new e.CognitiveSubscriptionKeyAuthentication(p) : this.tokenCredential ? new e.CognitiveTokenAuthentication(async () => {
        try {
          return (await this.tokenCredential.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (h) {
          throw h;
        }
      }, async () => {
        try {
          return (await this.tokenCredential.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (h) {
          throw h;
        }
      }) : new e.CognitiveTokenAuthentication(() => {
        const h = this.privProperties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(h);
      }, () => {
        const h = this.privProperties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(h);
      });
      this.privAdapter = this.createSynthesisAdapter(d, this.privConnectionFactory, l), this.privRestAdapter = this.createRestSynthesisAdapter(d, l);
    }
    static XMLEncode(n) {
      return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
  };
  It.Synthesizer = i;
  class a {
    constructor(n, c, u, l, p, d) {
      this.requestId = n, this.text = c, this.isSSML = u, this.cb = l, this.err = p, this.dataStream = d;
    }
  }
  return It.SynthesisRequest = a, It;
}
var Kn = {}, zp;
function CP() {
  if (zp) return Kn;
  zp = 1, Object.defineProperty(Kn, "__esModule", { value: !0 }), Kn.SpeechSynthesizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ uv(), o = /* @__PURE__ */ Rs(), i = /* @__PURE__ */ Kt(), a = /* @__PURE__ */ z(), s = /* @__PURE__ */ A(), n = /* @__PURE__ */ fc();
  let c = class zv extends s.Synthesizer {
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
     */
    constructor(l, p) {
      super(l), p !== null && (p === void 0 ? this.audioConfig = typeof window > "u" ? void 0 : s.AudioConfig.fromDefaultSpeakerOutput() : this.audioConfig = p), this.privConnectionFactory = new e.SpeechSynthesisConnectionFactory(), this.implCommonSynthesizeSetup();
    }
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
     */
    static FromConfig(l, p, d) {
      const h = l;
      return p.properties.mergeTo(h.properties), new zv(l, d);
    }
    /**
     * Executes speech synthesis on plain text.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param text - Text to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakTextAsync(l, p, d, h) {
      this.speakImpl(l, !1, p, d, h);
    }
    /**
     * Executes speech synthesis on SSML.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param ssml - SSML to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakSsmlAsync(l, p, d, h) {
      this.speakImpl(l, !0, p, d, h);
    }
    /**
     * Get list of synthesis voices available.
     * The task returns the synthesis voice result.
     * @member SpeechSynthesizer.prototype.getVoicesAsync
     * @function
     * @async
     * @public
     * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
     * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
     */
    async getVoicesAsync(l = "") {
      return this.getVoices(l);
    }
    /**
     * Dispose of associated resources.
     * @member SpeechSynthesizer.prototype.close
     * @function
     * @public
     */
    close(l, p) {
      a.Contracts.throwIfDisposed(this.privDisposed), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), l, p);
    }
    /**
     * @Internal
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privAdapter;
    }
    //
    // ################################################################################################################
    // IMPLEMENTATION.
    // ################################################################################################################
    //
    // Creates the synthesis adapter
    createSynthesisAdapter(l, p, d) {
      return new e.SpeechSynthesisAdapter(l, p, d, this, this.audioConfig);
    }
    createRestSynthesisAdapter(l, p) {
      return new e.SynthesisRestAdapter(p, l);
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(s.SpeechSynthesisOutputFormat[this.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)]);
    }
    speakImpl(l, p, d, h, f) {
      try {
        a.Contracts.throwIfDisposed(this.privDisposed);
        const g = (0, t.createNoDashGuid)();
        let m;
        f instanceof s.PushAudioOutputStreamCallback ? m = new i.PushAudioOutputStreamImpl(f) : f instanceof s.PullAudioOutputStream ? m = f : f !== void 0 ? m = new r.AudioFileWriter(f) : m = void 0, this.synthesisRequestQueue.enqueue(new n.SynthesisRequest(g, l, p, (v) => {
          if (this.privSynthesizing = !1, d)
            try {
              d(v);
            } catch (y) {
              h && h(y);
            }
          d = void 0, this.adapterSpeak().catch(() => {
          });
        }, (v) => {
          h && h(v);
        }, m)), this.adapterSpeak().catch(() => {
        });
      } catch (g) {
        if (h)
          if (g instanceof Error) {
            const m = g;
            h(m.name + ": " + m.message);
          } else
            h(g);
        this.dispose(!0).catch(() => {
        });
      }
    }
    async getVoices(l) {
      const p = (0, t.createNoDashGuid)(), d = await this.privRestAdapter.getVoicesList(p);
      if (d.ok && Array.isArray(d.json)) {
        let h = d.json;
        return l && l.length > 0 && (h = h.filter((f) => !!f.Locale && f.Locale.toLowerCase() === l.toLowerCase())), new s.SynthesisVoicesResult(p, h, void 0);
      } else
        return new s.SynthesisVoicesResult(p, void 0, `Error: ${d.status}: ${d.statusText}`);
    }
  };
  return Kn.SpeechSynthesizer = c, Kn;
}
var Jn = {}, Lp;
function RP() {
  if (Lp) return Jn;
  Lp = 1, Object.defineProperty(Jn, "__esModule", { value: !0 }), Jn.SynthesisResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, o, i, a) {
      this.privResultId = r, this.privReason = o, this.privErrorDetails = i, this.privProperties = a;
    }
    /**
     * Specifies the result identifier.
     * @member SynthesisResult.prototype.resultId
     * @function
     * @public
     * @returns {string} Specifies the result identifier.
     */
    get resultId() {
      return this.privResultId;
    }
    /**
     * Specifies status of the result.
     * @member SynthesisResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} Specifies status of the result.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * In case of an unsuccessful synthesis, provides details of the occurred error.
     * @member SynthesisResult.prototype.errorDetails
     * @function
     * @public
     * @returns {string} a brief description of an error.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * The set of properties exposed in the result.
     * @member SynthesisResult.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The set of properties exposed in the result.
     */
    get properties() {
      return this.privProperties;
    }
  };
  return Jn.SynthesisResult = e, Jn;
}
var Gn = {}, jp;
function PP() {
  if (jp) return Gn;
  jp = 1, Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.SpeechSynthesisResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {ArrayBuffer} audioData - The synthesized audio binary.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     * @param {number} audioDuration - The audio duration.
     */
    constructor(o, i, a, s, n, c) {
      super(o, i, s, n), this.privAudioData = a, this.privAudioDuration = c;
    }
    /**
     * The synthesized audio data
     * @member SpeechSynthesisResult.prototype.audioData
     * @function
     * @public
     * @returns {ArrayBuffer} The synthesized audio data.
     */
    get audioData() {
      return this.privAudioData;
    }
    /**
     * The time duration of synthesized audio, in ticks (100 nanoseconds).
     * @member SpeechSynthesisResult.prototype.audioDuration
     * @function
     * @public
     * @returns {number} The time duration of synthesized audio.
     */
    get audioDuration() {
      return this.privAudioDuration;
    }
  };
  return Gn.SpeechSynthesisResult = t, Gn;
}
var Qn = {}, qp;
function bP() {
  if (qp) return Qn;
  qp = 1, Object.defineProperty(Qn, "__esModule", { value: !0 }), Qn.SpeechSynthesisEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechSynthesisResult} result - The speech synthesis result.
     */
    constructor(r) {
      this.privResult = r;
    }
    /**
     * Specifies the synthesis result.
     * @member SpeechSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechSynthesisResult} the synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Qn.SpeechSynthesisEventArgs = e, Qn;
}
var Yn = {}, Fp;
function wP() {
  if (Fp) return Yn;
  Fp = 1, Object.defineProperty(Yn, "__esModule", { value: !0 }), Yn.SpeechSynthesisWordBoundaryEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} duration - The audio duration.
     * @param {string} text - The text.
     * @param {number} wordLength - The length of the word.
     * @param {number} textOffset - The text offset.
     * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
     */
    constructor(r, o, i, a, s, n) {
      this.privAudioOffset = r, this.privDuration = o, this.privText = i, this.privWordLength = a, this.privTextOffset = s, this.privBoundaryType = n;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the duration, in ticks (100 nanoseconds).
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
     * @function
     * @public
     * @returns {number} Duration in 100 nanosecond increments.
     */
    get duration() {
      return this.privDuration;
    }
    /**
     * Specifies the text of the word boundary event.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
     * @function
     * @public
     * @returns {string} the text.
     */
    get text() {
      return this.privText;
    }
    /**
     * Specifies the word length
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
     * @function
     * @public
     * @returns {number} the word length
     */
    get wordLength() {
      return this.privWordLength;
    }
    /**
     * Specifies the text offset.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
     * @function
     * @public
     * @returns {number} the text offset.
     */
    get textOffset() {
      return this.privTextOffset;
    }
    /**
     * Specifies the boundary type.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
     * @function
     * @public
     * @returns {SpeechSynthesisBoundaryType} the boundary type.
     */
    get boundaryType() {
      return this.privBoundaryType;
    }
  };
  return Yn.SpeechSynthesisWordBoundaryEventArgs = e, Yn;
}
var Zn = {}, Bp;
function EP() {
  if (Bp) return Zn;
  Bp = 1, Object.defineProperty(Zn, "__esModule", { value: !0 }), Zn.SpeechSynthesisBookmarkEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {string} text - The bookmark text.
     */
    constructor(r, o) {
      this.privAudioOffset = r, this.privText = o;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the bookmark.
     * @member SpeechSynthesisBookmarkEventArgs.prototype.text
     * @function
     * @public
     * @returns {string} the bookmark text.
     */
    get text() {
      return this.privText;
    }
  };
  return Zn.SpeechSynthesisBookmarkEventArgs = e, Zn;
}
var Xn = {}, Up;
function IP() {
  if (Up) return Xn;
  Up = 1, Object.defineProperty(Xn, "__esModule", { value: !0 }), Xn.SpeechSynthesisVisemeEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} visemeId - The viseme ID.
     * @param {string} animation - The animation, could be in svg or other format.
     */
    constructor(r, o, i) {
      this.privAudioOffset = r, this.privVisemeId = o, this.privAnimation = i;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the viseme ID.
     * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
     * @function
     * @public
     * @returns {number} the viseme ID.
     */
    get visemeId() {
      return this.privVisemeId;
    }
    /**
     * Specifies the animation.
     * @member SpeechSynthesisVisemeEventArgs.prototype.animation
     * @function
     * @public
     * @returns {string} the animation, could be in svg or other format.
     */
    get animation() {
      return this.privAnimation;
    }
  };
  return Xn.SpeechSynthesisVisemeEventArgs = e, Xn;
}
var ia = {}, $p;
function AP() {
  return $p || ($p = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeechSynthesisBoundaryType = void 0, function(t) {
      t.Word = "WordBoundary", t.Punctuation = "PunctuationBoundary", t.Sentence = "SentenceBoundary";
    }(e.SpeechSynthesisBoundaryType || (e.SpeechSynthesisBoundaryType = {}));
  }(ia)), ia;
}
var ei = {}, Vp;
function TP() {
  if (Vp) return ei;
  Vp = 1, Object.defineProperty(ei, "__esModule", { value: !0 }), ei.SynthesisVoicesResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param requestId - result id for request.
     * @param json - json payload from endpoint.
     */
    constructor(o, i, a) {
      if (Array.isArray(i)) {
        super(o, e.ResultReason.VoicesListRetrieved, void 0, new e.PropertyCollection()), this.privVoices = [];
        for (const s of i)
          this.privVoices.push(new e.VoiceInfo(s));
      } else
        super(o, e.ResultReason.Canceled, a || "Error information unavailable", new e.PropertyCollection());
    }
    /**
     * The list of voices
     * @member SynthesisVoicesResult.prototype.voices
     * @function
     * @public
     * @returns {VoiceInfo[]} List of synthesized voices.
     */
    get voices() {
      return this.privVoices;
    }
  };
  return ei.SynthesisVoicesResult = t, ei;
}
var sa = {}, Wp;
function _P() {
  return Wp || (Wp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.VoiceInfo = e.SynthesisVoiceType = e.SynthesisVoiceGender = void 0;
    var t;
    (function(s) {
      s[s.Unknown = 0] = "Unknown", s[s.Female = 1] = "Female", s[s.Male = 2] = "Male", s[s.Neutral = 3] = "Neutral";
    })(t = e.SynthesisVoiceGender || (e.SynthesisVoiceGender = {}));
    var r;
    (function(s) {
      s[s.Unknown = 0] = "Unknown", s[s.OnlineNeural = 1] = "OnlineNeural", s[s.OnlineStandard = 2] = "OnlineStandard", s[s.OfflineNeural = 3] = "OfflineNeural", s[s.OfflineStandard = 4] = "OfflineStandard", s[s.OnlineNeuralHD = 5] = "OnlineNeuralHD";
    })(r = e.SynthesisVoiceType || (e.SynthesisVoiceType = {}));
    const o = {
      [t[t.Neutral]]: t.Neutral,
      [t[t.Male]]: t.Male,
      [t[t.Female]]: t.Female
    }, i = {
      Neural: r.OnlineNeural,
      NeuralHD: r.OnlineNeuralHD
    };
    class a {
      constructor(n) {
        if (this.privStyleList = [], n) {
          if (this.privName = n.Name, this.privLocale = n.Locale, this.privShortName = n.ShortName, this.privLocaleName = n.LocaleName, this.privDisplayName = n.DisplayName, this.privLocalName = n.LocalName, this.privVoiceType = i[n.VoiceType] || r.Unknown, this.privGender = o[n.Gender] || t.Unknown, n.StyleList && Array.isArray(n.StyleList))
            for (const c of n.StyleList)
              this.privStyleList.push(c);
          this.privSampleRateHertz = n.SampleRateHertz, this.privStatus = n.Status, n.ExtendedPropertyMap && (this.privExtendedPropertyMap = n.ExtendedPropertyMap), this.privWordsPerMinute = n.WordsPerMinute, Array.isArray(n.SecondaryLocaleList) && (this.privSecondaryLocaleList = [...n.SecondaryLocaleList]), Array.isArray(n.RolePlayList) && (this.privRolePlayList = [...n.RolePlayList]), n.VoiceTag && (this.privVoiceTag = n.VoiceTag);
        }
      }
      get name() {
        return this.privName;
      }
      get locale() {
        return this.privLocale;
      }
      get shortName() {
        return this.privShortName;
      }
      get displayName() {
        return this.privDisplayName;
      }
      get localName() {
        return this.privLocalName;
      }
      get localeName() {
        return this.privLocaleName;
      }
      get gender() {
        return this.privGender;
      }
      get voiceType() {
        return this.privVoiceType;
      }
      get styleList() {
        return this.privStyleList;
      }
      get sampleRateHertz() {
        return this.privSampleRateHertz;
      }
      get status() {
        return this.privStatus;
      }
      get extendedPropertyMap() {
        return this.privExtendedPropertyMap;
      }
      get wordsPerMinute() {
        return this.privWordsPerMinute;
      }
      get secondaryLocaleList() {
        return this.privSecondaryLocaleList;
      }
      get rolePlayList() {
        return this.privRolePlayList;
      }
      get voiceTag() {
        return this.privVoiceTag;
      }
    }
    e.VoiceInfo = a;
  }(sa)), sa;
}
var ti = {}, Hp;
function kP() {
  if (Hp) return ti;
  Hp = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.SpeakerAudioDestination = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ Kt(), r = /* @__PURE__ */ jt(), o = 60 * 30, i = {
    [r.AudioFormatTag.PCM]: "audio/wav",
    [r.AudioFormatTag.MuLaw]: "audio/x-wav",
    [r.AudioFormatTag.MP3]: "audio/mpeg",
    [r.AudioFormatTag.OGG_OPUS]: "audio/ogg",
    [r.AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
    [r.AudioFormatTag.ALaw]: "audio/x-wav",
    [r.AudioFormatTag.FLAC]: "audio/flac",
    [r.AudioFormatTag.AMR_WB]: "audio/amr-wb",
    [r.AudioFormatTag.G722]: "audio/G722"
  };
  let a = class {
    constructor(n) {
      this.privPlaybackStarted = !1, this.privAppendingToBuffer = !1, this.privMediaSourceOpened = !1, this.privBytesReceived = 0, this.privId = n || (0, e.createNoDashGuid)(), this.privIsPaused = !1, this.privIsClosed = !1;
    }
    id() {
      return this.privId;
    }
    write(n, c, u) {
      this.privAudioBuffer !== void 0 ? (this.privAudioBuffer.push(n), this.updateSourceBuffer().then(() => {
        c && c();
      }, (l) => {
        u && u(l);
      })) : this.privAudioOutputStream !== void 0 && (this.privAudioOutputStream.write(n), this.privBytesReceived += n.byteLength);
    }
    close(n, c) {
      if (this.privIsClosed = !0, this.privSourceBuffer !== void 0)
        this.handleSourceBufferUpdateEnd().then(() => {
          n && n();
        }, (u) => {
          c && c(u);
        });
      else if (this.privAudioOutputStream !== void 0 && typeof window < "u")
        if ((this.privFormat.formatTag === r.AudioFormatTag.PCM || this.privFormat.formatTag === r.AudioFormatTag.MuLaw || this.privFormat.formatTag === r.AudioFormatTag.ALaw) && this.privFormat.hasHeader === !1)
          console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header."), this.onAudioEnd && this.onAudioEnd(this);
        else {
          let u = new ArrayBuffer(this.privBytesReceived);
          this.privAudioOutputStream.read(u).then(() => {
            u = this.privFormat.addHeader(u);
            const l = new Blob([u], { type: i[this.privFormat.formatTag] });
            this.privAudio.src = window.URL.createObjectURL(l), this.notifyPlayback().then(() => {
              n && n();
            }, (p) => {
              c && c(p);
            });
          }, (l) => {
            c && c(l);
          });
        }
      else
        this.onAudioEnd && this.onAudioEnd(this);
    }
    set format(n) {
      if (typeof AudioContext < "u" || typeof window < "u" && typeof window.webkitAudioContext < "u") {
        this.privFormat = n;
        const c = i[this.privFormat.formatTag];
        c === void 0 ? console.warn(`Unknown mimeType for format ${r.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`) : typeof MediaSource < "u" && MediaSource.isTypeSupported(c) ? (this.privAudio = new Audio(), this.privAudioBuffer = [], this.privMediaSource = new MediaSource(), this.privAudio.src = URL.createObjectURL(this.privMediaSource), this.privAudio.load(), this.privMediaSource.onsourceopen = () => {
          this.privMediaSourceOpened = !0, this.privMediaSource.duration = o, this.privSourceBuffer = this.privMediaSource.addSourceBuffer(c), this.privSourceBuffer.onupdate = () => {
            this.updateSourceBuffer().catch((u) => {
              e.Events.instance.onEvent(new e.BackgroundEvent(u));
            });
          }, this.privSourceBuffer.onupdateend = () => {
            this.handleSourceBufferUpdateEnd().catch((u) => {
              e.Events.instance.onEvent(new e.BackgroundEvent(u));
            });
          }, this.privSourceBuffer.onupdatestart = () => {
            this.privAppendingToBuffer = !1;
          };
        }, this.updateSourceBuffer().catch((u) => {
          e.Events.instance.onEvent(new e.BackgroundEvent(u));
        })) : (console.warn(`Format ${r.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`), this.privAudioOutputStream = new t.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privFormat, this.privAudio = new Audio());
      }
    }
    get volume() {
      return this.privAudio?.volume ?? -1;
    }
    set volume(n) {
      this.privAudio && (this.privAudio.volume = n);
    }
    mute() {
      this.privAudio && (this.privAudio.muted = !0);
    }
    unmute() {
      this.privAudio && (this.privAudio.muted = !1);
    }
    get isClosed() {
      return this.privIsClosed;
    }
    get currentTime() {
      return this.privAudio !== void 0 ? this.privAudio.currentTime : -1;
    }
    pause() {
      !this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.pause(), this.privIsPaused = !0);
    }
    resume(n, c) {
      this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.play().then(() => {
        n && n();
      }, (u) => {
        c && c(u);
      }), this.privIsPaused = !1);
    }
    get internalAudio() {
      return this.privAudio;
    }
    async updateSourceBuffer() {
      if (this.privAudioBuffer !== void 0 && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
        this.privAppendingToBuffer = !0;
        const n = this.privAudioBuffer.shift();
        try {
          this.privSourceBuffer.appendBuffer(n);
        } catch {
          this.privAudioBuffer.unshift(n), console.log("buffer filled, pausing addition of binaries until space is made");
          return;
        }
        await this.notifyPlayback();
      } else this.canEndStream() && await this.handleSourceBufferUpdateEnd();
    }
    async handleSourceBufferUpdateEnd() {
      this.canEndStream() && this.sourceBufferAvailable() && (this.privMediaSource.endOfStream(), await this.notifyPlayback());
    }
    async notifyPlayback() {
      !this.privPlaybackStarted && this.privAudio !== void 0 && (this.privPlaybackStarted = !0, this.onAudioStart && this.onAudioStart(this), this.privAudio.onended = () => {
        this.onAudioEnd && this.onAudioEnd(this);
      }, this.privIsPaused || await this.privAudio.play());
    }
    canEndStream() {
      return this.isClosed && this.privSourceBuffer !== void 0 && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
    }
    sourceBufferAvailable() {
      return this.privSourceBuffer !== void 0 && !this.privSourceBuffer.updating;
    }
  };
  return ti.SpeakerAudioDestination = a, ti;
}
var ri = {}, Kp;
function OP() {
  if (Kp) return ri;
  Kp = 1, Object.defineProperty(ri, "__esModule", { value: !0 }), ri.ConversationTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Ps();
  let t = class extends e.CancellationEventArgsBase {
  };
  return ri.ConversationTranscriptionCanceledEventArgs = t, ri;
}
var ni = {}, Jp;
function MP() {
  if (Jp) return ni;
  Jp = 1, Object.defineProperty(ni, "__esModule", { value: !0 }), ni.MeetingTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Ps();
  let t = class extends e.CancellationEventArgsBase {
  };
  return ni.MeetingTranscriptionCanceledEventArgs = t, ni;
}
var oa = {}, Gp;
function DP() {
  return Gp || (Gp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PronunciationAssessmentGradingSystem = void 0, function(t) {
      t[t.FivePoint = 1] = "FivePoint", t[t.HundredMark = 2] = "HundredMark";
    }(e.PronunciationAssessmentGradingSystem || (e.PronunciationAssessmentGradingSystem = {}));
  }(oa)), oa;
}
var aa = {}, Qp;
function NP() {
  return Qp || (Qp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PronunciationAssessmentGranularity = void 0, function(t) {
      t[t.Phoneme = 1] = "Phoneme", t[t.Word = 2] = "Word", t[t.FullText = 3] = "FullText";
    }(e.PronunciationAssessmentGranularity || (e.PronunciationAssessmentGranularity = {}));
  }(aa)), aa;
}
var ii = {}, Yp;
function xP() {
  if (Yp) return ii;
  Yp = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.PronunciationAssessmentConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class Lv {
    /**
     * PronunciationAssessmentConfig constructor.
     * @constructor
     * @param {string} referenceText
     * @param gradingSystem
     * @param granularity
     * @param enableMiscue
     */
    constructor(i, a = t.PronunciationAssessmentGradingSystem.FivePoint, s = t.PronunciationAssessmentGranularity.Phoneme, n = !1) {
      e.Contracts.throwIfNullOrUndefined(i, "referenceText"), this.privProperties = new t.PropertyCollection(), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_ReferenceText, i), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_GradingSystem, t.PronunciationAssessmentGradingSystem[a]), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_Granularity, t.PronunciationAssessmentGranularity[s]), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, String(n));
    }
    /**
     * @member PronunciationAssessmentConfig.fromJSON
     * @function
     * @public
     * @param {string} json The json string containing the pronunciation assessment parameters.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentConfig from json.
     * This method is designed to support the pronunciation assessment parameters still in preview.
     * Under normal circumstances, use the constructor instead.
     */
    static fromJSON(i) {
      e.Contracts.throwIfNullOrUndefined(i, "json");
      const a = new Lv("");
      return a.privProperties = new t.PropertyCollection(), a.properties.setProperty(t.PropertyId.PronunciationAssessment_Json, i), a;
    }
    toJSON() {
      return this.updateJson(), this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Params);
    }
    applyTo(i) {
      this.updateJson();
      const a = i.internalData;
      a.expectContentAssessmentResponse = !!this.privContentAssessmentTopic, a.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(t.PropertyId.PronunciationAssessment_Params), this.privContentAssessmentTopic, a.isSpeakerDiarizationEnabled);
    }
    /**
     * Gets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @returns {string} Reference text.
     */
    get referenceText() {
      return this.properties.getProperty(t.PropertyId.PronunciationAssessment_ReferenceText);
    }
    /**
     * Gets/Sets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @param {string} referenceText - Reference text.
     */
    set referenceText(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "referenceText"), this.properties.setProperty(t.PropertyId.PronunciationAssessment_ReferenceText, i);
    }
    /**
     * Sets the phoneme alphabet.
     * The valid values are "SAPI" (default) and "IPA".
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
     * @function
     * @public
     * @param {string} phonemeAlphabet - Phoneme alphabet.
     */
    set phonemeAlphabet(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "phonemeAlphabet"), this.privPhonemeAlphabet = i;
    }
    /**
     * Sets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @param {boolean} enableMiscue - enable miscue.
     */
    set enableMiscue(i) {
      const a = i ? "true" : "false";
      this.properties.setProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, a);
    }
    /**
     * Gets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @return {boolean} enableMiscue - enable miscue.
     */
    get enableMiscue() {
      return this.properties.getProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, "false").toLowerCase() === "true";
    }
    /**
     * Sets the nbest phoneme count
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
     * @function
     * @public
     * @param {number} nbestPhonemeCount - NBest phoneme count.
     */
    set nbestPhonemeCount(i) {
      this.privNBestPhonemeCount = i;
    }
    /**
     * Enables the prosody assessment.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableProsodyAssessment
     * @function
     * @public
     * @param {boolean} enableProsodyAssessment - enable prosody assessment.
     */
    set enableProsodyAssessment(i) {
      this.privEnableProsodyAssessment = i;
    }
    /**
     * Enables content assessment and sets the topic.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableContentAssessmentWithTopic
     * @function
     * @public
     * @param {string} topic - Topic for content assessment.
     */
    enableContentAssessmentWithTopic(i) {
      this.privContentAssessmentTopic = i;
    }
    /**
     * @member PronunciationAssessmentConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets a pronunciation assessment config properties
     */
    get properties() {
      return this.privProperties;
    }
    updateJson() {
      const i = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Json, "{}"), a = JSON.parse(i), s = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_ReferenceText);
      s && (a.referenceText = s);
      const n = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_GradingSystem);
      n && (a.gradingSystem = n);
      const c = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Granularity);
      c && (a.granularity = c), this.privPhonemeAlphabet && (a.phonemeAlphabet = this.privPhonemeAlphabet), this.privNBestPhonemeCount && (a.nbestPhonemeCount = this.privNBestPhonemeCount), a.enableProsodyAssessment = this.privEnableProsodyAssessment, a.dimension = "Comprehensive", this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_EnableMiscue) && (a.enableMiscue = this.enableMiscue), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_Params, JSON.stringify(a));
    }
  };
  return ii.PronunciationAssessmentConfig = r, ii;
}
var At = {}, Zp;
function zP() {
  if (Zp) return At;
  Zp = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.PronunciationAssessmentResult = At.ContentAssessmentResult = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  class r {
    /**
     * @Internal
     * Do not use externally.
     */
    constructor(a) {
      this.privPronJson = a;
    }
    /**
     * Correctness in using grammar and variety of sentence patterns.
     * Grammatical errors are jointly evaluated by lexical accuracy,
     * grammatical accuracy and diversity of sentence structures.
     * @member ContentAssessmentResult.prototype.grammarScore
     * @function
     * @public
     * @returns {number} Grammar score.
     */
    get grammarScore() {
      return this.privPronJson.ContentAssessment.GrammarScore;
    }
    /**
     * Proficiency in lexical usage. It evaluates the speaker's effective usage
     * of words and their appropriateness within the given context to express
     * ideas accurately, as well as level of lexical complexity.
     * @member ContentAssessmentResult.prototype.vocabularyScore
     * @function
     * @public
     * @returns {number} Vocabulary score.
     */
    get vocabularyScore() {
      return this.privPronJson.ContentAssessment.VocabularyScore;
    }
    /**
     * Level of understanding and engagement with the topic, which provides
     * insights into the speakers ability to express their thoughts and ideas
     * effectively and the ability to engage with the topic.
     * @member ContentAssessmentResult.prototype.topicScore
     * @function
     * @public
     * @returns {number} Topic score.
     */
    get topicScore() {
      return this.privPronJson.ContentAssessment.TopicScore;
    }
  }
  At.ContentAssessmentResult = r;
  let o = class jv {
    constructor(a) {
      const s = JSON.parse(a);
      e.Contracts.throwIfNullOrUndefined(s.NBest[0], "NBest"), this.privPronJson = s.NBest[0];
    }
    /**
     * @member PronunciationAssessmentResult.fromResult
     * @function
     * @public
     * @param {RecognitionResult} result The recognition result.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
     */
    static fromResult(a) {
      e.Contracts.throwIfNullOrUndefined(a, "result");
      const s = a.properties.getProperty(t.PropertyId.SpeechServiceResponse_JsonResult);
      return e.Contracts.throwIfNullOrUndefined(s, "json"), new jv(s);
    }
    /**
     * Gets the detail result of pronunciation assessment.
     * @member PronunciationAssessmentConfig.prototype.detailResult
     * @function
     * @public
     * @returns {DetailResult} detail result.
     */
    get detailResult() {
      return this.privPronJson;
    }
    /**
     * The score indicating the pronunciation accuracy of the given speech, which indicates
     * how closely the phonemes match a native speaker's pronunciation.
     * @member PronunciationAssessmentResult.prototype.accuracyScore
     * @function
     * @public
     * @returns {number} Accuracy score.
     */
    get accuracyScore() {
      return this.detailResult.PronunciationAssessment?.AccuracyScore;
    }
    /**
     * The overall score indicating the pronunciation quality of the given speech.
     * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
     * @member PronunciationAssessmentResult.prototype.pronunciationScore
     * @function
     * @public
     * @returns {number} Pronunciation score.
     */
    get pronunciationScore() {
      return this.detailResult.PronunciationAssessment?.PronScore;
    }
    /**
     * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
     * @member PronunciationAssessmentResult.prototype.completenessScore
     * @function
     * @public
     * @returns {number} Completeness score.
     */
    get completenessScore() {
      return this.detailResult.PronunciationAssessment?.CompletenessScore;
    }
    /**
     * The score indicating the fluency of the given speech.
     * @member PronunciationAssessmentResult.prototype.fluencyScore
     * @function
     * @public
     * @returns {number} Fluency score.
     */
    get fluencyScore() {
      return this.detailResult.PronunciationAssessment?.FluencyScore;
    }
    /**
     * The prosody score, which indicates how nature of the given speech, including stress, intonation, speaking speed and rhythm.
     * @member PronunciationAssessmentResult.prototype.prosodyScore
     * @function
     * @public
     * @returns {number} Prosody score.
     */
    get prosodyScore() {
      return this.detailResult.PronunciationAssessment?.ProsodyScore;
    }
    /**
     * The concent assessment result.
     * Only available when content assessment is enabled.
     * @member PronunciationAssessmentResult.prototype.contentAssessmentResult
     * @function
     * @public
     * @returns {ContentAssessmentResult} Content assessment result.
     */
    get contentAssessmentResult() {
      if (this.detailResult.ContentAssessment !== void 0)
        return new r(this.detailResult);
    }
  };
  return At.PronunciationAssessmentResult = o, At;
}
var si = {}, Xp;
function LP() {
  if (Xp) return si;
  Xp = 1, Object.defineProperty(si, "__esModule", { value: !0 }), si.AvatarConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ A();
  let r = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} character - The avatar character.
     * @param {string} style - The avatar style.
     * @param {AvatarVideoFormat} videoFormat - The talking avatar output video format.
     */
    constructor(i, a, s) {
      this.privCustomized = !1, this.privUseBuiltInVoice = !1, e.Contracts.throwIfNullOrWhitespace(i, "character"), this.character = i, this.style = a, s === void 0 && (s = new t.AvatarVideoFormat()), this.videoFormat = s;
    }
    /**
     * Indicates if the talking avatar is customized.
     */
    get customized() {
      return this.privCustomized;
    }
    /**
     * Sets if the talking avatar is customized.
     */
    set customized(i) {
      this.privCustomized = i;
    }
    /**
     * Indicates whether to use built-in voice for custom avatar.
     */
    get useBuiltInVoice() {
      return this.privUseBuiltInVoice;
    }
    /**
     * Sets whether to use built-in voice for custom avatar.
     */
    set useBuiltInVoice(i) {
      this.privUseBuiltInVoice = i;
    }
    /**
     * Gets the background color.
     */
    get backgroundColor() {
      return this.privBackgroundColor;
    }
    /**
     * Sets the background color.
     */
    set backgroundColor(i) {
      this.privBackgroundColor = i;
    }
    /**
     * Gets the background image.
     */
    get backgroundImage() {
      return this.privBackgroundImage;
    }
    /**
     * Sets the background image.
     * @param {URL} value - The background image.
     */
    set backgroundImage(i) {
      this.privBackgroundImage = i;
    }
    /**
     * Gets the remote ICE servers.
     * @remarks This method is designed to be used internally in the SDK.
     * @returns {RTCIceServer[]} The remote ICE servers.
     */
    get remoteIceServers() {
      return this.privRemoteIceServers;
    }
    /**
     * Sets the remote ICE servers.
     * @remarks Normally, the ICE servers are gathered from the PeerConnection,
     * set this property to override the ICE servers. E.g., the ICE servers are
     * different in client and server side.
     * @param {RTCIceServer[]} value - The remote ICE servers.
     */
    set remoteIceServers(i) {
      this.privRemoteIceServers = i;
    }
  };
  return si.AvatarConfig = r, si;
}
var ca = {}, ed;
function jP() {
  return ed || (ed = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AvatarEventArgs = e.AvatarEventTypes = void 0, function(r) {
      r.SwitchedToSpeaking = "SwitchedToSpeaking", r.SwitchedToIdle = "SwitchedToIdle", r.SessionClosed = "SessionClosed";
    }(e.AvatarEventTypes || (e.AvatarEventTypes = {}));
    class t {
      /**
       * Creates and initializes an instance of this class.
       * @constructor
       * @param {number} audioOffset - The audio offset.
       * @param {string} description - The description of the event.
       */
      constructor(o, i) {
        this.privOffset = o, this.privDescription = i;
      }
      /**
       * The type of the event.
       * @public
       * @returns {AvatarEventTypes} The type of the event.
       */
      get type() {
        return this.privType;
      }
      /**
       * The time offset associated with this event.
       * @public
       * @returns {number} The time offset associated with this event.
       */
      get offset() {
        return this.privOffset;
      }
      /**
       * The description of the event.
       * @public
       * @returns {string} The description of the event.
       */
      get description() {
        return this.privDescription;
      }
    }
    e.AvatarEventArgs = t;
  }(ca)), ca;
}
var oi = {}, ai = {}, td;
function qv() {
  if (td) return ai;
  td = 1, Object.defineProperty(ai, "__esModule", { value: !0 }), ai.SpeechSynthesisConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Te(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ pe(), a = /* @__PURE__ */ rt();
  let s = class {
    constructor() {
      this.synthesisUri = "/tts/cognitiveservices/websocket/v1";
    }
    async create(c, u, l) {
      let p = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const d = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, void 0), h = r.ConnectionFactoryBase.getHostSuffix(d), f = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), g = f === void 0 ? "tts" : "voice", m = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + d + "." + g + ".speech" + h), v = {}, y = {};
      if (u.token !== void 0 && u.token !== "" && (y[u.headerName] = u.token), y[i.HeaderNames.ConnectionId] = l, f !== void 0 && f !== "" && (!p || p.search(a.QueryParameterNames.CustomVoiceDeploymentId) === -1) && (v[a.QueryParameterNames.CustomVoiceDeploymentId] = f), c.avatarEnabled && (!p || p.search(a.QueryParameterNames.EnableAvatar) === -1) && (v[a.QueryParameterNames.EnableAvatar] = "true"), p) {
        const C = new URL(p), b = C.pathname;
        (b === "" || b === "/") && (C.pathname = this.synthesisUri, p = await r.ConnectionFactoryBase.getRedirectUrlFromEndpoint(C.toString()));
      }
      p || (p = m + this.synthesisUri), c.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, p);
      const S = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new e.WebsocketConnection(p, v, y, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromParameters(c.parameters), S, l);
    }
  };
  return ai.SpeechSynthesisConnectionFactory = s, ai;
}
var rd;
function qP() {
  if (rd) return oi;
  rd = 1, Object.defineProperty(oi, "__esModule", { value: !0 }), oi.AvatarSynthesizer = void 0;
  const e = /* @__PURE__ */ qv(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ O(), o = /* @__PURE__ */ Rs(), i = /* @__PURE__ */ A(), a = /* @__PURE__ */ z(), s = /* @__PURE__ */ fc();
  let n = class extends i.Synthesizer {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config.
     * @param {AvatarConfig} avatarConfig - The talking avatar config.
     */
    constructor(u, l) {
      super(u), a.Contracts.throwIfNullOrUndefined(l, "avatarConfig"), this.privConnectionFactory = new e.SpeechSynthesisConnectionFactory(), this.privAvatarConfig = l, this.implCommonSynthesizeSetup();
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(i.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);
    }
    /**
     * Starts the talking avatar session and establishes the WebRTC connection.
     * @member AvatarSynthesizer.prototype.startAvatarAsync
     * @function
     * @public
     * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.
     * @returns {Promise<SynthesisResult>} The promise of the connection result.
     */
    async startAvatarAsync(u) {
      a.Contracts.throwIfNullOrUndefined(u, "peerConnection"), this.privIceServers = u.getConfiguration().iceServers, a.Contracts.throwIfNullOrUndefined(this.privIceServers, "Ice servers must be set.");
      const l = new r.Deferred();
      u.onicegatheringstatechange = () => {
        r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering state: " + u.iceGatheringState, r.EventType.Debug)), u.iceGatheringState === "complete" && (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering complete.", r.EventType.Info)), l.resolve());
      }, u.onicecandidate = (g) => {
        g.candidate ? r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice candidate: " + g.candidate.candidate, r.EventType.Debug)) : (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice candidate: complete", r.EventType.Debug)), l.resolve());
      }, setTimeout(() => {
        u.iceGatheringState !== "complete" && (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering timeout.", r.EventType.Warning)), l.resolve());
      }, 2e3);
      const p = await u.createOffer();
      await u.setLocalDescription(p), await l.promise, r.Events.instance.onEvent(new r.PlatformEvent("peer connection: got local SDP.", r.EventType.Info)), this.privProperties.setProperty(i.PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(u.localDescription));
      const d = await this.speak("", !1);
      if (d.reason !== i.ResultReason.SynthesizingAudioCompleted)
        return new i.SynthesisResult(d.resultId, d.reason, d.errorDetails, d.properties);
      const h = atob(d.properties.getProperty(i.PropertyId.TalkingAvatarService_WebRTC_SDP)), f = new RTCSessionDescription(JSON.parse(h));
      return await u.setRemoteDescription(f), new i.SynthesisResult(d.resultId, d.reason, void 0, d.properties);
    }
    /**
     * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param {string} text - The plain text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakTextAsync(u) {
      const l = await this.speak(u, !1);
      return new i.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
    }
    /**
     * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param {string} ssml - The SSML text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakSsmlAsync(u) {
      const l = await this.speak(u, !0);
      return new i.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
    }
    /**
     * Speaks text asynchronously. The avatar will switch to idle state.
     * @member AvatarSynthesizer.prototype.stopSpeakingAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopSpeakingAsync() {
      for (; this.synthesisRequestQueue.length() > 0; )
        (await this.synthesisRequestQueue.dequeue()).err("Synthesis is canceled by user.");
      return this.privAdapter.stopSpeaking();
    }
    /**
     * Stops the talking avatar session and closes the WebRTC connection.
     * For now, this is the same as close().
     * You need to create a new AvatarSynthesizer instance to start a new session.
     * @member AvatarSynthesizer.prototype.stopAvatarAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopAvatarAsync() {
      return a.Contracts.throwIfDisposed(this.privDisposed), this.dispose(!0);
    }
    /**
     * Dispose of associated resources.
     * @member AvatarSynthesizer.prototype.close
     * @function
     * @public
     */
    async close() {
      if (!this.privDisposed)
        return this.dispose(!0);
    }
    /**
     * Gets the ICE servers. Internal use only.
     */
    get iceServers() {
      return this.privIceServers;
    }
    // Creates the synthesis adapter
    createSynthesisAdapter(u, l, p) {
      return new t.AvatarSynthesisAdapter(u, l, p, this, this.privAvatarConfig);
    }
    createRestSynthesisAdapter(u, l) {
    }
    createSynthesizerConfig(u) {
      const l = super.createSynthesizerConfig(u);
      return l.avatarEnabled = !0, l;
    }
    async speak(u, l) {
      const p = (0, r.createNoDashGuid)(), d = new r.Deferred();
      return this.synthesisRequestQueue.enqueue(new s.SynthesisRequest(p, u, l, (h) => {
        d.resolve(h), this.privSynthesizing = !1, this.adapterSpeak();
      }, (h) => {
        d.reject(h), this.privSynthesizing = !1;
      })), this.adapterSpeak(), d.promise;
    }
  };
  return oi.AvatarSynthesizer = n, oi;
}
var Tt = {}, nd;
function FP() {
  if (nd) return Tt;
  nd = 1, Object.defineProperty(Tt, "__esModule", { value: !0 }), Tt.AvatarVideoFormat = Tt.Coordinate = void 0;
  class e {
    constructor(o, i) {
      this.x = o, this.y = i;
    }
  }
  Tt.Coordinate = e;
  let t = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} codec - The video codec.
     * @param {number} bitrate - The video bitrate.
     * @param {number} width - The video width.
     * @param {number} height - The video height.
     */
    constructor(o = "H264", i = 2e6, a = 1920, s = 1080) {
      this.codec = o, this.bitrate = i, this.width = a, this.height = s;
    }
    /**
     * Sets the video crop range.
     */
    setCropRange(o, i) {
      this.cropRange = {
        bottomRight: i,
        topLeft: o
      };
    }
  };
  return Tt.AvatarVideoFormat = t, Tt;
}
var ci = {}, id;
function BP() {
  if (id) return ci;
  id = 1, Object.defineProperty(ci, "__esModule", { value: !0 }), ci.AvatarWebRTCConnectionResult = void 0;
  const e = /* @__PURE__ */ A();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {RTCSessionDescriptionInit} SDPAnswer - The SDP answer of WebRTC connection.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n) {
      super(i, a, s, n), this.privSDPAnswer = o;
    }
    /**
     * Specifies SDP (Session Description Protocol) answer of WebRTC connection.
     * @member AvatarWebRTCConnectionResult.prototype.SDPAnswer
     * @function
     * @public
     * @returns {RTCSessionDescriptionInit} Specifies the SDP answer of WebRTC connection.
     */
    get SDPAnswer() {
      return this.privSDPAnswer;
    }
  };
  return ci.AvatarWebRTCConnectionResult = t, ci;
}
var ui = {}, sd;
function UP() {
  if (sd) return ui;
  sd = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.Diagnostics = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ O();
  let r = class {
    static SetLoggingLevel(i) {
      this.privListener = new e.ConsoleLoggingListener(i), t.Events.instance.attachConsoleListener(this.privListener);
    }
    static StartConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !0);
    }
    static StopConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !1);
    }
    static SetLogOutputPath(i) {
      if (typeof window > "u")
        this.privListener && (this.privListener.logPath = i);
      else
        throw new Error("File system logging not available in browser.");
    }
    static set onLogOutput(i) {
      this.privListener && (this.privListener.logCallback = i);
    }
  };
  return ui.Diagnostics = r, r.privListener = void 0, ui;
}
var od;
function A() {
  return od || (od = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionEventArgs = e.CancellationErrorCode = e.CancellationDetails = e.CancellationDetailsBase = e.IntentRecognitionCanceledEventArgs = e.TranslationRecognitionCanceledEventArgs = e.NoMatchDetails = e.NoMatchReason = e.Translations = e.TranslationRecognizer = e.VoiceProfileType = e.IntentRecognizer = e.SpeechRecognizer = e.Recognizer = e.PropertyId = e.PropertyCollection = e.SpeechTranslationConfigImpl = e.SpeechTranslationConfig = e.SpeechConfigImpl = e.SpeechConfig = e.ResultReason = e.TranslationSynthesisResult = e.TranslationRecognitionResult = e.TranslationSynthesisEventArgs = e.TranslationRecognitionEventArgs = e.SpeechRecognitionCanceledEventArgs = e.MeetingTranscriptionEventArgs = e.ConversationTranscriptionEventArgs = e.SpeechRecognitionEventArgs = e.LanguageUnderstandingModel = e.IntentRecognitionResult = e.SpeechRecognitionResult = e.RecognitionResult = e.IntentRecognitionEventArgs = e.OutputFormat = e.RecognitionEventArgs = e.SessionEventArgs = e.KeywordRecognitionModel = e.PushAudioOutputStreamCallback = e.PullAudioInputStreamCallback = e.CancellationReason = e.PushAudioOutputStream = e.PullAudioOutputStream = e.AudioOutputStream = e.PushAudioInputStream = e.PullAudioInputStream = e.AudioInputStream = e.AudioFormatTag = e.AudioStreamFormat = e.AudioConfig = void 0, e.SpeechSynthesisEventArgs = e.SpeechSynthesisResult = e.SynthesisResult = e.SpeechSynthesizer = e.SpeechSynthesisOutputFormat = e.Synthesizer = e.User = e.ParticipantChangedReason = e.Participant = e.MeetingTranscriber = e.Meeting = e.ConversationTranscriptionResult = e.ConversationTranscriber = e.ConversationTranslator = e.ConversationTranslationResult = e.ConversationTranslationEventArgs = e.ConversationTranslationCanceledEventArgs = e.ConversationParticipantsChangedEventArgs = e.ConversationExpirationEventArgs = e.Conversation = e.SpeakerRecognitionCancellationDetails = e.SpeakerRecognitionResultType = e.SpeakerRecognitionResult = e.SourceLanguageConfig = e.AutoDetectSourceLanguageResult = e.AutoDetectSourceLanguageConfig = e.SpeakerVerificationModel = e.SpeakerIdentificationModel = e.SpeakerRecognizer = e.VoiceProfileClient = e.VoiceProfilePhraseResult = e.VoiceProfileCancellationDetails = e.VoiceProfileResult = e.VoiceProfileEnrollmentCancellationDetails = e.VoiceProfileEnrollmentResult = e.VoiceProfile = e.ConnectionMessage = e.ConnectionMessageEventArgs = e.BaseAudioPlayer = e.ProfanityOption = e.ServicePropertyChannel = e.TurnStatusReceivedEventArgs = e.ActivityReceivedEventArgs = e.DialogServiceConnector = e.CustomCommandsConfig = e.BotFrameworkConfig = e.DialogServiceConfig = e.PhraseListGrammar = e.Connection = e.ServiceEventArgs = void 0, e.LogLevel = e.Diagnostics = e.AvatarWebRTCConnectionResult = e.Coordinate = e.AvatarVideoFormat = e.AvatarSynthesizer = e.AvatarEventArgs = e.AvatarConfig = e.LanguageIdMode = e.PronunciationAssessmentResult = e.PronunciationAssessmentConfig = e.PronunciationAssessmentGranularity = e.PronunciationAssessmentGradingSystem = e.MeetingTranscriptionCanceledEventArgs = e.ConversationTranscriptionCanceledEventArgs = e.SpeakerAudioDestination = e.VoiceInfo = e.SynthesisVoiceType = e.SynthesisVoiceGender = e.SynthesisVoicesResult = e.SpeechSynthesisBoundaryType = e.SpeechSynthesisVisemeEventArgs = e.SpeechSynthesisBookmarkEventArgs = e.SpeechSynthesisWordBoundaryEventArgs = void 0;
    var t = /* @__PURE__ */ hv();
    Object.defineProperty(e, "AudioConfig", { enumerable: !0, get: function() {
      return t.AudioConfig;
    } });
    var r = /* @__PURE__ */ jt();
    Object.defineProperty(e, "AudioStreamFormat", { enumerable: !0, get: function() {
      return r.AudioStreamFormat;
    } }), Object.defineProperty(e, "AudioFormatTag", { enumerable: !0, get: function() {
      return r.AudioFormatTag;
    } });
    var o = /* @__PURE__ */ lv();
    Object.defineProperty(e, "AudioInputStream", { enumerable: !0, get: function() {
      return o.AudioInputStream;
    } }), Object.defineProperty(e, "PullAudioInputStream", { enumerable: !0, get: function() {
      return o.PullAudioInputStream;
    } }), Object.defineProperty(e, "PushAudioInputStream", { enumerable: !0, get: function() {
      return o.PushAudioInputStream;
    } });
    var i = /* @__PURE__ */ Kt();
    Object.defineProperty(e, "AudioOutputStream", { enumerable: !0, get: function() {
      return i.AudioOutputStream;
    } }), Object.defineProperty(e, "PullAudioOutputStream", { enumerable: !0, get: function() {
      return i.PullAudioOutputStream;
    } }), Object.defineProperty(e, "PushAudioOutputStream", { enumerable: !0, get: function() {
      return i.PushAudioOutputStream;
    } });
    var a = /* @__PURE__ */ tR();
    Object.defineProperty(e, "CancellationReason", { enumerable: !0, get: function() {
      return a.CancellationReason;
    } });
    var s = /* @__PURE__ */ rR();
    Object.defineProperty(e, "PullAudioInputStreamCallback", { enumerable: !0, get: function() {
      return s.PullAudioInputStreamCallback;
    } });
    var n = /* @__PURE__ */ nR();
    Object.defineProperty(e, "PushAudioOutputStreamCallback", { enumerable: !0, get: function() {
      return n.PushAudioOutputStreamCallback;
    } });
    var c = /* @__PURE__ */ iR();
    Object.defineProperty(e, "KeywordRecognitionModel", { enumerable: !0, get: function() {
      return c.KeywordRecognitionModel;
    } });
    var u = /* @__PURE__ */ sR();
    Object.defineProperty(e, "SessionEventArgs", { enumerable: !0, get: function() {
      return u.SessionEventArgs;
    } });
    var l = /* @__PURE__ */ oR();
    Object.defineProperty(e, "RecognitionEventArgs", { enumerable: !0, get: function() {
      return l.RecognitionEventArgs;
    } });
    var p = /* @__PURE__ */ aR();
    Object.defineProperty(e, "OutputFormat", { enumerable: !0, get: function() {
      return p.OutputFormat;
    } });
    var d = /* @__PURE__ */ cR();
    Object.defineProperty(e, "IntentRecognitionEventArgs", { enumerable: !0, get: function() {
      return d.IntentRecognitionEventArgs;
    } });
    var h = /* @__PURE__ */ uR();
    Object.defineProperty(e, "RecognitionResult", { enumerable: !0, get: function() {
      return h.RecognitionResult;
    } });
    var f = /* @__PURE__ */ lR();
    Object.defineProperty(e, "SpeechRecognitionResult", { enumerable: !0, get: function() {
      return f.SpeechRecognitionResult;
    } });
    var g = /* @__PURE__ */ pR();
    Object.defineProperty(e, "IntentRecognitionResult", { enumerable: !0, get: function() {
      return g.IntentRecognitionResult;
    } });
    var m = /* @__PURE__ */ dR();
    Object.defineProperty(e, "LanguageUnderstandingModel", { enumerable: !0, get: function() {
      return m.LanguageUnderstandingModel;
    } });
    var v = /* @__PURE__ */ hR();
    Object.defineProperty(e, "SpeechRecognitionEventArgs", { enumerable: !0, get: function() {
      return v.SpeechRecognitionEventArgs;
    } }), Object.defineProperty(e, "ConversationTranscriptionEventArgs", { enumerable: !0, get: function() {
      return v.ConversationTranscriptionEventArgs;
    } }), Object.defineProperty(e, "MeetingTranscriptionEventArgs", { enumerable: !0, get: function() {
      return v.MeetingTranscriptionEventArgs;
    } });
    var y = /* @__PURE__ */ fR();
    Object.defineProperty(e, "SpeechRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return y.SpeechRecognitionCanceledEventArgs;
    } });
    var S = /* @__PURE__ */ vR();
    Object.defineProperty(e, "TranslationRecognitionEventArgs", { enumerable: !0, get: function() {
      return S.TranslationRecognitionEventArgs;
    } });
    var C = /* @__PURE__ */ gR();
    Object.defineProperty(e, "TranslationSynthesisEventArgs", { enumerable: !0, get: function() {
      return C.TranslationSynthesisEventArgs;
    } });
    var b = /* @__PURE__ */ vv();
    Object.defineProperty(e, "TranslationRecognitionResult", { enumerable: !0, get: function() {
      return b.TranslationRecognitionResult;
    } });
    var w = /* @__PURE__ */ mR();
    Object.defineProperty(e, "TranslationSynthesisResult", { enumerable: !0, get: function() {
      return w.TranslationSynthesisResult;
    } });
    var I = /* @__PURE__ */ yR();
    Object.defineProperty(e, "ResultReason", { enumerable: !0, get: function() {
      return I.ResultReason;
    } });
    var E = /* @__PURE__ */ SR();
    Object.defineProperty(e, "SpeechConfig", { enumerable: !0, get: function() {
      return E.SpeechConfig;
    } }), Object.defineProperty(e, "SpeechConfigImpl", { enumerable: !0, get: function() {
      return E.SpeechConfigImpl;
    } });
    var N = /* @__PURE__ */ CR();
    Object.defineProperty(e, "SpeechTranslationConfig", { enumerable: !0, get: function() {
      return N.SpeechTranslationConfig;
    } }), Object.defineProperty(e, "SpeechTranslationConfigImpl", { enumerable: !0, get: function() {
      return N.SpeechTranslationConfigImpl;
    } });
    var R = /* @__PURE__ */ mv();
    Object.defineProperty(e, "PropertyCollection", { enumerable: !0, get: function() {
      return R.PropertyCollection;
    } });
    var M = /* @__PURE__ */ pc();
    Object.defineProperty(e, "PropertyId", { enumerable: !0, get: function() {
      return M.PropertyId;
    } });
    var T = /* @__PURE__ */ RR();
    Object.defineProperty(e, "Recognizer", { enumerable: !0, get: function() {
      return T.Recognizer;
    } });
    var L = /* @__PURE__ */ PR();
    Object.defineProperty(e, "SpeechRecognizer", { enumerable: !0, get: function() {
      return L.SpeechRecognizer;
    } });
    var U = /* @__PURE__ */ bR();
    Object.defineProperty(e, "IntentRecognizer", { enumerable: !0, get: function() {
      return U.IntentRecognizer;
    } });
    var Q = /* @__PURE__ */ wR();
    Object.defineProperty(e, "VoiceProfileType", { enumerable: !0, get: function() {
      return Q.VoiceProfileType;
    } });
    var ee = /* @__PURE__ */ ER();
    Object.defineProperty(e, "TranslationRecognizer", { enumerable: !0, get: function() {
      return ee.TranslationRecognizer;
    } });
    var re = /* @__PURE__ */ IR();
    Object.defineProperty(e, "Translations", { enumerable: !0, get: function() {
      return re.Translations;
    } });
    var he = /* @__PURE__ */ AR();
    Object.defineProperty(e, "NoMatchReason", { enumerable: !0, get: function() {
      return he.NoMatchReason;
    } });
    var W = /* @__PURE__ */ TR();
    Object.defineProperty(e, "NoMatchDetails", { enumerable: !0, get: function() {
      return W.NoMatchDetails;
    } });
    var ie = /* @__PURE__ */ _R();
    Object.defineProperty(e, "TranslationRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return ie.TranslationRecognitionCanceledEventArgs;
    } });
    var K = /* @__PURE__ */ kR();
    Object.defineProperty(e, "IntentRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return K.IntentRecognitionCanceledEventArgs;
    } });
    var Ne = /* @__PURE__ */ wv();
    Object.defineProperty(e, "CancellationDetailsBase", { enumerable: !0, get: function() {
      return Ne.CancellationDetailsBase;
    } });
    var nt = /* @__PURE__ */ OR();
    Object.defineProperty(e, "CancellationDetails", { enumerable: !0, get: function() {
      return nt.CancellationDetails;
    } });
    var He = /* @__PURE__ */ MR();
    Object.defineProperty(e, "CancellationErrorCode", { enumerable: !0, get: function() {
      return He.CancellationErrorCode;
    } });
    var xe = /* @__PURE__ */ DR();
    Object.defineProperty(e, "ConnectionEventArgs", { enumerable: !0, get: function() {
      return xe.ConnectionEventArgs;
    } });
    var it = /* @__PURE__ */ NR();
    Object.defineProperty(e, "ServiceEventArgs", { enumerable: !0, get: function() {
      return it.ServiceEventArgs;
    } });
    var qt = /* @__PURE__ */ Rv();
    Object.defineProperty(e, "Connection", { enumerable: !0, get: function() {
      return qt.Connection;
    } });
    var Ke = /* @__PURE__ */ xR();
    Object.defineProperty(e, "PhraseListGrammar", { enumerable: !0, get: function() {
      return Ke.PhraseListGrammar;
    } });
    var _e = /* @__PURE__ */ dc();
    Object.defineProperty(e, "DialogServiceConfig", { enumerable: !0, get: function() {
      return _e.DialogServiceConfig;
    } });
    var st = /* @__PURE__ */ zR();
    Object.defineProperty(e, "BotFrameworkConfig", { enumerable: !0, get: function() {
      return st.BotFrameworkConfig;
    } });
    var Gt = /* @__PURE__ */ LR();
    Object.defineProperty(e, "CustomCommandsConfig", { enumerable: !0, get: function() {
      return Gt.CustomCommandsConfig;
    } });
    var Je = /* @__PURE__ */ qR();
    Object.defineProperty(e, "DialogServiceConnector", { enumerable: !0, get: function() {
      return Je.DialogServiceConnector;
    } });
    var ot = /* @__PURE__ */ FR();
    Object.defineProperty(e, "ActivityReceivedEventArgs", { enumerable: !0, get: function() {
      return ot.ActivityReceivedEventArgs;
    } });
    var fe = /* @__PURE__ */ UR();
    Object.defineProperty(e, "TurnStatusReceivedEventArgs", { enumerable: !0, get: function() {
      return fe.TurnStatusReceivedEventArgs;
    } });
    var at = /* @__PURE__ */ $R();
    Object.defineProperty(e, "ServicePropertyChannel", { enumerable: !0, get: function() {
      return at.ServicePropertyChannel;
    } });
    var bs = /* @__PURE__ */ VR();
    Object.defineProperty(e, "ProfanityOption", { enumerable: !0, get: function() {
      return bs.ProfanityOption;
    } });
    var ws = /* @__PURE__ */ WR();
    Object.defineProperty(e, "BaseAudioPlayer", { enumerable: !0, get: function() {
      return ws.BaseAudioPlayer;
    } });
    var Qt = /* @__PURE__ */ HR();
    Object.defineProperty(e, "ConnectionMessageEventArgs", { enumerable: !0, get: function() {
      return Qt.ConnectionMessageEventArgs;
    } });
    var Yt = /* @__PURE__ */ Cv();
    Object.defineProperty(e, "ConnectionMessage", { enumerable: !0, get: function() {
      return Yt.ConnectionMessage;
    } });
    var Pe = /* @__PURE__ */ KR();
    Object.defineProperty(e, "VoiceProfile", { enumerable: !0, get: function() {
      return Pe.VoiceProfile;
    } });
    var be = /* @__PURE__ */ JR();
    Object.defineProperty(e, "VoiceProfileEnrollmentResult", { enumerable: !0, get: function() {
      return be.VoiceProfileEnrollmentResult;
    } }), Object.defineProperty(e, "VoiceProfileEnrollmentCancellationDetails", { enumerable: !0, get: function() {
      return be.VoiceProfileEnrollmentCancellationDetails;
    } });
    var Se = /* @__PURE__ */ GR();
    Object.defineProperty(e, "VoiceProfileResult", { enumerable: !0, get: function() {
      return Se.VoiceProfileResult;
    } }), Object.defineProperty(e, "VoiceProfileCancellationDetails", { enumerable: !0, get: function() {
      return Se.VoiceProfileCancellationDetails;
    } });
    var Ge = /* @__PURE__ */ QR();
    Object.defineProperty(e, "VoiceProfilePhraseResult", { enumerable: !0, get: function() {
      return Ge.VoiceProfilePhraseResult;
    } });
    var F = /* @__PURE__ */ YR();
    Object.defineProperty(e, "VoiceProfileClient", { enumerable: !0, get: function() {
      return F.VoiceProfileClient;
    } });
    var te = /* @__PURE__ */ ZR();
    Object.defineProperty(e, "SpeakerRecognizer", { enumerable: !0, get: function() {
      return te.SpeakerRecognizer;
    } });
    var ct = /* @__PURE__ */ XR();
    Object.defineProperty(e, "SpeakerIdentificationModel", { enumerable: !0, get: function() {
      return ct.SpeakerIdentificationModel;
    } });
    var ne = /* @__PURE__ */ eP();
    Object.defineProperty(e, "SpeakerVerificationModel", { enumerable: !0, get: function() {
      return ne.SpeakerVerificationModel;
    } });
    var Es = /* @__PURE__ */ tP();
    Object.defineProperty(e, "AutoDetectSourceLanguageConfig", { enumerable: !0, get: function() {
      return Es.AutoDetectSourceLanguageConfig;
    } });
    var Qe = /* @__PURE__ */ rP();
    Object.defineProperty(e, "AutoDetectSourceLanguageResult", { enumerable: !0, get: function() {
      return Qe.AutoDetectSourceLanguageResult;
    } });
    var ro = /* @__PURE__ */ nP();
    Object.defineProperty(e, "SourceLanguageConfig", { enumerable: !0, get: function() {
      return ro.SourceLanguageConfig;
    } });
    var Zt = /* @__PURE__ */ iP();
    Object.defineProperty(e, "SpeakerRecognitionResult", { enumerable: !0, get: function() {
      return Zt.SpeakerRecognitionResult;
    } }), Object.defineProperty(e, "SpeakerRecognitionResultType", { enumerable: !0, get: function() {
      return Zt.SpeakerRecognitionResultType;
    } }), Object.defineProperty(e, "SpeakerRecognitionCancellationDetails", { enumerable: !0, get: function() {
      return Zt.SpeakerRecognitionCancellationDetails;
    } });
    var oe = /* @__PURE__ */ hc();
    Object.defineProperty(e, "Conversation", { enumerable: !0, get: function() {
      return oe.Conversation;
    } }), Object.defineProperty(e, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return oe.ConversationExpirationEventArgs;
    } }), Object.defineProperty(e, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return oe.ConversationParticipantsChangedEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return oe.ConversationTranslationCanceledEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return oe.ConversationTranslationEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return oe.ConversationTranslationResult;
    } }), Object.defineProperty(e, "ConversationTranslator", { enumerable: !0, get: function() {
      return oe.ConversationTranslator;
    } }), Object.defineProperty(e, "ConversationTranscriber", { enumerable: !0, get: function() {
      return oe.ConversationTranscriber;
    } }), Object.defineProperty(e, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return oe.ConversationTranscriptionResult;
    } }), Object.defineProperty(e, "Meeting", { enumerable: !0, get: function() {
      return oe.Meeting;
    } }), Object.defineProperty(e, "MeetingTranscriber", { enumerable: !0, get: function() {
      return oe.MeetingTranscriber;
    } }), Object.defineProperty(e, "Participant", { enumerable: !0, get: function() {
      return oe.Participant;
    } }), Object.defineProperty(e, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return oe.ParticipantChangedReason;
    } }), Object.defineProperty(e, "User", { enumerable: !0, get: function() {
      return oe.User;
    } });
    var no = /* @__PURE__ */ fc();
    Object.defineProperty(e, "Synthesizer", { enumerable: !0, get: function() {
      return no.Synthesizer;
    } });
    var Is = /* @__PURE__ */ pv();
    Object.defineProperty(e, "SpeechSynthesisOutputFormat", { enumerable: !0, get: function() {
      return Is.SpeechSynthesisOutputFormat;
    } });
    var As = /* @__PURE__ */ CP();
    Object.defineProperty(e, "SpeechSynthesizer", { enumerable: !0, get: function() {
      return As.SpeechSynthesizer;
    } });
    var io = /* @__PURE__ */ RP();
    Object.defineProperty(e, "SynthesisResult", { enumerable: !0, get: function() {
      return io.SynthesisResult;
    } });
    var Ts = /* @__PURE__ */ PP();
    Object.defineProperty(e, "SpeechSynthesisResult", { enumerable: !0, get: function() {
      return Ts.SpeechSynthesisResult;
    } });
    var $ = /* @__PURE__ */ bP();
    Object.defineProperty(e, "SpeechSynthesisEventArgs", { enumerable: !0, get: function() {
      return $.SpeechSynthesisEventArgs;
    } });
    var X = /* @__PURE__ */ wP();
    Object.defineProperty(e, "SpeechSynthesisWordBoundaryEventArgs", { enumerable: !0, get: function() {
      return X.SpeechSynthesisWordBoundaryEventArgs;
    } });
    var V = /* @__PURE__ */ EP();
    Object.defineProperty(e, "SpeechSynthesisBookmarkEventArgs", { enumerable: !0, get: function() {
      return V.SpeechSynthesisBookmarkEventArgs;
    } });
    var H = /* @__PURE__ */ IP();
    Object.defineProperty(e, "SpeechSynthesisVisemeEventArgs", { enumerable: !0, get: function() {
      return H.SpeechSynthesisVisemeEventArgs;
    } });
    var ze = /* @__PURE__ */ AP();
    Object.defineProperty(e, "SpeechSynthesisBoundaryType", { enumerable: !0, get: function() {
      return ze.SpeechSynthesisBoundaryType;
    } });
    var G = /* @__PURE__ */ TP();
    Object.defineProperty(e, "SynthesisVoicesResult", { enumerable: !0, get: function() {
      return G.SynthesisVoicesResult;
    } });
    var ve = /* @__PURE__ */ _P();
    Object.defineProperty(e, "SynthesisVoiceGender", { enumerable: !0, get: function() {
      return ve.SynthesisVoiceGender;
    } }), Object.defineProperty(e, "SynthesisVoiceType", { enumerable: !0, get: function() {
      return ve.SynthesisVoiceType;
    } }), Object.defineProperty(e, "VoiceInfo", { enumerable: !0, get: function() {
      return ve.VoiceInfo;
    } });
    var Ce = /* @__PURE__ */ kP();
    Object.defineProperty(e, "SpeakerAudioDestination", { enumerable: !0, get: function() {
      return Ce.SpeakerAudioDestination;
    } });
    var Xt = /* @__PURE__ */ OP();
    Object.defineProperty(e, "ConversationTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return Xt.ConversationTranscriptionCanceledEventArgs;
    } });
    var so = /* @__PURE__ */ MP();
    Object.defineProperty(e, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return so.MeetingTranscriptionCanceledEventArgs;
    } });
    var oo = /* @__PURE__ */ DP();
    Object.defineProperty(e, "PronunciationAssessmentGradingSystem", { enumerable: !0, get: function() {
      return oo.PronunciationAssessmentGradingSystem;
    } });
    var ao = /* @__PURE__ */ NP();
    Object.defineProperty(e, "PronunciationAssessmentGranularity", { enumerable: !0, get: function() {
      return ao.PronunciationAssessmentGranularity;
    } });
    var co = /* @__PURE__ */ xP();
    Object.defineProperty(e, "PronunciationAssessmentConfig", { enumerable: !0, get: function() {
      return co.PronunciationAssessmentConfig;
    } });
    var uo = /* @__PURE__ */ zP();
    Object.defineProperty(e, "PronunciationAssessmentResult", { enumerable: !0, get: function() {
      return uo.PronunciationAssessmentResult;
    } });
    var lo = /* @__PURE__ */ _v();
    Object.defineProperty(e, "LanguageIdMode", { enumerable: !0, get: function() {
      return lo.LanguageIdMode;
    } });
    var po = /* @__PURE__ */ LP();
    Object.defineProperty(e, "AvatarConfig", { enumerable: !0, get: function() {
      return po.AvatarConfig;
    } });
    var ho = /* @__PURE__ */ jP();
    Object.defineProperty(e, "AvatarEventArgs", { enumerable: !0, get: function() {
      return ho.AvatarEventArgs;
    } });
    var gg = /* @__PURE__ */ qP();
    Object.defineProperty(e, "AvatarSynthesizer", { enumerable: !0, get: function() {
      return gg.AvatarSynthesizer;
    } });
    var Sc = /* @__PURE__ */ FP();
    Object.defineProperty(e, "AvatarVideoFormat", { enumerable: !0, get: function() {
      return Sc.AvatarVideoFormat;
    } }), Object.defineProperty(e, "Coordinate", { enumerable: !0, get: function() {
      return Sc.Coordinate;
    } });
    var mg = /* @__PURE__ */ BP();
    Object.defineProperty(e, "AvatarWebRTCConnectionResult", { enumerable: !0, get: function() {
      return mg.AvatarWebRTCConnectionResult;
    } });
    var yg = /* @__PURE__ */ UP();
    Object.defineProperty(e, "Diagnostics", { enumerable: !0, get: function() {
      return yg.Diagnostics;
    } });
    var Sg = /* @__PURE__ */ av();
    Object.defineProperty(e, "LogLevel", { enumerable: !0, get: function() {
      return Sg.LogLevel;
    } });
  }(Bo)), Bo;
}
var ad;
function $P() {
  if (ad) return zr;
  ad = 1, Object.defineProperty(zr, "__esModule", { value: !0 }), zr.ProxyInfo = void 0;
  const e = /* @__PURE__ */ A();
  let t = class Fv {
    constructor(o, i, a, s) {
      this.privProxyHostName = o, this.privProxyPort = i, this.privProxyUserName = a, this.privProxyPassword = s;
    }
    static fromParameters(o) {
      return new Fv(o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyPort), 10), o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyUserName), o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyPassword));
    }
    static fromRecognizerConfig(o) {
      return this.fromParameters(o.parameters);
    }
    get HostName() {
      return this.privProxyHostName;
    }
    get Port() {
      return this.privProxyPort;
    }
    get UserName() {
      return this.privProxyUserName;
    }
    get Password() {
      return this.privProxyPassword;
    }
  };
  return zr.ProxyInfo = t, zr;
}
var li = {}, ua, cd;
function VP() {
  if (cd) return ua;
  cd = 1;
  const e = /* @__PURE__ */ new Set(["json", "buffer", "string"]);
  return ua = (t) => (...r) => {
    const o = /* @__PURE__ */ new Set();
    let i, a, s, n = "";
    return r.forEach((c) => {
      if (typeof c == "string")
        if (c.toUpperCase() === c)
          if (i) {
            const u = `Can't set method to ${c}, already set to ${i}.`;
            throw new Error(u);
          } else
            i = c;
        else if (c.startsWith("http:") || c.startsWith("https:"))
          n = c;
        else if (e.has(c))
          a = c;
        else
          throw new Error(`Unknown encoding, ${c}`);
      else if (typeof c == "number")
        o.add(c);
      else if (typeof c == "object")
        if (Array.isArray(c) || c instanceof Set)
          c.forEach((u) => o.add(u));
        else {
          if (s)
            throw new Error("Cannot set headers twice.");
          s = c;
        }
      else
        throw new Error(`Unknown type: ${typeof c}`);
    }), i || (i = "GET"), o.size === 0 && o.add(200), t(o, i, a, s, n);
  }, ua;
}
var la, ud;
function WP() {
  if (ud) return la;
  ud = 1;
  const e = VP();
  class t extends Error {
    constructor(i, ...a) {
      super(...a), Error.captureStackTrace && Error.captureStackTrace(this, t), this.name = "StatusError", this.message = i.statusMessage, this.statusCode = i.status, this.res = i, this.json = i.json.bind(i), this.text = i.text.bind(i), this.arrayBuffer = i.arrayBuffer.bind(i);
      let s;
      Object.defineProperty(this, "responseBody", { get: () => (s || (s = this.arrayBuffer()), s) }), this.headers = {};
      for (const [c, u] of i.headers.entries())
        this.headers[c.toLowerCase()] = u;
    }
  }
  return la = e((o, i, a, s, n) => async (c, u, l = {}) => {
    c = n + (c || "");
    let p = new URL(c);
    if (s || (s = {}), p.username && (s.Authorization = "Basic " + btoa(p.username + ":" + p.password), p = new URL(p.protocol + "//" + p.host + p.pathname + p.search)), p.protocol !== "https:" && p.protocol !== "http:")
      throw new Error(`Unknown protocol, ${p.protocol}`);
    if (u && !(u instanceof ArrayBuffer || ArrayBuffer.isView(u) || typeof u == "string"))
      if (typeof u == "object")
        u = JSON.stringify(u), s["Content-Type"] = "application/json";
      else
        throw new Error("Unknown body type.");
    l = new Headers({ ...s || {}, ...l });
    const d = await fetch(p, { method: i, headers: l, body: u });
    if (d.statusCode = d.status, !o.has(d.status))
      throw new t(d);
    return a === "json" ? d.json() : a === "buffer" ? d.arrayBuffer() : a === "string" ? d.text() : d;
  }), la;
}
var ld;
function HP() {
  return ld || (ld = 1, function(e) {
    var t = li && li.__importDefault || function(s) {
      return s && s.__esModule ? s : { default: s };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RestMessageAdapter = e.RestRequestType = void 0;
    const r = t(WP()), o = /* @__PURE__ */ O();
    var i;
    (function(s) {
      s.Get = "GET", s.Post = "POST", s.Delete = "DELETE", s.File = "file";
    })(i = e.RestRequestType || (e.RestRequestType = {}));
    let a = class {
      constructor(n) {
        if (!n)
          throw new o.ArgumentNullError("configParams");
        this.privHeaders = n.headers, this.privIgnoreCache = n.ignoreCache;
      }
      static extractHeaderValue(n, c) {
        let u = "";
        try {
          const l = c.trim().split(/[\r\n]+/), p = {};
          l.forEach((d) => {
            const h = d.split(": "), f = h.shift().toLowerCase(), g = h.join(": ");
            p[f] = g;
          }), u = p[n.toLowerCase()];
        } catch {
        }
        return u;
      }
      set options(n) {
        this.privHeaders = n.headers, this.privIgnoreCache = n.ignoreCache;
      }
      setHeaders(n, c) {
        this.privHeaders[n] = c;
      }
      request(n, c, u = {}, l = null) {
        const p = new o.Deferred(), d = n === i.File ? "POST" : n, h = (g, m = {}) => {
          const v = g;
          return {
            data: JSON.stringify(m),
            headers: JSON.stringify(g.headers),
            json: m,
            ok: g.statusCode >= 200 && g.statusCode < 300,
            status: g.statusCode,
            statusText: m.error ? m.error.message : v.statusText ? v.statusText : v.statusMessage
          };
        }, f = (g) => {
          const m = (0, r.default)(c, d, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404), v = this.queryParams(u) === "" ? "" : `?${this.queryParams(u)}`;
          m(v, g).then(async (y) => {
            if (n === i.Delete || y.statusCode === 204)
              p.resolve(h(y));
            else
              try {
                const S = await y.json();
                p.resolve(h(y, S));
              } catch {
                p.resolve(h(y));
              }
          }).catch((y) => {
            p.reject(y);
          });
        };
        return this.privIgnoreCache && (this.privHeaders["Cache-Control"] = "no-cache"), n === i.Post && l && (this.privHeaders["content-type"] = "application/json", this.privHeaders["Content-Type"] = "application/json"), f(l), p.promise;
      }
      queryParams(n = {}) {
        return Object.keys(n).map((c) => encodeURIComponent(c) + "=" + encodeURIComponent(n[c])).join("&");
      }
    };
    e.RestMessageAdapter = a;
  }(li)), li;
}
var pi = {}, pd;
function Bv() {
  if (pd) return pi;
  pd = 1, Object.defineProperty(pi, "__esModule", { value: !0 }), pi.RestConfigBase = void 0;
  let e = class xs {
    static get requestOptions() {
      return xs.privDefaultRequestOptions;
    }
    static get configParams() {
      return xs.privDefaultParams;
    }
    static get restErrors() {
      return xs.privRestErrors;
    }
  };
  return pi.RestConfigBase = e, e.privDefaultRequestOptions = {
    headers: {
      Accept: "application/json"
    },
    ignoreCache: !1,
    timeout: 1e4
  }, e.privRestErrors = {
    authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
    authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
    invalidArgs: "Required input not found: {arg}.",
    invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
    invalidParticipantRequest: "The requested participant was not found.",
    permissionDeniedConnect: "Required credentials not found.",
    permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
    permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
    permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
    permissionDeniedStart: "Invalid operation: there is already an active conversation."
  }, e.privDefaultParams = {
    apiVersion: "api-version",
    authorization: "Authorization",
    clientAppId: "X-ClientAppId",
    contentTypeKey: "Content-Type",
    correlationId: "X-CorrelationId",
    languageCode: "language",
    nickname: "nickname",
    profanity: "profanity",
    requestId: "X-RequestId",
    roomId: "roomid",
    sessionToken: "token",
    subscriptionKey: "Ocp-Apim-Subscription-Key",
    subscriptionRegion: "Ocp-Apim-Subscription-Region",
    token: "X-CapitoToken"
  }, pi;
}
var dd;
function se() {
  return dd || (dd = 1, function(e) {
    var t = vt && vt.__createBinding || (Object.create ? function(o, i, a, s) {
      s === void 0 && (s = a), Object.defineProperty(o, s, { enumerable: !0, get: function() {
        return i[a];
      } });
    } : function(o, i, a, s) {
      s === void 0 && (s = a), o[s] = i[a];
    }), r = vt && vt.__exportStar || function(o, i) {
      for (var a in o) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, o, a);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), r(/* @__PURE__ */ JC(), e), r(/* @__PURE__ */ GC(), e), r(/* @__PURE__ */ QC(), e), r(/* @__PURE__ */ YC(), e), r(/* @__PURE__ */ ZC(), e), r(/* @__PURE__ */ XC(), e), r(/* @__PURE__ */ cv(), e), r(/* @__PURE__ */ eR(), e), r(/* @__PURE__ */ $P(), e), r(/* @__PURE__ */ HP(), e), r(/* @__PURE__ */ Bv(), e);
  }(vt)), vt;
}
var hd;
function KP() {
  if (hd) return kr;
  hd = 1, Object.defineProperty(kr, "__esModule", { value: !0 }), kr.IntentConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Te(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ pe();
  let a = class extends r.ConnectionFactoryBase {
    create(n, c, u) {
      let l = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint);
      if (!l) {
        const f = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_IntentRegion), g = r.ConnectionFactoryBase.getHostSuffix(f);
        l = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + f + ".sr.speech" + g) + "/speech/recognition/interactive/cognitiveservices/v1";
      }
      const p = {
        format: "simple",
        language: n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(n, p, l);
      const d = {};
      c.token !== void 0 && c.token !== "" && (d[c.headerName] = c.token), d[i.HeaderNames.ConnectionId] = u, n.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, l);
      const h = n.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(l, p, d, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(n), h, u));
    }
    getSpeechRegionFromIntentRegion(n) {
      switch (n) {
        case "West US":
        case "US West":
        case "westus":
          return "uswest";
        case "West US 2":
        case "US West 2":
        case "westus2":
          return "uswest2";
        case "South Central US":
        case "US South Central":
        case "southcentralus":
          return "ussouthcentral";
        case "West Central US":
        case "US West Central":
        case "westcentralus":
          return "uswestcentral";
        case "East US":
        case "US East":
        case "eastus":
          return "useast";
        case "East US 2":
        case "US East 2":
        case "eastus2":
          return "useast2";
        case "West Europe":
        case "Europe West":
        case "westeurope":
          return "europewest";
        case "North Europe":
        case "Europe North":
        case "northeurope":
          return "europenorth";
        case "Brazil South":
        case "South Brazil":
        case "southbrazil":
          return "brazilsouth";
        case "Australia East":
        case "East Australia":
        case "eastaustralia":
          return "australiaeast";
        case "Southeast Asia":
        case "Asia Southeast":
        case "southeastasia":
          return "asiasoutheast";
        case "East Asia":
        case "Asia East":
        case "eastasia":
          return "asiaeast";
        default:
          return n;
      }
    }
  };
  return kr.IntentConnectionFactory = a, kr;
}
var _t = {}, fd;
function JP() {
  if (fd) return _t;
  fd = 1, Object.defineProperty(_t, "__esModule", { value: !0 }), _t.VoiceProfileConnectionFactory = _t.SpeakerRecognitionConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Te(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ pe();
  class a extends r.ConnectionFactoryBase {
    create(u, l, p, d) {
      let h = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint);
      if (!h) {
        const v = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region), y = r.ConnectionFactoryBase.getHostSuffix(v), S = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, `wss://${v}.spr-frontend.speech${y}`), C = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
        h = `${S}/speaker/ws/${this.scenarioToPath(C)}/${p}`;
      }
      const f = {
        format: "simple",
        language: u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(u, f, h);
      const g = {};
      l.token !== void 0 && l.token !== "" && (g[l.headerName] = l.token), g[i.HeaderNames.ConnectionId] = d, g[i.HeaderNames.SpIDAuthKey] = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Key), u.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, h);
      const m = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(h, f, g, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), m, d));
    }
    scenarioToPath(u) {
      switch (u) {
        case "TextIndependentVerification":
        case "2":
          return "verification/text-independent";
        case "TextDependentVerification":
        case "1":
          return "verification/text-dependent";
        default:
          return "identification/text-independent";
      }
    }
  }
  let s = class extends a {
    create(u, l, p) {
      return super.create(u, l, "recognition", p);
    }
  };
  _t.SpeakerRecognitionConnectionFactory = s;
  class n extends a {
    create(u, l, p) {
      return super.create(u, l, "profile", p);
    }
  }
  return _t.VoiceProfileConnectionFactory = n, _t;
}
var pa = {}, vd;
function vc() {
  return vd || (vd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionEndedEvent = e.RecognitionCompletionStatus = e.RecognitionStartedEvent = e.ConnectingToServiceEvent = e.ListeningStartedEvent = e.RecognitionTriggeredEvent = e.SpeechRecognitionEvent = void 0;
    const t = /* @__PURE__ */ O();
    class r extends t.PlatformEvent {
      constructor(l, p, d, h = t.EventType.Info) {
        super(l, h), this.privRequestId = p, this.privSessionId = d;
      }
      get requestId() {
        return this.privRequestId;
      }
      get sessionId() {
        return this.privSessionId;
      }
    }
    e.SpeechRecognitionEvent = r;
    class o extends r {
      constructor(l, p, d, h) {
        super("RecognitionTriggeredEvent", l, p), this.privAudioSourceId = d, this.privAudioNodeId = h;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
    }
    e.RecognitionTriggeredEvent = o;
    class i extends r {
      constructor(l, p, d, h) {
        super("ListeningStartedEvent", l, p), this.privAudioSourceId = d, this.privAudioNodeId = h;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
    }
    e.ListeningStartedEvent = i;
    class a extends r {
      constructor(l, p, d) {
        super("ConnectingToServiceEvent", l, d), this.privAuthFetchEventid = p;
      }
      get authFetchEventid() {
        return this.privAuthFetchEventid;
      }
    }
    e.ConnectingToServiceEvent = a;
    class s extends r {
      constructor(l, p, d, h, f) {
        super("RecognitionStartedEvent", l, f), this.privAudioSourceId = p, this.privAudioNodeId = d, this.privAuthFetchEventId = h;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
      get authFetchEventId() {
        return this.privAuthFetchEventId;
      }
    }
    e.RecognitionStartedEvent = s;
    var n;
    (function(u) {
      u[u.Success = 0] = "Success", u[u.AudioSourceError = 1] = "AudioSourceError", u[u.AudioSourceTimeout = 2] = "AudioSourceTimeout", u[u.AuthTokenFetchError = 3] = "AuthTokenFetchError", u[u.AuthTokenFetchTimeout = 4] = "AuthTokenFetchTimeout", u[u.UnAuthorized = 5] = "UnAuthorized", u[u.ConnectTimeout = 6] = "ConnectTimeout", u[u.ConnectError = 7] = "ConnectError", u[u.ClientRecognitionActivityTimeout = 8] = "ClientRecognitionActivityTimeout", u[u.UnknownError = 9] = "UnknownError";
    })(n = e.RecognitionCompletionStatus || (e.RecognitionCompletionStatus = {}));
    class c extends r {
      constructor(l, p, d, h, f, g, m, v) {
        super("RecognitionEndedEvent", l, f, m === n.Success ? t.EventType.Info : t.EventType.Error), this.privAudioSourceId = p, this.privAudioNodeId = d, this.privAuthFetchEventId = h, this.privStatus = m, this.privError = v, this.privServiceTag = g;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
      get authFetchEventId() {
        return this.privAuthFetchEventId;
      }
      get serviceTag() {
        return this.privServiceTag;
      }
      get status() {
        return this.privStatus;
      }
      get error() {
        return this.privError;
      }
    }
    e.RecognitionEndedEvent = c;
  }(pa)), pa;
}
var di = {}, hi = {}, gd;
function Jt() {
  if (gd) return hi;
  gd = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.SpeechConnectionMessage = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ pe();
  class r extends e.ConnectionMessage {
    constructor(i, a, s, n, c, u, l, p) {
      if (!a)
        throw new e.ArgumentNullError("path");
      if (!s)
        throw new e.ArgumentNullError("requestId");
      const d = {};
      if (d[t.HeaderNames.Path] = a, d[t.HeaderNames.RequestId] = s, d[t.HeaderNames.RequestTimestamp] = (/* @__PURE__ */ new Date()).toISOString(), n && (d[t.HeaderNames.ContentType] = n), u && (d[t.HeaderNames.RequestStreamId] = u), l)
        for (const h in l)
          h && (d[h] = l[h]);
      p ? super(i, c, d, p) : super(i, c, d), this.privPath = a, this.privRequestId = s, this.privContentType = n, this.privStreamId = u, this.privAdditionalHeaders = l;
    }
    get path() {
      return this.privPath;
    }
    get requestId() {
      return this.privRequestId;
    }
    get contentType() {
      return this.privContentType;
    }
    get streamId() {
      return this.privStreamId;
    }
    get additionalHeaders() {
      return this.privAdditionalHeaders;
    }
    static fromConnectionMessage(i) {
      let a = null, s = null, n = null, c = null;
      const u = {};
      if (i.headers)
        for (const l in i.headers)
          l && (l.toLowerCase() === t.HeaderNames.Path.toLowerCase() ? a = i.headers[l] : l.toLowerCase() === t.HeaderNames.RequestId.toLowerCase() ? s = i.headers[l] : l.toLowerCase() === t.HeaderNames.ContentType.toLowerCase() ? n = i.headers[l] : l.toLowerCase() === t.HeaderNames.RequestStreamId.toLowerCase() ? c = i.headers[l] : u[l] = i.headers[l]);
      return new r(i.messageType, a, s, n, i.body, c, u, i.id);
    }
  }
  return hi.SpeechConnectionMessage = r, hi;
}
var da = {}, md;
function GP() {
  return md || (md = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SegmentationMode = void 0, function(t) {
      t.Normal = "Normal", t.Disabled = "Disabled", t.Custom = "Custom", t.Semantic = "Semantic";
    }(e.SegmentationMode || (e.SegmentationMode = {}));
  }(da)), da;
}
var ha = {}, yd;
function QP() {
  return yd || (yd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.None = "None", t.Synthesize = "Synthesize";
    }(e.NextAction || (e.NextAction = {}));
  }(ha)), ha;
}
var fa = {}, Sd;
function YP() {
  return Sd || (Sd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Mode = void 0, function(t) {
      t.None = "None", t.Always = "Always";
    }(e.Mode || (e.Mode = {}));
  }(fa)), fa;
}
var va = {}, Cd;
function ZP() {
  return Cd || (Cd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LanguageIdDetectionPriority = e.LanguageIdDetectionMode = void 0, function(t) {
      t.DetectAtAudioStart = "DetectAtAudioStart", t.DetectContinuous = "DetectContinuous", t.DetectSegments = "DetectSegments";
    }(e.LanguageIdDetectionMode || (e.LanguageIdDetectionMode = {})), function(t) {
      t.Auto = "Auto", t.PrioritizeLatency = "PrioritizeLatency", t.PrioritizeAccuracy = "PrioritizeAccuracy";
    }(e.LanguageIdDetectionPriority || (e.LanguageIdDetectionPriority = {}));
  }(va)), va;
}
var ga = {}, Rd;
function XP() {
  return Rd || (Rd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.Recognize = "Recognize", t.None = "None";
    }(e.NextAction || (e.NextAction = {}));
  }(ga)), ga;
}
var ma = {}, Pd;
function eb() {
  return Pd || (Pd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OnUnknownAction = void 0, function(t) {
      t.RecognizeWithDefaultLanguage = "RecognizeWithDefaultLanguage", t.None = "None";
    }(e.OnUnknownAction || (e.OnUnknownAction = {}));
  }(ma)), ma;
}
var ya = {}, bd;
function tb() {
  return bd || (bd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ResultType = void 0, function(t) {
      t.Auto = "Auto", t.StableFragment = "StableFragment", t.Hypothesis = "Hypothesis", t.None = "None";
    }(e.ResultType || (e.ResultType = {}));
  }(ya)), ya;
}
var Sa = {}, wd;
function rb() {
  return wd || (wd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PhraseResultOutputType = void 0, function(t) {
      t.Always = "Always", t.None = "None";
    }(e.PhraseResultOutputType || (e.PhraseResultOutputType = {}));
  }(Sa)), Sa;
}
var Ca = {}, Ed;
function nb() {
  return Ed || (Ed = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.None = "None", t.Translate = "Translate";
    }(e.NextAction || (e.NextAction = {}));
  }(Ca)), Ca;
}
var Id;
function ib() {
  if (Id) return di;
  Id = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.ServiceRecognizerBase = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ GP(), s = /* @__PURE__ */ Re(), n = /* @__PURE__ */ QP(), c = /* @__PURE__ */ YP(), u = /* @__PURE__ */ ZP(), l = /* @__PURE__ */ XP(), p = /* @__PURE__ */ eb(), d = /* @__PURE__ */ tb(), h = /* @__PURE__ */ rb(), f = /* @__PURE__ */ nb();
  let g = class ls {
    constructor(v, y, S, C, b) {
      if (this.privConnectionConfigurationPromise = void 0, this.privConnectionPromise = void 0, this.privSetTimeout = setTimeout, this.privIsLiveAudio = !1, this.privAverageBytesPerMs = 0, this.privEnableSpeakerId = !1, this.privExpectContentAssessmentResponse = !1, this.recognizeOverride = void 0, this.recognizeSpeaker = void 0, this.disconnectOverride = void 0, this.receiveMessageOverride = void 0, this.sendPrePayloadJSONOverride = void 0, this.postConnectImplOverride = void 0, this.configConnectionOverride = void 0, this.handleSpeechPhraseMessage = void 0, this.handleSpeechHypothesisMessage = void 0, !v)
        throw new t.ArgumentNullError("authentication");
      if (!y)
        throw new t.ArgumentNullError("connectionFactory");
      if (!S)
        throw new t.ArgumentNullError("audioSource");
      if (!C)
        throw new t.ArgumentNullError("recognizerConfig");
      this.privEnableSpeakerId = C.isSpeakerDiarizationEnabled, this.privMustReportEndOfStream = !1, this.privAuthentication = v, this.privConnectionFactory = y, this.privAudioSource = S, this.privRecognizerConfig = C, this.privIsDisposed = !1, this.privRecognizer = b, this.privRequestSession = new o.RequestSession(this.privAudioSource.id()), this.privConnectionEvents = new t.EventSource(), this.privServiceEvents = new t.EventSource(), this.privDynamicGrammar = new o.DynamicGrammarBuilder(), this.privSpeechContext = new o.SpeechContext(this.privDynamicGrammar), this.privAgentConfig = new o.AgentConfig(), this.privRecognizerConfig.parameters.getProperty(r.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? this.privSetTimeout = t.Timeout.setTimeout : (typeof window < "u" && (this.privSetTimeout = window.setTimeout.bind(window)), typeof globalThis < "u" && (this.privSetTimeout = globalThis.setTimeout.bind(globalThis))), this.connectionEvents.attach((I) => {
        if (I.name === "ConnectionClosedEvent") {
          const E = I;
          (E.statusCode === 1003 || E.statusCode === 1007 || E.statusCode === 1002 || E.statusCode === 4e3 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) && this.cancelRecognitionLocal(r.CancellationReason.Error, E.statusCode === 1007 ? r.CancellationErrorCode.BadRequestParameters : r.CancellationErrorCode.ConnectionFailure, `${E.reason} websocket error code: ${E.statusCode}`);
        }
      }), this.privEnableSpeakerId && (this.privDiarizationSessionId = (0, t.createNoDashGuid)());
    }
    setTranslationJson() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0);
      if (v !== void 0) {
        const y = v.split(","), S = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0), C = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationCategoryId, void 0), b = S !== void 0 ? n.NextAction.Synthesize : n.NextAction.None;
        if (this.privSpeechContext.getContext().translation = {
          onPassthrough: { action: b },
          onSuccess: { action: b },
          output: {
            includePassThroughResults: !0,
            interimResults: { mode: c.Mode.Always }
          },
          targetLanguages: y
        }, C !== void 0 && (this.privSpeechContext.getContext().translation.category = C), S !== void 0) {
          const I = {};
          for (const E of y)
            I[E] = S;
          this.privSpeechContext.getContext().synthesis = {
            defaultVoices: I
          };
        }
        const w = this.privSpeechContext.getContext().phraseDetection || {};
        w.onSuccess = { action: f.NextAction.Translate }, w.onInterim = { action: f.NextAction.Translate }, this.privSpeechContext.getContext().phraseDetection = w;
      }
    }
    setSpeechSegmentationTimeoutJson() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationSilenceTimeoutMs, void 0), y = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationMaximumTimeMs, void 0), S = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationStrategy, void 0), C = {
        mode: a.SegmentationMode.Normal
      };
      let b = !1;
      if (S !== void 0) {
        b = !0;
        let w = a.SegmentationMode.Normal;
        switch (S.toLowerCase()) {
          case "default":
            break;
          case "time":
            w = a.SegmentationMode.Custom;
            break;
          case "semantic":
            w = a.SegmentationMode.Semantic;
            break;
        }
        C.mode = w;
      }
      if (v !== void 0) {
        b = !0;
        const w = parseInt(v, 10);
        C.mode = a.SegmentationMode.Custom, C.segmentationSilenceTimeoutMs = w;
      }
      if (y !== void 0) {
        b = !0;
        const w = parseInt(y, 10);
        C.mode = a.SegmentationMode.Custom, C.segmentationForcedTimeoutMs = w;
      }
      if (b) {
        const w = this.privSpeechContext.getContext().phraseDetection || {};
        switch (w.mode = this.recognitionMode, this.recognitionMode) {
          case s.RecognitionMode.Conversation:
            w.conversation = w.conversation ?? { segmentation: {} }, w.conversation.segmentation = C;
            break;
          case s.RecognitionMode.Interactive:
            w.interactive = w.interactive ?? { segmentation: {} }, w.interactive.segmentation = C;
            break;
          case s.RecognitionMode.Dictation:
            w.dictation = w.dictation ?? {}, w.dictation.segmentation = C;
            break;
        }
        this.privSpeechContext.getContext().phraseDetection = w;
      }
    }
    setLanguageIdJson() {
      const v = this.privSpeechContext.getContext().phraseDetection || {};
      if (this.privRecognizerConfig.autoDetectSourceLanguages !== void 0) {
        const y = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
        y.length === 1 && y[0] === o.AutoDetectSourceLanguagesOpenRangeOptionName && (y[0] = "UND");
        let S;
        this.privRecognizerConfig.languageIdMode === "Continuous" ? S = u.LanguageIdDetectionMode.DetectContinuous : S = u.LanguageIdDetectionMode.DetectAtAudioStart, this.privSpeechContext.getContext().languageId = {
          languages: y,
          mode: S,
          onSuccess: { action: l.NextAction.Recognize },
          onUnknown: { action: p.OnUnknownAction.None },
          priority: u.LanguageIdDetectionPriority.PrioritizeLatency
        }, this.privSpeechContext.getContext().phraseOutput = {
          interimResults: {
            resultType: d.ResultType.Auto
          },
          phraseResults: {
            resultType: h.PhraseResultOutputType.Always
          }
        };
        const C = this.privRecognizerConfig.sourceLanguageModels;
        C !== void 0 && (v.customModels = C, v.onInterim = { action: f.NextAction.None }, v.onSuccess = { action: f.NextAction.None });
      }
      this.privSpeechContext.getContext().phraseDetection = v;
    }
    setOutputDetailLevelJson() {
      this.privEnableSpeakerId && (this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true" ? this.privSpeechContext.setWordLevelTimings() : this.privRecognizerConfig.parameters.getProperty(o.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase() === r.OutputFormat[r.OutputFormat.Detailed].toLocaleLowerCase() && this.privSpeechContext.setDetailedOutputFormat());
    }
    get isSpeakerDiarizationEnabled() {
      return this.privEnableSpeakerId;
    }
    get audioSource() {
      return this.privAudioSource;
    }
    get speechContext() {
      return this.privSpeechContext;
    }
    get dynamicGrammar() {
      return this.privDynamicGrammar;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    set conversationTranslatorToken(v) {
      this.privRecognizerConfig.parameters.setProperty(r.PropertyId.ConversationTranslator_Token, v);
    }
    set voiceProfileType(v) {
      this.privRecognizerConfig.parameters.setProperty(r.PropertyId.SpeechServiceConnection_SpeakerIdMode, v);
    }
    set authentication(v) {
      this.privAuthentication = v;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(v) {
      if (this.privIsDisposed = !0, this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose(v);
        } catch {
          return;
        }
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    get recognitionMode() {
      return this.privRecognizerConfig.recognitionMode;
    }
    async recognize(v, y, S) {
      if (this.recognizeOverride !== void 0) {
        await this.recognizeOverride(v, y, S);
        return;
      }
      if (this.privConnectionConfigurationPromise = void 0, this.privRecognizerConfig.recognitionMode = v, this.privRecognizerConfig.recognitionEndpointVersion === "2") {
        const E = this.privSpeechContext.getContext().phraseDetection || {};
        E.mode = v, this.privSpeechContext.getContext().phraseDetection = E;
      }
      this.setLanguageIdJson(), this.setTranslationJson(), this.privRecognizerConfig.autoDetectSourceLanguages !== void 0 && this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 && this.setupTranslationWithLanguageId(), this.setSpeechSegmentationTimeoutJson(), this.setOutputDetailLevelJson(), this.privSuccessCallback = y, this.privErrorCallback = S, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
      const C = this.connectImpl();
      let b;
      try {
        const E = await this.audioSource.attach(this.privRequestSession.audioNodeId), N = await this.audioSource.format, R = await this.audioSource.deviceInfo;
        this.privIsLiveAudio = R.type && R.type === o.type.Microphones, b = new e.ReplayableAudioNode(E, N.avgBytesPerSec), await this.privRequestSession.onAudioSourceAttachCompleted(b, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: R };
      } catch (E) {
        throw await this.privRequestSession.onStopRecognizing(), E;
      }
      try {
        await C;
      } catch (E) {
        await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, E);
        return;
      }
      const w = new r.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, w), this.receiveMessage(), this.sendAudio(b).catch(async (E) => {
        await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, E);
      });
    }
    async stopRecognizing() {
      if (this.privRequestSession.isRecognizing)
        try {
          await this.audioSource.turnOff(), await this.sendFinalAudio(), await this.privRequestSession.onStopRecognizing(), await this.privRequestSession.turnCompletionPromise;
        } finally {
          await this.privRequestSession.dispose();
        }
    }
    async connect() {
      return await this.connectImpl(), Promise.resolve();
    }
    connectAsync(v, y) {
      this.connectImpl().then(() => {
        try {
          v && v();
        } catch (S) {
          y && y(S);
        }
      }, (S) => {
        try {
          y && y(S);
        } catch {
        }
      });
    }
    async disconnect() {
      if (await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.NoError, "Disconnecting"), this.disconnectOverride !== void 0 && await this.disconnectOverride(), this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose();
        } catch {
        }
      this.privConnectionPromise = void 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendMessage(v) {
    }
    async sendNetworkMessage(v, y) {
      const S = typeof y == "string" ? t.MessageType.Text : t.MessageType.Binary, C = typeof y == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new i.SpeechConnectionMessage(S, v, this.privRequestSession.requestId, C, y));
    }
    set activityTemplate(v) {
      this.privActivityTemplate = v;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set expectContentAssessmentResponse(v) {
      this.privExpectContentAssessmentResponse = v;
    }
    async sendTelemetryData() {
      const v = this.privRequestSession.getTelemetry();
      if (ls.telemetryDataEnabled !== !0 || this.privIsDisposed || v === null)
        return;
      if (ls.telemetryData)
        try {
          ls.telemetryData(v);
        } catch {
        }
      await (await this.fetchConnection()).send(new i.SpeechConnectionMessage(t.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", v));
    }
    // Cancels recognition.
    async cancelRecognitionLocal(v, y, S) {
      this.privRequestSession.isRecognizing && (await this.privRequestSession.onStopRecognizing(), this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, v, y, S));
    }
    async receiveMessage() {
      try {
        if (this.privIsDisposed)
          return;
        let v = await this.fetchConnection();
        const y = await v.read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (!y)
          return this.receiveMessage();
        this.privServiceHasSentMessage = !0;
        const S = i.SpeechConnectionMessage.fromConnectionMessage(y);
        if (S.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase())
          switch (S.path.toLowerCase()) {
            case "turn.start":
              this.privMustReportEndOfStream = !0, this.privRequestSession.onServiceTurnStartResponse();
              break;
            case "speech.startdetected":
              const C = o.SpeechDetected.fromJSON(S.textBody, this.privRequestSession.currentTurnAudioOffset), b = new r.RecognitionEventArgs(C.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, b);
              break;
            case "speech.enddetected":
              let w;
              S.textBody.length > 0 ? w = S.textBody : w = "{ Offset: 0 }";
              const I = o.SpeechDetected.fromJSON(w, this.privRequestSession.currentTurnAudioOffset), E = new r.RecognitionEventArgs(I.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, E);
              break;
            case "turn.end":
              await this.sendTelemetryData(), this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream && (this.privMustReportEndOfStream = !1, await this.cancelRecognitionLocal(r.CancellationReason.EndOfStream, r.CancellationErrorCode.NoError, void 0));
              const N = new r.SessionEventArgs(this.privRequestSession.sessionId);
              if (await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition), !this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, N);
                return;
              } else
                v = await this.fetchConnection(), await this.sendPrePayloadJSON(v);
              break;
            default:
              await this.processTypeSpecificMessages(S) || this.privServiceEvents && this.serviceEvents.onEvent(new t.ServiceEvent(S.path.toLowerCase(), S.textBody));
          }
        return this.receiveMessage();
      } catch {
        return null;
      }
    }
    updateSpeakerDiarizationAudioOffset() {
      const v = this.privRequestSession.recognitionBytesSent, y = this.privAverageBytesPerMs !== 0 ? v / this.privAverageBytesPerMs : 0;
      this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(y);
    }
    sendSpeechContext(v, y) {
      this.privEnableSpeakerId && this.updateSpeakerDiarizationAudioOffset();
      const S = this.speechContext.toJSON();
      if (y && this.privRequestSession.onSpeechContext(), S)
        return v.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", S));
    }
    setupTranslationWithLanguageId() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0), y = this.privRecognizerConfig.autoDetectSourceLanguages !== void 0;
      if (v !== void 0 && y) {
        this.privSpeechContext.getContext().phraseOutput = {
          interimResults: {
            resultType: d.ResultType.None
          },
          phraseResults: {
            resultType: h.PhraseResultOutputType.None
          }
        };
        const S = this.privSpeechContext.getContext().translation;
        if (S) {
          const C = this.privRecognizerConfig.sourceLanguageModels;
          if (C !== void 0 && C.length > 0) {
            const w = this.privSpeechContext.getContext().phraseDetection || {};
            w.customModels = C, this.privSpeechContext.getContext().phraseDetection = w;
          }
          this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && (S.onSuccess = { action: n.NextAction.Synthesize }, S.onPassthrough = { action: n.NextAction.Synthesize });
        }
      }
    }
    noOp() {
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendPrePayloadJSON(v, y = !0) {
      if (this.sendPrePayloadJSONOverride !== void 0)
        return this.sendPrePayloadJSONOverride(v);
      await this.sendSpeechContext(v, y), await this.sendWaveHeader(v);
    }
    async sendWaveHeader(v) {
      const y = await this.audioSource.format;
      return v.send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", y.header));
    }
    // Establishes a websocket connection to the end point.
    connectImpl() {
      return this.privConnectionPromise !== void 0 ? this.privConnectionPromise.then((v) => v.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl())) : (this.privConnectionPromise = this.retryableConnect(), this.privConnectionPromise.catch(() => {
      }), this.postConnectImplOverride !== void 0 ? this.postConnectImplOverride(this.privConnectionPromise) : this.privConnectionPromise);
    }
    sendSpeechServiceConfig(v, y, S) {
      if (y.onSpeechContext(), ls.telemetryDataEnabled !== !0) {
        const b = {
          context: {
            system: JSON.parse(S).context.system
          }
        };
        S = JSON.stringify(b);
      }
      if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
        const C = JSON.parse(S);
        C.context.DisableReferenceChannel = "True", C.context.MicSpec = "1_0_0", S = JSON.stringify(C);
      }
      if (S)
        return v.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speech.config", y.requestId, "application/json", S));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((v) => v.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    async sendAudio(v) {
      const y = await this.audioSource.format;
      this.privAverageBytesPerMs = y.avgBytesPerSec / 1e3;
      let S = Date.now();
      const C = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000"), b = y.avgBytesPerSec / 1e3 * parseInt(C, 10), w = this.privRequestSession.recogNumber, I = async () => {
        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === w) {
          const E = await this.fetchConnection(), N = await v.read();
          if (this.privRequestSession.isSpeechEnded)
            return;
          let R, M;
          if (!N || N.isEnd ? (R = null, M = 0) : (R = N.buffer, this.privRequestSession.onAudioSent(R.byteLength), b >= this.privRequestSession.bytesSent ? M = 0 : M = Math.max(0, S - Date.now())), M !== 0 && await this.delay(M), R !== null && (S = Date.now() + R.byteLength * 1e3 / (y.avgBytesPerSec * 2)), !this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === w)
            if (E.send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, null, R)).catch(() => {
              this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {
              });
            }), N?.isEnd)
              this.privIsLiveAudio || this.privRequestSession.onSpeechEnded();
            else
              return I();
        }
      };
      return I();
    }
    async retryableConnect() {
      let v = !1;
      this.privAuthFetchEventId = (0, t.createNoDashGuid)();
      const y = this.privRequestSession.sessionId;
      this.privConnectionId = y !== void 0 ? y : (0, t.createNoDashGuid)(), this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
      let S = 0, C = "";
      for (; this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount; ) {
        this.privRequestSession.onRetryConnection();
        const w = await (v ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId));
        await this.privRequestSession.onAuthCompleted(!1);
        const I = await this.privConnectionFactory.create(this.privRecognizerConfig, w, this.privConnectionId);
        this.privRequestSession.listenForServiceTelemetry(I.events), I.events.attach((N) => {
          this.connectionEvents.onEvent(N);
        });
        const E = await I.open();
        if (E.statusCode === 200)
          return await this.privRequestSession.onConnectionEstablishCompleted(E.statusCode), Promise.resolve(I);
        E.statusCode === 1006 && (v = !0), S = E.statusCode, C = E.reason;
      }
      return await this.privRequestSession.onConnectionEstablishCompleted(S, C), Promise.reject(`Unable to contact server. StatusCode: ${S}, ${this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${C}`);
    }
    delay(v) {
      return new Promise((y) => this.privSetTimeout(y, v));
    }
    writeBufferToConsole(v) {
      let y = "Buffer Size: ";
      if (v === null)
        y += "null";
      else {
        const S = new Uint8Array(v);
        y += `${v.byteLength}\r
`;
        for (let C = 0; C < v.byteLength; C++)
          y += S[C].toString(16).padStart(2, "0") + " ", (C + 1) % 16 === 0 && (console.info(y), y = "");
      }
      console.info(y);
    }
    async sendFinalAudio() {
      await (await this.fetchConnection()).send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const v = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(v) : (await this.sendSpeechServiceConfig(v, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendPrePayloadJSON(v, !1), v);
    }
  };
  return di.ServiceRecognizerBase = g, g.telemetryDataEnabled = !0, di;
}
var fi = {}, Ad;
function sb() {
  if (Ad) return fi;
  Ad = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.ConversationServiceRecognizer = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ _();
  let r = class extends t.ServiceRecognizerBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, n, c), this.handleSpeechPhraseMessage = async (u) => this.handleSpeechPhrase(u), this.handleSpeechHypothesisMessage = (u) => this.handleSpeechHypothesis(u);
    }
    processTypeSpecificMessages(i) {
    }
    handleRecognizedCallback(i, a, s) {
    }
    handleRecognizingCallback(i, a, s) {
    }
    async processSpeechMessages(i) {
      let a = !1;
      switch (i.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          this.handleSpeechHypothesisMessage && this.handleSpeechHypothesisMessage(i.textBody), a = !0;
          break;
        case "speech.phrase":
          this.handleSpeechPhraseMessage && await this.handleSpeechPhraseMessage(i.textBody), a = !0;
          break;
      }
      return a;
    }
    cancelRecognition(i, a, s, n, c) {
    }
    async handleSpeechPhrase(i) {
      const a = t.SimpleSpeechPhrase.fromJSON(i, this.privRequestSession.currentTurnAudioOffset), s = t.EnumTranslation.implTranslateRecognitionResult(a.RecognitionStatus);
      let n;
      const c = new e.PropertyCollection();
      if (c.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, i), this.privRequestSession.onPhraseRecognized(a.Offset + a.Duration), e.ResultReason.Canceled === s) {
        const u = t.EnumTranslation.implTranslateCancelResult(a.RecognitionStatus), l = t.EnumTranslation.implTranslateCancelErrorCode(a.RecognitionStatus);
        await this.cancelRecognitionLocal(u, l, t.EnumTranslation.implTranslateErrorDetails(l));
      } else if (a.RecognitionStatus !== t.RecognitionStatus.EndOfDictation) {
        if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
          n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, s, a.DisplayText, a.Duration, a.Offset, a.Language, a.LanguageDetectionConfidence, a.SpeakerId, void 0, a.asJson(), c);
        else {
          const u = t.DetailedSpeechPhrase.fromJSON(i, this.privRequestSession.currentTurnAudioOffset);
          n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, s, u.Text, u.Duration, u.Offset, u.Language, u.LanguageDetectionConfidence, u.SpeakerId, void 0, u.asJson(), c);
        }
        this.handleRecognizedCallback(n, n.offset, this.privRequestSession.sessionId);
      }
    }
    handleSpeechHypothesis(i) {
      const a = t.SpeechHypothesis.fromJSON(i, this.privRequestSession.currentTurnAudioOffset), s = new e.PropertyCollection();
      s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, i);
      const n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, e.ResultReason.RecognizingSpeech, a.Text, a.Duration, a.Offset, a.Language, a.LanguageDetectionConfidence, a.SpeakerId, void 0, a.asJson(), s);
      this.privRequestSession.onHypothesis(a.Offset), this.handleRecognizingCallback(n, a.Duration, this.privRequestSession.sessionId);
    }
  };
  return fi.ConversationServiceRecognizer = r, fi;
}
var Ra = {}, Td;
function ob() {
  return Td || (Td = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognizerConfig = e.SpeechResultFormat = void 0;
    const t = /* @__PURE__ */ A(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Re();
    (function(a) {
      a[a.Simple = 0] = "Simple", a[a.Detailed = 1] = "Detailed";
    })(e.SpeechResultFormat || (e.SpeechResultFormat = {}));
    class i {
      constructor(s, n) {
        this.privSpeechServiceConfig = s || new r.SpeechServiceConfig(new r.Context(null)), this.privParameters = n, this.privMaxRetryCount = parseInt(n.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10), this.privLanguageIdMode = n.getProperty(t.PropertyId.SpeechServiceConnection_LanguageIdMode, void 0), this.privEnableSpeakerId = !1;
      }
      get parameters() {
        return this.privParameters;
      }
      get recognitionMode() {
        return this.privRecognitionMode;
      }
      set recognitionMode(s) {
        this.privRecognitionMode = s, this.privRecognitionActivityTimeout = s === o.RecognitionMode.Interactive ? 8e3 : 25e3, this.privSpeechServiceConfig.Recognition = o.RecognitionMode[s];
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
      get recognitionActivityTimeout() {
        return this.privRecognitionActivityTimeout;
      }
      get isContinuousRecognition() {
        return this.privRecognitionMode !== o.RecognitionMode.Interactive;
      }
      get languageIdMode() {
        return this.privLanguageIdMode;
      }
      get autoDetectSourceLanguages() {
        return this.parameters.getProperty(t.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0);
      }
      get recognitionEndpointVersion() {
        return this.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
      }
      set recognitionEndpointVersion(s) {
        this.parameters.setProperty(t.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, s);
      }
      get sourceLanguageModels() {
        const s = [];
        let n = !1;
        if (this.autoDetectSourceLanguages !== void 0)
          for (const c of this.autoDetectSourceLanguages.split(",")) {
            const u = c + t.PropertyId.SpeechServiceConnection_EndpointId.toString(), l = this.parameters.getProperty(u, void 0);
            l !== void 0 ? (s.push({ language: c, endpoint: l }), n = !0) : s.push({ language: c, endpoint: "" });
          }
        return n ? s : void 0;
      }
      get maxRetryCount() {
        return this.privMaxRetryCount;
      }
      get isSpeakerDiarizationEnabled() {
        return this.privEnableSpeakerId;
      }
      set isSpeakerDiarizationEnabled(s) {
        this.privEnableSpeakerId = s;
      }
    }
    e.RecognizerConfig = i;
  }(Ra)), Ra;
}
var Pa = {}, _d;
function ab() {
  return _d || (_d = 1, Object.defineProperty(Pa, "__esModule", { value: !0 })), Pa;
}
var vi = {}, kd;
function cb() {
  if (kd) return vi;
  kd = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.WebsocketMessageFormatter = void 0;
  const e = /* @__PURE__ */ O(), t = `\r
`;
  let r = class {
    toConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = i.textContent;
          let n = {}, c = null;
          if (s) {
            const u = s.split(`\r
\r
`);
            u && u.length > 0 && (n = this.parseHeaders(u[0]), u.length > 1 && (c = u[1]));
          }
          a.resolve(new e.ConnectionMessage(i.messageType, c, n, i.id));
        } else if (i.messageType === e.MessageType.Binary) {
          const s = i.binaryContent;
          let n = {}, c = null;
          if (!s || s.byteLength < 2)
            throw new Error("Invalid binary message format. Header length missing.");
          const u = new DataView(s), l = u.getInt16(0);
          if (s.byteLength < l + 2)
            throw new Error("Invalid binary message format. Header content missing.");
          let p = "";
          for (let d = 0; d < l; d++)
            p += String.fromCharCode(u.getInt8(d + 2));
          n = this.parseHeaders(p), s.byteLength > l + 2 && (c = s.slice(2 + l)), a.resolve(new e.ConnectionMessage(i.messageType, c, n, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. Error: ${s}`);
      }
      return a.promise;
    }
    fromConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = `${this.makeHeaders(i)}${t}${i.textBody ? i.textBody : ""}`;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Text, s, i.id));
        } else if (i.messageType === e.MessageType.Binary) {
          const s = this.makeHeaders(i), n = i.binaryBody, c = this.stringToArrayBuffer(s), u = new Int8Array(c), l = u.byteLength, p = new Int8Array(2 + l + (n ? n.byteLength : 0));
          if (p[0] = l >> 8 & 255, p[1] = l & 255, p.set(u, 2), n) {
            const h = new Int8Array(n);
            p.set(h, 2 + l);
          }
          const d = p.buffer;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Binary, d, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. ${s}`);
      }
      return a.promise;
    }
    makeHeaders(i) {
      let a = "";
      if (i.headers)
        for (const s in i.headers)
          s && (a += `${s}: ${i.headers[s]}${t}`);
      return a;
    }
    parseHeaders(i) {
      const a = {};
      if (i) {
        const s = i.match(/[^\r\n]+/g);
        if (a) {
          for (const n of s)
            if (n) {
              const c = n.indexOf(":"), u = c > 0 ? n.substr(0, c).trim().toLowerCase() : n, l = c > 0 && n.length > c + 1 ? n.substr(c + 1).trim() : "";
              a[u] = l;
            }
        }
      }
      return a;
    }
    stringToArrayBuffer(i) {
      const a = new ArrayBuffer(i.length), s = new DataView(a);
      for (let n = 0; n < i.length; n++)
        s.setUint8(n, i.charCodeAt(n));
      return a;
    }
  };
  return vi.WebsocketMessageFormatter = r, vi;
}
var gi = {}, Od;
function ub() {
  if (Od) return gi;
  Od = 1, Object.defineProperty(gi, "__esModule", { value: !0 }), gi.SpeechConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ Te(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ pe(), s = /* @__PURE__ */ rt(), n = /* @__PURE__ */ Re();
  let c = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1", this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1", this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1", this.universalUri = "/stt/speech/universal/v";
    }
    async create(l, p, d) {
      let h = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region, void 0), g = o.ConnectionFactoryBase.getHostSuffix(f), m = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://" + f + ".stt.speech" + g), v = {}, y = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId, void 0), S = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (y ? (!h || h.search(s.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (v[s.QueryParameterNames.CustomSpeechDeploymentId] = y) : S && (!h || h.search(s.QueryParameterNames.Language) === -1) && (v[s.QueryParameterNames.Language] = S), (!h || h.search(s.QueryParameterNames.Format) === -1) && (v[s.QueryParameterNames.Format] = l.parameters.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase()), l.autoDetectSourceLanguages !== void 0 && (v[s.QueryParameterNames.EnableLanguageId] = "true"), this.setCommonUrlParams(l, v, h), h) {
        const E = new URL(h), N = E.pathname;
        (N === "" || N === "/") && (E.pathname = this.universalUri + l.recognitionEndpointVersion, h = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(E.toString()));
      }
      if (!h)
        switch (l.recognitionMode) {
          case n.RecognitionMode.Conversation:
            l.parameters.getProperty(t.ForceDictationPropertyName, "false") === "true" ? h = m + this.dictationRelativeUri : l.recognitionEndpointVersion !== void 0 && parseInt(l.recognitionEndpointVersion, 10) > 1 ? h = `${m}${this.universalUri}${l.recognitionEndpointVersion}` : h = m + this.conversationRelativeUri;
            break;
          case n.RecognitionMode.Dictation:
            h = m + this.dictationRelativeUri;
            break;
          default:
            l.recognitionEndpointVersion !== void 0 && parseInt(l.recognitionEndpointVersion, 10) > 1 ? h = `${m}${this.universalUri}${l.recognitionEndpointVersion}` : h = m + this.interactiveRelativeUri;
            break;
        }
      const C = {};
      p.token !== void 0 && p.token !== "" && (C[p.headerName] = p.token), C[a.HeaderNames.ConnectionId] = d, C.connectionId = d;
      const b = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", w = new e.WebsocketConnection(h, v, C, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), b, d), I = w.uri;
      return l.parameters.setProperty(r.PropertyId.SpeechServiceConnection_Url, I), w;
    }
  };
  return gi.SpeechConnectionFactory = c, gi;
}
var mi = {}, Md;
function lb() {
  if (Md) return mi;
  Md = 1, Object.defineProperty(mi, "__esModule", { value: !0 }), mi.ConversationTranscriberConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Te(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ pe(), s = /* @__PURE__ */ rt();
  let n = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/stt/speech/universal/v2";
    }
    async create(u, l, p) {
      let d = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, void 0), f = o.ConnectionFactoryBase.getHostSuffix(h), g = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + h + ".stt.speech" + f), m = {}, v = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), y = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (v ? (!d || d.search(s.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (m[s.QueryParameterNames.CustomSpeechDeploymentId] = v) : y && (!d || d.search(s.QueryParameterNames.Language) === -1) && (m[s.QueryParameterNames.Language] = y), u.autoDetectSourceLanguages !== void 0 && (m[s.QueryParameterNames.EnableLanguageId] = "true"), this.setV2UrlParams(u, m, d), d) {
        const I = new URL(d), E = I.pathname;
        (E === "" || E === "/") && (I.pathname = this.universalUri, d = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(I.toString()));
      }
      d || (d = `${g}${this.universalUri}`);
      const S = {};
      l.token !== void 0 && l.token !== "" && (S[l.headerName] = l.token), S[a.HeaderNames.ConnectionId] = p;
      const C = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", b = new e.WebsocketConnection(d, m, S, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), C, p), w = b.uri;
      return u.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, w), b;
    }
    setV2UrlParams(u, l, p) {
      (/* @__PURE__ */ new Map([
        [t.PropertyId.Speech_SegmentationSilenceTimeoutMs, s.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceConnection_EnableAudioLogging, s.QueryParameterNames.EnableAudioLogging],
        [t.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, s.QueryParameterNames.EndSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, s.QueryParameterNames.InitialSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceResponse_PostProcessingOption, s.QueryParameterNames.Postprocessing],
        [t.PropertyId.SpeechServiceResponse_ProfanityOption, s.QueryParameterNames.Profanity],
        [t.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, s.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((f, g) => {
        this.setUrlParameter(g, f, u, l, p);
      });
      const h = JSON.parse(u.parameters.getProperty(r.ServicePropertiesPropertyName, "{}"));
      Object.keys(h).forEach((f) => {
        l[f] = h[f];
      });
    }
  };
  return mi.ConversationTranscriberConnectionFactory = n, mi;
}
var yi = {}, Dd;
function pb() {
  if (Dd) return yi;
  Dd = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.TranscriberConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Te(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ pe(), a = /* @__PURE__ */ rt();
  let s = class extends r.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
    }
    create(c, u, l) {
      let p = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const d = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, "centralus"), h = r.ConnectionFactoryBase.getHostSuffix(d), f = "wss://transcribe." + d + ".cts.speech" + h + this.multiaudioRelativeUri, g = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, f), m = {};
      this.setQueryParams(m, c, p), p || (p = g);
      const v = {};
      u.token !== void 0 && u.token !== "" && (v[u.headerName] = u.token), v[i.HeaderNames.ConnectionId] = l, c.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, p);
      const y = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(p, m, v, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(c), y, l));
    }
    setQueryParams(c, u, l) {
      const p = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), d = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      p && !(a.QueryParameterNames.CustomSpeechDeploymentId in c) && (c[a.QueryParameterNames.CustomSpeechDeploymentId] = p), d && !(a.QueryParameterNames.Language in c) && (c[a.QueryParameterNames.Language] = d);
      const h = u.parameters.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true", f = u.parameters.getProperty(o.OutputFormatPropertyName, t.OutputFormat[t.OutputFormat.Simple]) !== t.OutputFormat[t.OutputFormat.Simple];
      (h || f) && (c[a.QueryParameterNames.Format] = t.OutputFormat[t.OutputFormat.Detailed].toLowerCase()), this.setCommonUrlParams(u, c, l);
    }
  };
  return yi.TranscriberConnectionFactory = s, yi;
}
var Si = {}, Nd;
function db() {
  if (Nd) return Si;
  Nd = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.TranslationConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ Mv(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ Te(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ pe(), s = /* @__PURE__ */ rt(), n = /* @__PURE__ */ Re();
  let c = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/stt/speech/universal/v2", this.translationV1Uri = "/speech/translation/cognitiveservices/v1";
    }
    async create(l, p, d) {
      let h = this.getEndpointUrl(l);
      const f = {};
      if (this.setQueryParams(f, l, h), h) {
        const y = new URL(h), S = y.pathname;
        (S === "" || S === "/") && (y.pathname = this.universalUri, h = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(y.toString()));
      }
      const g = {};
      p.token !== void 0 && p.token !== "" && (g[p.headerName] = p.token), g[a.HeaderNames.ConnectionId] = d, l.parameters.setProperty(r.PropertyId.SpeechServiceConnection_Url, h);
      const m = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new e.WebsocketConnection(h, f, g, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), m, d);
    }
    getEndpointUrl(l, p) {
      const d = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region), h = o.ConnectionFactoryBase.getHostSuffix(d);
      let f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      return f ? p === !0 ? f : t.StringUtils.formatString(f, { region: d }) : (l.parameters.getProperty("SPEECH-ForceV1Endpoint", "false") === "true" ? f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + h) + this.translationV1Uri : f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + h) + this.universalUri, p === !0 ? f : t.StringUtils.formatString(f, { region: d }));
    }
    setQueryParams(l, p, d) {
      l.from = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), l.to = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages), l.scenario = p.recognitionMode === n.RecognitionMode.Interactive ? "interactive" : p.recognitionMode === n.RecognitionMode.Conversation ? "conversation" : "", this.setCommonUrlParams(p, l, d), this.setUrlParameter(r.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, s.QueryParameterNames.StableTranslation, p, l, d);
      const h = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
      h !== void 0 && (l.voice = h, l.features = "requireVoice");
    }
  };
  return Si.TranslationConnectionFactory = c, Si;
}
var Ci = {}, xd;
function hb() {
  if (xd) return Ci;
  xd = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.EnumTranslation = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ _();
  let r = class {
    static implTranslateRecognitionResult(i, a = !1) {
      let s = e.ResultReason.Canceled;
      switch (i) {
        case t.RecognitionStatus.Success:
          s = e.ResultReason.RecognizedSpeech;
          break;
        case t.RecognitionStatus.EndOfDictation:
          s = a ? e.ResultReason.RecognizedSpeech : e.ResultReason.NoMatch;
          break;
        case t.RecognitionStatus.NoMatch:
        case t.RecognitionStatus.InitialSilenceTimeout:
        case t.RecognitionStatus.BabbleTimeout:
          s = e.ResultReason.NoMatch;
          break;
        case t.RecognitionStatus.Error:
        case t.RecognitionStatus.BadRequest:
        case t.RecognitionStatus.Forbidden:
        default:
          s = e.ResultReason.Canceled;
          break;
      }
      return s;
    }
    static implTranslateCancelResult(i) {
      let a = e.CancellationReason.EndOfStream;
      switch (i) {
        case t.RecognitionStatus.Success:
        case t.RecognitionStatus.EndOfDictation:
        case t.RecognitionStatus.NoMatch:
          a = e.CancellationReason.EndOfStream;
          break;
        case t.RecognitionStatus.InitialSilenceTimeout:
        case t.RecognitionStatus.BabbleTimeout:
        case t.RecognitionStatus.Error:
        case t.RecognitionStatus.BadRequest:
        case t.RecognitionStatus.Forbidden:
        default:
          a = e.CancellationReason.Error;
          break;
      }
      return a;
    }
    static implTranslateCancelErrorCode(i) {
      let a = e.CancellationErrorCode.NoError;
      switch (i) {
        case t.RecognitionStatus.Error:
          a = e.CancellationErrorCode.ServiceError;
          break;
        case t.RecognitionStatus.TooManyRequests:
          a = e.CancellationErrorCode.TooManyRequests;
          break;
        case t.RecognitionStatus.BadRequest:
          a = e.CancellationErrorCode.BadRequestParameters;
          break;
        case t.RecognitionStatus.Forbidden:
          a = e.CancellationErrorCode.Forbidden;
          break;
        default:
          a = e.CancellationErrorCode.NoError;
          break;
      }
      return a;
    }
    static implTranslateErrorDetails(i) {
      let a = "The speech service encountered an internal error and could not continue.";
      switch (i) {
        case e.CancellationErrorCode.Forbidden:
          a = "The recognizer is using a free subscription that ran out of quota.";
          break;
        case e.CancellationErrorCode.BadRequestParameters:
          a = "Invalid parameter or unsupported audio format in the request.";
          break;
        case e.CancellationErrorCode.TooManyRequests:
          a = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
          break;
      }
      return a;
    }
  };
  return Ci.EnumTranslation = r, Ci;
}
var ba = {}, zd;
function fb() {
  return zd || (zd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionStatus = e.SynthesisStatus = void 0, function(t) {
      t[t.Success = 0] = "Success", t[t.SynthesisEnd = 1] = "SynthesisEnd", t[t.Error = 2] = "Error";
    }(e.SynthesisStatus || (e.SynthesisStatus = {})), function(t) {
      t[t.Success = 0] = "Success", t[t.NoMatch = 1] = "NoMatch", t[t.InitialSilenceTimeout = 2] = "InitialSilenceTimeout", t[t.BabbleTimeout = 3] = "BabbleTimeout", t[t.Error = 4] = "Error", t[t.EndOfDictation = 5] = "EndOfDictation", t[t.TooManyRequests = 6] = "TooManyRequests", t[t.BadRequest = 7] = "BadRequest", t[t.Forbidden = 8] = "Forbidden";
    }(e.RecognitionStatus || (e.RecognitionStatus = {}));
  }(ba)), ba;
}
var Ri = {}, Ld;
function vb() {
  if (Ld) return Ri;
  Ld = 1, Object.defineProperty(Ri, "__esModule", { value: !0 }), Ri.TranslationSynthesisEnd = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Uv {
    constructor(o) {
      this.privSynthesisEnd = JSON.parse(o), this.privSynthesisEnd.SynthesisStatus && (this.privSynthesisEnd.SynthesisStatus = e.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus]), this.privSynthesisEnd.Status && (this.privSynthesisEnd.SynthesisStatus = e.SynthesisStatus[this.privSynthesisEnd.Status]);
    }
    static fromJSON(o) {
      return new Uv(o);
    }
    get SynthesisStatus() {
      return this.privSynthesisEnd.SynthesisStatus;
    }
    get FailureReason() {
      return this.privSynthesisEnd.FailureReason;
    }
  };
  return Ri.TranslationSynthesisEnd = t, Ri;
}
var Pi = {}, jd;
function gb() {
  if (jd) return Pi;
  jd = 1, Object.defineProperty(Pi, "__esModule", { value: !0 }), Pi.TranslationHypothesis = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ uc();
  let r = class Qa {
    constructor(i, a) {
      this.privTranslationHypothesis = i, this.privTranslationHypothesis.Offset += a, this.privTranslationHypothesis.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationHypothesis.Translation.TranslationStatus);
    }
    static fromJSON(i, a) {
      return new Qa(JSON.parse(i), a);
    }
    static fromTranslationResponse(i, a) {
      e.Contracts.throwIfNullOrUndefined(i, "translationHypothesis");
      const s = i.SpeechHypothesis;
      return i.SpeechHypothesis = void 0, s.Translation = i, new Qa(s, a);
    }
    get Duration() {
      return this.privTranslationHypothesis.Duration;
    }
    get Offset() {
      return this.privTranslationHypothesis.Offset;
    }
    get Text() {
      return this.privTranslationHypothesis.Text;
    }
    get Translation() {
      return this.privTranslationHypothesis.Translation;
    }
    get Language() {
      return this.privTranslationHypothesis.PrimaryLanguage?.Language;
    }
    asJson() {
      const i = { ...this.privTranslationHypothesis };
      return i.Translation !== void 0 ? JSON.stringify({
        ...i,
        TranslationStatus: t.TranslationStatus[i.Translation.TranslationStatus]
      }) : JSON.stringify(i);
    }
    mapTranslationStatus(i) {
      if (typeof i == "string")
        return t.TranslationStatus[i];
      if (typeof i == "number")
        return i;
    }
  };
  return Pi.TranslationHypothesis = r, Pi;
}
var bi = {}, qd;
function mb() {
  if (qd) return bi;
  qd = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.TranslationPhrase = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ uc();
  let o = class Ya {
    constructor(a, s) {
      this.privTranslationPhrase = a, this.privTranslationPhrase.Offset += s, this.privTranslationPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privTranslationPhrase.RecognitionStatus), this.privTranslationPhrase.Translation !== void 0 && (this.privTranslationPhrase.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationPhrase.Translation.TranslationStatus));
    }
    static fromJSON(a, s) {
      return new Ya(JSON.parse(a), s);
    }
    static fromTranslationResponse(a, s) {
      e.Contracts.throwIfNullOrUndefined(a, "translationResponse");
      const n = a.SpeechPhrase;
      return a.SpeechPhrase = void 0, n.Translation = a, n.Text = n.DisplayText, new Ya(n, s);
    }
    get RecognitionStatus() {
      return this.privTranslationPhrase.RecognitionStatus;
    }
    get Offset() {
      return this.privTranslationPhrase.Offset;
    }
    get Duration() {
      return this.privTranslationPhrase.Duration;
    }
    get Text() {
      return this.privTranslationPhrase.Text;
    }
    get Language() {
      return this.privTranslationPhrase.PrimaryLanguage?.Language;
    }
    get Confidence() {
      return this.privTranslationPhrase.PrimaryLanguage?.Confidence;
    }
    get Translation() {
      return this.privTranslationPhrase.Translation;
    }
    asJson() {
      const a = { ...this.privTranslationPhrase }, s = {
        ...a,
        RecognitionStatus: t.RecognitionStatus[a.RecognitionStatus]
      };
      return a.Translation && (s.Translation = {
        ...a.Translation,
        TranslationStatus: r.TranslationStatus[a.Translation.TranslationStatus]
      }), JSON.stringify(s);
    }
    mapRecognitionStatus(a) {
      if (typeof a == "string")
        return t.RecognitionStatus[a];
      if (typeof a == "number")
        return a;
    }
    mapTranslationStatus(a) {
      if (typeof a == "string")
        return r.TranslationStatus[a];
      if (typeof a == "number")
        return a;
    }
  };
  return bi.TranslationPhrase = o, bi;
}
var wi = {}, Fd;
function yb() {
  if (Fd) return wi;
  Fd = 1, Object.defineProperty(wi, "__esModule", { value: !0 }), wi.TranslationServiceRecognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ _();
  let o = class extends r.ConversationServiceRecognizer {
    constructor(a, s, n, c, u) {
      super(a, s, n, c, u), this.privTranslationRecognizer = u, this.connectionEvents.attach((l) => {
        l.name === "ConnectionEstablishedEvent" && this.privTranslationRecognizer.onConnection();
      });
    }
    async processTypeSpecificMessages(a) {
      const s = new t.PropertyCollection();
      let n = await this.processSpeechMessages(a);
      if (n)
        return !0;
      const c = async (l) => {
        if (s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, l.asJson()), this.privRequestSession.onPhraseRecognized(l.Offset + l.Duration), l.RecognitionStatus === r.RecognitionStatus.Success) {
          const p = this.fireEventForResult(l, s);
          if (this.privTranslationRecognizer.recognized)
            try {
              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, p);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(p.result);
            } catch (d) {
              this.privErrorCallback && this.privErrorCallback(d);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
        } else {
          const p = r.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus), d = new t.TranslationRecognitionResult(void 0, this.privRequestSession.requestId, p, l.Text, l.Duration, l.Offset, l.Language, l.Confidence, void 0, l.asJson(), s);
          if (p === t.ResultReason.Canceled) {
            const h = r.EnumTranslation.implTranslateCancelResult(l.RecognitionStatus), f = r.EnumTranslation.implTranslateCancelErrorCode(l.RecognitionStatus);
            await this.cancelRecognitionLocal(h, f, r.EnumTranslation.implTranslateErrorDetails(f));
          } else if (l.RecognitionStatus !== r.RecognitionStatus.EndOfDictation) {
            const h = new t.TranslationRecognitionEventArgs(d, d.offset, this.privRequestSession.sessionId);
            if (this.privTranslationRecognizer.recognized)
              try {
                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, h);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(d);
              } catch (f) {
                this.privErrorCallback && this.privErrorCallback(f);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          n = !0;
        }
      }, u = (l) => {
        s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, l.asJson());
        const p = this.fireEventForResult(l, s);
        if (this.privRequestSession.onHypothesis(p.offset), this.privTranslationRecognizer.recognizing)
          try {
            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, p);
          } catch {
          }
        n = !0;
      };
      switch (a.messageType === e.MessageType.Text && s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, a.textBody), a.path.toLowerCase()) {
        case "translation.hypothesis":
          u(r.TranslationHypothesis.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.response":
          const l = JSON.parse(a.textBody);
          if (l.SpeechPhrase)
            await c(r.TranslationPhrase.fromTranslationResponse(l, this.privRequestSession.currentTurnAudioOffset));
          else {
            const d = JSON.parse(a.textBody);
            d.SpeechHypothesis && u(r.TranslationHypothesis.fromTranslationResponse(d, this.privRequestSession.currentTurnAudioOffset));
          }
          break;
        case "translation.phrase":
          await c(r.TranslationPhrase.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.synthesis":
        case "audio":
          this.sendSynthesisAudio(a.binaryBody, this.privRequestSession.sessionId), n = !0;
          break;
        case "audio.end":
        case "translation.synthesis.end":
          const p = r.TranslationSynthesisEnd.fromJSON(a.textBody);
          switch (p.SynthesisStatus) {
            case r.SynthesisStatus.Error:
              if (this.privTranslationRecognizer.synthesizing) {
                const d = new t.TranslationSynthesisResult(t.ResultReason.Canceled, void 0), h = new t.TranslationSynthesisEventArgs(d, this.privRequestSession.sessionId);
                try {
                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, h);
                } catch {
                }
              }
              if (this.privTranslationRecognizer.canceled) {
                const d = new t.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, t.CancellationReason.Error, p.FailureReason, t.CancellationErrorCode.ServiceError, null);
                try {
                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, d);
                } catch {
                }
              }
              break;
            case r.SynthesisStatus.Success:
              this.sendSynthesisAudio(void 0, this.privRequestSession.sessionId);
              break;
          }
          n = !0;
          break;
      }
      return n;
    }
    // Cancels recognition.
    cancelRecognition(a, s, n, c, u) {
      const l = new t.PropertyCollection();
      if (l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]), this.privTranslationRecognizer.canceled) {
        const p = new t.TranslationRecognitionCanceledEventArgs(a, n, u, c, void 0);
        try {
          this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.TranslationRecognitionResult(
          void 0,
          // Translations
          s,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Druation
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          l
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    handleRecognizingCallback(a, s, n) {
      try {
        const c = new t.TranslationRecognitionEventArgs(t.TranslationRecognitionResult.fromSpeechRecognitionResult(a), s, n);
        this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    handleRecognizedCallback(a, s, n) {
      try {
        const c = new t.TranslationRecognitionEventArgs(t.TranslationRecognitionResult.fromSpeechRecognitionResult(a), s, n);
        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    fireEventForResult(a, s) {
      let n;
      if (a.Translation.Translations !== void 0) {
        n = new t.Translations();
        for (const h of a.Translation.Translations)
          n.set(h.Language, h.Text || h.DisplayText);
      }
      let c, u;
      a instanceof r.TranslationPhrase ? (a.Translation && a.Translation.TranslationStatus === e.TranslationStatus.Success ? c = t.ResultReason.TranslatedSpeech : c = t.ResultReason.RecognizedSpeech, u = a.Confidence) : c = t.ResultReason.TranslatingSpeech;
      const l = a.Language, p = new t.TranslationRecognitionResult(n, this.privRequestSession.requestId, c, a.Text, a.Duration, a.Offset, l, u, a.Translation.FailureReason, a.asJson(), s);
      return new t.TranslationRecognitionEventArgs(p, a.Offset, this.privRequestSession.sessionId);
    }
    sendSynthesisAudio(a, s) {
      const n = a === void 0 ? t.ResultReason.SynthesizingAudioCompleted : t.ResultReason.SynthesizingAudio, c = new t.TranslationSynthesisResult(n, a), u = new t.TranslationSynthesisEventArgs(c, s);
      if (this.privTranslationRecognizer.synthesizing)
        try {
          this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, u);
        } catch {
        }
    }
  };
  return wi.TranslationServiceRecognizer = o, wi;
}
var Ei = {}, Bd;
function Sb() {
  if (Bd) return Ei;
  Bd = 1, Object.defineProperty(Ei, "__esModule", { value: !0 }), Ei.SpeechDetected = void 0;
  let e = class $v {
    constructor(r, o) {
      this.privSpeechStartDetected = JSON.parse(r), this.privSpeechStartDetected.Offset += o;
    }
    static fromJSON(r, o) {
      return new $v(r, o);
    }
    get Offset() {
      return this.privSpeechStartDetected.Offset;
    }
  };
  return Ei.SpeechDetected = e, Ei;
}
var Ii = {}, Ud;
function Cb() {
  if (Ud) return Ii;
  Ud = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.SpeechHypothesis = void 0;
  let e = class Vv {
    constructor(r, o) {
      this.privSpeechHypothesis = JSON.parse(r), this.updateOffset(o);
    }
    static fromJSON(r, o) {
      return new Vv(r, o);
    }
    updateOffset(r) {
      this.privSpeechHypothesis.Offset += r;
    }
    asJson() {
      return JSON.stringify(this.privSpeechHypothesis);
    }
    get Text() {
      return this.privSpeechHypothesis.Text;
    }
    get Offset() {
      return this.privSpeechHypothesis.Offset;
    }
    get Duration() {
      return this.privSpeechHypothesis.Duration;
    }
    get Language() {
      return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSpeechHypothesis.SpeakerId;
    }
  };
  return Ii.SpeechHypothesis = e, Ii;
}
var Ai = {}, $d;
function Rb() {
  if ($d) return Ai;
  $d = 1, Object.defineProperty(Ai, "__esModule", { value: !0 }), Ai.SpeechKeyword = void 0;
  let e = class Wv {
    constructor(r, o) {
      this.privSpeechKeyword = JSON.parse(r), this.privSpeechKeyword.Offset += o;
    }
    static fromJSON(r, o) {
      return new Wv(r, o);
    }
    get Status() {
      return this.privSpeechKeyword.Status;
    }
    get Text() {
      return this.privSpeechKeyword.Text;
    }
    get Offset() {
      return this.privSpeechKeyword.Offset;
    }
    get Duration() {
      return this.privSpeechKeyword.Duration;
    }
    asJson() {
      return JSON.stringify(this.privSpeechKeyword);
    }
  };
  return Ai.SpeechKeyword = e, Ai;
}
var Ti = {}, Vd;
function Pb() {
  if (Vd) return Ti;
  Vd = 1, Object.defineProperty(Ti, "__esModule", { value: !0 }), Ti.SpeechServiceRecognizer = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ _();
  let r = class extends t.ServiceRecognizerBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, n, c), this.privSpeechRecognizer = c;
    }
    async processTypeSpecificMessages(i) {
      let a;
      const s = new e.PropertyCollection();
      let n = !1;
      switch (i.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const c = t.SpeechHypothesis.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
          s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, c.asJson()), a = new e.SpeechRecognitionResult(
            this.privRequestSession.requestId,
            e.ResultReason.RecognizingSpeech,
            c.Text,
            c.Duration,
            c.Offset,
            c.Language,
            c.LanguageDetectionConfidence,
            void 0,
            // Speaker Id
            void 0,
            c.asJson(),
            s
          ), this.privRequestSession.onHypothesis(c.Offset);
          const u = new e.SpeechRecognitionEventArgs(a, c.Offset, this.privRequestSession.sessionId);
          if (this.privSpeechRecognizer.recognizing)
            try {
              this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, u);
            } catch {
            }
          n = !0;
          break;
        case "speech.phrase":
          const l = t.SimpleSpeechPhrase.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
          s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, l.asJson());
          const p = t.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus, this.privExpectContentAssessmentResponse);
          if (this.privRequestSession.onPhraseRecognized(l.Offset + l.Duration), e.ResultReason.Canceled === p) {
            const d = t.EnumTranslation.implTranslateCancelResult(l.RecognitionStatus), h = t.EnumTranslation.implTranslateCancelErrorCode(l.RecognitionStatus);
            await this.cancelRecognitionLocal(d, h, t.EnumTranslation.implTranslateErrorDetails(h));
          } else {
            if (l.RecognitionStatus === t.RecognitionStatus.EndOfDictation)
              break;
            if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
              a = new e.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                p,
                l.DisplayText,
                l.Duration,
                l.Offset,
                l.Language,
                l.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                l.asJson(),
                s
              );
            else {
              const h = t.DetailedSpeechPhrase.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
              s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, h.asJson()), a = new e.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                p,
                h.RecognitionStatus === t.RecognitionStatus.Success ? h.NBest[0].Display : "",
                h.Duration,
                h.Offset,
                h.Language,
                h.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                h.asJson(),
                s
              );
            }
            const d = new e.SpeechRecognitionEventArgs(a, a.offset, this.privRequestSession.sessionId);
            if (this.privSpeechRecognizer.recognized)
              try {
                this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, d);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(a);
              } catch (h) {
                this.privErrorCallback && this.privErrorCallback(h);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          n = !0;
          break;
      }
      return n;
    }
    // Cancels recognition.
    cancelRecognition(i, a, s, n, c) {
      const u = new e.PropertyCollection();
      if (u.setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[n]), this.privSpeechRecognizer.canceled) {
        const l = new e.SpeechRecognitionCanceledEventArgs(s, c, n, void 0, i);
        try {
          this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, l);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const l = new e.SpeechRecognitionResult(
          a,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          c,
          void 0,
          // Json
          u
        );
        try {
          this.privSuccessCallback(l), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Ti.SpeechServiceRecognizer = r, Ti;
}
var _i = {}, wa = {}, Wd;
function bb() {
  return Wd || (Wd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.IdentityProvider = e.SpeakerDiarizationMode = void 0, function(t) {
      t.None = "None", t.Identity = "Identity", t.Anonymous = "Anonymous";
    }(e.SpeakerDiarizationMode || (e.SpeakerDiarizationMode = {})), function(t) {
      t.CallCenter = "CallCenter";
    }(e.IdentityProvider || (e.IdentityProvider = {}));
  }(wa)), wa;
}
var Hd;
function wb() {
  if (Hd) return _i;
  Hd = 1, Object.defineProperty(_i, "__esModule", { value: !0 }), _i.ConversationTranscriptionServiceRecognizer = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ bb(), o = /* @__PURE__ */ Re();
  let i = class extends t.ServiceRecognizerBase {
    constructor(s, n, c, u, l) {
      super(s, n, c, u, l), this.privConversationTranscriber = l, this.setSpeakerDiarizationJson();
    }
    setSpeakerDiarizationJson() {
      if (this.privEnableSpeakerId) {
        const s = this.privSpeechContext.getContext().phraseDetection || {};
        s.mode = o.RecognitionMode.Conversation;
        const n = {};
        n.mode = r.SpeakerDiarizationMode.Anonymous, n.audioSessionId = this.privDiarizationSessionId, n.audioOffsetMs = 0, n.diarizeIntermediates = this.privRecognizerConfig.parameters.getProperty(e.PropertyId.SpeechServiceResponse_DiarizeIntermediateResults, "false") === "true", s.speakerDiarization = n, this.privSpeechContext.getContext().phraseDetection = s;
      }
    }
    async processTypeSpecificMessages(s) {
      let n;
      const c = new e.PropertyCollection();
      c.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, s.textBody);
      let u = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const l = t.SpeechHypothesis.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, e.ResultReason.RecognizingSpeech, l.Text, l.Duration, l.Offset, l.Language, l.LanguageDetectionConfidence, l.SpeakerId, void 0, l.asJson(), c), this.privRequestSession.onHypothesis(l.Offset);
          const p = new e.ConversationTranscriptionEventArgs(n, l.Duration, this.privRequestSession.sessionId);
          if (this.privConversationTranscriber.transcribing)
            try {
              this.privConversationTranscriber.transcribing(this.privConversationTranscriber, p);
            } catch {
            }
          u = !0;
          break;
        case "speech.phrase":
          const d = t.SimpleSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset), h = t.EnumTranslation.implTranslateRecognitionResult(d.RecognitionStatus);
          if (this.privRequestSession.onPhraseRecognized(d.Offset + d.Duration), e.ResultReason.Canceled === h) {
            const f = t.EnumTranslation.implTranslateCancelResult(d.RecognitionStatus), g = t.EnumTranslation.implTranslateCancelErrorCode(d.RecognitionStatus);
            await this.cancelRecognitionLocal(f, g, t.EnumTranslation.implTranslateErrorDetails(g));
          } else if (!(this.privRequestSession.isSpeechEnded && h === e.ResultReason.NoMatch && d.RecognitionStatus !== t.RecognitionStatus.InitialSilenceTimeout)) {
            if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
              n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, h, d.DisplayText, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, d.SpeakerId, void 0, d.asJson(), c);
            else {
              const g = t.DetailedSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
              n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, h, g.RecognitionStatus === t.RecognitionStatus.Success ? g.NBest[0].Display : void 0, g.Duration, g.Offset, g.Language, g.LanguageDetectionConfidence, d.SpeakerId, void 0, g.asJson(), c);
            }
            const f = new e.ConversationTranscriptionEventArgs(n, n.offset, this.privRequestSession.sessionId);
            if (this.privConversationTranscriber.transcribed)
              try {
                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, f);
              } catch {
              }
          }
          u = !0;
          break;
      }
      return u;
    }
    // Cancels recognition.
    cancelRecognition(s, n, c, u, l) {
      if (new e.PropertyCollection().setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[u]), this.privConversationTranscriber.canceled) {
        const d = new e.ConversationTranscriptionCanceledEventArgs(c, l, u, void 0, s);
        try {
          this.privConversationTranscriber.canceled(this.privConversationTranscriber, d);
        } catch {
        }
      }
    }
  };
  return _i.ConversationTranscriptionServiceRecognizer = i, _i;
}
var ki = {}, Kd;
function Eb() {
  if (Kd) return ki;
  Kd = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.TranscriptionServiceRecognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Jt();
  let i = class extends r.ConversationServiceRecognizer {
    constructor(s, n, c, u, l) {
      super(s, n, c, u, l), this.privTranscriberRecognizer = l, this.sendPrePayloadJSONOverride = (p) => this.sendTranscriptionStartJSON(p), this.privRecognizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true" && this.privSpeechContext.setWordLevelTimings();
    }
    async sendSpeechEventAsync(s, n) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createSpeechEventPayload(s, n));
      }
    }
    async sendMeetingSpeechEventAsync(s, n) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createMeetingSpeechEventPayload(s, n));
      }
    }
    processTypeSpecificMessages(s) {
      return this.processSpeechMessages(s);
    }
    handleRecognizedCallback(s, n, c) {
      try {
        const u = new t.SpeechRecognitionEventArgs(s, n, c);
        if (this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, u), this.privSuccessCallback) {
          try {
            this.privSuccessCallback(s);
          } catch (l) {
            this.privErrorCallback && this.privErrorCallback(l);
          }
          this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
        }
      } catch {
      }
    }
    handleRecognizingCallback(s, n, c) {
      try {
        const u = new t.SpeechRecognitionEventArgs(s, n, c);
        this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, u);
      } catch {
      }
    }
    // Cancels recognition.
    cancelRecognition(s, n, c, u, l) {
      const p = new t.PropertyCollection();
      if (p.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[u]), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        if (this.privTranscriberRecognizer.canceled) {
          const d = new t.MeetingTranscriptionCanceledEventArgs(c, l, u, void 0, s);
          try {
            this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, d);
          } catch {
          }
        }
      } else if (this.privTranscriberRecognizer.canceled) {
        const d = new t.ConversationTranscriptionCanceledEventArgs(c, l, u, void 0, s);
        try {
          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, d);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const d = new t.SpeechRecognitionResult(
          n,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          l,
          void 0,
          // Json
          p
        );
        try {
          this.privSuccessCallback(d), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendTranscriptionStartJSON(s) {
      if (await this.sendSpeechContext(s, !0), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        const n = this.privTranscriberRecognizer.getMeetingInfo(), c = this.createMeetingSpeechEventPayload(n, "start");
        await this.sendSpeechEvent(s, c);
      } else {
        const n = this.privTranscriberRecognizer.getConversationInfo(), c = this.createSpeechEventPayload(n, "start");
        await this.sendSpeechEvent(s, c);
      }
      await this.sendWaveHeader(s);
    }
    sendSpeechEvent(s, n) {
      const c = JSON.stringify(n);
      if (c)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", c));
    }
    createSpeechEventPayload(s, n) {
      const c = { id: "meeting", name: n, meeting: s.conversationProperties };
      return c.meeting.id = s.id, c.meeting.attendees = s.participants, c;
    }
    createMeetingSpeechEventPayload(s, n) {
      const c = { id: "meeting", name: n, meeting: s.meetingProperties };
      return c.meeting.id = s.id, c.meeting.attendees = s.participants, c;
    }
  };
  return ki.TranscriptionServiceRecognizer = i, ki;
}
var Oi = {}, Jd;
function Ib() {
  if (Jd) return Oi;
  Jd = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.DetailedSpeechPhrase = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Hv {
    constructor(o, i) {
      this.privDetailedSpeechPhrase = JSON.parse(o), this.privDetailedSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privDetailedSpeechPhrase.RecognitionStatus), this.updateOffsets(i);
    }
    static fromJSON(o, i) {
      return new Hv(o, i);
    }
    updateOffsets(o) {
      if (this.privDetailedSpeechPhrase.Offset += o, this.privDetailedSpeechPhrase.NBest)
        for (const i of this.privDetailedSpeechPhrase.NBest) {
          if (i.Words)
            for (const a of i.Words)
              a.Offset += o;
          if (i.DisplayWords)
            for (const a of i.DisplayWords)
              a.Offset += o;
        }
    }
    asJson() {
      const o = { ...this.privDetailedSpeechPhrase };
      return JSON.stringify({
        ...o,
        RecognitionStatus: e.RecognitionStatus[o.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privDetailedSpeechPhrase.RecognitionStatus;
    }
    get NBest() {
      return this.privDetailedSpeechPhrase.NBest;
    }
    get Duration() {
      return this.privDetailedSpeechPhrase.Duration;
    }
    get Offset() {
      return this.privDetailedSpeechPhrase.Offset;
    }
    get Language() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get Text() {
      return this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0] ? this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText : this.privDetailedSpeechPhrase.DisplayText;
    }
    get SpeakerId() {
      return this.privDetailedSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(o) {
      if (typeof o == "string")
        return e.RecognitionStatus[o];
      if (typeof o == "number")
        return o;
    }
  };
  return Oi.DetailedSpeechPhrase = t, Oi;
}
var Mi = {}, Gd;
function Ab() {
  if (Gd) return Mi;
  Gd = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.SimpleSpeechPhrase = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Kv {
    constructor(o, i = 0) {
      this.privSimpleSpeechPhrase = JSON.parse(o), this.privSimpleSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privSimpleSpeechPhrase.RecognitionStatus), this.updateOffset(i);
    }
    static fromJSON(o, i) {
      return new Kv(o, i);
    }
    updateOffset(o) {
      this.privSimpleSpeechPhrase.Offset += o;
    }
    asJson() {
      const o = { ...this.privSimpleSpeechPhrase };
      return JSON.stringify({
        ...o,
        RecognitionStatus: e.RecognitionStatus[o.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privSimpleSpeechPhrase.RecognitionStatus;
    }
    get DisplayText() {
      return this.privSimpleSpeechPhrase.DisplayText;
    }
    get Offset() {
      return this.privSimpleSpeechPhrase.Offset;
    }
    get Duration() {
      return this.privSimpleSpeechPhrase.Duration;
    }
    get Language() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSimpleSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(o) {
      if (typeof o == "string")
        return e.RecognitionStatus[o];
      if (typeof o == "number")
        return o;
    }
  };
  return Mi.SimpleSpeechPhrase = t, Mi;
}
var Di = {}, Qd;
function Tb() {
  if (Qd) return Di;
  Qd = 1, Object.defineProperty(Di, "__esModule", { value: !0 }), Di.AddedLmIntent = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param modelImpl - The model.
     * @param intentName - The intent name.
     */
    constructor(r, o) {
      this.modelImpl = r, this.intentName = o;
    }
  };
  return Di.AddedLmIntent = e, Di;
}
var Ni = {}, Yd;
function _b() {
  if (Yd) return Ni;
  Yd = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.IntentServiceRecognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ _();
  let o = class extends r.ServiceRecognizerBase {
    constructor(a, s, n, c, u) {
      super(a, s, n, c, u), this.privIntentRecognizer = u, this.privIntentDataSent = !1, c.recognitionEndpointVersion = "1";
    }
    setIntents(a, s) {
      this.privAddedLmIntents = a, this.privUmbrellaIntent = s, this.privIntentDataSent = !0;
    }
    processTypeSpecificMessages(a) {
      let s, n, c = !1;
      const u = new t.PropertyCollection();
      switch (a.messageType === e.MessageType.Text && u.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, a.textBody), a.path.toLowerCase()) {
        case "speech.hypothesis":
          const p = r.SpeechHypothesis.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (s = new t.IntentRecognitionResult(void 0, this.privRequestSession.requestId, t.ResultReason.RecognizingIntent, p.Text, p.Duration, p.Offset, p.Language, p.LanguageDetectionConfidence, void 0, p.asJson(), u), this.privRequestSession.onHypothesis(s.offset), n = new t.IntentRecognitionEventArgs(s, p.Offset, this.privRequestSession.sessionId), this.privIntentRecognizer.recognizing)
            try {
              this.privIntentRecognizer.recognizing(this.privIntentRecognizer, n);
            } catch {
            }
          c = !0;
          break;
        case "speech.phrase":
          const d = r.SimpleSpeechPhrase.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset);
          s = new t.IntentRecognitionResult(void 0, this.privRequestSession.requestId, r.EnumTranslation.implTranslateRecognitionResult(d.RecognitionStatus), d.DisplayText, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, void 0, d.asJson(), u), n = new t.IntentRecognitionEventArgs(s, s.offset, this.privRequestSession.sessionId);
          const h = () => {
            if (this.privIntentRecognizer.recognized)
              try {
                this.privIntentRecognizer.recognized(this.privIntentRecognizer, n);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(s);
              } catch (g) {
                this.privErrorCallback && this.privErrorCallback(g);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          };
          this.privIntentDataSent === !1 || t.ResultReason.NoMatch === n.result.reason ? (this.privRequestSession.onPhraseRecognized(n.offset + n.result.duration), h()) : this.privPendingIntentArgs = n, c = !0;
          break;
        case "response":
          if (n = this.privPendingIntentArgs, this.privPendingIntentArgs = void 0, n === void 0) {
            if (a.textBody === "")
              return;
            n = new t.IntentRecognitionEventArgs(new t.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
          }
          const f = r.IntentResponse.fromJSON(a.textBody);
          if (f !== null && f.topScoringIntent && f.topScoringIntent.intent) {
            let g = this.privAddedLmIntents[f.topScoringIntent.intent];
            if (this.privUmbrellaIntent !== void 0 && (g = this.privUmbrellaIntent), g) {
              const m = g === void 0 || g.intentName === void 0 ? f.topScoringIntent.intent : g.intentName;
              let v = n.result.reason;
              m !== void 0 && (v = t.ResultReason.RecognizedIntent);
              const y = n.result.properties !== void 0 ? n.result.properties : new t.PropertyCollection();
              y.setProperty(t.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, a.textBody), n = new t.IntentRecognitionEventArgs(new t.IntentRecognitionResult(m, n.result.resultId, v, n.result.text, n.result.duration, n.result.offset, void 0, void 0, n.result.errorDetails, n.result.json, y), n.offset, n.sessionId);
            }
          }
          if (this.privRequestSession.onPhraseRecognized(n.offset + n.result.duration), this.privIntentRecognizer.recognized)
            try {
              this.privIntentRecognizer.recognized(this.privIntentRecognizer, n);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(n.result);
            } catch (g) {
              this.privErrorCallback && this.privErrorCallback(g);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
          c = !0;
          break;
      }
      const l = new e.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(a, s, n, c, u) {
      const l = new t.PropertyCollection();
      if (l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]), this.privIntentRecognizer.canceled) {
        const p = new t.IntentRecognitionCanceledEventArgs(n, u, c, void 0, void 0, a);
        try {
          this.privIntentRecognizer.canceled(this.privIntentRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.IntentRecognitionResult(
          void 0,
          // Intent Id
          s,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          l
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Ni.IntentServiceRecognizer = o, Ni;
}
var xi = {}, Zd;
function kb() {
  if (Zd) return xi;
  Zd = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.IntentResponse = void 0;
  let e = class Jv {
    constructor(r) {
      r === "" ? this.privIntentResponse = {} : this.privIntentResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new Jv(r);
    }
    get query() {
      return this.privIntentResponse.query;
    }
    get topScoringIntent() {
      return this.privIntentResponse.topScoringIntent;
    }
    get entities() {
      return this.privIntentResponse.entities;
    }
  };
  return xi.IntentResponse = e, xi;
}
var Ea = {}, Xd;
function Ob() {
  return Xd || (Xd = 1, Object.defineProperty(Ea, "__esModule", { value: !0 })), Ea;
}
var zi = {}, Li = {}, eh;
function Mb() {
  if (eh) return Li;
  eh = 1, Object.defineProperty(Li, "__esModule", { value: !0 }), Li.ServiceTelemetryListener = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ vc();
  class r {
    constructor(i, a, s) {
      this.privIsDisposed = !1, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privRequestId = i, this.privAudioSourceId = a, this.privAudioNodeId = s, this.privReceivedMessages = {}, this.privPhraseLatencies = [], this.privHypothesisLatencies = [];
    }
    phraseReceived(i) {
      i > 0 && this.privPhraseLatencies.push(Date.now() - i);
    }
    hypothesisReceived(i) {
      i > 0 && this.privHypothesisLatencies.push(Date.now() - i);
    }
    onEvent(i) {
      this.privIsDisposed || (i instanceof t.RecognitionTriggeredEvent && i.requestId === this.privRequestId && (this.privListeningTriggerMetric = {
        End: i.eventTime,
        Name: "ListeningTrigger",
        Start: i.eventTime
      }), i instanceof e.AudioStreamNodeAttachingEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = i.eventTime), i instanceof e.AudioStreamNodeAttachedEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = i.eventTime), i instanceof e.AudioSourceErrorEvent && i.audioSourceId === this.privAudioSourceId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Error: i.error,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof e.AudioStreamNodeErrorEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Error: i.error,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof e.AudioStreamNodeDetachedEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof t.ConnectingToServiceEvent && i.requestId === this.privRequestId && (this.privConnectionId = i.sessionId), i instanceof e.ConnectionStartEvent && i.connectionId === this.privConnectionId && (this.privConnectionStartTime = i.eventTime), i instanceof e.ConnectionEstablishedEvent && i.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
        End: i.eventTime,
        Id: this.privConnectionId,
        Name: "Connection",
        Start: this.privConnectionStartTime
      })), i instanceof e.ConnectionEstablishErrorEvent && i.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
        End: i.eventTime,
        Error: this.getConnectionError(i.statusCode),
        Id: this.privConnectionId,
        Name: "Connection",
        Start: this.privConnectionStartTime
      })), i instanceof e.ConnectionMessageReceivedEvent && i.connectionId === this.privConnectionId && i.message && i.message.headers && i.message.headers.path && (this.privReceivedMessages[i.message.headers.path] || (this.privReceivedMessages[i.message.headers.path] = new Array()), this.privReceivedMessages[i.message.headers.path].length < 50 && this.privReceivedMessages[i.message.headers.path].push(i.networkReceivedTime)));
    }
    getTelemetry() {
      const i = new Array();
      this.privListeningTriggerMetric && i.push(this.privListeningTriggerMetric), this.privMicMetric && i.push(this.privMicMetric), this.privConnectionEstablishMetric && i.push(this.privConnectionEstablishMetric), this.privPhraseLatencies.length > 0 && i.push({
        PhraseLatencyMs: this.privPhraseLatencies
      }), this.privHypothesisLatencies.length > 0 && i.push({
        FirstHypothesisLatencyMs: this.privHypothesisLatencies
      });
      const a = {
        Metrics: i,
        ReceivedMessages: this.privReceivedMessages
      }, s = JSON.stringify(a);
      return this.privReceivedMessages = {}, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privPhraseLatencies = [], this.privHypothesisLatencies = [], s;
    }
    // Determines if there are any telemetry events to send to the service.
    get hasTelemetry() {
      return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
    }
    dispose() {
      this.privIsDisposed = !0;
    }
    getConnectionError(i) {
      switch (i) {
        case 400:
        case 1002:
        case 1003:
        case 1005:
        case 1007:
        case 1008:
        case 1009:
          return "BadRequest";
        case 401:
          return "Unauthorized";
        case 403:
          return "Forbidden";
        case 503:
        case 1001:
          return "ServerUnavailable";
        case 500:
        case 1011:
          return "ServerError";
        case 408:
        case 504:
          return "Timeout";
        default:
          return "statuscode:" + i.toString();
      }
    }
  }
  return Li.ServiceTelemetryListener = r, Li;
}
var th;
function Db() {
  if (th) return zi;
  th = 1, Object.defineProperty(zi, "__esModule", { value: !0 }), zi.RequestSession = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ vc(), r = /* @__PURE__ */ Mb();
  let o = class {
    constructor(a) {
      this.privIsDisposed = !1, this.privDetachables = new Array(), this.privIsAudioNodeDetached = !1, this.privIsRecognizing = !1, this.privIsSpeechEnded = !1, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privHypothesisReceived = !1, this.privBytesSent = 0, this.privRecognitionBytesSent = 0, this.privRecogNumber = 0, this.privInTurn = !1, this.privConnectionAttempts = 0, this.privAudioSourceId = a, this.privRequestId = (0, e.createNoDashGuid)(), this.privAudioNodeId = (0, e.createNoDashGuid)(), this.privTurnDeferral = new e.Deferred(), this.privTurnDeferral.resolve();
    }
    get sessionId() {
      return this.privSessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSpeechEnded() {
      return this.privIsSpeechEnded;
    }
    get isRecognizing() {
      return this.privIsRecognizing;
    }
    get currentTurnAudioOffset() {
      return this.privTurnStartAudioOffset;
    }
    get recogNumber() {
      return this.privRecogNumber;
    }
    get numConnectionAttempts() {
      return this.privConnectionAttempts;
    }
    // The number of bytes sent for the current connection.
    // Counter is reset to 0 each time a connection is established.
    get bytesSent() {
      return this.privBytesSent;
    }
    // The number of bytes sent for the current recognition.
    // Counter is reset to 0 each time recognition is started.
    get recognitionBytesSent() {
      return this.privRecognitionBytesSent;
    }
    listenForServiceTelemetry(a) {
      this.privServiceTelemetryListener && this.privDetachables.push(a.attachListener(this.privServiceTelemetryListener));
    }
    startNewRecognition() {
      this.privRecognitionBytesSent = 0, this.privIsSpeechEnded = !1, this.privIsRecognizing = !0, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privRecogNumber++, this.privServiceTelemetryListener = new r.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId), this.onEvent(new t.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
    async onAudioSourceAttachCompleted(a, s) {
      this.privAudioNode = a, this.privIsAudioNodeDetached = !1, s ? await this.onComplete() : this.onEvent(new t.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
    onPreConnectionStart(a, s) {
      this.privAuthFetchEventId = a, this.privSessionId = s, this.onEvent(new t.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
    }
    async onAuthCompleted(a) {
      a && await this.onComplete();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onConnectionEstablishCompleted(a, s) {
      if (a === 200) {
        this.onEvent(new t.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId)), this.privAudioNode && this.privAudioNode.replay(), this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privBytesSent = 0;
        return;
      } else a === 403 && await this.onComplete();
    }
    async onServiceTurnEndResponse(a) {
      this.privTurnDeferral.resolve(), !a || this.isSpeechEnded ? (await this.onComplete(), this.privInTurn = !1) : (this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privAudioNode.replay());
    }
    onSpeechContext() {
      this.privRequestId = (0, e.createNoDashGuid)();
    }
    onServiceTurnStartResponse() {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new e.Deferred();
    }
    onHypothesis(a) {
      this.privHypothesisReceived || (this.privHypothesisReceived = !0, this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(a)));
    }
    onPhraseRecognized(a) {
      this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(a)), this.onServiceRecognized(a);
    }
    onServiceRecognized(a) {
      this.privLastRecoOffset = a, this.privHypothesisReceived = !1, this.privAudioNode.shrinkBuffers(a), this.privConnectionAttempts = 0;
    }
    onAudioSent(a) {
      this.privBytesSent += a, this.privRecognitionBytesSent += a;
    }
    onRetryConnection() {
      this.privConnectionAttempts++;
    }
    async dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = !0;
        for (const a of this.privDetachables)
          await a.detach();
        this.privServiceTelemetryListener && this.privServiceTelemetryListener.dispose(), this.privIsRecognizing = !1;
      }
    }
    getTelemetry() {
      return this.privServiceTelemetryListener.hasTelemetry ? this.privServiceTelemetryListener.getTelemetry() : null;
    }
    async onStopRecognizing() {
      await this.onComplete();
    }
    // Should be called with the audioNode for this session has indicated that it is out of speech.
    onSpeechEnded() {
      this.privIsSpeechEnded = !0;
    }
    onEvent(a) {
      this.privServiceTelemetryListener && this.privServiceTelemetryListener.onEvent(a), e.Events.instance.onEvent(a);
    }
    async onComplete() {
      this.privIsRecognizing && (this.privIsRecognizing = !1, await this.detachAudioNode());
    }
    async detachAudioNode() {
      this.privIsAudioNodeDetached || (this.privIsAudioNodeDetached = !0, this.privAudioNode && await this.privAudioNode.detach());
    }
  };
  return zi.RequestSession = o, zi;
}
var ji = {}, Ia = {}, rh;
function Nb() {
  return rh || (rh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TentativePhraseResultsOption = e.OutputFormat = e.PhraseExtension = e.PhraseOption = void 0, function(t) {
      t.WordTimings = "WordTimings", t.SNR = "SNR", t.Pronunciation = "Pronunciation", t.WordPronunciation = "WordPronunciation", t.WordConfidence = "WordConfidence", t.Words = "Words", t.Sentiment = "Sentiment", t.PronunciationAssessment = "PronunciationAssessment", t.ContentAssessment = "ContentAssessment", t.PhraseAMScore = "PhraseAMScore", t.PhraseLMScore = "PhraseLMScore", t.WordAMScore = "WordAMScore", t.WordLMScore = "WordLMScore", t.RuleTree = "RuleTree", t.NBestTimings = "NBestTimings", t.DecoderDiagnostics = "DecoderDiagnostics", t.DisplayWordTimings = "DisplayWordTimings", t.DisplayWords = "DisplayWords";
    }(e.PhraseOption || (e.PhraseOption = {})), function(t) {
      t.Graph = "Graph", t.Corrections = "Corrections", t.Sentiment = "Sentiment";
    }(e.PhraseExtension || (e.PhraseExtension = {})), function(t) {
      t.Simple = "Simple", t.Detailed = "Detailed";
    }(e.OutputFormat || (e.OutputFormat = {})), function(t) {
      t.None = "None", t.Always = "Always";
    }(e.TentativePhraseResultsOption || (e.TentativePhraseResultsOption = {}));
  }(Ia)), Ia;
}
var nh;
function xb() {
  if (nh) return ji;
  nh = 1, Object.defineProperty(ji, "__esModule", { value: !0 }), ji.SpeechContext = void 0;
  const e = /* @__PURE__ */ Re(), t = /* @__PURE__ */ Nb();
  let r = class {
    constructor(i) {
      this.privContext = {}, this.privDynamicGrammar = i;
    }
    getContext() {
      return this.privContext;
    }
    /**
     * @Internal
     * This is only used by pronunciation assessment config.
     * Do not use externally, object returned will change without warning or notice.
     */
    setPronunciationAssessmentParams(i, a, s = !1) {
      this.privContext.phraseDetection === void 0 && (this.privContext.phraseDetection = {
        enrichment: {
          pronunciationAssessment: {}
        }
      }), this.privContext.phraseDetection.enrichment === void 0 && (this.privContext.phraseDetection.enrichment = {
        pronunciationAssessment: {}
      }), this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(i) || {}, s && (this.privContext.phraseDetection.mode = e.RecognitionMode.Conversation), this.setWordLevelTimings(), this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.PronunciationAssessment), this.privContext.phraseOutput.detailed.options.indexOf(t.PhraseOption.SNR) === -1 && this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.SNR), a && (this.privContext.phraseDetection.enrichment.contentAssessment = {
        topic: a
      }, this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.ContentAssessment));
    }
    setDetailedOutputFormat() {
      this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
        detailed: {
          options: []
        }
      }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
        options: []
      }), this.privContext.phraseOutput.format = t.OutputFormat.Detailed;
    }
    setWordLevelTimings() {
      this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
        detailed: {
          options: []
        }
      }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
        options: []
      }), this.privContext.phraseOutput.format = t.OutputFormat.Detailed, this.privContext.phraseOutput.detailed.options.indexOf(t.PhraseOption.WordTimings) === -1 && this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.WordTimings);
    }
    setSpeakerDiarizationAudioOffsetMs(i) {
      this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = i;
    }
    toJSON() {
      const i = this.privDynamicGrammar.generateGrammarObject();
      return this.privContext.dgi = i, JSON.stringify(this.privContext);
    }
  };
  return ji.SpeechContext = r, ji;
}
var qi = {}, Aa = {}, ih;
function zb() {
  return ih || (ih = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SubstringMatchType = e.GroupType = void 0, function(t) {
      t.IntentText = "IntentText", t.IntentEntity = "IntentEntity", t.Generic = "Generic", t.People = "People", t.Place = "Place", t.DynamicEntity = "DynamicEntity";
    }(e.GroupType || (e.GroupType = {})), function(t) {
      t.None = "None", t.LeftRooted = "LeftRooted", t.PartialName = "PartialName", t.MiddleOfSentence = "MiddleOfSentence";
    }(e.SubstringMatchType || (e.SubstringMatchType = {}));
  }(Aa)), Aa;
}
var sh;
function Lb() {
  if (sh) return qi;
  sh = 1, Object.defineProperty(qi, "__esModule", { value: !0 }), qi.DynamicGrammarBuilder = void 0;
  const e = /* @__PURE__ */ zb();
  let t = class {
    // Adds one more reference phrases to the dynamic grammar to send.
    // All added phrases are generic phrases.
    addPhrase(o) {
      this.privPhrases || (this.privPhrases = []), o instanceof Array ? this.privPhrases = this.privPhrases.concat(o) : this.privPhrases.push(o);
    }
    // Clears all phrases stored in the current object.
    clearPhrases() {
      this.privPhrases = void 0;
    }
    // Adds one or more reference grammars to the current grammar.
    addReferenceGrammar(o) {
      this.privGrammars || (this.privGrammars = []), o instanceof Array ? this.privGrammars = this.privGrammars.concat(o) : this.privGrammars.push(o);
    }
    // clears all grammars stored on the recognizer.
    clearGrammars() {
      this.privGrammars = void 0;
    }
    // Generates an object that represents the dynamic grammar used by the Speech Service.
    // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
    // of a DynamicGrammarBuilder
    generateGrammarObject() {
      if (this.privGrammars === void 0 && this.privPhrases === void 0)
        return;
      const o = {};
      if (o.referenceGrammars = this.privGrammars, this.privPhrases !== void 0 && this.privPhrases.length !== 0) {
        const i = [];
        this.privPhrases.forEach((a) => {
          i.push({
            text: a
          });
        }), o.groups = [{ type: e.GroupType.Generic, items: i }];
      }
      return o;
    }
  };
  return qi.DynamicGrammarBuilder = t, qi;
}
var Fi = {}, Bi = {}, Ui = {}, Ta = {}, oh;
function Gv() {
  return oh || (oh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MessageDataStreamType = e.ActivityPayloadResponse = void 0;
    class t {
      constructor(o) {
        this.privActivityResponse = JSON.parse(o);
      }
      static fromJSON(o) {
        return new t(o);
      }
      get conversationId() {
        return this.privActivityResponse.conversationId;
      }
      get messageDataStreamType() {
        return this.privActivityResponse.messageDataStreamType;
      }
      get messagePayload() {
        return this.privActivityResponse.messagePayload;
      }
      get version() {
        return this.privActivityResponse.version;
      }
    }
    e.ActivityPayloadResponse = t, function(r) {
      r[r.None = 0] = "None", r[r.TextToSpeechAudio = 1] = "TextToSpeechAudio";
    }(e.MessageDataStreamType || (e.MessageDataStreamType = {}));
  }(Ta)), Ta;
}
var ah;
function jb() {
  if (ah) return Ui;
  ah = 1, Object.defineProperty(Ui, "__esModule", { value: !0 }), Ui.DialogServiceTurnState = void 0;
  const e = /* @__PURE__ */ Rs(), t = /* @__PURE__ */ Kt(), r = /* @__PURE__ */ Gv();
  let o = class {
    constructor(a, s) {
      this.privRequestId = s, this.privIsCompleted = !1, this.privAudioStream = null, this.privTurnManager = a, this.resetTurnEndTimeout();
    }
    get audioStream() {
      return this.resetTurnEndTimeout(), this.privAudioStream;
    }
    processActivityPayload(a, s) {
      return a.messageDataStreamType === r.MessageDataStreamType.TextToSpeechAudio && (this.privAudioStream = t.AudioOutputStream.createPullStream(), this.privAudioStream.format = s !== void 0 ? s : e.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privAudioStream;
    }
    endAudioStream() {
      this.privAudioStream !== null && !this.privAudioStream.isClosed && this.privAudioStream.close();
    }
    complete() {
      this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.endAudioStream();
    }
    resetTurnEndTimeout() {
      this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.privTimeoutToken = setTimeout(() => {
        this.privTurnManager.CompleteTurn(this.privRequestId);
      }, 2e3);
    }
  };
  return Ui.DialogServiceTurnState = o, Ui;
}
var ch;
function qb() {
  if (ch) return Bi;
  ch = 1, Object.defineProperty(Bi, "__esModule", { value: !0 }), Bi.DialogServiceTurnStateManager = void 0;
  const e = /* @__PURE__ */ De(), t = /* @__PURE__ */ jb();
  let r = class {
    constructor() {
      this.privTurnMap = /* @__PURE__ */ new Map();
    }
    StartTurn(i) {
      if (this.privTurnMap.has(i))
        throw new e.InvalidOperationError("Service error: There is already a turn with id:" + i);
      const a = new t.DialogServiceTurnState(this, i);
      return this.privTurnMap.set(i, a), this.privTurnMap.get(i);
    }
    GetTurn(i) {
      return this.privTurnMap.get(i);
    }
    CompleteTurn(i) {
      if (!this.privTurnMap.has(i))
        throw new e.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + i);
      const a = this.privTurnMap.get(i);
      return a.complete(), this.privTurnMap.delete(i), a;
    }
  };
  return Bi.DialogServiceTurnStateManager = r, Bi;
}
var _a = {}, uh;
function Fb() {
  return uh || (uh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.InvocationSource = void 0, function(t) {
      t.None = "None", t.VoiceActivationWithKeyword = "VoiceActivationWithKeyword";
    }(e.InvocationSource || (e.InvocationSource = {}));
  }(_a)), _a;
}
var ka = {}, lh;
function Bb() {
  return lh || (lh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OnRejectAction = e.KeywordDetectionType = void 0, function(t) {
      t.StartTrigger = "StartTrigger";
    }(e.KeywordDetectionType || (e.KeywordDetectionType = {})), function(t) {
      t.EndOfTurn = "EndOfTurn", t.Continue = "Continue";
    }(e.OnRejectAction || (e.OnRejectAction = {}));
  }(ka)), ka;
}
var ph;
function Ub() {
  if (ph) return Fi;
  ph = 1, Object.defineProperty(Fi, "__esModule", { value: !0 }), Fi.DialogServiceAdapter = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ rv(), r = /* @__PURE__ */ O(), o = /* @__PURE__ */ Rs(), i = /* @__PURE__ */ A(), a = /* @__PURE__ */ qb(), s = /* @__PURE__ */ _(), n = /* @__PURE__ */ Gv(), c = /* @__PURE__ */ Fb(), u = /* @__PURE__ */ Bb(), l = /* @__PURE__ */ Jt();
  let p = class extends s.ServiceRecognizerBase {
    constructor(h, f, g, m, v) {
      super(h, f, g, m, v), this.privEvents = new r.EventSource(), this.privDialogServiceConnector = v, this.receiveMessageOverride = () => this.receiveDialogMessageOverride(), this.privTurnStateManager = new a.DialogServiceTurnStateManager(), this.recognizeOverride = (y, S, C) => this.listenOnce(y, S, C), this.postConnectImplOverride = (y) => this.dialogConnectImpl(y), this.configConnectionOverride = (y) => this.configConnection(y), this.disconnectOverride = () => this.privDisconnect(), this.privDialogAudioSource = g, this.agentConfigSent = !1, this.privLastResult = null, this.connectionEvents.attach((y) => {
        y.name === "ConnectionClosedEvent" && (this.terminateMessageLoop = !0);
      });
    }
    async sendMessage(h) {
      const f = (0, r.createGuid)(), g = (0, r.createNoDashGuid)(), m = {
        context: {
          interactionId: f
        },
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        messagePayload: JSON.parse(h),
        version: 0.5
      }, v = JSON.stringify(m);
      await (await this.fetchConnection()).send(new l.SpeechConnectionMessage(r.MessageType.Text, "agent", g, "application/json", v));
    }
    async privDisconnect() {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, this.agentConfigSent = !1;
    }
    processTypeSpecificMessages(h) {
      const f = new i.PropertyCollection();
      h.messageType === r.MessageType.Text && f.setProperty(i.PropertyId.SpeechServiceResponse_JsonResult, h.textBody);
      let g, m;
      switch (h.path.toLowerCase()) {
        case "speech.phrase":
          const y = s.SimpleSpeechPhrase.fromJSON(h.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (this.privRequestSession.onPhraseRecognized(y.Offset + y.Duration), y.RecognitionStatus !== s.RecognitionStatus.TooManyRequests && y.RecognitionStatus !== s.RecognitionStatus.Error) {
            const I = this.fireEventForResult(y, f);
            if (this.privLastResult = I.result, this.privDialogServiceConnector.recognized)
              try {
                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, I);
              } catch {
              }
          }
          m = !0;
          break;
        case "speech.hypothesis":
          const S = s.SpeechHypothesis.fromJSON(h.textBody, this.privRequestSession.currentTurnAudioOffset);
          g = new i.SpeechRecognitionResult(this.privRequestSession.requestId, i.ResultReason.RecognizingSpeech, S.Text, S.Duration, S.Offset, S.Language, S.LanguageDetectionConfidence, void 0, void 0, S.asJson(), f), this.privRequestSession.onHypothesis(S.Offset);
          const C = new i.SpeechRecognitionEventArgs(g, S.Offset, this.privRequestSession.sessionId);
          if (this.privDialogServiceConnector.recognizing)
            try {
              this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, C);
            } catch {
            }
          m = !0;
          break;
        case "speech.keyword":
          const b = s.SpeechKeyword.fromJSON(h.textBody, this.privRequestSession.currentTurnAudioOffset);
          g = new i.SpeechRecognitionResult(this.privRequestSession.requestId, b.Status === "Accepted" ? i.ResultReason.RecognizedKeyword : i.ResultReason.NoMatch, b.Text, b.Duration, b.Offset, void 0, void 0, void 0, void 0, b.asJson(), f), b.Status !== "Accepted" && (this.privLastResult = g);
          const w = new i.SpeechRecognitionEventArgs(g, g.duration, g.resultId);
          if (this.privDialogServiceConnector.recognized)
            try {
              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, w);
            } catch {
            }
          m = !0;
          break;
        case "audio":
          {
            const I = h.requestId.toUpperCase(), E = this.privTurnStateManager.GetTurn(I);
            try {
              h.binaryBody ? E.audioStream.write(h.binaryBody) : E.endAudioStream();
            } catch {
            }
          }
          m = !0;
          break;
        case "response":
          this.handleResponseMessage(h), m = !0;
          break;
      }
      const v = new r.Deferred();
      return v.resolve(m), v.promise;
    }
    // Cancels recognition.
    async cancelRecognition(h, f, g, m, v) {
      if (this.terminateMessageLoop = !0, this.privRequestSession.isRecognizing && await this.privRequestSession.onStopRecognizing(), this.privDialogServiceConnector.canceled) {
        const y = new i.PropertyCollection();
        y.setProperty(s.CancellationErrorCodePropertyName, i.CancellationErrorCode[m]);
        const S = new i.SpeechRecognitionCanceledEventArgs(g, v, m, void 0, h);
        try {
          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, S);
        } catch {
        }
        if (this.privSuccessCallback) {
          const C = new i.SpeechRecognitionResult(
            void 0,
            // ResultId
            i.ResultReason.Canceled,
            void 0,
            // Text
            void 0,
            // Duration
            void 0,
            // Offset
            void 0,
            // Language
            void 0,
            // Language Detection Confidence
            void 0,
            // Speaker Id
            v,
            void 0,
            // Json
            y
          );
          try {
            this.privSuccessCallback(C), this.privSuccessCallback = void 0;
          } catch {
          }
        }
      }
    }
    async listenOnce(h, f, g) {
      this.privRecognizerConfig.recognitionMode = h, this.privSuccessCallback = f, this.privErrorCallback = g, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events), this.privRecognizerConfig.parameters.setProperty(i.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const m = this.connectImpl(), v = this.sendPreAudioMessages(), y = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId), S = await this.privDialogAudioSource.format, C = await this.privDialogAudioSource.deviceInfo, b = new e.ReplayableAudioNode(y, S.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(b, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: C };
      try {
        await m, await v;
      } catch (E) {
        return await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.ConnectionFailure, E), Promise.resolve();
      }
      const w = new i.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, w), this.sendAudio(b).then(() => {
      }, async (E) => {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.RuntimeError, E);
      });
    }
    // Establishes a websocket connection to the end point.
    dialogConnectImpl(h) {
      return this.privConnectionLoop = this.startMessageLoop(), h;
    }
    receiveDialogMessageOverride() {
      const h = new r.Deferred(), f = async () => {
        try {
          const g = this.isDisposed(), m = !this.isDisposed() && this.terminateMessageLoop;
          if (g || m) {
            h.resolve(void 0);
            return;
          }
          const y = await (await this.fetchConnection()).read();
          if (!y)
            return f();
          const S = l.SpeechConnectionMessage.fromConnectionMessage(y);
          switch (S.path.toLowerCase()) {
            case "turn.start":
              {
                const R = S.requestId.toUpperCase(), M = this.privRequestSession.requestId.toUpperCase();
                R !== M ? this.privTurnStateManager.StartTurn(R) : this.privRequestSession.onServiceTurnStartResponse();
              }
              break;
            case "speech.startdetected":
              const b = s.SpeechDetected.fromJSON(S.textBody, this.privRequestSession.currentTurnAudioOffset), w = new i.RecognitionEventArgs(b.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, w);
              break;
            case "speech.enddetected":
              let I;
              S.textBody.length > 0 ? I = S.textBody : I = "{ Offset: 0 }";
              const E = s.SpeechDetected.fromJSON(I, this.privRequestSession.currentTurnAudioOffset);
              this.privRequestSession.onServiceRecognized(E.Offset);
              const N = new i.RecognitionEventArgs(E.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, N);
              break;
            case "turn.end":
              {
                const R = S.requestId.toUpperCase(), M = this.privRequestSession.requestId.toUpperCase();
                if (R !== M)
                  this.privTurnStateManager.CompleteTurn(R);
                else {
                  const T = new i.SessionEventArgs(this.privRequestSession.sessionId);
                  if (await this.privRequestSession.onServiceTurnEndResponse(!1), (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) && this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, T), this.privSuccessCallback && this.privLastResult) {
                    try {
                      this.privSuccessCallback(this.privLastResult), this.privLastResult = null;
                    } catch (L) {
                      this.privErrorCallback && this.privErrorCallback(L);
                    }
                    this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
                  }
                }
              }
              break;
            default:
              try {
                await this.processTypeSpecificMessages(S) || this.serviceEvents && this.serviceEvents.onEvent(new r.ServiceEvent(S.path.toLowerCase(), S.textBody));
              } catch {
              }
          }
          return f();
        } catch {
          this.terminateMessageLoop = !0, h.resolve();
        }
      };
      return f().catch((g) => {
        r.Events.instance.onEvent(new r.BackgroundEvent(g));
      }), h.promise;
    }
    async startMessageLoop() {
      this.terminateMessageLoop = !1;
      try {
        await this.receiveDialogMessageOverride();
      } catch (h) {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.RuntimeError, h);
      }
      return Promise.resolve();
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configConnection(h) {
      return this.terminateMessageLoop ? (this.terminateMessageLoop = !1, Promise.reject("Connection to service terminated.")) : (await this.sendSpeechServiceConfig(h, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendAgentConfig(h), h);
    }
    async sendPreAudioMessages() {
      const h = await this.fetchConnection();
      this.addKeywordContextData(), await this.sendSpeechContext(h, !0), await this.sendAgentContext(h), await this.sendWaveHeader(h);
    }
    sendAgentConfig(h) {
      if (this.agentConfig && !this.agentConfigSent) {
        if (this.privRecognizerConfig.parameters.getProperty(i.PropertyId.Conversation_DialogType) === i.DialogServiceConfig.DialogTypes.CustomCommands) {
          const g = this.agentConfig.get();
          g.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us"), this.agentConfig.set(g);
        }
        this.onEvent(new t.SendingAgentContextMessageEvent(this.agentConfig));
        const f = this.agentConfig.toJsonString();
        return this.agentConfigSent = !0, h.send(new l.SpeechConnectionMessage(r.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", f));
      }
    }
    sendAgentContext(h) {
      const f = (0, r.createGuid)(), g = this.privDialogServiceConnector.properties.getProperty(i.PropertyId.Conversation_Speech_Activity_Template), v = JSON.stringify({
        channelData: "",
        context: {
          interactionId: f
        },
        messagePayload: typeof g === void 0 ? void 0 : g,
        version: 0.5
      });
      return h.send(new l.SpeechConnectionMessage(r.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", v));
    }
    fireEventForResult(h, f) {
      const g = s.EnumTranslation.implTranslateRecognitionResult(h.RecognitionStatus), m = new i.SpeechRecognitionResult(this.privRequestSession.requestId, g, h.DisplayText, h.Duration, h.Offset, h.Language, h.LanguageDetectionConfidence, void 0, void 0, h.asJson(), f);
      return new i.SpeechRecognitionEventArgs(m, h.Offset, this.privRequestSession.sessionId);
    }
    handleResponseMessage(h) {
      const f = JSON.parse(h.textBody);
      switch (f.messageType.toLowerCase()) {
        case "message":
          const g = h.requestId.toUpperCase(), m = n.ActivityPayloadResponse.fromJSON(h.textBody), v = this.privTurnStateManager.GetTurn(g);
          if (m.conversationId) {
            const C = this.agentConfig.get();
            C.botInfo.conversationId = m.conversationId, this.agentConfig.set(C);
          }
          const y = v.processActivityPayload(m, o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(i.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0))), S = new i.ActivityReceivedEventArgs(m.messagePayload, y);
          if (this.privDialogServiceConnector.activityReceived)
            try {
              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, S);
            } catch {
            }
          break;
        case "messagestatus":
          if (this.privDialogServiceConnector.turnStatusReceived)
            try {
              this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new i.TurnStatusReceivedEventArgs(h.textBody));
            } catch {
            }
          break;
        default:
          r.Events.instance.onEvent(new r.BackgroundEvent(`Unexpected response of type ${f.messageType}. Ignoring.`));
          break;
      }
    }
    onEvent(h) {
      this.privEvents.onEvent(h), r.Events.instance.onEvent(h);
    }
    addKeywordContextData() {
      const h = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
      if (h === void 0)
        return;
      const f = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets"), g = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations"), m = h.split(";"), v = f === void 0 ? [] : f.split(";"), y = g === void 0 ? [] : g.split(";"), S = [];
      for (let C = 0; C < m.length; C++) {
        const b = {
          text: m[C]
        };
        C < v.length && (b.startOffset = Number(v[C])), C < y.length && (b.duration = Number(y[C])), S.push(b);
      }
      this.speechContext.getContext().invocationSource = c.InvocationSource.VoiceActivationWithKeyword, this.speechContext.getContext().keywordDetection = [{
        clientDetectedKeywords: S,
        onReject: { action: u.OnRejectAction.EndOfTurn },
        type: u.KeywordDetectionType.StartTrigger
      }];
    }
  };
  return Fi.DialogServiceAdapter = p, Fi;
}
var $i = {}, dh;
function $b() {
  if (dh) return $i;
  dh = 1, Object.defineProperty($i, "__esModule", { value: !0 }), $i.AgentConfig = void 0;
  let e = class {
    toJsonString() {
      return JSON.stringify(this.iPrivConfig);
    }
    get() {
      return this.iPrivConfig;
    }
    /**
     * Setter for the agent.config object.
     * @param value a JSON serializable object.
     */
    set(r) {
      this.iPrivConfig = r;
    }
  };
  return $i.AgentConfig = e, $i;
}
var Oa = {}, Vi = {}, Wi = {}, hh;
function gc() {
  if (hh) return Wi;
  hh = 1, Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.ConversationConnectionConfig = void 0;
  const e = /* @__PURE__ */ Bv();
  let t = class tt extends e.RestConfigBase {
    static get host() {
      return tt.privHost;
    }
    static get apiVersion() {
      return tt.privApiVersion;
    }
    static get clientAppId() {
      return tt.privClientAppId;
    }
    static get defaultLanguageCode() {
      return tt.privDefaultLanguageCode;
    }
    static get restPath() {
      return tt.privRestPath;
    }
    static get webSocketPath() {
      return tt.privWebSocketPath;
    }
    static get transcriptionEventKeys() {
      return tt.privTranscriptionEventKeys;
    }
  };
  return Wi.ConversationConnectionConfig = t, t.privHost = "dev.microsofttranslator.com", t.privRestPath = "/capito/room", t.privApiVersion = "2.0", t.privDefaultLanguageCode = "en-US", t.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15", t.privWebSocketPath = "/capito/translate", t.privTranscriptionEventKeys = ["iCalUid", "callId", "organizer", "FLAC", "MTUri", "DifferentiateGuestSpeakers", "audiorecording", "Threadid", "OrganizerMri", "OrganizerTenantId", "UserToken"], Wi;
}
var fh;
function Vb() {
  if (fh) return Vi;
  fh = 1, Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.ConversationManager = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ gc();
  let i = class {
    constructor() {
      this.privRequestParams = o.ConversationConnectionConfig.configParams, this.privErrors = o.ConversationConnectionConfig.restErrors, this.privHost = o.ConversationConnectionConfig.host, this.privApiVersion = o.ConversationConnectionConfig.apiVersion, this.privRestPath = o.ConversationConnectionConfig.restPath, this.privRestAdapter = new e.RestMessageAdapter({});
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */
    createOrJoin(s, n, c, u) {
      try {
        t.Contracts.throwIfNullOrUndefined(s, "args");
        const l = s.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, o.ConversationConnectionConfig.defaultLanguageCode), p = s.getProperty(r.PropertyId.ConversationTranslator_Name, "conversation_host"), d = s.getProperty(r.PropertyId.ConversationTranslator_Host, this.privHost), h = s.getProperty(r.PropertyId.ConversationTranslator_CorrelationId), f = s.getProperty(r.PropertyId.SpeechServiceConnection_Key), g = s.getProperty(r.PropertyId.SpeechServiceConnection_Region), m = s.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
        t.Contracts.throwIfNullOrWhitespace(l, "languageCode"), t.Contracts.throwIfNullOrWhitespace(p, "nickname"), t.Contracts.throwIfNullOrWhitespace(d, "endpointHost");
        const v = {};
        v[this.privRequestParams.apiVersion] = this.privApiVersion, v[this.privRequestParams.languageCode] = l, v[this.privRequestParams.nickname] = p;
        const y = {};
        h && (y[this.privRequestParams.correlationId] = h), y[this.privRequestParams.clientAppId] = o.ConversationConnectionConfig.clientAppId, n !== void 0 ? v[this.privRequestParams.roomId] = n : (t.Contracts.throwIfNullOrUndefined(g, this.privErrors.authInvalidSubscriptionRegion), y[this.privRequestParams.subscriptionRegion] = g, f ? y[this.privRequestParams.subscriptionKey] = f : m ? y[this.privRequestParams.authorization] = `Bearer ${m}` : t.Contracts.throwIfNullOrUndefined(f, this.privErrors.authInvalidSubscriptionKey));
        const S = {};
        S.headers = y, this.privRestAdapter.options = S;
        const C = `https://${d}${this.privRestPath}`;
        this.privRestAdapter.request(e.RestRequestType.Post, C, v, null).then((b) => {
          const w = e.RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, b.headers);
          if (!b.ok) {
            if (u) {
              let E = this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", b.status.toString()), N;
              try {
                N = JSON.parse(b.data), E += ` [${N.error.code}: ${N.error.message}]`;
              } catch {
                E += ` [${b.data}]`;
              }
              w && (E += ` ${w}`), u(E);
            }
            return;
          }
          const I = JSON.parse(b.data);
          if (I && (I.requestId = w), c) {
            try {
              c(I);
            } catch (E) {
              u && u(E);
            }
            c = void 0;
          }
        }).catch(() => {
        });
      } catch (l) {
        if (u)
          if (l instanceof Error) {
            const p = l;
            u(p.name + ": " + p.message);
          } else
            u(l);
      }
    }
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */
    leave(s, n) {
      return new Promise((c, u) => {
        try {
          t.Contracts.throwIfNullOrUndefined(s, this.privErrors.invalidArgs.replace("{arg}", "config")), t.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "token"));
          const l = s.getProperty(r.PropertyId.ConversationTranslator_Host, this.privHost), p = s.getProperty(r.PropertyId.ConversationTranslator_CorrelationId), d = {};
          d[this.privRequestParams.apiVersion] = this.privApiVersion, d[this.privRequestParams.sessionToken] = n;
          const h = {};
          p && (h[this.privRequestParams.correlationId] = p);
          const f = {};
          f.headers = h, this.privRestAdapter.options = f;
          const g = `https://${l}${this.privRestPath}`;
          this.privRestAdapter.request(e.RestRequestType.Delete, g, d, null).then((m) => {
            m.ok, c();
          }).catch(() => {
          });
        } catch (l) {
          if (l instanceof Error) {
            const p = l;
            u(p.name + ": " + p.message);
          } else
            u(l);
        }
      });
    }
  };
  return Vi.ConversationManager = i, Vi;
}
var kt = {}, Hi = {}, Ki = {}, Ji = {}, vh;
function Qv() {
  if (vh) return Ji;
  vh = 1, Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.ConversationConnectionMessage = void 0;
  const e = /* @__PURE__ */ O();
  let t = class extends e.ConnectionMessage {
    constructor(o, i, a, s) {
      super(o, i, a, s);
      const n = JSON.parse(this.textBody);
      n.type !== void 0 && (this.privConversationMessageType = n.type);
    }
    get conversationMessageType() {
      return this.privConversationMessageType;
    }
  };
  return Ji.ConversationConnectionMessage = t, Ji;
}
var gh;
function Wb() {
  if (gh) return Ki;
  gh = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.ConversationWebsocketMessageFormatter = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ Qv();
  let r = class {
    /**
     * Format incoming messages: text (speech partial/final, IM) or binary (tts)
     */
    toConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = new t.ConversationConnectionMessage(i.messageType, i.textContent, {}, i.id);
          a.resolve(s);
        } else i.messageType === e.MessageType.Binary && a.resolve(new t.ConversationConnectionMessage(i.messageType, i.binaryContent, void 0, i.id));
      } catch (s) {
        a.reject(`Error formatting the message. Error: ${s}`);
      }
      return a.promise;
    }
    /**
     * Format outgoing messages: text (commands or IM)
     */
    fromConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = `${i.textBody ? i.textBody : ""}`;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Text, s, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. ${s}`);
      }
      return a.promise;
    }
  };
  return Ki.ConversationWebsocketMessageFormatter = r, Ki;
}
var mh;
function Hb() {
  if (mh) return Hi;
  mh = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.ConversationConnectionFactory = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A(), i = /* @__PURE__ */ Te(), a = /* @__PURE__ */ gc(), s = /* @__PURE__ */ Wb();
  let n = class extends i.ConnectionFactoryBase {
    create(u, l, p) {
      const d = u.parameters.getProperty(o.PropertyId.ConversationTranslator_Host, a.ConversationConnectionConfig.host), h = u.parameters.getProperty(o.PropertyId.ConversationTranslator_CorrelationId, (0, t.createGuid)()), f = `wss://${d}${a.ConversationConnectionConfig.webSocketPath}`, g = u.parameters.getProperty(o.PropertyId.ConversationTranslator_Token, void 0);
      r.Contracts.throwIfNullOrUndefined(g, "token");
      const m = {};
      m[a.ConversationConnectionConfig.configParams.apiVersion] = a.ConversationConnectionConfig.apiVersion, m[a.ConversationConnectionConfig.configParams.token] = g, m[a.ConversationConnectionConfig.configParams.correlationId] = h;
      const v = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(f, m, {}, new s.ConversationWebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), v, p));
    }
  };
  return Hi.ConversationConnectionFactory = n, Hi;
}
var Gi = {}, Qi = {}, yh;
function Kb() {
  if (yh) return Qi;
  yh = 1, Object.defineProperty(Qi, "__esModule", { value: !0 }), Qi.ConversationRequestSession = void 0;
  const e = /* @__PURE__ */ O();
  let t = class {
    constructor(o) {
      this.privIsDisposed = !1, this.privDetachables = new Array(), this.privSessionId = o, this.privRequestId = (0, e.createNoDashGuid)(), this.privRequestCompletionDeferral = new e.Deferred();
    }
    get sessionId() {
      return this.privSessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get completionPromise() {
      return this.privRequestCompletionDeferral.promise;
    }
    onPreConnectionStart(o, i) {
      this.privSessionId = i;
    }
    onAuthCompleted(o) {
      o && this.onComplete();
    }
    onConnectionEstablishCompleted(o) {
      o !== 200 && o === 403 && this.onComplete();
    }
    onServiceTurnEndResponse(o) {
      o ? this.privRequestId = (0, e.createNoDashGuid)() : this.onComplete();
    }
    async dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = !0;
        for (const o of this.privDetachables)
          await o.detach();
      }
    }
    onComplete() {
    }
  };
  return Qi.ConversationRequestSession = t, Qi;
}
var ue = {}, Sh;
function Yv() {
  if (Sh) return ue;
  Sh = 1, Object.defineProperty(ue, "__esModule", { value: !0 }), ue.ConversationReceivedTranslationEventArgs = ue.ParticipantsListEventArgs = ue.ParticipantAttributeEventArgs = ue.ParticipantEventArgs = ue.LockRoomEventArgs = ue.MuteAllEventArgs = void 0;
  const e = /* @__PURE__ */ A();
  class t extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsMuted = c;
    }
    get isMuted() {
      return this.privIsMuted;
    }
  }
  ue.MuteAllEventArgs = t;
  class r extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsLocked = c;
    }
    get isMuted() {
      return this.privIsLocked;
    }
  }
  ue.LockRoomEventArgs = r;
  class o extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privParticipant = c;
    }
    get participant() {
      return this.privParticipant;
    }
  }
  ue.ParticipantEventArgs = o;
  class i extends e.SessionEventArgs {
    constructor(c, u, l, p) {
      super(p), this.privKey = u, this.privValue = l, this.privParticipantId = c;
    }
    get value() {
      return this.privValue;
    }
    get key() {
      return this.privKey;
    }
    get id() {
      return this.privParticipantId;
    }
  }
  ue.ParticipantAttributeEventArgs = i;
  class a extends e.SessionEventArgs {
    constructor(c, u, l, p, d, h, f, g, m) {
      super(m), this.privRoomId = c, this.privSessionToken = u, this.privTranslateTo = l, this.privProfanityFilter = p, this.privRoomProfanityFilter = d, this.privIsRoomLocked = h, this.privIsRoomLocked = f, this.privParticipants = g;
    }
    get sessionToken() {
      return this.privSessionToken;
    }
    get conversationId() {
      return this.privRoomId;
    }
    get translateTo() {
      return this.privTranslateTo;
    }
    get profanityFilter() {
      return this.privProfanityFilter;
    }
    get roomProfanityFilter() {
      return this.privRoomProfanityFilter;
    }
    get isRoomLocked() {
      return this.privIsRoomLocked;
    }
    get isMuteAll() {
      return this.privIsMuteAll;
    }
    get participants() {
      return this.privParticipants;
    }
  }
  ue.ParticipantsListEventArgs = a;
  class s {
    constructor(c, u, l) {
      this.privPayload = u, this.privCommand = c, this.privSessionId = l;
    }
    get payload() {
      return this.privPayload;
    }
    get command() {
      return this.privCommand;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  return ue.ConversationReceivedTranslationEventArgs = s, ue;
}
var Be = {}, Ch;
function Zv() {
  if (Ch) return Be;
  Ch = 1, Object.defineProperty(Be, "__esModule", { value: !0 }), Be.ConversationTranslatorCommandTypes = Be.ConversationTranslatorMessageTypes = Be.InternalParticipants = void 0;
  class e {
    constructor(r = [], o) {
      this.participants = r, this.meId = o;
    }
    /**
     * Add or update a participant
     * @param value
     */
    addOrUpdateParticipant(r) {
      if (r === void 0)
        return;
      const o = this.getParticipantIndex(r.id);
      return o > -1 ? this.participants.splice(o, 1, r) : this.participants.push(r), this.getParticipant(r.id);
    }
    /**
     * Find the participant's position in the participants list.
     * @param id
     */
    getParticipantIndex(r) {
      return this.participants.findIndex((o) => o.id === r);
    }
    /**
     * Find the participant by id.
     * @param id
     */
    getParticipant(r) {
      return this.participants.find((o) => o.id === r);
    }
    /**
     * Remove a participant from the participants list.
     */
    deleteParticipant(r) {
      this.participants = this.participants.filter((o) => o.id !== r);
    }
    /**
     * Helper to return the conversation host.
     */
    get host() {
      return this.participants.find((r) => r.isHost === !0);
    }
    /**
     * Helper to return the current user.
     */
    get me() {
      return this.getParticipant(this.meId);
    }
  }
  return Be.InternalParticipants = e, Be.ConversationTranslatorMessageTypes = {
    command: "command",
    final: "final",
    info: "info",
    instantMessage: "instant_message",
    keepAlive: "keep_alive",
    partial: "partial",
    participantCommand: "participant_command",
    translatedMessage: "translated_message"
  }, Be.ConversationTranslatorCommandTypes = {
    changeNickname: "ChangeNickname",
    disconnectSession: "DisconnectSession",
    ejectParticipant: "EjectParticipant",
    instant_message: "instant_message",
    joinSession: "JoinSession",
    leaveSession: "LeaveSession",
    participantList: "ParticipantList",
    roomExpirationWarning: "RoomExpirationWarning",
    setLockState: "SetLockState",
    setMute: "SetMute",
    setMuteAll: "SetMuteAll",
    setProfanityFiltering: "SetProfanityFiltering",
    setTranslateToLanguages: "SetTranslateToLanguages",
    setUseTTS: "SetUseTTS"
  }, Be;
}
var Ma = {}, Yi = {}, Rh;
function Jb() {
  if (Rh) return Yi;
  Rh = 1, Object.defineProperty(Yi, "__esModule", { value: !0 }), Yi.CommandResponsePayload = void 0;
  const e = (r) => JSON.parse(r);
  let t = class Xv {
    constructor(o) {
      this.privCommandResponse = e(o);
    }
    get type() {
      return this.privCommandResponse.type;
    }
    get command() {
      return this.privCommandResponse.command;
    }
    get id() {
      return this.privCommandResponse.id;
    }
    get nickname() {
      return this.privCommandResponse.nickname;
    }
    get participantId() {
      return this.privCommandResponse.participantId;
    }
    get roomid() {
      return this.privCommandResponse.roomid;
    }
    get value() {
      return this.privCommandResponse.value;
    }
    get token() {
      return this.privCommandResponse.token;
    }
    static fromJSON(o) {
      return new Xv(o);
    }
  };
  return Yi.CommandResponsePayload = t, Yi;
}
var Ot = {}, Ph;
function Gb() {
  if (Ph) return Ot;
  Ph = 1, Object.defineProperty(Ot, "__esModule", { value: !0 }), Ot.ParticipantPayloadResponse = Ot.ParticipantsListPayloadResponse = void 0;
  const e = (i) => JSON.parse(i), t = (i) => JSON.parse(i);
  class r {
    constructor(a) {
      this.privParticipantsPayloadResponse = e(a);
    }
    get roomid() {
      return this.privParticipantsPayloadResponse.roomid;
    }
    get id() {
      return this.privParticipantsPayloadResponse.id;
    }
    get command() {
      return this.privParticipantsPayloadResponse.command;
    }
    get participants() {
      return this.privParticipantsPayloadResponse.participants;
    }
    get token() {
      return this.privParticipantsPayloadResponse.token;
    }
    get translateTo() {
      return this.privParticipantsPayloadResponse.translateTo;
    }
    get profanityFilter() {
      return this.privParticipantsPayloadResponse.profanityFilter;
    }
    get roomProfanityFilter() {
      return this.privParticipantsPayloadResponse.roomProfanityFilter;
    }
    get roomLocked() {
      return this.privParticipantsPayloadResponse.roomLocked;
    }
    get muteAll() {
      return this.privParticipantsPayloadResponse.muteAll;
    }
    get type() {
      return this.privParticipantsPayloadResponse.type;
    }
    static fromJSON(a) {
      return new r(a);
    }
  }
  Ot.ParticipantsListPayloadResponse = r;
  class o {
    constructor(a) {
      this.privParticipantPayloadResponse = t(a);
    }
    get nickname() {
      return this.privParticipantPayloadResponse.nickname;
    }
    get locale() {
      return this.privParticipantPayloadResponse.locale;
    }
    get usetts() {
      return this.privParticipantPayloadResponse.usetts;
    }
    get ismuted() {
      return this.privParticipantPayloadResponse.ismuted;
    }
    get ishost() {
      return this.privParticipantPayloadResponse.ishost;
    }
    get participantId() {
      return this.privParticipantPayloadResponse.participantId;
    }
    get avatar() {
      return this.privParticipantPayloadResponse.avatar;
    }
    static fromJSON(a) {
      return new o(a);
    }
  }
  return Ot.ParticipantPayloadResponse = o, Ot;
}
var Mt = {}, bh;
function Qb() {
  if (bh) return Mt;
  bh = 1, Object.defineProperty(Mt, "__esModule", { value: !0 }), Mt.TextResponsePayload = Mt.SpeechResponsePayload = void 0;
  const e = (i) => JSON.parse(i), t = (i) => JSON.parse(i);
  class r {
    constructor(a) {
      this.privSpeechResponse = e(a);
    }
    get recognition() {
      return this.privSpeechResponse.recognition;
    }
    get translations() {
      return this.privSpeechResponse.translations;
    }
    get id() {
      return this.privSpeechResponse.id;
    }
    get language() {
      return this.privSpeechResponse.language;
    }
    get nickname() {
      return this.privSpeechResponse.nickname;
    }
    get participantId() {
      return this.privSpeechResponse.participantId;
    }
    get roomid() {
      return this.privSpeechResponse.roomid;
    }
    get timestamp() {
      return this.privSpeechResponse.timestamp;
    }
    get type() {
      return this.privSpeechResponse.type;
    }
    get isFinal() {
      return this.privSpeechResponse.type === "final";
    }
    static fromJSON(a) {
      return new r(a);
    }
  }
  Mt.SpeechResponsePayload = r;
  class o {
    constructor(a) {
      this.privTextResponse = t(a);
    }
    get originalText() {
      return this.privTextResponse.originalText;
    }
    get translations() {
      return this.privTextResponse.translations;
    }
    get id() {
      return this.privTextResponse.id;
    }
    get language() {
      return this.privTextResponse.language;
    }
    get nickname() {
      return this.privTextResponse.nickname;
    }
    get participantId() {
      return this.privTextResponse.participantId;
    }
    get roomid() {
      return this.privTextResponse.roomid;
    }
    get timestamp() {
      return this.privTextResponse.timestamp;
    }
    get type() {
      return this.privTextResponse.type;
    }
    static fromJSON(a) {
      return new o(a);
    }
  }
  return Mt.TextResponsePayload = o, Mt;
}
var wh;
function Yb() {
  return wh || (wh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TextResponsePayload = e.SpeechResponsePayload = e.ParticipantPayloadResponse = e.ParticipantsListPayloadResponse = e.CommandResponsePayload = void 0;
    var t = /* @__PURE__ */ Jb();
    Object.defineProperty(e, "CommandResponsePayload", { enumerable: !0, get: function() {
      return t.CommandResponsePayload;
    } });
    var r = /* @__PURE__ */ Gb();
    Object.defineProperty(e, "ParticipantsListPayloadResponse", { enumerable: !0, get: function() {
      return r.ParticipantsListPayloadResponse;
    } }), Object.defineProperty(e, "ParticipantPayloadResponse", { enumerable: !0, get: function() {
      return r.ParticipantPayloadResponse;
    } });
    var o = /* @__PURE__ */ Qb();
    Object.defineProperty(e, "SpeechResponsePayload", { enumerable: !0, get: function() {
      return o.SpeechResponsePayload;
    } }), Object.defineProperty(e, "TextResponsePayload", { enumerable: !0, get: function() {
      return o.TextResponsePayload;
    } });
  }(Ma)), Ma;
}
var Eh;
function Zb() {
  if (Eh) return Gi;
  Eh = 1, Object.defineProperty(Gi, "__esModule", { value: !0 }), Gi.ConversationServiceAdapter = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Qv(), i = /* @__PURE__ */ Kb(), a = /* @__PURE__ */ Yv(), s = /* @__PURE__ */ Zv(), n = /* @__PURE__ */ Yb();
  let c = class extends r.ServiceRecognizerBase {
    constructor(l, p, d, h, f) {
      super(l, p, d, h, f), this.privConnectionConfigPromise = void 0, this.privLastPartialUtteranceId = "", this.privConversationServiceConnector = f, this.privConversationAuthentication = l, this.receiveMessageOverride = () => this.receiveConversationMessageOverride(), this.recognizeOverride = () => this.noOp(), this.postConnectImplOverride = (g) => this.conversationConnectImpl(g), this.configConnectionOverride = () => this.configConnection(), this.disconnectOverride = () => this.privDisconnect(), this.privConversationRequestSession = new i.ConversationRequestSession((0, e.createNoDashGuid)()), this.privConversationConnectionFactory = p, this.privConversationIsDisposed = !1;
    }
    isDisposed() {
      return super.isDisposed() || this.privConversationIsDisposed;
    }
    async dispose(l) {
      this.privConversationIsDisposed = !0, this.privConnectionConfigPromise !== void 0 && await (await this.privConnectionConfigPromise).dispose(l), await super.dispose(l);
    }
    async sendMessage(l) {
      return (await this.fetchConnection()).send(new o.ConversationConnectionMessage(e.MessageType.Text, l));
    }
    async sendMessageAsync(l) {
      await (await this.fetchConnection()).send(new o.ConversationConnectionMessage(e.MessageType.Text, l));
    }
    privDisconnect() {
      if (!this.terminateMessageLoop)
        return this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, t.CancellationReason.Error, t.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async processTypeSpecificMessages() {
      return !0;
    }
    // Cancels recognition.
    cancelRecognition(l, p, d, h, f) {
      this.terminateMessageLoop = !0;
      const g = new t.ConversationTranslationCanceledEventArgs(d, f, h, void 0, l);
      try {
        this.privConversationServiceConnector.canceled && this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, g);
      } catch {
      }
    }
    /**
     * Establishes a websocket connection to the end point.
     */
    async conversationConnectImpl(l) {
      return this.privConnectionLoop = this.startMessageLoop(), l;
    }
    /**
     * Process incoming websocket messages
     */
    async receiveConversationMessageOverride() {
      if (this.isDisposed() || this.terminateMessageLoop)
        return Promise.resolve();
      const l = new e.Deferred();
      try {
        const d = await (await this.fetchConnection()).read();
        if (this.isDisposed() || this.terminateMessageLoop)
          return l.resolve(), Promise.resolve();
        if (!d)
          return this.receiveConversationMessageOverride();
        const h = this.privConversationRequestSession.sessionId, f = d.conversationMessageType.toLowerCase();
        let g = !1;
        try {
          switch (f) {
            case "info":
            case "participant_command":
            case "command":
              const m = n.CommandResponsePayload.fromJSON(d.textBody);
              switch (m.command.toLowerCase()) {
                /**
                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.
                 * The consuming client must wait for this message to arrive
                 * before starting to send their own data.
                 */
                case "participantlist":
                  const w = n.ParticipantsListPayloadResponse.fromJSON(d.textBody), I = w.participants.map((L) => ({
                    avatar: L.avatar,
                    displayName: L.nickname,
                    id: L.participantId,
                    isHost: L.ishost,
                    isMuted: L.ismuted,
                    isUsingTts: L.usetts,
                    preferredLanguage: L.locale
                  }));
                  this.privConversationServiceConnector.participantsListReceived && this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new a.ParticipantsListEventArgs(w.roomid, w.token, w.translateTo, w.profanityFilter, w.roomProfanityFilter, w.roomLocked, w.muteAll, I, h));
                  break;
                /**
                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).
                 * This is sent at the start of the Conversation
                 */
                case "settranslatetolanguages":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setTranslateToLanguages, m.value, h));
                  break;
                /**
                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.
                 * If sent by the participant the setting will effect only their own profanity level.
                 * If sent by the host, the setting will effect all participants including the host.
                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'
                 */
                case "setprofanityfiltering":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setProfanityFiltering, m.value, h));
                  break;
                /**
                 * 'SetMute' is sent if the participant has been muted by the host.
                 * Check the 'participantId' to determine if the current user has been muted.
                 */
                case "setmute":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setMute, m.value, h));
                  break;
                /**
                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.
                 */
                case "setmuteall":
                  this.privConversationServiceConnector.muteAllCommandReceived && this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new a.MuteAllEventArgs(m.value, h));
                  break;
                /**
                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.
                 */
                case "roomexpirationwarning":
                  this.privConversationServiceConnector.conversationExpiration && this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new t.ConversationExpirationEventArgs(m.value, this.privConversationRequestSession.sessionId));
                  break;
                /**
                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.
                 */
                case "setusetts":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setUseTTS, m.value, h));
                  break;
                /**
                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.
                 */
                case "setlockstate":
                  this.privConversationServiceConnector.lockRoomCommandReceived && this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new a.LockRoomEventArgs(m.value, h));
                  break;
                /**
                 * 'ChangeNickname' is received if a user changes their display name.
                 * Any cached particpiants list should be updated to reflect the display name.
                 */
                case "changenickname":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.changeNickname, m.value, h));
                  break;
                /**
                 * 'JoinSession' is sent when a user joins the Conversation.
                 */
                case "joinsession":
                  const E = n.ParticipantPayloadResponse.fromJSON(d.textBody), N = {
                    avatar: E.avatar,
                    displayName: E.nickname,
                    id: E.participantId,
                    isHost: E.ishost,
                    isMuted: E.ismuted,
                    isUsingTts: E.usetts,
                    preferredLanguage: E.locale
                  };
                  this.privConversationServiceConnector.participantJoinCommandReceived && this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new a.ParticipantEventArgs(N, h));
                  break;
                /**
                 * 'LeaveSession' is sent when a user leaves the Conversation'.
                 */
                case "leavesession":
                  const R = {
                    id: m.participantId
                  };
                  this.privConversationServiceConnector.participantLeaveCommandReceived && this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new a.ParticipantEventArgs(R, h));
                  break;
                /**
                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).
                 * Check the 'ParticipantId' to check whether the message is for the current user.
                 */
                case "disconnectsession":
                  const M = {
                    id: m.participantId
                  };
                  break;
                case "token":
                  const T = new r.CognitiveTokenAuthentication(() => {
                    const L = m.token;
                    return Promise.resolve(L);
                  }, () => {
                    const L = m.token;
                    return Promise.resolve(L);
                  });
                  this.authentication = T, this.privConversationServiceConnector.onToken(T);
                  break;
                /**
                 * Message not recognized.
                 */
                default:
                  break;
              }
              break;
            /**
             * 'partial' (or 'hypothesis') represents a unfinalized speech message.
             */
            case "partial":
            /**
             * 'final' (or 'phrase') represents a finalized speech message.
             */
            case "final":
              const v = n.SpeechResponsePayload.fromJSON(d.textBody), y = f === "final" ? t.ResultReason.TranslatedParticipantSpeech : t.ResultReason.TranslatingParticipantSpeech, S = new t.ConversationTranslationResult(v.participantId, this.getTranslations(v.translations), v.language, v.id, y, v.recognition, void 0, void 0, d.textBody, void 0);
              v.isFinal ? ((S.text !== void 0 && S.text.length > 0 || v.id === this.privLastPartialUtteranceId) && (g = !0), g && this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.final, S, h))) : S.text !== void 0 && (this.privLastPartialUtteranceId = v.id, this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.partial, S, h)));
              break;
            /**
             * "translated_message" is a text message or instant message (IM).
             */
            case "translated_message":
              const C = n.TextResponsePayload.fromJSON(d.textBody), b = new t.ConversationTranslationResult(C.participantId, this.getTranslations(C.translations), C.language, void 0, void 0, C.originalText, void 0, void 0, void 0, d.textBody, void 0);
              this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.instantMessage, b, h));
              break;
            default:
              break;
          }
        } catch {
        }
        return this.receiveConversationMessageOverride();
      } catch {
        this.terminateMessageLoop = !0;
      }
      return l.promise;
    }
    async startMessageLoop() {
      if (this.isDisposed())
        return Promise.resolve();
      this.terminateMessageLoop = !1;
      const l = this.receiveConversationMessageOverride();
      try {
        return await l;
      } catch (p) {
        return this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", t.CancellationReason.Error, t.CancellationErrorCode.RuntimeError, p), null;
      }
    }
    // Takes an established websocket connection to the endpoint
    configConnection() {
      return this.isDisposed() ? Promise.resolve(void 0) : this.privConnectionConfigPromise !== void 0 ? this.privConnectionConfigPromise.then((l) => l.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection()) : this.privConnectionConfigPromise, () => (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection())) : this.terminateMessageLoop ? Promise.resolve(void 0) : (this.privConnectionConfigPromise = this.connectImpl().then((l) => l), this.privConnectionConfigPromise);
    }
    getTranslations(l) {
      let p;
      if (l !== void 0) {
        p = new t.Translations();
        for (const d of l)
          p.set(d.lang, d.translation);
      }
      return p;
    }
  };
  return Gi.ConversationServiceAdapter = c, Gi;
}
var Ih;
function Xb() {
  if (Ih) return kt;
  Ih = 1, Object.defineProperty(kt, "__esModule", { value: !0 }), kt.ConversationTranslatorRecognizer = kt.ConversationRecognizerFactory = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ A(), i = /* @__PURE__ */ Hb(), a = /* @__PURE__ */ Zb();
  class s {
    static fromConfig(u, l, p) {
      return new n(u, l, p);
    }
  }
  kt.ConversationRecognizerFactory = s;
  let n = class extends o.Recognizer {
    constructor(u, l, p) {
      const d = l;
      r.Contracts.throwIfNull(d, "speechConfig");
      const h = u;
      r.Contracts.throwIfNull(h, "conversationImpl"), super(p, d.properties, new i.ConversationConnectionFactory()), this.privConversation = h, this.privIsDisposed = !1, this.privProperties = d.properties.clone(), this.privConnection = o.Connection.fromRecognizer(this), this.privProperties.getProperty(o.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? (this.privSetTimeout = t.Timeout.setTimeout, this.privClearTimeout = t.Timeout.clearTimeout) : typeof window < "u" ? (this.privSetTimeout = window.setTimeout.bind(window), this.privClearTimeout = window.clearTimeout.bind(window)) : (this.privSetTimeout = setTimeout, this.privClearTimeout = clearTimeout);
    }
    set connected(u) {
      this.privConnection.connected = u;
    }
    set disconnected(u) {
      this.privConnection.disconnected = u;
    }
    /**
     * Return the speech language used by the recognizer
     */
    get speechRecognitionLanguage() {
      return this.privSpeechRecognitionLanguage;
    }
    /**
     * Return the properties for the recognizer
     */
    get properties() {
      return this.privProperties;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    /**
     * Connect to the recognizer
     * @param token
     */
    connect(u, l, p) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfNullOrWhitespace(u, "token"), this.privReco.conversationTranslatorToken = u, this.resetConversationTimeout(), this.privReco.connectAsync(l, p);
      } catch (d) {
        if (p)
          if (d instanceof Error) {
            const h = d;
            p(h.name + ": " + h.message);
          } else
            p(d);
      }
    }
    /**
     * Disconnect from the recognizer
     */
    disconnect(u, l) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privReco.disconnect().then(() => {
          u && u();
        }, (p) => {
          l && l(p);
        });
      } catch (p) {
        if (l)
          if (p instanceof Error) {
            const d = p;
            l(d.name + ": " + d.message);
          } else
            l(p);
        this.dispose(!0).catch((d) => {
          t.Events.instance.onEvent(new t.BackgroundEvent(d));
        });
      }
    }
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendRequest(u, l, p) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), this.sendMessage(u, l, p);
      } catch (d) {
        if (p)
          if (d instanceof Error) {
            const h = d;
            p(h.name + ": " + h.message);
          } else
            p(d);
        this.dispose(!0).catch((h) => {
          t.Events.instance.onEvent(new t.BackgroundEvent(h));
        });
      }
    }
    /**
     * Handle update of service auth token (#694)
     */
    onToken(u) {
      this.privConversation.onToken(u);
    }
    /**
     * Close and dispose the recognizer
     */
    async close() {
      this.privIsDisposed || (this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close()), this.privConnection = void 0, await this.dispose(!0));
    }
    /**
     * Dispose the recognizer
     * @param disposing
     */
    async dispose(u) {
      this.privIsDisposed || u && (this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privIsDisposed = !0, this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close(), this.privConnection = void 0), await super.dispose(u));
    }
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    createRecognizerConfig(u) {
      return new e.RecognizerConfig(u, this.privProperties);
    }
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    createServiceRecognizer(u, l, p, d) {
      const h = p;
      return new a.ConversationServiceAdapter(u, l, h, d, this);
    }
    sendMessage(u, l, p) {
      const d = this.privReco;
      ((f, g, m) => {
        f !== void 0 ? f.then(() => {
          try {
            g && g();
          } catch (v) {
            m && m(`'Unhandled error on promise callback: ${v}'`);
          }
        }, (v) => {
          try {
            m && m(v);
          } catch {
          }
        }) : m && m("Null promise");
      })(d.sendMessageAsync(u), l, p), this.resetConversationTimeout();
    }
    resetConversationTimeout() {
      this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privTimeoutToken = this.privSetTimeout(() => {
        this.sendRequest(this.privConversation.getKeepAlive());
      }, 6e4);
    }
  };
  return kt.ConversationTranslatorRecognizer = n, kt;
}
var Zi = {}, Ah;
function ew() {
  if (Ah) return Zi;
  Ah = 1, Object.defineProperty(Zi, "__esModule", { value: !0 }), Zi.TranscriberRecognizer = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Re();
  let a = class extends r.Recognizer {
    /**
     * TranscriberRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      t.Contracts.throwIfNull(u, "speechTranslationConfig");
      const l = c;
      t.Contracts.throwIfNull(l, "audioConfigImpl"), t.Contracts.throwIfNullOrWhitespace(u.speechRecognitionLanguage, r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new o.TranscriberConnectionFactory()), this.privDisposedRecognizer = !1, this.isMeetingRecognizer = !1;
    }
    get speechRecognitionLanguage() {
      return t.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    get properties() {
      return this.privProperties;
    }
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(n) {
      t.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    set conversation(n) {
      t.Contracts.throwIfNullOrUndefined(n, "Conversation"), this.isMeetingRecognizer = !1, this.privConversation = n;
    }
    getConversationInfo() {
      return t.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation"), this.privConversation.conversationInfo;
    }
    set meeting(n) {
      t.Contracts.throwIfNullOrUndefined(n, "Meeting"), this.isMeetingRecognizer = !0, this.privMeeting = n;
    }
    getMeetingInfo() {
      return t.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting"), this.privMeeting.meetingInfo;
    }
    IsMeetingRecognizer() {
      return this.isMeetingRecognizer;
    }
    startContinuousRecognitionAsync(n, c) {
      (0, e.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(i.RecognitionMode.Conversation), n, c);
    }
    stopContinuousRecognitionAsync(n, c) {
      (0, e.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    async close() {
      this.privDisposedRecognizer || await this.dispose(!0);
    }
    // Push async join/leave conversation message via serviceRecognizer
    async pushConversationEvent(n, c) {
      const u = this.privReco;
      t.Contracts.throwIfNullOrUndefined(u, "serviceRecognizer"), await u.sendSpeechEventAsync(n, c);
    }
    // Push async join/leave meeting message via serviceRecognizer
    async pushMeetingEvent(n, c) {
      const u = this.privReco;
      t.Contracts.throwIfNullOrUndefined(u, "serviceRecognizer"), await u.sendMeetingSpeechEventAsync(n, c);
    }
    async enforceAudioGating() {
      const u = (await this.audioConfig.format).channels;
      if (u === 1) {
        if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true")
          throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
      } else if (u !== 8)
        throw new Error(`Unsupported audio configuration: Detected ${u}-channel audio`);
    }
    connectMeetingCallbacks(n) {
      this.isMeetingRecognizer = !0, this.canceled = (c, u) => {
        n.canceled && n.canceled(n, u);
      }, this.recognizing = (c, u) => {
        n.transcribing && n.transcribing(n, u);
      }, this.recognized = (c, u) => {
        n.transcribed && n.transcribed(n, u);
      }, this.sessionStarted = (c, u) => {
        n.sessionStarted && n.sessionStarted(n, u);
      }, this.sessionStopped = (c, u) => {
        n.sessionStopped && n.sessionStopped(n, u);
      };
    }
    disconnectCallbacks() {
      this.canceled = void 0, this.recognizing = void 0, this.recognized = void 0, this.sessionStarted = void 0, this.sessionStopped = void 0;
    }
    /**
     * Disposes any resources held by the object.
     * @member ConversationTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new o.RecognizerConfig(n, this.properties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new o.TranscriptionServiceRecognizer(n, c, p, l, this);
    }
  };
  return Zi.TranscriberRecognizer = a, Zi;
}
var Th;
function tw() {
  return Th || (Th = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.InternalParticipants = e.ConversationTranslatorMessageTypes = e.ConversationTranslatorCommandTypes = e.ParticipantsListEventArgs = e.ParticipantEventArgs = e.ParticipantAttributeEventArgs = e.MuteAllEventArgs = e.LockRoomEventArgs = e.ConversationReceivedTranslationEventArgs = e.TranscriberRecognizer = e.ConversationRecognizerFactory = e.ConversationConnectionConfig = e.ConversationManager = void 0;
    var t = /* @__PURE__ */ Vb();
    Object.defineProperty(e, "ConversationManager", { enumerable: !0, get: function() {
      return t.ConversationManager;
    } });
    var r = /* @__PURE__ */ gc();
    Object.defineProperty(e, "ConversationConnectionConfig", { enumerable: !0, get: function() {
      return r.ConversationConnectionConfig;
    } });
    var o = /* @__PURE__ */ Xb();
    Object.defineProperty(e, "ConversationRecognizerFactory", { enumerable: !0, get: function() {
      return o.ConversationRecognizerFactory;
    } });
    var i = /* @__PURE__ */ ew();
    Object.defineProperty(e, "TranscriberRecognizer", { enumerable: !0, get: function() {
      return i.TranscriberRecognizer;
    } });
    var a = /* @__PURE__ */ Yv();
    Object.defineProperty(e, "ConversationReceivedTranslationEventArgs", { enumerable: !0, get: function() {
      return a.ConversationReceivedTranslationEventArgs;
    } }), Object.defineProperty(e, "LockRoomEventArgs", { enumerable: !0, get: function() {
      return a.LockRoomEventArgs;
    } }), Object.defineProperty(e, "MuteAllEventArgs", { enumerable: !0, get: function() {
      return a.MuteAllEventArgs;
    } }), Object.defineProperty(e, "ParticipantAttributeEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantAttributeEventArgs;
    } }), Object.defineProperty(e, "ParticipantEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantEventArgs;
    } }), Object.defineProperty(e, "ParticipantsListEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantsListEventArgs;
    } });
    var s = /* @__PURE__ */ Zv();
    Object.defineProperty(e, "ConversationTranslatorCommandTypes", { enumerable: !0, get: function() {
      return s.ConversationTranslatorCommandTypes;
    } }), Object.defineProperty(e, "ConversationTranslatorMessageTypes", { enumerable: !0, get: function() {
      return s.ConversationTranslatorMessageTypes;
    } }), Object.defineProperty(e, "InternalParticipants", { enumerable: !0, get: function() {
      return s.InternalParticipants;
    } });
  }(Oa)), Oa;
}
var Da = {}, _h;
function eg() {
  return _h || (_h = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SynthesisAudioMetadata = e.MetadataType = void 0, function(r) {
      r.WordBoundary = "WordBoundary", r.Bookmark = "Bookmark", r.Viseme = "Viseme", r.SentenceBoundary = "SentenceBoundary", r.SessionEnd = "SessionEnd", r.AvatarSignal = "TalkingAvatarSignal";
    }(e.MetadataType || (e.MetadataType = {}));
    class t {
      constructor(o) {
        this.privSynthesisAudioMetadata = JSON.parse(o);
      }
      static fromJSON(o) {
        return new t(o);
      }
      get Metadata() {
        return this.privSynthesisAudioMetadata.Metadata;
      }
    }
    e.SynthesisAudioMetadata = t;
  }(Da)), Da;
}
var Xi = {}, Ie = {}, kh;
function rw() {
  if (kh) return Ie;
  kh = 1, Object.defineProperty(Ie, "__esModule", { value: !0 }), Ie.SynthesisStartedEvent = Ie.ConnectingToSynthesisServiceEvent = Ie.SynthesisTriggeredEvent = Ie.SpeechSynthesisEvent = void 0;
  const e = /* @__PURE__ */ O();
  class t extends e.PlatformEvent {
    constructor(s, n, c = e.EventType.Info) {
      super(s, c), this.privRequestId = n;
    }
    get requestId() {
      return this.privRequestId;
    }
  }
  Ie.SpeechSynthesisEvent = t;
  class r extends t {
    constructor(s, n, c) {
      super("SynthesisTriggeredEvent", s), this.privSessionAudioDestinationId = n, this.privTurnAudioDestinationId = c;
    }
    get audioSessionDestinationId() {
      return this.privSessionAudioDestinationId;
    }
    get audioTurnDestinationId() {
      return this.privTurnAudioDestinationId;
    }
  }
  Ie.SynthesisTriggeredEvent = r;
  class o extends t {
    constructor(s, n) {
      super("ConnectingToSynthesisServiceEvent", s), this.privAuthFetchEventId = n;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  Ie.ConnectingToSynthesisServiceEvent = o;
  class i extends t {
    constructor(s, n) {
      super("SynthesisStartedEvent", s), this.privAuthFetchEventId = n;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  return Ie.SynthesisStartedEvent = i, Ie;
}
var Oh;
function nw() {
  if (Oh) return Xi;
  Oh = 1, Object.defineProperty(Xi, "__esModule", { value: !0 }), Xi.SynthesisTurn = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ Kt(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ eg(), i = /* @__PURE__ */ rw();
  let a = class Za {
    constructor() {
      this.privIsDisposed = !1, this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !1, this.privBytesReceived = 0, this.privInTurn = !1, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privRequestId = (0, e.createNoDashGuid)(), this.privTurnDeferral = new e.Deferred(), this.privTurnDeferral.resolve();
    }
    get requestId() {
      return this.privRequestId;
    }
    get streamId() {
      return this.privStreamId;
    }
    set streamId(n) {
      this.privStreamId = n;
    }
    get audioOutputFormat() {
      return this.privAudioOutputFormat;
    }
    set audioOutputFormat(n) {
      this.privAudioOutputFormat = n;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSynthesisEnded() {
      return this.privIsSynthesisEnded;
    }
    get isSynthesizing() {
      return this.privIsSynthesizing;
    }
    get currentTextOffset() {
      return this.privTextOffset;
    }
    get currentSentenceOffset() {
      return this.privSentenceOffset;
    }
    // The number of bytes received for current turn
    get bytesReceived() {
      return this.privBytesReceived;
    }
    get audioDuration() {
      return this.privAudioDuration;
    }
    get extraProperties() {
      if (this.privWebRTCSDP) {
        const n = new r.PropertyCollection();
        return n.setProperty(r.PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP), n;
      }
    }
    async getAllReceivedAudio() {
      return this.privReceivedAudio ? Promise.resolve(this.privReceivedAudio) : this.privIsSynthesisEnded ? (await this.readAllAudioFromStream(), Promise.resolve(this.privReceivedAudio)) : null;
    }
    async getAllReceivedAudioWithHeader() {
      if (this.privReceivedAudioWithHeader)
        return this.privReceivedAudioWithHeader;
      if (!this.privIsSynthesisEnded)
        return null;
      if (this.audioOutputFormat.hasHeader) {
        const n = await this.getAllReceivedAudio();
        return this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(n), this.privReceivedAudioWithHeader;
      } else
        return this.getAllReceivedAudio();
    }
    startNewSynthesis(n, c, u, l) {
      this.privIsSynthesisEnded = !1, this.privIsSynthesizing = !0, this.privRequestId = n, this.privRawText = c, this.privIsSSML = u, this.privAudioOutputStream = new t.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privAudioOutputFormat, this.privReceivedAudio = null, this.privReceivedAudioWithHeader = null, this.privBytesReceived = 0, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privPartialVisemeAnimation = "", this.privWebRTCSDP = "", l !== void 0 && (this.privTurnAudioDestination = l, this.privTurnAudioDestination.format = this.privAudioOutputFormat), this.onEvent(new i.SynthesisTriggeredEvent(this.requestId, void 0, l === void 0 ? void 0 : l.id()));
    }
    onPreConnectionStart(n) {
      this.privAuthFetchEventId = n, this.onEvent(new i.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
    }
    onAuthCompleted(n) {
      n && this.onComplete();
    }
    onConnectionEstablishCompleted(n) {
      if (n === 200) {
        this.onEvent(new i.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId)), this.privBytesReceived = 0;
        return;
      } else n === 403 && this.onComplete();
    }
    onServiceResponseMessage(n) {
      const c = JSON.parse(n);
      this.streamId = c.audio.streamId;
    }
    onServiceTurnEndResponse() {
      this.privInTurn = !1, this.privTurnDeferral.resolve(), this.onComplete();
    }
    onServiceTurnStartResponse(n) {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new e.Deferred();
      const c = JSON.parse(n);
      c.webrtc && (this.privWebRTCSDP = c.webrtc.connectionString);
    }
    onAudioChunkReceived(n) {
      this.isSynthesizing && (this.privAudioOutputStream.write(n), this.privBytesReceived += n.byteLength, this.privTurnAudioDestination !== void 0 && this.privTurnAudioDestination.write(n));
    }
    onTextBoundaryEvent(n) {
      this.updateTextOffset(n.Data.text.Text, n.Type);
    }
    onVisemeMetadataReceived(n) {
      n.Data.AnimationChunk !== void 0 && (this.privPartialVisemeAnimation += n.Data.AnimationChunk);
    }
    onSessionEnd(n) {
      this.privAudioDuration = n.Data.Offset;
    }
    async constructSynthesisResult() {
      const n = await this.getAllReceivedAudioWithHeader();
      return new r.SpeechSynthesisResult(this.requestId, r.ResultReason.SynthesizingAudioCompleted, n, void 0, this.extraProperties, this.audioDuration);
    }
    dispose() {
      this.privIsDisposed || (this.privIsDisposed = !0);
    }
    onStopSynthesizing() {
      this.onComplete();
    }
    /**
     * Gets the viseme animation string (merged from animation chunk), and clears the internal
     * partial animation.
     */
    getAndClearVisemeAnimation() {
      const n = this.privPartialVisemeAnimation;
      return this.privPartialVisemeAnimation = "", n;
    }
    onEvent(n) {
      e.Events.instance.onEvent(n);
    }
    /**
     * Check if the text is an XML(SSML) tag
     * @param text
     * @private
     */
    static isXmlTag(n) {
      return n.length >= 2 && n[0] === "<" && n[n.length - 1] === ">";
    }
    updateTextOffset(n, c) {
      c === o.MetadataType.WordBoundary ? (this.privTextOffset = this.privRawText.indexOf(n, this.privNextSearchTextIndex), this.privTextOffset >= 0 && (this.privNextSearchTextIndex = this.privTextOffset + n.length, this.privIsSSML && this.withinXmlTag(this.privTextOffset) && !Za.isXmlTag(n) && this.updateTextOffset(n, c))) : (this.privSentenceOffset = this.privRawText.indexOf(n, this.privNextSearchSentenceIndex), this.privSentenceOffset >= 0 && (this.privNextSearchSentenceIndex = this.privSentenceOffset + n.length, this.privIsSSML && this.withinXmlTag(this.privSentenceOffset) && !Za.isXmlTag(n) && this.updateTextOffset(n, c)));
    }
    onComplete() {
      this.privIsSynthesizing && (this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !0, this.privAudioOutputStream.close(), this.privInTurn = !1, this.privTurnAudioDestination !== void 0 && (this.privTurnAudioDestination.close(), this.privTurnAudioDestination = void 0));
    }
    async readAllAudioFromStream() {
      if (this.privIsSynthesisEnded) {
        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
        try {
          await this.privAudioOutputStream.read(this.privReceivedAudio);
        } catch {
          this.privReceivedAudio = new ArrayBuffer(0);
        }
      }
    }
    /**
     * Check if current idx is in XML(SSML) tag
     * @param idx
     * @private
     */
    withinXmlTag(n) {
      return this.privRawText.indexOf("<", n + 1) > this.privRawText.indexOf(">", n + 1);
    }
  };
  return Xi.SynthesisTurn = a, Xi;
}
var es = {}, Mh;
function iw() {
  if (Mh) return es;
  Mh = 1, Object.defineProperty(es, "__esModule", { value: !0 }), es.SynthesisAdapterBase = void 0;
  const e = /* @__PURE__ */ O(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Jt();
  let i = class {
    constructor(s, n, c, u) {
      if (this.speakOverride = void 0, this.receiveMessageOverride = void 0, this.connectImplOverride = void 0, this.configConnectionOverride = void 0, this.privConnectionConfigurationPromise = void 0, !s)
        throw new e.ArgumentNullError("authentication");
      if (!n)
        throw new e.ArgumentNullError("connectionFactory");
      if (!c)
        throw new e.ArgumentNullError("synthesizerConfig");
      this.privAuthentication = s, this.privConnectionFactory = n, this.privSynthesizerConfig = c, this.privIsDisposed = !1, this.privSessionAudioDestination = u, this.privSynthesisTurn = new r.SynthesisTurn(), this.privConnectionEvents = new e.EventSource(), this.privServiceEvents = new e.EventSource(), this.privSynthesisContext = new r.SynthesisContext(), this.privAgentConfig = new r.AgentConfig(), this.connectionEvents.attach((l) => {
        if (l.name === "ConnectionClosedEvent") {
          const p = l;
          p.statusCode !== 1e3 && this.cancelSynthesisLocal(t.CancellationReason.Error, p.statusCode === 1007 ? t.CancellationErrorCode.BadRequestParameters : t.CancellationErrorCode.ConnectionFailure, `${p.reason} websocket error code: ${p.statusCode}`);
        }
      });
    }
    get synthesisContext() {
      return this.privSynthesisContext;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    set activityTemplate(s) {
      this.privActivityTemplate = s;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set audioOutputFormat(s) {
      this.privAudioOutputFormat = s, this.privSynthesisTurn.audioOutputFormat = s, this.privSessionAudioDestination !== void 0 && (this.privSessionAudioDestination.format = s), this.synthesisContext !== void 0 && (this.synthesisContext.audioOutputFormat = s);
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(s) {
      this.privIsDisposed = !0, this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.close(), this.privConnectionConfigurationPromise !== void 0 && await (await this.privConnectionConfigurationPromise).dispose(s);
    }
    async connect() {
      await this.connectImpl();
    }
    async sendNetworkMessage(s, n) {
      const c = typeof n == "string" ? e.MessageType.Text : e.MessageType.Binary, u = typeof n == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new o.SpeechConnectionMessage(c, s, this.privSynthesisTurn.requestId, u, n));
    }
    async Speak(s, n, c, u, l, p) {
      let d;
      if (n ? d = s : d = this.privSynthesizer.buildSsml(s), this.speakOverride !== void 0)
        return this.speakOverride(d, c, u, l);
      this.privSuccessCallback = u, this.privErrorCallback = l, this.privSynthesisTurn.startNewSynthesis(c, s, n, p);
      try {
        await this.connectImpl();
        const h = await this.fetchConnection();
        await this.sendSynthesisContext(h), await this.sendSsmlMessage(h, d, c), this.onSynthesisStarted(c), this.receiveMessage();
      } catch (h) {
        return this.cancelSynthesisLocal(t.CancellationReason.Error, t.CancellationErrorCode.ConnectionFailure, h), Promise.reject(h);
      }
    }
    async stopSpeaking() {
      return await this.connectImpl(), (await this.fetchConnection()).send(new o.SpeechConnectionMessage(e.MessageType.Text, "synthesis.control", this.privSynthesisTurn.requestId, "application/json", JSON.stringify({
        action: "stop"
      })));
    }
    // Cancels synthesis.
    cancelSynthesis(s, n, c, u) {
      const l = new t.PropertyCollection();
      l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]);
      const p = new t.SpeechSynthesisResult(s, t.ResultReason.Canceled, void 0, u, l);
      if (this.onSynthesisCancelled(p), this.privSuccessCallback)
        try {
          this.privSuccessCallback(p);
        } catch {
        }
    }
    // Cancels synthesis.
    cancelSynthesisLocal(s, n, c) {
      this.privSynthesisTurn.isSynthesizing && (this.privSynthesisTurn.onStopSynthesizing(), this.cancelSynthesis(this.privSynthesisTurn.requestId, s, n, c));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processTypeSpecificMessages(s) {
      return !0;
    }
    async receiveMessage() {
      try {
        const n = await (await this.fetchConnection()).read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (this.privIsDisposed)
          return;
        if (!n)
          return this.privSynthesisTurn.isSynthesizing ? this.receiveMessage() : void 0;
        const c = o.SpeechConnectionMessage.fromConnectionMessage(n);
        if (c.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase())
          switch (c.path.toLowerCase()) {
            case "turn.start":
              this.privSynthesisTurn.onServiceTurnStartResponse(c.textBody);
              break;
            case "response":
              this.privSynthesisTurn.onServiceResponseMessage(c.textBody);
              break;
            case "audio":
              this.privSynthesisTurn.streamId.toLowerCase() === c.streamId.toLowerCase() && c.binaryBody && (this.privSynthesisTurn.onAudioChunkReceived(c.binaryBody), this.onSynthesizing(c.binaryBody), this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.write(c.binaryBody));
              break;
            case "audio.metadata":
              const u = r.SynthesisAudioMetadata.fromJSON(c.textBody).Metadata;
              for (const p of u)
                switch (p.Type) {
                  case r.MetadataType.WordBoundary:
                  case r.MetadataType.SentenceBoundary:
                    this.privSynthesisTurn.onTextBoundaryEvent(p);
                    const d = new t.SpeechSynthesisWordBoundaryEventArgs(p.Data.Offset, p.Data.Duration, p.Data.text.Text, p.Data.text.Length, p.Type === r.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, p.Data.text.BoundaryType);
                    this.onWordBoundary(d);
                    break;
                  case r.MetadataType.Bookmark:
                    const h = new t.SpeechSynthesisBookmarkEventArgs(p.Data.Offset, p.Data.Bookmark);
                    this.onBookmarkReached(h);
                    break;
                  case r.MetadataType.Viseme:
                    if (this.privSynthesisTurn.onVisemeMetadataReceived(p), p.Data.IsLastAnimation) {
                      const f = new t.SpeechSynthesisVisemeEventArgs(p.Data.Offset, p.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                      this.onVisemeReceived(f);
                    }
                    break;
                  case r.MetadataType.AvatarSignal:
                    this.onAvatarEvent(p);
                    break;
                  case r.MetadataType.SessionEnd:
                    this.privSynthesisTurn.onSessionEnd(p);
                    break;
                }
              break;
            case "turn.end":
              this.privSynthesisTurn.onServiceTurnEndResponse();
              let l;
              try {
                l = await this.privSynthesisTurn.constructSynthesisResult(), this.privSuccessCallback && this.privSuccessCallback(l);
              } catch (p) {
                this.privErrorCallback && this.privErrorCallback(p);
              }
              this.onSynthesisCompleted(l);
              break;
            default:
              this.processTypeSpecificMessages(c) || this.privServiceEvents && this.serviceEvents.onEvent(new e.ServiceEvent(c.path.toLowerCase(), c.textBody));
          }
        return this.receiveMessage();
      } catch {
      }
    }
    sendSynthesisContext(s) {
      this.setSynthesisContextSynthesisSection();
      const n = this.synthesisContext.toJSON();
      if (n)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", n));
    }
    setSpeechConfigSynthesisSection() {
    }
    connectImpl(s = !1) {
      if (this.privConnectionPromise != null)
        return this.privConnectionPromise.then((c) => c.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()));
      this.privAuthFetchEventId = (0, e.createNoDashGuid)(), this.privConnectionId = (0, e.createNoDashGuid)(), this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
      const n = s ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
      return this.privConnectionPromise = n.then(async (c) => {
        this.privSynthesisTurn.onAuthCompleted(!1);
        const u = await this.privConnectionFactory.create(this.privSynthesizerConfig, c, this.privConnectionId);
        u.events.attach((p) => {
          this.connectionEvents.onEvent(p);
        });
        const l = await u.open();
        return l.statusCode === 200 ? (this.privSynthesisTurn.onConnectionEstablishCompleted(l.statusCode), Promise.resolve(u)) : l.statusCode === 403 && !s ? this.connectImpl(!0) : (this.privSynthesisTurn.onConnectionEstablishCompleted(l.statusCode), Promise.reject(`Unable to contact server. StatusCode: ${l.statusCode},
                    ${this.privSynthesizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Url)} Reason: ${l.reason}`));
      }, (c) => {
        throw this.privSynthesisTurn.onAuthCompleted(!0), new Error(c);
      }), this.privConnectionPromise.catch(() => {
      }), this.privConnectionPromise;
    }
    sendSpeechServiceConfig(s, n) {
      if (n)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", n));
    }
    sendSsmlMessage(s, n, c) {
      return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "ssml", c, "application/ssml+xml", n));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((s) => s.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const s = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(s) : (this.setSpeechConfigSynthesisSection(), await this.sendSpeechServiceConfig(s, this.privSynthesizerConfig.SpeechServiceConfig.serialize()), s);
    }
    onAvatarEvent(s) {
    }
    onSynthesisStarted(s) {
    }
    onSynthesizing(s) {
    }
    onSynthesisCancelled(s) {
    }
    onSynthesisCompleted(s) {
    }
    onWordBoundary(s) {
    }
    onVisemeReceived(s) {
    }
    onBookmarkReached(s) {
    }
  };
  return es.SynthesisAdapterBase = i, i.telemetryDataEnabled = !0, es;
}
var ts = {}, Dh;
function sw() {
  if (Dh) return ts;
  Dh = 1, Object.defineProperty(ts, "__esModule", { value: !0 }), ts.AvatarSynthesisAdapter = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ _();
  let r = class extends t.SynthesisAdapterBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, void 0), this.privAvatarSynthesizer = n, this.privSynthesizer = n, this.privAvatarConfig = c;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(void 0);
    }
    setSpeechConfigSynthesisSection() {
      this.privSynthesizerConfig.synthesisVideoSection = {
        format: {
          bitrate: this.privAvatarConfig.videoFormat?.bitrate,
          codec: this.privAvatarConfig.videoFormat?.codec,
          crop: {
            bottomRight: {
              x: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.x,
              y: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.y
            },
            topLeft: {
              x: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.x,
              y: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.y
            }
          },
          resolution: {
            height: this.privAvatarConfig.videoFormat?.height,
            width: this.privAvatarConfig.videoFormat?.width
          }
        },
        protocol: {
          name: "WebRTC",
          webrtcConfig: {
            clientDescription: btoa(this.privSynthesizerConfig.parameters.getProperty(e.PropertyId.TalkingAvatarService_WebRTC_SDP)),
            iceServers: this.privAvatarConfig.remoteIceServers ?? this.privAvatarSynthesizer.iceServers
          }
        },
        talkingAvatar: {
          background: {
            color: this.privAvatarConfig.backgroundColor,
            image: {
              url: this.privAvatarConfig.backgroundImage?.toString()
            }
          },
          character: this.privAvatarConfig.character,
          customized: this.privAvatarConfig.customized,
          style: this.privAvatarConfig.style,
          useBuiltInVoice: this.privAvatarConfig.useBuiltInVoice
        }
      };
    }
    onAvatarEvent(i) {
      if (this.privAvatarSynthesizer.avatarEventReceived) {
        const a = new e.AvatarEventArgs(i.Data.Offset, i.Data.Name);
        try {
          this.privAvatarSynthesizer.avatarEventReceived(this.privAvatarSynthesizer, a);
        } catch {
        }
      }
    }
  };
  return ts.AvatarSynthesisAdapter = r, ts;
}
var rs = {}, Nh;
function ow() {
  if (Nh) return rs;
  Nh = 1, Object.defineProperty(rs, "__esModule", { value: !0 }), rs.SpeechSynthesisAdapter = void 0;
  const e = /* @__PURE__ */ A(), t = /* @__PURE__ */ _();
  let r = class extends t.SynthesisAdapterBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, c), this.privSpeechSynthesizer = n, this.privSynthesizer = n;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(this.privSpeechSynthesizer);
    }
    onSynthesisStarted(i) {
      const a = new e.SpeechSynthesisEventArgs(new e.SpeechSynthesisResult(i, e.ResultReason.SynthesizingAudioStarted));
      this.privSpeechSynthesizer.synthesisStarted && this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, a);
    }
    onSynthesizing(i) {
      if (this.privSpeechSynthesizer.synthesizing)
        try {
          const a = this.privSynthesisTurn.audioOutputFormat.addHeader(i), s = new e.SpeechSynthesisEventArgs(new e.SpeechSynthesisResult(this.privSynthesisTurn.requestId, e.ResultReason.SynthesizingAudio, a));
          this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
    onSynthesisCancelled(i) {
      if (this.privSpeechSynthesizer.SynthesisCanceled) {
        const a = new e.SpeechSynthesisEventArgs(i);
        try {
          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, a);
        } catch {
        }
      }
    }
    onSynthesisCompleted(i) {
      if (this.privSpeechSynthesizer.synthesisCompleted)
        try {
          this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new e.SpeechSynthesisEventArgs(i));
        } catch {
        }
    }
    onWordBoundary(i) {
      if (this.privSpeechSynthesizer.wordBoundary)
        try {
          this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
    onVisemeReceived(i) {
      if (this.privSpeechSynthesizer.visemeReceived)
        try {
          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
    onBookmarkReached(i) {
      if (this.privSpeechSynthesizer.bookmarkReached)
        try {
          this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
  };
  return rs.SpeechSynthesisAdapter = r, rs;
}
var ns = {}, xh;
function aw() {
  if (xh) return ns;
  xh = 1, Object.defineProperty(ns, "__esModule", { value: !0 }), ns.SynthesisRestAdapter = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ A(), r = /* @__PURE__ */ Te(), o = /* @__PURE__ */ pe();
  let i = class {
    constructor(s, n) {
      let c = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      if (!c) {
        const l = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, "westus"), p = r.ConnectionFactoryBase.getHostSuffix(l);
        c = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, `https://${l}.tts.speech${p}`);
      }
      this.privUri = `${c}/cognitiveservices/voices/list`;
      const u = e.RestConfigBase.requestOptions;
      this.privRestAdapter = new e.RestMessageAdapter(u), this.privAuthentication = n;
    }
    /**
     * Sends list voices request to endpoint.
     * @function
     * @public
     * @param connectionId - guid for connectionId
     * @returns {Promise<IRestResponse>} rest response to status request
     */
    getVoicesList(s) {
      return this.privRestAdapter.setHeaders(o.HeaderNames.ConnectionId, s), this.privAuthentication.fetch(s).then((n) => (this.privRestAdapter.setHeaders(n.headerName, n.token), this.privRestAdapter.request(e.RestRequestType.Get, this.privUri)));
    }
  };
  return ns.SynthesisRestAdapter = i, ns;
}
var Na = {}, zh;
function cw() {
  return zh || (zh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SynthesizerConfig = e.SynthesisServiceType = void 0;
    const t = /* @__PURE__ */ _();
    var r;
    (function(i) {
      i[i.Standard = 0] = "Standard", i[i.Custom = 1] = "Custom";
    })(r = e.SynthesisServiceType || (e.SynthesisServiceType = {}));
    class o {
      constructor(a, s) {
        this.privSynthesisServiceType = r.Standard, this.avatarEnabled = !1, this.privSpeechServiceConfig = a || new t.SpeechServiceConfig(new t.Context(null)), this.privParameters = s;
      }
      get parameters() {
        return this.privParameters;
      }
      get synthesisServiceType() {
        return this.privSynthesisServiceType;
      }
      set synthesisServiceType(a) {
        this.privSynthesisServiceType = a;
      }
      set synthesisVideoSection(a) {
        this.privSpeechServiceConfig.Context.synthesis = {
          video: a
        };
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
    }
    e.SynthesizerConfig = o;
  }(Na)), Na;
}
var is = {}, Lh;
function uw() {
  if (Lh) return is;
  Lh = 1, Object.defineProperty(is, "__esModule", { value: !0 }), is.SynthesisContext = void 0;
  const e = /* @__PURE__ */ A();
  let t = class {
    constructor() {
      this.privContext = {};
    }
    /**
     * Adds a section to the synthesis.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */
    setSection(o, i) {
      this.privContext[o] = i;
    }
    /**
     * Sets the audio output format for synthesis context generation.
     * @param format {AudioOutputFormatImpl} the output format
     */
    set audioOutputFormat(o) {
      this.privAudioOutputFormat = o;
    }
    toJSON() {
      return JSON.stringify(this.privContext);
    }
    setSynthesisSection(o) {
      const i = this.buildSynthesisContext(o);
      this.setSection("synthesis", i);
    }
    buildSynthesisContext(o) {
      return {
        audio: {
          metadataOptions: {
            bookmarkEnabled: !!o?.bookmarkReached,
            punctuationBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!o?.wordBoundary),
            sentenceBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, !1),
            sessionEndEnabled: !0,
            visemeEnabled: !!o?.visemeReceived,
            wordBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!o?.wordBoundary)
          },
          outputFormat: this.privAudioOutputFormat.requestAudioFormatString
        },
        language: {
          autoDetection: o?.autoDetectSourceLanguage
        }
      };
    }
  };
  return is.SynthesisContext = t, is;
}
var ss = {}, jh;
function lw() {
  if (jh) return ss;
  jh = 1, Object.defineProperty(ss, "__esModule", { value: !0 }), ss.SpeakerRecognitionConfig = void 0;
  const e = /* @__PURE__ */ _();
  let t = class {
    constructor(o, i) {
      this.privContext = o || new e.Context(null), this.privParameters = i;
    }
    get parameters() {
      return this.privParameters;
    }
    get Context() {
      return this.privContext;
    }
  };
  return ss.SpeakerRecognitionConfig = t, ss;
}
var os = {}, qh;
function pw() {
  if (qh) return os;
  qh = 1, Object.defineProperty(os, "__esModule", { value: !0 }), os.SpeakerServiceRecognizer = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Jt();
  let a = class extends o.ServiceRecognizerBase {
    constructor(n, c, u, l, p) {
      super(n, c, u, l, p), this.privSpeakerRecognizer = p, this.privSpeakerAudioSource = u, this.recognizeSpeaker = (d) => this.recognizeSpeakerOnce(d), this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    processTypeSpecificMessages(n) {
      let c = !1;
      const u = new r.PropertyCollection();
      switch (n.messageType === t.MessageType.Text && u.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, n.textBody), n.path.toLowerCase()) {
        case "speaker.response":
          const p = JSON.parse(n.textBody);
          let d;
          p.status.statusCode.toLowerCase() !== "success" ? d = new r.SpeakerRecognitionResult(p, r.ResultReason.Canceled, r.CancellationErrorCode.ServiceError, p.status.reason) : d = new r.SpeakerRecognitionResult(p, r.ResultReason.RecognizedSpeaker), this.privResultDeferral && this.privResultDeferral.resolve(d), c = !0;
          break;
      }
      const l = new t.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(n, c, u, l, p) {
      if (new r.PropertyCollection().setProperty(o.CancellationErrorCodePropertyName, r.CancellationErrorCode[l]), this.privResultDeferral) {
        const h = new r.SpeakerRecognitionResult({
          scenario: this.privSpeakerModel.scenario,
          status: { statusCode: p, reason: p }
        }, r.ResultReason.Canceled, l, p);
        try {
          this.privResultDeferral.resolve(h);
        } catch (f) {
          this.privResultDeferral.reject(f);
        }
      }
    }
    async recognizeSpeakerOnce(n) {
      this.privSpeakerModel = n, this.voiceProfileType = n.scenario, this.privResultDeferral || (this.privResultDeferral = new t.Deferred()), this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(r.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const c = this.connectImpl(), u = this.sendPreAudioMessages(this.extractSpeakerContext(n)), l = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), p = await this.privSpeakerAudioSource.format, d = await this.privSpeakerAudioSource.deviceInfo, h = new e.ReplayableAudioNode(l, p.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(h, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: d };
      try {
        await c, await u;
      } catch (m) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, m);
      }
      const f = new r.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, f), this.receiveMessage(), this.sendAudio(h).then(() => {
      }, (m) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, m);
      }), this.privResultDeferral.promise;
    }
    async sendPreAudioMessages(n) {
      const c = await this.fetchConnection();
      await this.sendSpeakerRecognition(c, n);
    }
    async sendSpeakerRecognition(n, c) {
      const u = JSON.stringify(c);
      return n.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", u));
    }
    extractSpeakerContext(n) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: n.profileIds,
        scenario: n.scenario
      };
    }
  };
  return os.SpeakerServiceRecognizer = a, os;
}
var as = {}, Fh;
function dw() {
  if (Fh) return as;
  Fh = 1, Object.defineProperty(as, "__esModule", { value: !0 }), as.VoiceServiceRecognizer = void 0;
  const e = /* @__PURE__ */ se(), t = /* @__PURE__ */ O(), r = /* @__PURE__ */ A(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Jt();
  let a = class extends o.ServiceRecognizerBase {
    constructor(n, c, u, l, p) {
      super(n, c, u, l, p), this.privDeferralMap = new t.DeferralMap(), this.privSpeakerAudioSource = u, this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    set SpeakerAudioSource(n) {
      this.privSpeakerAudioSource = n;
    }
    processTypeSpecificMessages(n) {
      let c = !1;
      const u = new r.PropertyCollection();
      switch (n.messageType === t.MessageType.Text && u.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, n.textBody), n.path.toLowerCase()) {
        // Profile management response for create, fetch, delete, reset
        case "speaker.profiles":
          const p = JSON.parse(n.textBody);
          switch (p.operation.toLowerCase()) {
            case "create":
              this.handleCreateResponse(p, n.requestId);
              break;
            case "delete":
            case "reset":
              this.handleResultResponse(p, n.requestId);
              break;
            case "fetch":
              const g = JSON.parse(n.textBody);
              this.handleFetchResponse(g, n.requestId);
              break;
          }
          c = !0;
          break;
        // Activation and authorization phrase response
        case "speaker.phrases":
          const d = JSON.parse(n.textBody);
          this.handlePhrasesResponse(d, n.requestId), c = !0;
          break;
        // Enrollment response
        case "speaker.profile.enrollment":
          const h = JSON.parse(n.textBody), f = new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(h.enrollment ? h.enrollment.enrollmentStatus : h.status.statusCode), h.enrollment ? JSON.stringify(h.enrollment) : void 0, h.status.reason);
          this.privDeferralMap.getId(n.requestId) && this.privDeferralMap.complete(n.requestId, f), this.privRequestSession.onSpeechEnded(), c = !0;
          break;
      }
      const l = new t.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(n, c, u, l, p) {
      new r.PropertyCollection().setProperty(o.CancellationErrorCodePropertyName, r.CancellationErrorCode[l]);
      const h = new r.VoiceProfileEnrollmentResult(r.ResultReason.Canceled, p, p);
      this.privDeferralMap.getId(c) && this.privDeferralMap.complete(c, h);
    }
    async createProfile(n, c) {
      this.voiceProfileType = n.toString();
      const u = this.connectImpl();
      try {
        const l = new t.Deferred();
        return await u, await this.sendCreateProfile(l, n, c), this.receiveMessage(), l.promise;
      } catch (l) {
        throw l;
      }
    }
    async resetProfile(n) {
      return this.voiceProfileType = n.profileType.toString(), this.sendCommonRequest("reset", n.profileType, n);
    }
    async deleteProfile(n) {
      return this.voiceProfileType = n.profileType.toString(), this.sendCommonRequest("delete", n.profileType, n);
    }
    async retrieveEnrollmentResult(n) {
      return this.voiceProfileType = n.profileType.toString(), this.privExpectedProfileId = n.profileId, this.sendCommonRequest("fetch", n.profileType, n);
    }
    async getAllProfiles(n) {
      return this.voiceProfileType = n.toString(), this.sendCommonRequest("fetch", n);
    }
    async getActivationPhrases(n, c) {
      this.voiceProfileType = n.toString();
      const u = this.connectImpl();
      try {
        const l = new t.Deferred();
        return await u, await this.sendPhrasesRequest(l, n, c), this.receiveMessage(), l.promise;
      } catch (l) {
        throw l;
      }
    }
    async enrollProfile(n) {
      this.voiceProfileType = n.profileType.toString();
      const c = new t.Deferred();
      this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(r.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const u = this.connectImpl(), l = this.sendPreAudioMessages(n, c), p = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), d = await this.privSpeakerAudioSource.format, h = await this.privSpeakerAudioSource.deviceInfo, f = new e.ReplayableAudioNode(p, d.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(f, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: h };
      try {
        await u, await l;
      } catch (v) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, v);
      }
      const g = new r.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, g), this.receiveMessage(), this.sendAudio(f).then(() => {
      }, (v) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, v);
      }), c.promise;
    }
    async sendPreAudioMessages(n, c) {
      const u = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, c), await this.sendBaseRequest(u, "enroll", this.scenarioFrom(n.profileType), n);
    }
    async sendPhrasesRequest(n, c, u) {
      const l = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, n);
      const p = this.scenarioFrom(c), d = {
        locale: u,
        scenario: p
      };
      return l.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(d)));
    }
    async sendCreateProfile(n, c, u) {
      const l = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, n);
      const p = c === r.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : c === r.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification", d = {
        locale: u,
        number: "1",
        scenario: p
      };
      return l.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(d)));
    }
    async sendCommonRequest(n, c, u = void 0) {
      const l = this.connectImpl();
      try {
        const p = new t.Deferred();
        this.privRequestSession.onSpeechContext(), await l;
        const d = await this.fetchConnection();
        return this.privDeferralMap.add(this.privRequestSession.requestId, p), await this.sendBaseRequest(d, n, this.scenarioFrom(c), u), this.receiveMessage(), p.promise;
      } catch (p) {
        throw p;
      }
    }
    async sendBaseRequest(n, c, u, l) {
      const p = {
        scenario: u
      };
      return l ? p.profileIds = [l.profileId] : p.maxPageSize = -1, n.send(new i.SpeechConnectionMessage(t.MessageType.Text, `speaker.profile.${c}`, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(p)));
    }
    extractSpeakerContext(n) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: n.profileIds,
        scenario: n.scenario
      };
    }
    handlePhrasesResponse(n, c) {
      if (this.privDeferralMap.getId(c))
        if (n.status.statusCode.toLowerCase() !== "success") {
          const u = r.ResultReason.Canceled, l = new r.VoiceProfilePhraseResult(u, n.status.statusCode, n.passPhraseType, []);
          this.privDeferralMap.complete(c, l);
        } else if (n.phrases && n.phrases.length > 0) {
          const u = r.ResultReason.EnrollingVoiceProfile, l = new r.VoiceProfilePhraseResult(u, n.status.statusCode, n.passPhraseType, n.phrases);
          this.privDeferralMap.complete(c, l);
        } else
          throw new Error("Voice Profile get activation phrases failed, no phrases received");
      else
        throw new Error(`Voice Profile get activation phrases request for requestID ${c} not found`);
    }
    handleCreateResponse(n, c) {
      if (n.profiles && n.profiles.length > 0)
        if (this.privDeferralMap.getId(c)) {
          const u = n.profiles.map((l) => l.profileId);
          this.privDeferralMap.complete(c, u);
        } else
          throw new Error(`Voice Profile create request for requestID ${c} not found`);
      else
        throw new Error("Voice Profile create failed, no profile id received");
    }
    handleResultResponse(n, c) {
      if (this.privDeferralMap.getId(c)) {
        const u = n.operation.toLowerCase() === "delete" ? r.ResultReason.DeletedVoiceProfile : r.ResultReason.ResetVoiceProfile, l = n.status.statusCode.toLowerCase() === "success" ? u : r.ResultReason.Canceled, p = new r.VoiceProfileResult(l, `statusCode: ${n.status.statusCode}, errorDetails: ${n.status.reason}`);
        this.privDeferralMap.complete(c, p);
      } else
        throw new Error(`Voice Profile create request for requestID ${c} not found`);
    }
    handleFetchResponse(n, c) {
      if (this.privDeferralMap.getId(c) && n.profiles[0]) {
        if (this.privExpectedProfileId && n.profiles.length === 1 && n.profiles[0].profileId === this.privExpectedProfileId) {
          this.privExpectedProfileId = void 0;
          const u = n.profiles[0], l = new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(u.enrollmentStatus), JSON.stringify(u), n.status.reason);
          this.privDeferralMap.complete(c, l);
        } else if (n.profiles.length > 0) {
          const u = n.profiles, l = [];
          for (const p of u)
            l.push(new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(p.enrollmentStatus), JSON.stringify(p), n.status.reason));
          this.privDeferralMap.complete(c, l);
        }
      } else
        throw new Error(`Voice Profile fetch request for requestID ${c} not found`);
    }
    enrollmentReasonFrom(n) {
      switch (n.toLowerCase()) {
        case "enrolled":
          return r.ResultReason.EnrolledVoiceProfile;
        case "invalidlocale":
        case "invalidphrase":
        case "invalidaudioformat":
        case "invalidscenario":
        case "invalidprofilecount":
        case "invalidoperation":
        case "audiotooshort":
        case "audiotoolong":
        case "toomanyenrollments":
        case "storageconflict":
        case "profilenotfound":
        case "incompatibleprofiles":
        case "incompleteenrollment":
          return r.ResultReason.Canceled;
        default:
          return r.ResultReason.EnrollingVoiceProfile;
      }
    }
    scenarioFrom(n) {
      return n === r.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : n === r.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    }
  };
  return as.VoiceServiceRecognizer = a, as;
}
var xa = {}, Bh;
function hw() {
  return Bh || (Bh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.type = e.connectivity = e.Device = e.OS = e.System = e.Context = e.SpeechServiceConfig = void 0;
    class t {
      constructor(n) {
        this.context = n;
      }
      serialize() {
        return JSON.stringify(this, (n, c) => {
          if (c && typeof c == "object" && !Array.isArray(c)) {
            const u = {};
            for (const l in c)
              Object.hasOwnProperty.call(c, l) && (u[l && l.charAt(0).toLowerCase() + l.substring(1)] = c[l]);
            return u;
          }
          return c;
        });
      }
      get Context() {
        return this.context;
      }
      get Recognition() {
        return this.recognition;
      }
      set Recognition(n) {
        this.recognition = n.toLowerCase();
      }
    }
    e.SpeechServiceConfig = t;
    class r {
      constructor(n) {
        this.system = new o(), this.os = n;
      }
    }
    e.Context = r;
    class o {
      constructor() {
        const n = "1.44.1";
        this.name = "SpeechSDK", this.version = n, this.build = "JavaScript", this.lang = "JavaScript";
      }
    }
    e.System = o;
    class i {
      constructor(n, c, u) {
        this.platform = n, this.name = c, this.version = u;
      }
    }
    e.OS = i;
    class a {
      constructor(n, c, u) {
        this.manufacturer = n, this.model = c, this.version = u;
      }
    }
    e.Device = a, function(s) {
      s.Bluetooth = "Bluetooth", s.Wired = "Wired", s.WiFi = "WiFi", s.Cellular = "Cellular", s.InBuilt = "InBuilt", s.Unknown = "Unknown";
    }(e.connectivity || (e.connectivity = {})), function(s) {
      s.Phone = "Phone", s.Speaker = "Speaker", s.Car = "Car", s.Headset = "Headset", s.Thermostat = "Thermostat", s.Microphones = "Microphones", s.Deskphone = "Deskphone", s.RemoteControl = "RemoteControl", s.Unknown = "Unknown", s.File = "File", s.Stream = "Stream";
    }(e.type || (e.type = {}));
  }(xa)), xa;
}
var Uh;
function _() {
  return Uh || (Uh = 1, function(e) {
    var t = pt && pt.__createBinding || (Object.create ? function(a, s, n, c) {
      c === void 0 && (c = n), Object.defineProperty(a, c, { enumerable: !0, get: function() {
        return s[n];
      } });
    } : function(a, s, n, c) {
      c === void 0 && (c = n), a[c] = s[n];
    }), r = pt && pt.__exportStar || function(a, s) {
      for (var n in a) n !== "default" && !Object.prototype.hasOwnProperty.call(s, n) && t(s, a, n);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AutoDetectSourceLanguagesOpenRangeOptionName = e.ForceDictationPropertyName = e.ServicePropertiesPropertyName = e.CancellationErrorCodePropertyName = e.OutputFormatPropertyName = e.SpeechSynthesisAdapter = e.AvatarSynthesisAdapter = void 0, r(/* @__PURE__ */ UC(), e), r(/* @__PURE__ */ $C(), e), r(/* @__PURE__ */ lc(), e), r(/* @__PURE__ */ VC(), e), r(/* @__PURE__ */ WC(), e), r(/* @__PURE__ */ KP(), e), r(/* @__PURE__ */ JP(), e), r(/* @__PURE__ */ vc(), e), r(/* @__PURE__ */ ib(), e), r(/* @__PURE__ */ sb(), e), r(/* @__PURE__ */ ob(), e), r(/* @__PURE__ */ ab(), e), r(/* @__PURE__ */ cb(), e), r(/* @__PURE__ */ ub(), e), r(/* @__PURE__ */ lb(), e), r(/* @__PURE__ */ pb(), e), r(/* @__PURE__ */ db(), e), r(/* @__PURE__ */ qv(), e), r(/* @__PURE__ */ hb(), e), r(/* @__PURE__ */ fb(), e), r(/* @__PURE__ */ vb(), e), r(/* @__PURE__ */ gb(), e), r(/* @__PURE__ */ mb(), e), r(/* @__PURE__ */ yb(), e), r(/* @__PURE__ */ Sb(), e), r(/* @__PURE__ */ Cb(), e), r(/* @__PURE__ */ Rb(), e), r(/* @__PURE__ */ Pb(), e), r(/* @__PURE__ */ wb(), e), r(/* @__PURE__ */ Eb(), e), r(/* @__PURE__ */ Ib(), e), r(/* @__PURE__ */ Ab(), e), r(/* @__PURE__ */ Tb(), e), r(/* @__PURE__ */ _b(), e), r(/* @__PURE__ */ kb(), e), r(/* @__PURE__ */ Ob(), e), r(/* @__PURE__ */ Db(), e), r(/* @__PURE__ */ xb(), e), r(/* @__PURE__ */ Lb(), e), r(/* @__PURE__ */ Ub(), e), r(/* @__PURE__ */ $b(), e), r(/* @__PURE__ */ tw(), e), r(/* @__PURE__ */ eg(), e), r(/* @__PURE__ */ nw(), e), r(/* @__PURE__ */ iw(), e);
    var o = /* @__PURE__ */ sw();
    Object.defineProperty(e, "AvatarSynthesisAdapter", { enumerable: !0, get: function() {
      return o.AvatarSynthesisAdapter;
    } });
    var i = /* @__PURE__ */ ow();
    Object.defineProperty(e, "SpeechSynthesisAdapter", { enumerable: !0, get: function() {
      return i.SpeechSynthesisAdapter;
    } }), r(/* @__PURE__ */ aw(), e), r(/* @__PURE__ */ cw(), e), r(/* @__PURE__ */ uw(), e), r(/* @__PURE__ */ lw(), e), r(/* @__PURE__ */ pw(), e), r(/* @__PURE__ */ dw(), e), r(/* @__PURE__ */ hw(), e), e.OutputFormatPropertyName = "OutputFormat", e.CancellationErrorCodePropertyName = "CancellationErrorCode", e.ServicePropertiesPropertyName = "ServiceProperties", e.ForceDictationPropertyName = "ForceDictation", e.AutoDetectSourceLanguagesOpenRangeOptionName = "UND";
  }(pt)), pt;
}
var $h;
function fw() {
  return $h || ($h = 1, function(e) {
    var t = lt && lt.__createBinding || (Object.create ? function(i, a, s, n) {
      n === void 0 && (n = s), Object.defineProperty(i, n, { enumerable: !0, get: function() {
        return a[s];
      } });
    } : function(i, a, s, n) {
      n === void 0 && (n = s), i[n] = a[s];
    }), r = lt && lt.__exportStar || function(i, a) {
      for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(a, s) && t(a, i, s);
    };
    Object.defineProperty(e, "__esModule", { value: !0 });
    const o = /* @__PURE__ */ _();
    new o.AgentConfig(), r(/* @__PURE__ */ A(), e);
  }(lt)), lt;
}
var cs = /* @__PURE__ */ fw();
const vw = ys.Provider, gw = ys.Root, mw = ys.Trigger, tg = ae.forwardRef(({ className: e, sideOffset: t = 4, ...r }, o) => /* @__PURE__ */ P(
  ys.Content,
  {
    ref: o,
    sideOffset: t,
    className: ps(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      e
    ),
    ...r
  }
));
tg.displayName = ys.Content.displayName;
const yw = {
  en: "en-US",
  es: "es-ES",
  pt: "pt-PT",
  fr: "fr-FR",
  de: "de-DE",
  zh: "zh-CN",
  ja: "ja-JP",
  hi: "hi-IN",
  ar: "ar-SA",
  ru: "ru-RU"
};
function rg({
  avatarName: e,
  disabled: t = !1,
  voiceMode: r,
  setSpokenText: o,
  setIsSpeaking: i,
  setInterruptReplica: a,
  region: s,
  speechKey: n
}) {
  const [c, u] = D(!1), [l, p] = D(!1), [d, h] = D(null), [f, g] = D("en");
  B(() => {
    typeof window < "u" && g(localStorage.getItem("lang") || "en");
  }, []);
  const m = c ? `You're now talking to ${e}` : `Click here to talk to ${e}`;
  B(() => (c ? v() : y(), () => {
    y();
  }), [c]);
  const v = async () => {
    try {
      const C = cs.SpeechConfig.fromSubscription(
        n,
        s
      );
      C.speechRecognitionLanguage = yw[f || "en"];
      const b = cs.AudioConfig.fromDefaultMicrophoneInput(), w = new cs.SpeechRecognizer(C, b);
      w.recognizing = (I, E) => {
        console.log(`RECOGNIZING: Text=${E.result.text}`);
      }, w.recognized = (I, E) => {
        E.result.reason === cs.ResultReason.RecognizedSpeech && (console.log(`RECOGNIZED: Text=${E.result.text}`), E.result.text && (o(E.result.text), u(!1), i(!1), a(!1)));
      }, w.canceled = (I, E) => {
        console.log(`CANCELED: Reason=${E.reason}`), E.reason === cs.CancellationReason.Error && console.error(`ERROR: Details=${E.errorDetails}`), u(!1), i(!1);
      }, w.sessionStopped = () => {
        u(!1), i(!1);
      }, await w.startContinuousRecognitionAsync(), h(w), i(!0), a(!0);
    } catch (C) {
      console.error("Error starting continuous recognition:", C), u(!1), i(!1);
    }
  }, y = async () => {
    if (d)
      try {
        await d.stopContinuousRecognitionAsync(), d.close(), h(null);
      } catch (C) {
        console.error("Error stopping recognition:", C);
      }
  }, S = () => {
    t || l || u(!c);
  };
  return r ? /* @__PURE__ */ P(vw, { children: /* @__PURE__ */ k(gw, { children: [
    /* @__PURE__ */ P(mw, { asChild: !0, children: /* @__PURE__ */ P(
      ke,
      {
        variant: "outline",
        size: "icon",
        onClick: S,
        disabled: t || l || !1,
        className: "rounded-full bg-primary hover:bg-secondary h-9 w-9",
        children: l ? /* @__PURE__ */ P(ja, { className: "w-6 h-6 text-white animate-spin" }) : c ? /* @__PURE__ */ P(Ig, { className: "w-6 h-6 text-white" }) : /* @__PURE__ */ P(Ag, { className: "w-6 h-6 text-white" })
      }
    ) }),
    /* @__PURE__ */ P(tg, { children: /* @__PURE__ */ P("p", { children: m }) })
  ] }) }) : null;
}
const Vh = async (e, t = "", r = "", o = "chat", i = "", a = 0, s = 1, n = "en", c) => {
  for (let u = 0; u < s; u++) {
    const l = new Headers();
    l.append("Accept", "application/json");
    const p = e + "Language: " + n, d = "52533633434137384342", h = new FormData();
    h.append("Input", p), h.append("UserId", t || d), h.append("BusinessId", r), h.append("Intent", o), h.append("SessionId", i), h.append("Platform", "EF0306CD"), c && c.size > 0 ? (h.append("Files", c), console.log("File appended to FormData")) : console.log("No file to append");
    const f = new AbortController(), g = setTimeout(() => f.abort(), 9e4), m = {
      method: "POST",
      headers: l,
      body: h,
      signal: f.signal
      // Add the abort signal to the request
    };
    try {
      const y = await fetch(
        "https://developmentapis.azure-api.net/sandbox/v1/api/AI/assistant",
        m
      );
      if (clearTimeout(g), !y.ok) {
        const C = await y.json();
        throw new Error(
          C?.Message || `HTTP error! Status: ${y.status}`
        );
      }
      const S = await y.json();
      if (S.Success && (S.Data?.Message === null || S.Data?.Message.toUpperCase() === "INVALID JSON" || S.Data?.Message === "local variable 'result' referenced before assignment" || S.Data?.Message === "Object reference not set to an instance of an object." || S.Data?.Message?.toLowerCase().includes("exception thrown"))) {
        console.warn(
          `Attempt ${u + 1}: Success but received null data. Retrying...`
        ), a > 0 && await new Promise((C) => setTimeout(C, a));
        continue;
      }
      return S;
    } catch (v) {
      if (clearTimeout(g), v instanceof Error && v.name === "AbortError")
        return console.error("Request timed out after 90 seconds"), { Success: !1, Message: "ERROR: API timed out", Data: null };
      console.error("Error in chat API:", v);
    }
  }
  return {
    Success: !1,
    Message: "API call failed after all retries",
    Data: null
  };
}, Sw = () => "https://developmentapis.azure-api.net/sandbox/v1/api", mc = (e) => {
  const t = Sw().replace(/\/$/, "");
  let r = e.startsWith("/") ? e : `/${e}`;
  return t.endsWith("/api") && r.startsWith("/api/") && (r = r.replace(/^\/api/, "")), `${t}${r}`;
}, Cw = async (e, t, r, o) => {
  const a = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
      // Indicate JSON payload
    },
    body: JSON.stringify({
      Input: e,
      UserId: t,
      BusinessId: r,
      Accepted: o
    })
    // Convert the payload to a JSON string
  };
  let s;
  try {
    const n = await fetch(
      mc("/api/AI/training"),
      a
    );
    if (!n.ok) {
      const c = await n.text();
      throw console.error("Error details:", c), new Error(`Failed: ${n.statusText} - ${c}`);
    }
    if (n.headers.get("content-length") === "0")
      s = {};
    else {
      const c = n.headers.get("content-type");
      c && c.includes("application/json") ? s = await n.json() : console.error("Unexpected response format:", c);
    }
  } catch (n) {
    console.error("Saving chat error:", n);
  }
  return s;
}, Rw = ({
  onStart: e,
  loading: t,
  buttonText: r = "Start Conversation",
  videoRef: o,
  platform: i,
  replicaId: a,
  containerClassName: s = "",
  imageHeight: n = "auto",
  buttonSize: c = "md",
  learningPrompts: u,
  onPromptClick: l,
  userCredits: p,
  avatars: d,
  personaName: h,
  config: f
}) => {
  const [g, m] = D("en");
  B(() => {
    typeof window < "u" && m(localStorage.getItem("lang") || "en");
  }, []);
  const [v, y] = D({ loading: "Loading...", avatarNotFound: "Avatar not found" }), S = d.find((b) => b.ExternalId === a), C = {
    sm: "text-sm px-4 py-2",
    md: "text-base px-6 py-3",
    lg: "text-lg px-8 py-4"
  };
  return B(() => {
    (async () => {
      if (g !== "en") {
        const [w, I] = await Qs(["Loading...", "Avatar not found"], g, "en", f?.azureTranslatorKey || "", f?.azureTranslatorEndpoint || "", f?.azureTranslatorRegion || "");
        y({ loading: w, avatarNotFound: I });
      } else
        y({ loading: "Loading...", avatarNotFound: "Avatar not found" });
    })();
  }, [g]), /* @__PURE__ */ k("div", { className: `flex flex-col items-center justify-center ${s}`, children: [
    /* @__PURE__ */ P("div", { className: `w-full ${n} max-h-[300px] mb-6 relative`, children: S ? /* @__PURE__ */ k(zs, { children: [
      /* @__PURE__ */ P(
        "img",
        {
          ref: o,
          src: S.ImageUrl,
          alt: S.Name,
          className: "w-full h-full object-cover rounded-lg"
        }
      ),
      /* @__PURE__ */ k("div", { className: "absolute top-3 right-3 flex items-center bg-black/70 px-2 py-1 rounded-full text-white text-xs font-medium shadow-md", children: [
        /* @__PURE__ */ k("div", { className: "relative flex h-3 w-3 mr-1.5", children: [
          /* @__PURE__ */ P("span", { className: "animate-ping absolute inline-flex h-full w-full rounded-full bg-green-500 opacity-75" }),
          /* @__PURE__ */ P("span", { className: "relative inline-flex rounded-full h-3 w-3 bg-green-600" })
        ] }),
        /* @__PURE__ */ P("span", { children: "LIVE" })
      ] }),
      /* @__PURE__ */ k("div", { className: "absolute bottom-3 left-3 right-3 bg-gradient-to-t from-black/70 to-transparent p-3 rounded-b-lg", children: [
        /* @__PURE__ */ P("h3", { className: "text-white font-semibold text-sm", children: S.Name }),
        /* @__PURE__ */ P("p", { className: "text-white/80 text-xs", children: h })
      ] })
    ] }) : /* @__PURE__ */ P("div", { className: "w-full h-full bg-light rounded-lg flex items-center justify-center", children: /* @__PURE__ */ P("p", { className: "text-secondary", children: v.avatarNotFound }) }) }),
    /* @__PURE__ */ P(
      "button",
      {
        onClick: e,
        disabled: t || p !== void 0 && p <= 0,
        className: `bg-primary text-white rounded-full font-semibold hover:bg-secondary transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${C[c]}`,
        children: t ? v.loading : r
      }
    ),
    u && u.length > 0 && /* @__PURE__ */ k("div", { className: "mt-6 w-full", children: [
      /* @__PURE__ */ P("h3", { className: "text-lg font-semibold mb-3", children: "Try asking about:" }),
      /* @__PURE__ */ P("div", { className: "space-y-2", children: u.map((b, w) => /* @__PURE__ */ P(
        "button",
        {
          onClick: () => l?.(b),
          className: "w-full text-left p-3 bg-gray-50 hover:bg-gray-100 rounded-lg transition-colors",
          children: b
        },
        w
      )) })
    ] })
  ] });
}, ng = ({ id: e, style: t = {} }) => {
  const r = gf(e), o = r?.isOff, [i, a] = D(!1), s = Ve(null);
  return B(() => {
    const n = s.current;
    if (!n) return;
    const c = () => a(!0);
    return n.addEventListener("canplay", c), () => {
      n.removeEventListener("canplay", c);
    };
  }, [r]), /* @__PURE__ */ k(
    "div",
    {
      className: `w-full rounded-lg overflow-hidden bg-slate-100 relative transition-all duration-300 mx-auto\r
                    h-[200px] sm:h-[250px] md:h-[350px] lg:h-[450px] xl:h-[500px]`,
      style: t,
      children: [
        e && /* @__PURE__ */ P(
          zg,
          {
            automirror: !0,
            sessionId: e,
            type: "video",
            ref: s,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              display: o || !i ? "none" : "block"
            }
          }
        ),
        !i && !o && /* @__PURE__ */ P("div", { className: "absolute top-0 left-0 w-full h-full flex items-center justify-center bg-slate-100 z-10", children: /* @__PURE__ */ k(
          "svg",
          {
            className: "animate-spin h-8 w-8 text-blue-500",
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ P(
                "circle",
                {
                  className: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ P(
                "path",
                {
                  className: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                }
              )
            ]
          }
        ) }),
        o && /* @__PURE__ */ P("div", { className: "absolute top-0 left-0 w-full h-full flex items-center justify-center bg-slate-100 z-5", children: /* @__PURE__ */ P(
          "svg",
          {
            className: "h-1/2 w-auto",
            width: "24px",
            height: "24px",
            viewBox: "0 0 24 24",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg",
            children: /* @__PURE__ */ k("g", { stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: [
              /* @__PURE__ */ P(
                "path",
                {
                  d: "M18.571,4 C19.142,4 19.557,4.23 19.815,4.689 C20.073,5.148 20.073,5.622 19.815,6.111 L16,12 L19.815,17.889 C20.073,18.377 20.073,18.852 19.815,19.311 C19.557,19.77 19.142,20 18.571,20 L5.429,20 C4.857,20 4.443,19.77 4.185,19.311 C3.927,18.852 3.927,18.377 4.185,17.889 L8,12 L4.185,6.111 C3.927,5.622 3.927,5.148 4.185,4.689 C4.443,4.23 4.857,4 5.429,4 L18.571,4 Z",
                  fill: "#555555"
                }
              ),
              /* @__PURE__ */ P(
                "line",
                {
                  x1: "4",
                  y1: "4",
                  x2: "20",
                  y2: "20",
                  stroke: "#E92A09",
                  strokeWidth: "2.5",
                  strokeLinecap: "round"
                }
              )
            ] })
          }
        ) })
      ]
    }
  );
}, Pw = ({
  handleJoin: e,
  handleEnd: t,
  platform: r,
  setScreen: o,
  containerClassName: i = "",
  videoDimensions: a = { width: "100%", height: "auto" },
  buttonsSize: s = "md"
}) => {
  const n = mf(), c = Ws();
  B(() => {
    (async () => {
      if (c) {
        const p = c?.meetingState();
        if (p === "new" || p === "loading")
          try {
            c.startCamera({ startVideoOff: !0, startAudioOff: !0 }), o("call");
          } catch (d) {
            console.warn("Failed to start camera:", d);
          }
        else
          console.log("Call already started, skipping startCamera()");
      }
    })();
  }, [c, n]);
  const u = {
    sm: "px-3 py-1.5 text-xs",
    md: "px-4 py-2 text-sm",
    lg: "px-6 py-3 text-base"
  };
  return /* @__PURE__ */ k(
    vf.div,
    {
      className: `flex flex-col items-center ${i}`,
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      transition: { duration: 0.3 },
      children: [
        /* @__PURE__ */ k("div", { className: "mb-4 flex flex-col items-center justify-center gap-4 text-center w-full max-w-2xl mx-auto mt-4 px-2", children: [
          /* @__PURE__ */ P("h2", { className: "text-xl font-bold text-secondary mb-1", children: "Check your camera and microphone" }),
          /* @__PURE__ */ P("p", { className: "text-sm text-secondary", children: "Make sure your devices are working properly before joining" })
        ] }),
        /* @__PURE__ */ P("div", { className: "w-full max-w-lg mb-6 rounded-lg border border-gray-300 overflow-hidden bg-gray-100", children: /* @__PURE__ */ P("div", { className: "p-8 flex items-center justify-center bg-gradient-to-b from-gray-800 to-primary/60 text-white", children: /* @__PURE__ */ k("div", { className: "text-center", children: [
          /* @__PURE__ */ P("div", { className: "mx-auto h-24 w-24 rounded-full bg-black/80 flex items-center justify-center mb-4", children: /* @__PURE__ */ k(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "32",
              height: "32",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ P("path", { d: "M23 7l-7 5 7 5V7z" }),
                /* @__PURE__ */ P("rect", { x: "1", y: "5", width: "15", height: "14", rx: "2", ry: "2" })
              ]
            }
          ) }),
          /* @__PURE__ */ P(
            "div",
            {
              className: "relative rounded-xl border-4 border-primary overflow-hidden shadow-lg",
              style: {
                width: a.width || "100%",
                height: a.height || "auto"
              },
              children: /* @__PURE__ */ P(ng, { id: n })
            }
          )
        ] }) }) }),
        /* @__PURE__ */ k("div", { className: `flex flex-wrap gap-4 mt-2 justify-center ${s === "sm" ? "scale-90" : s === "lg" ? "scale-110" : ""}`, children: [
          /* @__PURE__ */ k("div", { className: "flex items-center gap-2 px-3 py-2 bg-black/5 rounded-md", children: [
            /* @__PURE__ */ k(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "18",
                height: "18",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ P("path", { d: "M23 7l-7 5 7 5V7z" }),
                  /* @__PURE__ */ P("rect", { x: "1", y: "5", width: "15", height: "14", rx: "2", ry: "2" })
                ]
              }
            ),
            /* @__PURE__ */ P("span", { className: "text-sm", children: "Camera: Ready" })
          ] }),
          /* @__PURE__ */ k("div", { className: "flex items-center gap-2 px-3 py-2 bg-black/5 rounded-md", children: [
            /* @__PURE__ */ k(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "18",
                height: "18",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ P("path", { d: "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" }),
                  /* @__PURE__ */ P("path", { d: "M19 10v2a7 7 0 0 1-14 0v-2" }),
                  /* @__PURE__ */ P("line", { x1: "12", y1: "19", x2: "12", y2: "23" }),
                  /* @__PURE__ */ P("line", { x1: "8", y1: "23", x2: "16", y2: "23" })
                ]
              }
            ),
            /* @__PURE__ */ P("span", { className: "text-sm", children: "Microphone: Ready" })
          ] })
        ] }),
        /* @__PURE__ */ k("div", { className: "flex gap-4 mt-6", children: [
          /* @__PURE__ */ P(
            "button",
            {
              onClick: t,
              className: `border border-primary text-primary rounded-md hover:bg-secondary transition ${u[s]}`,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ P(
            "button",
            {
              onClick: e,
              className: `bg-primary hover:bg-secondary text-white rounded-md transition ${u[s]}`,
              children: "Join Conversation"
            }
          )
        ] })
      ]
    }
  );
}, bw = ({
  actionLabel: e,
  onAction: t,
  cancelLabel: r,
  onCancel: o,
  chatLabel: i,
  onChat: a,
  chatVisible: s = !1,
  platform: n,
  setInterruptReplica: c,
  setIsSpeaking: u,
  setSpokenText: l,
  region: p,
  speechKey: d
}) => {
  Ws();
  const { currentCam: h, currentMic: f, refreshDevices: g } = Lg(), m = mf(), v = gf(m), y = jg(m);
  v.isOff, y.isOff;
  const [S, C] = D(!1);
  return B(() => {
    (() => {
      document.querySelectorAll("[data-replit-metadata]").forEach((I) => {
        I.hasAttribute("data-replit-metadata") && I.removeAttribute("data-replit-metadata");
      });
    })();
  }, []), qg(
    "camera-error",
    nc(() => {
      C(!0);
    }, [])
  ), /* @__PURE__ */ k("div", { className: "mt-2 p-2 rounded-lg max-w-md flex gap-4 justify-around items-center mx-auto bg-primary", children: [
    /* @__PURE__ */ P("div", { className: "flex items-center", children: /* @__PURE__ */ P(
      rg,
      {
        avatarName: n === "university" ? "Instructor" : n === "pr" ? "PR Strategist" : n === "business_advisor" ? "Medical Advisor" : n === "survey" ? "AI Surveyor" : n === "concierge" ? "Concierge" : "Business Expert",
        disabled: !1,
        voiceMode: !0,
        setSpokenText: l,
        setIsSpeaking: u,
        setInterruptReplica: c,
        region: p,
        speechKey: d
      }
    ) }),
    e && e === "End Conversation" && /* @__PURE__ */ P(
      "button",
      {
        onClick: t,
        disabled: S || (!h || !f) && n !== "home" && n !== "university" && n !== "concierge" && n !== "pr" && n !== "business_advisor" && n !== "survey",
        className: "flex items-center justify-center p-1 rounded-full border border-white text-white w-10 h-10",
        children: /* @__PURE__ */ P(Vg, { className: "w-6 h-6" })
      }
    )
  ] });
}, ww = ({
  conversationId: e,
  platform: t,
  videoMode: r,
  endConv: o,
  onAction: i,
  videoHeight: a = "auto",
  aspectRatio: s = "16:9",
  setInterruptReplica: n,
  currentScript: c,
  interruptReplica: u,
  personaName: l,
  config: p
}) => {
  const d = Ws(), h = Fg({ filter: "remote" }), [f, g] = D("full"), [m, v] = D([]), [y, S] = D(!1), [C, b] = D("en");
  B(() => {
    typeof window < "u" && b(localStorage.getItem("lang") || "en");
  }, []);
  const w = Bg({
    onAppMessage: nc((T) => {
      const L = T.data;
      v((U) => [...U, L]);
    }, [])
  }), [I, E] = D({ waiting: `${l} will be here shortly...`, endConversation: "Ending Conversation..." });
  B(() => {
    (async () => {
      if (C !== "en") {
        const [L, U] = await Qs([`${l} will be here shortly...`, "Ending Conversation..."], C, "en", p?.azureTranslatorKey || "", p?.azureTranslatorEndpoint || "", p?.azureTranslatorRegion || "");
        E({ waiting: L, endConversation: U });
      } else
        E({ waiting: `${l} will be here shortly...`, endConversation: "Ending Conversation..." });
    })();
  }, [C]);
  const N = (T) => T ? T.replace(/\*\*/g, "").replace(/[#_][^\s]+/g, "").replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "").replace(/[^\w\s.,!?'"-]/g, "").replace(/\s+/g, " ").trim() : "";
  B(() => {
    const T = () => S(!0);
    return d && d.on("joined-meeting", T), () => {
      d && d.off("joined-meeting", T);
    };
  }, [d]), B(() => {
    try {
      if (d && y && c) {
        n(!1);
        const T = N(c);
        R(T);
      }
    } catch (T) {
      console.error("Error sending echo interaction:", T);
    }
  }, [c, y]), B(() => {
    d && y && u && M();
  }, [u]), B(() => {
    r && g(r);
  }, [r]);
  const R = (T) => {
    const L = {
      message_type: "conversation",
      event_type: "conversation.echo",
      conversation_id: e,
      properties: {
        modality: "text",
        text: `${T}`
      }
    };
    console.log("Sending Echo Interaction:", L), w(L, "*");
  }, M = () => {
    const T = {
      message_type: "conversation",
      event_type: "conversation.interrupt",
      conversation_id: e
    };
    console.log("Sending Echo Interaction:", T), w(T, "*");
  };
  return /* @__PURE__ */ k(zs, { children: [
    /* @__PURE__ */ P("div", { className: "flex flex-col items-center justify-center gap-4 text-center mx-auto px-2 h-full overflow-hidden", children: /* @__PURE__ */ P("div", { className: "relative w-full h-full rounded-xl border-4 border-neutral overflow-hidden shadow-lg", children: h.length > 0 ? /* @__PURE__ */ P(
      "div",
      {
        className: "relative w-full h-full",
        style: {
          backgroundColor: "#000",
          position: "relative",
          overflow: "hidden"
          // To contain absolutely positioned elements
        },
        children: /* @__PURE__ */ P(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              // Add flex to center content if needed
              justifyContent: "center",
              // Center content horizontally
              alignItems: "center"
              // Center content vertically
            },
            children: /* @__PURE__ */ P(
              ng,
              {
                id: h[0],
                style: {
                  borderRadius: "0px",
                  objectFit: "contain",
                  width: "100%",
                  height: "100%",
                  backgroundColor: "#000"
                }
              }
            )
          }
        )
      }
    ) : /* @__PURE__ */ P(
      "div",
      {
        className: "relative flex justify-center items-center w-full h-full",
        style: {
          backgroundColor: "#000",
          width: "100%",
          height: "100%",
          position: "relative"
        },
        children: /* @__PURE__ */ P("div", { className: "absolute inset-0 flex justify-center items-center", children: /* @__PURE__ */ P("h2", { className: "text-white text-xl text-center px-4", children: o ? I.endConversation : I.waiting }) })
      }
    ) }) }),
    /* @__PURE__ */ P(Ug, {})
  ] });
}, Ew = ({
  conversation: e,
  handleEnd: t,
  platform: r,
  videoMode: o,
  endConv: i,
  chatVisible: a,
  toggleChat: s,
  containerClassName: n = "",
  videoHeight: c = "auto",
  controlsSize: u = "md",
  aspectRatio: l = "16:9",
  setInterruptReplica: p,
  currentScript: d,
  setCurrentScript: h,
  interruptReplica: f,
  setIsSpeaking: g,
  setSpokenText: m,
  region: v,
  speechKey: y,
  personaName: S,
  config: C
}) => {
  const b = Ws();
  B(() => {
    (() => {
      document.querySelectorAll("[data-replit-metadata]").forEach((T) => {
        T.hasAttribute("data-replit-metadata") && T.removeAttribute("data-replit-metadata");
      });
    })();
  }, []), B(() => {
    if (e && b) {
      const { conversation_url: R } = e;
      b.join({
        url: R
      });
    }
  }, [b, e]);
  const w = async () => {
    await b?.leave(), t();
  }, I = {
    sm: "scale-75",
    md: "",
    lg: "scale-125"
  }, E = "bottom-4", N = () => c === "auto" ? "min-h-[360px]" : c;
  return /* @__PURE__ */ P("div", { className: `flex flex-col w-full h-full relative ${n}`, children: /* @__PURE__ */ k("div", { className: "flex-1 w-full h-full relative overflow-hidden", children: [
    /* @__PURE__ */ P(
      ww,
      {
        conversationId: e.conversation_id,
        platform: r,
        videoMode: o,
        endConv: i,
        onAction: w,
        videoHeight: N(),
        aspectRatio: l,
        setInterruptReplica: p,
        currentScript: d,
        interruptReplica: f,
        config: C,
        personaName: S
      }
    ),
    /* @__PURE__ */ P("div", { className: `absolute ${E} left-0 right-0 z-10 flex justify-center ${I[u]}`, children: /* @__PURE__ */ P(
      bw,
      {
        actionLabel: "End Conversation",
        onAction: w,
        platform: r,
        chatLabel: "Open Chat",
        onChat: s,
        chatVisible: a,
        setInterruptReplica: p,
        setIsSpeaking: g,
        setSpokenText: m,
        region: v,
        speechKey: y
      }
    ) })
  ] }) });
}, Iw = async ({
  replicaId: e,
  personaId: t,
  conversationName: r,
  conversationalContext: o,
  customGreeting: i,
  language: a,
  apiKey: s
}) => {
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": s
    },
    body: JSON.stringify({
      replica_id: e,
      persona_id: t,
      conversation_name: r,
      conversational_context: o,
      custom_greeting: i,
      properties: {
        enable_recording: !1,
        participant_absent_timeout: 180,
        language: a
      }
    })
  };
  try {
    const c = await fetch(
      "https://tavusapi.com/v2/conversations",
      n
    );
    if (!c.ok) {
      const l = c.headers.get("content-type");
      let p;
      throw l && l.includes("application/json") ? p = await c.json() : p = { message: await c.text() }, new Error(
        p?.message || `HTTP error! Status: ${c.status}`
      );
    }
    return await c.json();
  } catch (c) {
    throw console.error("Error creating Tavus conversation:", c), c;
  }
}, Wh = async ({
  conversationId: e,
  apiKey: t
}) => {
  const r = {
    method: "POST",
    headers: {
      "x-api-key": t
    }
  };
  try {
    await fetch(
      `https://tavusapi.com/v2/conversations/${e}/end`,
      r
    );
  } catch {
  }
}, ig = async () => {
  const e = new Headers();
  e.append("Accept", "application/json");
  const t = {
    method: "GET",
    headers: e,
    redirect: "follow"
  };
  let r;
  try {
    const o = await fetch(mc("/api/Avatar/get/all"), t);
    if (!o.ok)
      throw new Error(`HTTP error! status: ${o.status}`);
    r = o.headers.get("content-length") === "0" ? { Success: !0, Data: [] } : await o.json();
  } catch (o) {
    console.error("Error fetching avatars:", o);
  }
  return r;
}, x = (e) => typeof e == "string", us = () => {
  let e, t;
  const r = new Promise((o, i) => {
    e = o, t = i;
  });
  return r.resolve = e, r.reject = t, r;
}, Hh = (e) => e == null ? "" : "" + e, Aw = (e, t, r) => {
  e.forEach((o) => {
    t[o] && (r[o] = t[o]);
  });
}, Tw = /###/g, Kh = (e) => e && e.indexOf("###") > -1 ? e.replace(Tw, ".") : e, Jh = (e) => !e || x(e), ds = (e, t, r) => {
  const o = x(t) ? t.split(".") : t;
  let i = 0;
  for (; i < o.length - 1; ) {
    if (Jh(e)) return {};
    const a = Kh(o[i]);
    !e[a] && r && (e[a] = new r()), Object.prototype.hasOwnProperty.call(e, a) ? e = e[a] : e = {}, ++i;
  }
  return Jh(e) ? {} : {
    obj: e,
    k: Kh(o[i])
  };
}, Gh = (e, t, r) => {
  const {
    obj: o,
    k: i
  } = ds(e, t, Object);
  if (o !== void 0 || t.length === 1) {
    o[i] = r;
    return;
  }
  let a = t[t.length - 1], s = t.slice(0, t.length - 1), n = ds(e, s, Object);
  for (; n.obj === void 0 && s.length; )
    a = `${s[s.length - 1]}.${a}`, s = s.slice(0, s.length - 1), n = ds(e, s, Object), n?.obj && typeof n.obj[`${n.k}.${a}`] < "u" && (n.obj = void 0);
  n.obj[`${n.k}.${a}`] = r;
}, _w = (e, t, r, o) => {
  const {
    obj: i,
    k: a
  } = ds(e, t, Object);
  i[a] = i[a] || [], i[a].push(r);
}, qs = (e, t) => {
  const {
    obj: r,
    k: o
  } = ds(e, t);
  if (r && Object.prototype.hasOwnProperty.call(r, o))
    return r[o];
}, kw = (e, t, r) => {
  const o = qs(e, r);
  return o !== void 0 ? o : qs(t, r);
}, sg = (e, t, r) => {
  for (const o in t)
    o !== "__proto__" && o !== "constructor" && (o in e ? x(e[o]) || e[o] instanceof String || x(t[o]) || t[o] instanceof String ? r && (e[o] = t[o]) : sg(e[o], t[o], r) : e[o] = t[o]);
  return e;
}, Bt = (e) => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var Ow = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const Mw = (e) => x(e) ? e.replace(/[&<>"'\/]/g, (t) => Ow[t]) : e;
class Dw {
  constructor(t) {
    this.capacity = t, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(t) {
    const r = this.regExpMap.get(t);
    if (r !== void 0)
      return r;
    const o = new RegExp(t);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, o), this.regExpQueue.push(t), o;
  }
}
const Nw = [" ", ",", "?", "!", ";"], xw = new Dw(20), zw = (e, t, r) => {
  t = t || "", r = r || "";
  const o = Nw.filter((s) => t.indexOf(s) < 0 && r.indexOf(s) < 0);
  if (o.length === 0) return !0;
  const i = xw.getRegExp(`(${o.map((s) => s === "?" ? "\\?" : s).join("|")})`);
  let a = !i.test(e);
  if (!a) {
    const s = e.indexOf(r);
    s > 0 && !i.test(e.substring(0, s)) && (a = !0);
  }
  return a;
}, Xa = function(e, t) {
  let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!e) return;
  if (e[t])
    return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0;
  const o = t.split(r);
  let i = e;
  for (let a = 0; a < o.length; ) {
    if (!i || typeof i != "object")
      return;
    let s, n = "";
    for (let c = a; c < o.length; ++c)
      if (c !== a && (n += r), n += o[c], s = i[n], s !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof s) > -1 && c < o.length - 1)
          continue;
        a += c - a + 1;
        break;
      }
    i = s;
  }
  return i;
}, Fs = (e) => e?.replace("_", "-"), Lw = {
  type: "logger",
  log(e) {
    this.output("log", e);
  },
  warn(e) {
    this.output("warn", e);
  },
  error(e) {
    this.output("error", e);
  },
  output(e, t) {
    console?.[e]?.apply?.(console, t);
  }
};
class Bs {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(t, r);
  }
  init(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = r.prefix || "i18next:", this.logger = t || Lw, this.options = r, this.debug = r.debug;
  }
  log() {
    for (var t = arguments.length, r = new Array(t), o = 0; o < t; o++)
      r[o] = arguments[o];
    return this.forward(r, "log", "", !0);
  }
  warn() {
    for (var t = arguments.length, r = new Array(t), o = 0; o < t; o++)
      r[o] = arguments[o];
    return this.forward(r, "warn", "", !0);
  }
  error() {
    for (var t = arguments.length, r = new Array(t), o = 0; o < t; o++)
      r[o] = arguments[o];
    return this.forward(r, "error", "");
  }
  deprecate() {
    for (var t = arguments.length, r = new Array(t), o = 0; o < t; o++)
      r[o] = arguments[o];
    return this.forward(r, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(t, r, o, i) {
    return i && !this.debug ? null : (x(t[0]) && (t[0] = `${o}${this.prefix} ${t[0]}`), this.logger[r](t));
  }
  create(t) {
    return new Bs(this.logger, {
      prefix: `${this.prefix}:${t}:`,
      ...this.options
    });
  }
  clone(t) {
    return t = t || this.options, t.prefix = t.prefix || this.prefix, new Bs(this.logger, t);
  }
}
var Oe = new Bs();
class Xs {
  constructor() {
    this.observers = {};
  }
  on(t, r) {
    return t.split(" ").forEach((o) => {
      this.observers[o] || (this.observers[o] = /* @__PURE__ */ new Map());
      const i = this.observers[o].get(r) || 0;
      this.observers[o].set(r, i + 1);
    }), this;
  }
  off(t, r) {
    if (this.observers[t]) {
      if (!r) {
        delete this.observers[t];
        return;
      }
      this.observers[t].delete(r);
    }
  }
  emit(t) {
    for (var r = arguments.length, o = new Array(r > 1 ? r - 1 : 0), i = 1; i < r; i++)
      o[i - 1] = arguments[i];
    this.observers[t] && Array.from(this.observers[t].entries()).forEach((s) => {
      let [n, c] = s;
      for (let u = 0; u < c; u++)
        n(...o);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach((s) => {
      let [n, c] = s;
      for (let u = 0; u < c; u++)
        n.apply(n, [t, ...o]);
    });
  }
}
class Qh extends Xs {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super(), this.data = t || {}, this.options = r, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(t) {
    this.options.ns.indexOf(t) < 0 && this.options.ns.push(t);
  }
  removeNamespaces(t) {
    const r = this.options.ns.indexOf(t);
    r > -1 && this.options.ns.splice(r, 1);
  }
  getResource(t, r, o) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, s = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let n;
    t.indexOf(".") > -1 ? n = t.split(".") : (n = [t, r], o && (Array.isArray(o) ? n.push(...o) : x(o) && a ? n.push(...o.split(a)) : n.push(o)));
    const c = qs(this.data, n);
    return !c && !r && !o && t.indexOf(".") > -1 && (t = n[0], r = n[1], o = n.slice(2).join(".")), c || !s || !x(o) ? c : Xa(this.data?.[t]?.[r], o, a);
  }
  addResource(t, r, o, i) {
    let a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: !1
    };
    const s = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator;
    let n = [t, r];
    o && (n = n.concat(s ? o.split(s) : o)), t.indexOf(".") > -1 && (n = t.split("."), i = r, r = n[1]), this.addNamespaces(r), Gh(this.data, n, i), a.silent || this.emit("added", t, r, o, i);
  }
  addResources(t, r, o) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: !1
    };
    for (const a in o)
      (x(o[a]) || Array.isArray(o[a])) && this.addResource(t, r, a, o[a], {
        silent: !0
      });
    i.silent || this.emit("added", t, r, o);
  }
  addResourceBundle(t, r, o, i, a) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: !1,
      skipCopy: !1
    }, n = [t, r];
    t.indexOf(".") > -1 && (n = t.split("."), i = o, o = r, r = n[1]), this.addNamespaces(r);
    let c = qs(this.data, n) || {};
    s.skipCopy || (o = JSON.parse(JSON.stringify(o))), i ? sg(c, o, a) : c = {
      ...c,
      ...o
    }, Gh(this.data, n, c), s.silent || this.emit("added", t, r, o);
  }
  removeResourceBundle(t, r) {
    this.hasResourceBundle(t, r) && delete this.data[t][r], this.removeNamespaces(r), this.emit("removed", t, r);
  }
  hasResourceBundle(t, r) {
    return this.getResource(t, r) !== void 0;
  }
  getResourceBundle(t, r) {
    return r || (r = this.options.defaultNS), this.getResource(t, r);
  }
  getDataByLanguage(t) {
    return this.data[t];
  }
  hasLanguageSomeTranslations(t) {
    const r = this.getDataByLanguage(t);
    return !!(r && Object.keys(r) || []).find((i) => r[i] && Object.keys(r[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var og = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e;
  },
  handle(e, t, r, o, i) {
    return e.forEach((a) => {
      t = this.processors[a]?.process(t, r, o, i) ?? t;
    }), t;
  }
};
const Yh = {}, Zh = (e) => !x(e) && typeof e != "boolean" && typeof e != "number";
class Us extends Xs {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), Aw(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = r, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Oe.create("translator");
  }
  changeLanguage(t) {
    t && (this.language = t);
  }
  exists(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    return t == null ? !1 : this.resolve(t, r)?.res !== void 0;
  }
  extractFromKey(t, r) {
    let o = r.nsSeparator !== void 0 ? r.nsSeparator : this.options.nsSeparator;
    o === void 0 && (o = ":");
    const i = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator;
    let a = r.ns || this.options.defaultNS || [];
    const s = o && t.indexOf(o) > -1, n = !this.options.userDefinedKeySeparator && !r.keySeparator && !this.options.userDefinedNsSeparator && !r.nsSeparator && !zw(t, o, i);
    if (s && !n) {
      const c = t.match(this.interpolator.nestingRegexp);
      if (c && c.length > 0)
        return {
          key: t,
          namespaces: x(a) ? [a] : a
        };
      const u = t.split(o);
      (o !== i || o === i && this.options.ns.indexOf(u[0]) > -1) && (a = u.shift()), t = u.join(i);
    }
    return {
      key: t,
      namespaces: x(a) ? [a] : a
    };
  }
  translate(t, r, o) {
    if (typeof r != "object" && this.options.overloadTranslationOptionHandler && (r = this.options.overloadTranslationOptionHandler(arguments)), typeof r == "object" && (r = {
      ...r
    }), r || (r = {}), t == null) return "";
    Array.isArray(t) || (t = [String(t)]);
    const i = r.returnDetails !== void 0 ? r.returnDetails : this.options.returnDetails, a = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator, {
      key: s,
      namespaces: n
    } = this.extractFromKey(t[t.length - 1], r), c = n[n.length - 1], u = r.lng || this.language, l = r.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (u?.toLowerCase() === "cimode") {
      if (l) {
        const M = r.nsSeparator || this.options.nsSeparator;
        return i ? {
          res: `${c}${M}${s}`,
          usedKey: s,
          exactUsedKey: s,
          usedLng: u,
          usedNS: c,
          usedParams: this.getUsedParamsDetails(r)
        } : `${c}${M}${s}`;
      }
      return i ? {
        res: s,
        usedKey: s,
        exactUsedKey: s,
        usedLng: u,
        usedNS: c,
        usedParams: this.getUsedParamsDetails(r)
      } : s;
    }
    const p = this.resolve(t, r);
    let d = p?.res;
    const h = p?.usedKey || s, f = p?.exactUsedKey || s, g = ["[object Number]", "[object Function]", "[object RegExp]"], m = r.joinArrays !== void 0 ? r.joinArrays : this.options.joinArrays, v = !this.i18nFormat || this.i18nFormat.handleAsObject, y = r.count !== void 0 && !x(r.count), S = Us.hasDefaultValue(r), C = y ? this.pluralResolver.getSuffix(u, r.count, r) : "", b = r.ordinal && y ? this.pluralResolver.getSuffix(u, r.count, {
      ordinal: !1
    }) : "", w = y && !r.ordinal && r.count === 0, I = w && r[`defaultValue${this.options.pluralSeparator}zero`] || r[`defaultValue${C}`] || r[`defaultValue${b}`] || r.defaultValue;
    let E = d;
    v && !d && S && (E = I);
    const N = Zh(E), R = Object.prototype.toString.apply(E);
    if (v && E && N && g.indexOf(R) < 0 && !(x(m) && Array.isArray(E))) {
      if (!r.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const M = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(h, E, {
          ...r,
          ns: n
        }) : `key '${s} (${this.language})' returned an object instead of string.`;
        return i ? (p.res = M, p.usedParams = this.getUsedParamsDetails(r), p) : M;
      }
      if (a) {
        const M = Array.isArray(E), T = M ? [] : {}, L = M ? f : h;
        for (const U in E)
          if (Object.prototype.hasOwnProperty.call(E, U)) {
            const Q = `${L}${a}${U}`;
            S && !d ? T[U] = this.translate(Q, {
              ...r,
              defaultValue: Zh(I) ? I[U] : void 0,
              joinArrays: !1,
              ns: n
            }) : T[U] = this.translate(Q, {
              ...r,
              joinArrays: !1,
              ns: n
            }), T[U] === Q && (T[U] = E[U]);
          }
        d = T;
      }
    } else if (v && x(m) && Array.isArray(d))
      d = d.join(m), d && (d = this.extendTranslation(d, t, r, o));
    else {
      let M = !1, T = !1;
      !this.isValidLookup(d) && S && (M = !0, d = I), this.isValidLookup(d) || (T = !0, d = s);
      const U = (r.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && T ? void 0 : d, Q = S && I !== d && this.options.updateMissing;
      if (T || M || Q) {
        if (this.logger.log(Q ? "updateKey" : "missingKey", u, c, s, Q ? I : d), a) {
          const W = this.resolve(s, {
            ...r,
            keySeparator: !1
          });
          W && W.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let ee = [];
        const re = this.languageUtils.getFallbackCodes(this.options.fallbackLng, r.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && re && re[0])
          for (let W = 0; W < re.length; W++)
            ee.push(re[W]);
        else this.options.saveMissingTo === "all" ? ee = this.languageUtils.toResolveHierarchy(r.lng || this.language) : ee.push(r.lng || this.language);
        const he = (W, ie, K) => {
          const Ne = S && K !== d ? K : U;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(W, c, ie, Ne, Q, r) : this.backendConnector?.saveMissing && this.backendConnector.saveMissing(W, c, ie, Ne, Q, r), this.emit("missingKey", W, c, ie, d);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && y ? ee.forEach((W) => {
          const ie = this.pluralResolver.getSuffixes(W, r);
          w && r[`defaultValue${this.options.pluralSeparator}zero`] && ie.indexOf(`${this.options.pluralSeparator}zero`) < 0 && ie.push(`${this.options.pluralSeparator}zero`), ie.forEach((K) => {
            he([W], s + K, r[`defaultValue${K}`] || I);
          });
        }) : he(ee, s, I));
      }
      d = this.extendTranslation(d, t, r, p, o), T && d === s && this.options.appendNamespaceToMissingKey && (d = `${c}:${s}`), (T || M) && this.options.parseMissingKeyHandler && (d = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${c}:${s}` : s, M ? d : void 0));
    }
    return i ? (p.res = d, p.usedParams = this.getUsedParamsDetails(r), p) : d;
  }
  extendTranslation(t, r, o, i, a) {
    var s = this;
    if (this.i18nFormat?.parse)
      t = this.i18nFormat.parse(t, {
        ...this.options.interpolation.defaultVariables,
        ...o
      }, o.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!o.skipInterpolation) {
      o.interpolation && this.interpolator.init({
        ...o,
        interpolation: {
          ...this.options.interpolation,
          ...o.interpolation
        }
      });
      const u = x(t) && (o?.interpolation?.skipOnVariables !== void 0 ? o.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let l;
      if (u) {
        const d = t.match(this.interpolator.nestingRegexp);
        l = d && d.length;
      }
      let p = o.replace && !x(o.replace) ? o.replace : o;
      if (this.options.interpolation.defaultVariables && (p = {
        ...this.options.interpolation.defaultVariables,
        ...p
      }), t = this.interpolator.interpolate(t, p, o.lng || this.language || i.usedLng, o), u) {
        const d = t.match(this.interpolator.nestingRegexp), h = d && d.length;
        l < h && (o.nest = !1);
      }
      !o.lng && i && i.res && (o.lng = this.language || i.usedLng), o.nest !== !1 && (t = this.interpolator.nest(t, function() {
        for (var d = arguments.length, h = new Array(d), f = 0; f < d; f++)
          h[f] = arguments[f];
        return a?.[0] === h[0] && !o.context ? (s.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${r[0]}`), null) : s.translate(...h, r);
      }, o)), o.interpolation && this.interpolator.reset();
    }
    const n = o.postProcess || this.options.postProcess, c = x(n) ? [n] : n;
    return t != null && c?.length && o.applyPostProcessor !== !1 && (t = og.handle(c, t, r, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(o)
      },
      ...o
    } : o, this)), t;
  }
  resolve(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o, i, a, s, n;
    return x(t) && (t = [t]), t.forEach((c) => {
      if (this.isValidLookup(o)) return;
      const u = this.extractFromKey(c, r), l = u.key;
      i = l;
      let p = u.namespaces;
      this.options.fallbackNS && (p = p.concat(this.options.fallbackNS));
      const d = r.count !== void 0 && !x(r.count), h = d && !r.ordinal && r.count === 0, f = r.context !== void 0 && (x(r.context) || typeof r.context == "number") && r.context !== "", g = r.lngs ? r.lngs : this.languageUtils.toResolveHierarchy(r.lng || this.language, r.fallbackLng);
      p.forEach((m) => {
        this.isValidLookup(o) || (n = m, !Yh[`${g[0]}-${m}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(n) && (Yh[`${g[0]}-${m}`] = !0, this.logger.warn(`key "${i}" for languages "${g.join(", ")}" won't get resolved as namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), g.forEach((v) => {
          if (this.isValidLookup(o)) return;
          s = v;
          const y = [l];
          if (this.i18nFormat?.addLookupKeys)
            this.i18nFormat.addLookupKeys(y, l, v, m, r);
          else {
            let C;
            d && (C = this.pluralResolver.getSuffix(v, r.count, r));
            const b = `${this.options.pluralSeparator}zero`, w = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (d && (y.push(l + C), r.ordinal && C.indexOf(w) === 0 && y.push(l + C.replace(w, this.options.pluralSeparator)), h && y.push(l + b)), f) {
              const I = `${l}${this.options.contextSeparator}${r.context}`;
              y.push(I), d && (y.push(I + C), r.ordinal && C.indexOf(w) === 0 && y.push(I + C.replace(w, this.options.pluralSeparator)), h && y.push(I + b));
            }
          }
          let S;
          for (; S = y.pop(); )
            this.isValidLookup(o) || (a = S, o = this.getResource(v, m, S, r));
        }));
      });
    }), {
      res: o,
      usedKey: i,
      exactUsedKey: a,
      usedLng: s,
      usedNS: n
    };
  }
  isValidLookup(t) {
    return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "");
  }
  getResource(t, r, o) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    return this.i18nFormat?.getResource ? this.i18nFormat.getResource(t, r, o, i) : this.resourceStore.getResource(t, r, o, i);
  }
  getUsedParamsDetails() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const r = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], o = t.replace && !x(t.replace);
    let i = o ? t.replace : t;
    if (o && typeof t.count < "u" && (i.count = t.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !o) {
      i = {
        ...i
      };
      for (const a of r)
        delete i[a];
    }
    return i;
  }
  static hasDefaultValue(t) {
    const r = "defaultValue";
    for (const o in t)
      if (Object.prototype.hasOwnProperty.call(t, o) && r === o.substring(0, r.length) && t[o] !== void 0)
        return !0;
    return !1;
  }
}
class Xh {
  constructor(t) {
    this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Oe.create("languageUtils");
  }
  getScriptPartFromCode(t) {
    if (t = Fs(t), !t || t.indexOf("-") < 0) return null;
    const r = t.split("-");
    return r.length === 2 || (r.pop(), r[r.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(r.join("-"));
  }
  getLanguagePartFromCode(t) {
    if (t = Fs(t), !t || t.indexOf("-") < 0) return t;
    const r = t.split("-");
    return this.formatLanguageCode(r[0]);
  }
  formatLanguageCode(t) {
    if (x(t) && t.indexOf("-") > -1) {
      let r;
      try {
        r = Intl.getCanonicalLocales(t)[0];
      } catch {
      }
      return r && this.options.lowerCaseLng && (r = r.toLowerCase()), r || (this.options.lowerCaseLng ? t.toLowerCase() : t);
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
  }
  isSupportedCode(t) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1;
  }
  getBestMatchFromCodes(t) {
    if (!t) return null;
    let r;
    return t.forEach((o) => {
      if (r) return;
      const i = this.formatLanguageCode(o);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (r = i);
    }), !r && this.options.supportedLngs && t.forEach((o) => {
      if (r) return;
      const i = this.getLanguagePartFromCode(o);
      if (this.isSupportedCode(i)) return r = i;
      r = this.options.supportedLngs.find((a) => {
        if (a === i) return a;
        if (!(a.indexOf("-") < 0 && i.indexOf("-") < 0) && (a.indexOf("-") > 0 && i.indexOf("-") < 0 && a.substring(0, a.indexOf("-")) === i || a.indexOf(i) === 0 && i.length > 1))
          return a;
      });
    }), r || (r = this.getFallbackCodes(this.options.fallbackLng)[0]), r;
  }
  getFallbackCodes(t, r) {
    if (!t) return [];
    if (typeof t == "function" && (t = t(r)), x(t) && (t = [t]), Array.isArray(t)) return t;
    if (!r) return t.default || [];
    let o = t[r];
    return o || (o = t[this.getScriptPartFromCode(r)]), o || (o = t[this.formatLanguageCode(r)]), o || (o = t[this.getLanguagePartFromCode(r)]), o || (o = t.default), o || [];
  }
  toResolveHierarchy(t, r) {
    const o = this.getFallbackCodes(r || this.options.fallbackLng || [], t), i = [], a = (s) => {
      s && (this.isSupportedCode(s) ? i.push(s) : this.logger.warn(`rejecting language code not found in supportedLngs: ${s}`));
    };
    return x(t) && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && a(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && a(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && a(this.getLanguagePartFromCode(t))) : x(t) && a(this.formatLanguageCode(t)), o.forEach((s) => {
      i.indexOf(s) < 0 && a(this.formatLanguageCode(s));
    }), i;
  }
}
const ef = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, tf = {
  select: (e) => e === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class jw {
  constructor(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = t, this.options = r, this.logger = Oe.create("pluralResolver"), this.pluralRulesCache = {};
  }
  addRule(t, r) {
    this.rules[t] = r;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const o = Fs(t === "dev" ? "en" : t), i = r.ordinal ? "ordinal" : "cardinal", a = JSON.stringify({
      cleanedCode: o,
      type: i
    });
    if (a in this.pluralRulesCache)
      return this.pluralRulesCache[a];
    let s;
    try {
      s = new Intl.PluralRules(o, {
        type: i
      });
    } catch {
      if (!Intl)
        return this.logger.error("No Intl support, please use an Intl polyfill!"), tf;
      if (!t.match(/-|_/)) return tf;
      const c = this.languageUtils.getLanguagePartFromCode(t);
      s = this.getRule(c, r);
    }
    return this.pluralRulesCache[a] = s, s;
  }
  needsPlural(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = this.getRule(t, r);
    return o || (o = this.getRule("dev", r)), o?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(t, r) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(t, o).map((i) => `${r}${i}`);
  }
  getSuffixes(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, o = this.getRule(t, r);
    return o || (o = this.getRule("dev", r)), o ? o.resolvedOptions().pluralCategories.sort((i, a) => ef[i] - ef[a]).map((i) => `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : [];
  }
  getSuffix(t, r) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const i = this.getRule(t, o);
    return i ? `${this.options.prepend}${o.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(r)}` : (this.logger.warn(`no plural rule found for: ${t}`), this.getSuffix("dev", r, o));
  }
}
const rf = function(e, t, r) {
  let o = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".", i = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : !0, a = kw(e, t, r);
  return !a && i && x(r) && (a = Xa(e, r, o), a === void 0 && (a = Xa(t, r, o))), a;
}, za = (e) => e.replace(/\$/g, "$$$$");
class qw {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Oe.create("interpolator"), this.options = t, this.format = t?.interpolation?.format || ((r) => r), this.init(t);
  }
  init() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    t.interpolation || (t.interpolation = {
      escapeValue: !0
    });
    const {
      escape: r,
      escapeValue: o,
      useRawValueToEscape: i,
      prefix: a,
      prefixEscaped: s,
      suffix: n,
      suffixEscaped: c,
      formatSeparator: u,
      unescapeSuffix: l,
      unescapePrefix: p,
      nestingPrefix: d,
      nestingPrefixEscaped: h,
      nestingSuffix: f,
      nestingSuffixEscaped: g,
      nestingOptionsSeparator: m,
      maxReplaces: v,
      alwaysFormat: y
    } = t.interpolation;
    this.escape = r !== void 0 ? r : Mw, this.escapeValue = o !== void 0 ? o : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = a ? Bt(a) : s || "{{", this.suffix = n ? Bt(n) : c || "}}", this.formatSeparator = u || ",", this.unescapePrefix = l ? "" : p || "-", this.unescapeSuffix = this.unescapePrefix ? "" : l || "", this.nestingPrefix = d ? Bt(d) : h || Bt("$t("), this.nestingSuffix = f ? Bt(f) : g || Bt(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = v || 1e3, this.alwaysFormat = y !== void 0 ? y : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const t = (r, o) => r?.source === o ? (r.lastIndex = 0, r) : new RegExp(o, "g");
    this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(t, r, o, i) {
    let a, s, n;
    const c = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, u = (h) => {
      if (h.indexOf(this.formatSeparator) < 0) {
        const v = rf(r, c, h, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(v, void 0, o, {
          ...i,
          ...r,
          interpolationkey: h
        }) : v;
      }
      const f = h.split(this.formatSeparator), g = f.shift().trim(), m = f.join(this.formatSeparator).trim();
      return this.format(rf(r, c, g, this.options.keySeparator, this.options.ignoreJSONStructure), m, o, {
        ...i,
        ...r,
        interpolationkey: g
      });
    };
    this.resetRegExp();
    const l = i?.missingInterpolationHandler || this.options.missingInterpolationHandler, p = i?.interpolation?.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (h) => za(h)
    }, {
      regex: this.regexp,
      safeValue: (h) => this.escapeValue ? za(this.escape(h)) : za(h)
    }].forEach((h) => {
      for (n = 0; a = h.regex.exec(t); ) {
        const f = a[1].trim();
        if (s = u(f), s === void 0)
          if (typeof l == "function") {
            const m = l(t, a, i);
            s = x(m) ? m : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, f))
            s = "";
          else if (p) {
            s = a[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${f} for interpolating ${t}`), s = "";
        else !x(s) && !this.useRawValueToEscape && (s = Hh(s));
        const g = h.safeValue(s);
        if (t = t.replace(a[0], g), p ? (h.regex.lastIndex += s.length, h.regex.lastIndex -= a[0].length) : h.regex.lastIndex = 0, n++, n >= this.maxReplaces)
          break;
      }
    }), t;
  }
  nest(t, r) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i, a, s;
    const n = (c, u) => {
      const l = this.nestingOptionsSeparator;
      if (c.indexOf(l) < 0) return c;
      const p = c.split(new RegExp(`${l}[ ]*{`));
      let d = `{${p[1]}`;
      c = p[0], d = this.interpolate(d, s);
      const h = d.match(/'/g), f = d.match(/"/g);
      ((h?.length ?? 0) % 2 === 0 && !f || f.length % 2 !== 0) && (d = d.replace(/'/g, '"'));
      try {
        s = JSON.parse(d), u && (s = {
          ...u,
          ...s
        });
      } catch (g) {
        return this.logger.warn(`failed parsing options string in nesting for key ${c}`, g), `${c}${l}${d}`;
      }
      return s.defaultValue && s.defaultValue.indexOf(this.prefix) > -1 && delete s.defaultValue, c;
    };
    for (; i = this.nestingRegexp.exec(t); ) {
      let c = [];
      s = {
        ...o
      }, s = s.replace && !x(s.replace) ? s.replace : s, s.applyPostProcessor = !1, delete s.defaultValue;
      let u = !1;
      if (i[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(i[1])) {
        const l = i[1].split(this.formatSeparator).map((p) => p.trim());
        i[1] = l.shift(), c = l, u = !0;
      }
      if (a = r(n.call(this, i[1].trim(), s), s), a && i[0] === t && !x(a)) return a;
      x(a) || (a = Hh(a)), a || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`), a = ""), u && (a = c.reduce((l, p) => this.format(l, p, o.lng, {
        ...o,
        interpolationkey: i[1].trim()
      }), a.trim())), t = t.replace(i[0], a), this.regexp.lastIndex = 0;
    }
    return t;
  }
}
const Fw = (e) => {
  let t = e.toLowerCase().trim();
  const r = {};
  if (e.indexOf("(") > -1) {
    const o = e.split("(");
    t = o[0].toLowerCase().trim();
    const i = o[1].substring(0, o[1].length - 1);
    t === "currency" && i.indexOf(":") < 0 ? r.currency || (r.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? r.range || (r.range = i.trim()) : i.split(";").forEach((s) => {
      if (s) {
        const [n, ...c] = s.split(":"), u = c.join(":").trim().replace(/^'+|'+$/g, ""), l = n.trim();
        r[l] || (r[l] = u), u === "false" && (r[l] = !1), u === "true" && (r[l] = !0), isNaN(u) || (r[l] = parseInt(u, 10));
      }
    });
  }
  return {
    formatName: t,
    formatOptions: r
  };
}, Ut = (e) => {
  const t = {};
  return (r, o, i) => {
    let a = i;
    i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (a = {
      ...a,
      [i.interpolationkey]: void 0
    });
    const s = o + JSON.stringify(a);
    let n = t[s];
    return n || (n = e(Fs(o), i), t[s] = n), n(r);
  };
};
class Bw {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = Oe.create("formatter"), this.options = t, this.formats = {
      number: Ut((r, o) => {
        const i = new Intl.NumberFormat(r, {
          ...o
        });
        return (a) => i.format(a);
      }),
      currency: Ut((r, o) => {
        const i = new Intl.NumberFormat(r, {
          ...o,
          style: "currency"
        });
        return (a) => i.format(a);
      }),
      datetime: Ut((r, o) => {
        const i = new Intl.DateTimeFormat(r, {
          ...o
        });
        return (a) => i.format(a);
      }),
      relativetime: Ut((r, o) => {
        const i = new Intl.RelativeTimeFormat(r, {
          ...o
        });
        return (a) => i.format(a, o.range || "day");
      }),
      list: Ut((r, o) => {
        const i = new Intl.ListFormat(r, {
          ...o
        });
        return (a) => i.format(a);
      })
    }, this.init(t);
  }
  init(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = r.interpolation.formatSeparator || ",";
  }
  add(t, r) {
    this.formats[t.toLowerCase().trim()] = r;
  }
  addCached(t, r) {
    this.formats[t.toLowerCase().trim()] = Ut(r);
  }
  format(t, r, o) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const a = r.split(this.formatSeparator);
    if (a.length > 1 && a[0].indexOf("(") > 1 && a[0].indexOf(")") < 0 && a.find((n) => n.indexOf(")") > -1)) {
      const n = a.findIndex((c) => c.indexOf(")") > -1);
      a[0] = [a[0], ...a.splice(1, n)].join(this.formatSeparator);
    }
    return a.reduce((n, c) => {
      const {
        formatName: u,
        formatOptions: l
      } = Fw(c);
      if (this.formats[u]) {
        let p = n;
        try {
          const d = i?.formatParams?.[i.interpolationkey] || {}, h = d.locale || d.lng || i.locale || i.lng || o;
          p = this.formats[u](n, h, {
            ...l,
            ...i,
            ...d
          });
        } catch (d) {
          this.logger.warn(d);
        }
        return p;
      } else
        this.logger.warn(`there was no format function for ${u}`);
      return n;
    }, t);
  }
}
const Uw = (e, t) => {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
};
class $w extends Xs {
  constructor(t, r, o) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super(), this.backend = t, this.store = r, this.services = o, this.languageUtils = o.languageUtils, this.options = i, this.logger = Oe.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend?.init?.(o, i.backend, i);
  }
  queueLoad(t, r, o, i) {
    const a = {}, s = {}, n = {}, c = {};
    return t.forEach((u) => {
      let l = !0;
      r.forEach((p) => {
        const d = `${u}|${p}`;
        !o.reload && this.store.hasResourceBundle(u, p) ? this.state[d] = 2 : this.state[d] < 0 || (this.state[d] === 1 ? s[d] === void 0 && (s[d] = !0) : (this.state[d] = 1, l = !1, s[d] === void 0 && (s[d] = !0), a[d] === void 0 && (a[d] = !0), c[p] === void 0 && (c[p] = !0)));
      }), l || (n[u] = !0);
    }), (Object.keys(a).length || Object.keys(s).length) && this.queue.push({
      pending: s,
      pendingCount: Object.keys(s).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(a),
      pending: Object.keys(s),
      toLoadLanguages: Object.keys(n),
      toLoadNamespaces: Object.keys(c)
    };
  }
  loaded(t, r, o) {
    const i = t.split("|"), a = i[0], s = i[1];
    r && this.emit("failedLoading", a, s, r), !r && o && this.store.addResourceBundle(a, s, o, void 0, void 0, {
      skipCopy: !0
    }), this.state[t] = r ? -1 : 2, r && o && (this.state[t] = 0);
    const n = {};
    this.queue.forEach((c) => {
      _w(c.loaded, [a], s), Uw(c, t), r && c.errors.push(r), c.pendingCount === 0 && !c.done && (Object.keys(c.loaded).forEach((u) => {
        n[u] || (n[u] = {});
        const l = c.loaded[u];
        l.length && l.forEach((p) => {
          n[u][p] === void 0 && (n[u][p] = !0);
        });
      }), c.done = !0, c.errors.length ? c.callback(c.errors) : c.callback());
    }), this.emit("loaded", n), this.queue = this.queue.filter((c) => !c.done);
  }
  read(t, r, o) {
    let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0, a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout, s = arguments.length > 5 ? arguments[5] : void 0;
    if (!t.length) return s(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: t,
        ns: r,
        fcName: o,
        tried: i,
        wait: a,
        callback: s
      });
      return;
    }
    this.readingCalls++;
    const n = (u, l) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const p = this.waitingReads.shift();
        this.read(p.lng, p.ns, p.fcName, p.tried, p.wait, p.callback);
      }
      if (u && l && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, t, r, o, i + 1, a * 2, s);
        }, a);
        return;
      }
      s(u, l);
    }, c = this.backend[o].bind(this.backend);
    if (c.length === 2) {
      try {
        const u = c(t, r);
        u && typeof u.then == "function" ? u.then((l) => n(null, l)).catch(n) : n(null, u);
      } catch (u) {
        n(u);
      }
      return;
    }
    return c(t, r, n);
  }
  prepareLoading(t, r) {
    let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, i = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    x(t) && (t = this.languageUtils.toResolveHierarchy(t)), x(r) && (r = [r]);
    const a = this.queueLoad(t, r, o, i);
    if (!a.toLoad.length)
      return a.pending.length || i(), null;
    a.toLoad.forEach((s) => {
      this.loadOne(s);
    });
  }
  load(t, r, o) {
    this.prepareLoading(t, r, {}, o);
  }
  reload(t, r, o) {
    this.prepareLoading(t, r, {
      reload: !0
    }, o);
  }
  loadOne(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const o = t.split("|"), i = o[0], a = o[1];
    this.read(i, a, "read", void 0, void 0, (s, n) => {
      s && this.logger.warn(`${r}loading namespace ${a} for language ${i} failed`, s), !s && n && this.logger.log(`${r}loaded namespace ${a} for language ${i}`, n), this.loaded(t, s, n);
    });
  }
  saveMissing(t, r, o, i, a) {
    let s = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {}, n = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(r)) {
      this.logger.warn(`did not save key "${o}" as the namespace "${r}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(o == null || o === "")) {
      if (this.backend?.create) {
        const c = {
          ...s,
          isUpdate: a
        }, u = this.backend.create.bind(this.backend);
        if (u.length < 6)
          try {
            let l;
            u.length === 5 ? l = u(t, r, o, i, c) : l = u(t, r, o, i), l && typeof l.then == "function" ? l.then((p) => n(null, p)).catch(n) : n(null, l);
          } catch (l) {
            n(l);
          }
        else
          u(t, r, o, i, n, c);
      }
      !t || !t[0] || this.store.addResource(t[0], r, o, i);
    }
  }
}
const nf = () => ({
  debug: !1,
  initAsync: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (e) => {
    let t = {};
    if (typeof e[1] == "object" && (t = e[1]), x(e[1]) && (t.defaultValue = e[1]), x(e[2]) && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
      const r = e[3] || e[2];
      Object.keys(r).forEach((o) => {
        t[o] = r[o];
      });
    }
    return t;
  },
  interpolation: {
    escapeValue: !0,
    format: (e) => e,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  }
}), sf = (e) => (x(e.ns) && (e.ns = [e.ns]), x(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), x(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs?.indexOf?.("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), typeof e.initImmediate == "boolean" && (e.initAsync = e.initImmediate), e), Os = () => {
}, Vw = (e) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((r) => {
    typeof e[r] == "function" && (e[r] = e[r].bind(e));
  });
};
class vs extends Xs {
  constructor() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    if (super(), this.options = sf(t), this.services = {}, this.logger = Oe, this.modules = {
      external: []
    }, Vw(this), r && !this.isInitialized && !t.isClone) {
      if (!this.options.initAsync)
        return this.init(t, r), this;
      setTimeout(() => {
        this.init(t, r);
      }, 0);
    }
  }
  init() {
    var t = this;
    let r = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, o = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = !0, typeof r == "function" && (o = r, r = {}), r.defaultNS == null && r.ns && (x(r.ns) ? r.defaultNS = r.ns : r.ns.indexOf("translation") < 0 && (r.defaultNS = r.ns[0]));
    const i = nf();
    this.options = {
      ...i,
      ...this.options,
      ...sf(r)
    }, this.options.interpolation = {
      ...i.interpolation,
      ...this.options.interpolation
    }, r.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = r.keySeparator), r.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = r.nsSeparator);
    const a = (l) => l ? typeof l == "function" ? new l() : l : null;
    if (!this.options.isClone) {
      this.modules.logger ? Oe.init(a(this.modules.logger), this.options) : Oe.init(null, this.options);
      let l;
      this.modules.formatter ? l = this.modules.formatter : l = Bw;
      const p = new Xh(this.options);
      this.store = new Qh(this.options.resources, this.options);
      const d = this.services;
      d.logger = Oe, d.resourceStore = this.store, d.languageUtils = p, d.pluralResolver = new jw(p, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), l && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (d.formatter = a(l), d.formatter.init(d, this.options), this.options.interpolation.format = d.formatter.format.bind(d.formatter)), d.interpolator = new qw(this.options), d.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, d.backendConnector = new $w(a(this.modules.backend), d.resourceStore, d, this.options), d.backendConnector.on("*", function(h) {
        for (var f = arguments.length, g = new Array(f > 1 ? f - 1 : 0), m = 1; m < f; m++)
          g[m - 1] = arguments[m];
        t.emit(h, ...g);
      }), this.modules.languageDetector && (d.languageDetector = a(this.modules.languageDetector), d.languageDetector.init && d.languageDetector.init(d, this.options.detection, this.options)), this.modules.i18nFormat && (d.i18nFormat = a(this.modules.i18nFormat), d.i18nFormat.init && d.i18nFormat.init(this)), this.translator = new Us(this.services, this.options), this.translator.on("*", function(h) {
        for (var f = arguments.length, g = new Array(f > 1 ? f - 1 : 0), m = 1; m < f; m++)
          g[m - 1] = arguments[m];
        t.emit(h, ...g);
      }), this.modules.external.forEach((h) => {
        h.init && h.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, o || (o = Os), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const l = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      l.length > 0 && l[0] !== "dev" && (this.options.lng = l[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((l) => {
      this[l] = function() {
        return t.store[l](...arguments);
      };
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((l) => {
      this[l] = function() {
        return t.store[l](...arguments), t;
      };
    });
    const c = us(), u = () => {
      const l = (p, d) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), c.resolve(d), o(p, d);
      };
      if (this.languages && !this.isInitialized) return l(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, l);
    };
    return this.options.resources || !this.options.initAsync ? u() : setTimeout(u, 0), c;
  }
  loadResources(t) {
    let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Os;
    const i = x(t) ? t : this.language;
    if (typeof t == "function" && (o = t), !this.options.resources || this.options.partialBundledLanguages) {
      if (i?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return o();
      const a = [], s = (n) => {
        if (!n || n === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(n).forEach((u) => {
          u !== "cimode" && a.indexOf(u) < 0 && a.push(u);
        });
      };
      i ? s(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((c) => s(c)), this.options.preload?.forEach?.((n) => s(n)), this.services.backendConnector.load(a, this.options.ns, (n) => {
        !n && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), o(n);
      });
    } else
      o(null);
  }
  reloadResources(t, r, o) {
    const i = us();
    return typeof t == "function" && (o = t, t = void 0), typeof r == "function" && (o = r, r = void 0), t || (t = this.languages), r || (r = this.options.ns), o || (o = Os), this.services.backendConnector.reload(t, r, (a) => {
      i.resolve(), o(a);
    }), i;
  }
  use(t) {
    if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && og.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this;
  }
  setResolvedLanguage(t) {
    if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1))
      for (let r = 0; r < this.languages.length; r++) {
        const o = this.languages[r];
        if (!(["cimode", "dev"].indexOf(o) > -1) && this.store.hasLanguageSomeTranslations(o)) {
          this.resolvedLanguage = o;
          break;
        }
      }
  }
  changeLanguage(t, r) {
    var o = this;
    this.isLanguageChangingTo = t;
    const i = us();
    this.emit("languageChanging", t);
    const a = (c) => {
      this.language = c, this.languages = this.services.languageUtils.toResolveHierarchy(c), this.resolvedLanguage = void 0, this.setResolvedLanguage(c);
    }, s = (c, u) => {
      u ? (a(u), this.translator.changeLanguage(u), this.isLanguageChangingTo = void 0, this.emit("languageChanged", u), this.logger.log("languageChanged", u)) : this.isLanguageChangingTo = void 0, i.resolve(function() {
        return o.t(...arguments);
      }), r && r(c, function() {
        return o.t(...arguments);
      });
    }, n = (c) => {
      !t && !c && this.services.languageDetector && (c = []);
      const u = x(c) ? c : this.services.languageUtils.getBestMatchFromCodes(c);
      u && (this.language || a(u), this.translator.language || this.translator.changeLanguage(u), this.services.languageDetector?.cacheUserLanguage?.(u)), this.loadResources(u, (l) => {
        s(l, u);
      });
    };
    return !t && this.services.languageDetector && !this.services.languageDetector.async ? n(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(n) : this.services.languageDetector.detect(n) : n(t), i;
  }
  getFixedT(t, r, o) {
    var i = this;
    const a = function(s, n) {
      let c;
      if (typeof n != "object") {
        for (var u = arguments.length, l = new Array(u > 2 ? u - 2 : 0), p = 2; p < u; p++)
          l[p - 2] = arguments[p];
        c = i.options.overloadTranslationOptionHandler([s, n].concat(l));
      } else
        c = {
          ...n
        };
      c.lng = c.lng || a.lng, c.lngs = c.lngs || a.lngs, c.ns = c.ns || a.ns, c.keyPrefix !== "" && (c.keyPrefix = c.keyPrefix || o || a.keyPrefix);
      const d = i.options.keySeparator || ".";
      let h;
      return c.keyPrefix && Array.isArray(s) ? h = s.map((f) => `${c.keyPrefix}${d}${f}`) : h = c.keyPrefix ? `${c.keyPrefix}${d}${s}` : s, i.t(h, c);
    };
    return x(t) ? a.lng = t : a.lngs = t, a.ns = r, a.keyPrefix = o, a;
  }
  t() {
    for (var t = arguments.length, r = new Array(t), o = 0; o < t; o++)
      r[o] = arguments[o];
    return this.translator?.translate(...r);
  }
  exists() {
    for (var t = arguments.length, r = new Array(t), o = 0; o < t; o++)
      r[o] = arguments[o];
    return this.translator?.exists(...r);
  }
  setDefaultNamespace(t) {
    this.options.defaultNS = t;
  }
  hasLoadedNamespace(t) {
    let r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const o = r.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, a = this.languages[this.languages.length - 1];
    if (o.toLowerCase() === "cimode") return !0;
    const s = (n, c) => {
      const u = this.services.backendConnector.state[`${n}|${c}`];
      return u === -1 || u === 0 || u === 2;
    };
    if (r.precheck) {
      const n = r.precheck(this, s);
      if (n !== void 0) return n;
    }
    return !!(this.hasResourceBundle(o, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || s(o, t) && (!i || s(a, t)));
  }
  loadNamespaces(t, r) {
    const o = us();
    return this.options.ns ? (x(t) && (t = [t]), t.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      o.resolve(), r && r(i);
    }), o) : (r && r(), Promise.resolve());
  }
  loadLanguages(t, r) {
    const o = us();
    x(t) && (t = [t]);
    const i = this.options.preload || [], a = t.filter((s) => i.indexOf(s) < 0 && this.services.languageUtils.isSupportedCode(s));
    return a.length ? (this.options.preload = i.concat(a), this.loadResources((s) => {
      o.resolve(), r && r(s);
    }), o) : (r && r(), Promise.resolve());
  }
  dir(t) {
    if (t || (t = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language)), !t) return "rtl";
    const r = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], o = this.services?.languageUtils || new Xh(nf());
    return r.indexOf(o.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 ? arguments[1] : void 0;
    return new vs(t, r);
  }
  cloneInstance() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, r = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Os;
    const o = t.forkResourceStore;
    o && delete t.forkResourceStore;
    const i = {
      ...this.options,
      ...t,
      isClone: !0
    }, a = new vs(i);
    if ((t.debug !== void 0 || t.prefix !== void 0) && (a.logger = a.logger.clone(t)), ["store", "services", "language"].forEach((n) => {
      a[n] = this[n];
    }), a.services = {
      ...this.services
    }, a.services.utils = {
      hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
    }, o) {
      const n = Object.keys(this.store.data).reduce((c, u) => (c[u] = {
        ...this.store.data[u]
      }, Object.keys(c[u]).reduce((l, p) => (l[p] = {
        ...c[u][p]
      }, l), {})), {});
      a.store = new Qh(n, i), a.services.resourceStore = a.store;
    }
    return a.translator = new Us(a.services, i), a.translator.on("*", function(n) {
      for (var c = arguments.length, u = new Array(c > 1 ? c - 1 : 0), l = 1; l < c; l++)
        u[l - 1] = arguments[l];
      a.emit(n, ...u);
    }), a.init(i, r), a.translator.options = i, a.translator.backendConnector.services.utils = {
      hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
    }, a;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const ce = vs.createInstance();
ce.createInstance = vs.createInstance;
ce.createInstance;
ce.dir;
ce.init;
ce.loadResources;
ce.reloadResources;
ce.use;
ce.changeLanguage;
ce.getFixedT;
ce.t;
ce.exists;
ce.setDefaultNamespace;
ce.hasLoadedNamespace;
ce.loadNamespaces;
ce.loadLanguages;
var eo = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    return this.listeners.add(e), this.onSubscribe(), () => {
      this.listeners.delete(e), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, to = typeof window > "u" || "Deno" in globalThis;
function Ae() {
}
function Ww(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Hw(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function Kw(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function ec(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Jw(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function of(e, t) {
  const {
    type: r = "all",
    exact: o,
    fetchStatus: i,
    predicate: a,
    queryKey: s,
    stale: n
  } = e;
  if (s) {
    if (o) {
      if (t.queryHash !== yc(s, t.options))
        return !1;
    } else if (!ms(t.queryKey, s))
      return !1;
  }
  if (r !== "all") {
    const c = t.isActive();
    if (r === "active" && !c || r === "inactive" && c)
      return !1;
  }
  return !(typeof n == "boolean" && t.isStale() !== n || i && i !== t.state.fetchStatus || a && !a(t));
}
function af(e, t) {
  const { exact: r, status: o, predicate: i, mutationKey: a } = e;
  if (a) {
    if (!t.options.mutationKey)
      return !1;
    if (r) {
      if (gs(t.options.mutationKey) !== gs(a))
        return !1;
    } else if (!ms(t.options.mutationKey, a))
      return !1;
  }
  return !(o && t.state.status !== o || i && !i(t));
}
function yc(e, t) {
  return (t?.queryKeyHashFn || gs)(e);
}
function gs(e) {
  return JSON.stringify(
    e,
    (t, r) => rc(r) ? Object.keys(r).sort().reduce((o, i) => (o[i] = r[i], o), {}) : r
  );
}
function ms(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every((r) => ms(e[r], t[r])) : !1;
}
function tc(e, t) {
  if (e === t)
    return e;
  const r = cf(e) && cf(t);
  if (r || rc(e) && rc(t)) {
    const o = r ? e : Object.keys(e), i = o.length, a = r ? t : Object.keys(t), s = a.length, n = r ? [] : {}, c = new Set(o);
    let u = 0;
    for (let l = 0; l < s; l++) {
      const p = r ? l : a[l];
      (!r && c.has(p) || r) && e[p] === void 0 && t[p] === void 0 ? (n[p] = void 0, u++) : (n[p] = tc(e[p], t[p]), n[p] === e[p] && e[p] !== void 0 && u++);
    }
    return i === s && u === i ? e : n;
  }
  return t;
}
function cf(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function rc(e) {
  if (!uf(e))
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const r = t.prototype;
  return !(!uf(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function uf(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Gw(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function Qw(e, t, r) {
  if (typeof r.structuralSharing == "function")
    return r.structuralSharing(e, t);
  if (r.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return tc(e, t);
      } catch (o) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${o}`
        ), o;
      }
    return tc(e, t);
  }
  return t;
}
function Yw(e, t, r = 0) {
  const o = [...e, t];
  return r && o.length > r ? o.slice(1) : o;
}
function Zw(e, t, r = 0) {
  const o = [t, ...e];
  return r && o.length > r ? o.slice(0, -1) : o;
}
var $s = Symbol();
function ag(e, t) {
  return process.env.NODE_ENV !== "production" && e.queryFn === $s && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${e.queryHash}'`
  ), !e.queryFn && t?.initialPromise ? () => t.initialPromise : !e.queryFn || e.queryFn === $s ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
var Xw = class extends eo {
  #e;
  #t;
  #r;
  constructor() {
    super(), this.#r = (e) => {
      if (!to && window.addEventListener) {
        const t = () => e();
        return window.addEventListener("visibilitychange", t, !1), () => {
          window.removeEventListener("visibilitychange", t);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#r);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(e) {
    this.#r = e, this.#t?.(), this.#t = e((t) => {
      typeof t == "boolean" ? this.setFocused(t) : this.onFocus();
    });
  }
  setFocused(e) {
    this.#e !== e && (this.#e = e, this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  isFocused() {
    return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden";
  }
}, cg = new Xw(), eE = class extends eo {
  #e = !0;
  #t;
  #r;
  constructor() {
    super(), this.#r = (e) => {
      if (!to && window.addEventListener) {
        const t = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", t, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", t), window.removeEventListener("offline", r);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#r);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(e) {
    this.#r = e, this.#t?.(), this.#t = e(this.setOnline.bind(this));
  }
  setOnline(e) {
    this.#e !== e && (this.#e = e, this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return this.#e;
  }
}, Vs = new eE();
function tE() {
  let e, t;
  const r = new Promise((i, a) => {
    e = i, t = a;
  });
  r.status = "pending", r.catch(() => {
  });
  function o(i) {
    Object.assign(r, i), delete r.resolve, delete r.reject;
  }
  return r.resolve = (i) => {
    o({
      status: "fulfilled",
      value: i
    }), e(i);
  }, r.reject = (i) => {
    o({
      status: "rejected",
      reason: i
    }), t(i);
  }, r;
}
function rE(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function ug(e) {
  return (e ?? "online") === "online" ? Vs.isOnline() : !0;
}
var lg = class extends Error {
  constructor(e) {
    super("CancelledError"), this.revert = e?.revert, this.silent = e?.silent;
  }
};
function La(e) {
  return e instanceof lg;
}
function pg(e) {
  let t = !1, r = 0, o = !1, i;
  const a = tE(), s = (g) => {
    o || (d(new lg(g)), e.abort?.());
  }, n = () => {
    t = !0;
  }, c = () => {
    t = !1;
  }, u = () => cg.isFocused() && (e.networkMode === "always" || Vs.isOnline()) && e.canRun(), l = () => ug(e.networkMode) && e.canRun(), p = (g) => {
    o || (o = !0, e.onSuccess?.(g), i?.(), a.resolve(g));
  }, d = (g) => {
    o || (o = !0, e.onError?.(g), i?.(), a.reject(g));
  }, h = () => new Promise((g) => {
    i = (m) => {
      (o || u()) && g(m);
    }, e.onPause?.();
  }).then(() => {
    i = void 0, o || e.onContinue?.();
  }), f = () => {
    if (o)
      return;
    let g;
    const m = r === 0 ? e.initialPromise : void 0;
    try {
      g = m ?? e.fn();
    } catch (v) {
      g = Promise.reject(v);
    }
    Promise.resolve(g).then(p).catch((v) => {
      if (o)
        return;
      const y = e.retry ?? (to ? 0 : 3), S = e.retryDelay ?? rE, C = typeof S == "function" ? S(r, v) : S, b = y === !0 || typeof y == "number" && r < y || typeof y == "function" && y(r, v);
      if (t || !b) {
        d(v);
        return;
      }
      r++, e.onFail?.(r, v), Gw(C).then(() => u() ? void 0 : h()).then(() => {
        t ? d(v) : f();
      });
    });
  };
  return {
    promise: a,
    cancel: s,
    continue: () => (i?.(), a),
    cancelRetry: n,
    continueRetry: c,
    canStart: l,
    start: () => (l() ? f() : h().then(f), a)
  };
}
var nE = (e) => setTimeout(e, 0);
function iE() {
  let e = [], t = 0, r = (n) => {
    n();
  }, o = (n) => {
    n();
  }, i = nE;
  const a = (n) => {
    t ? e.push(n) : i(() => {
      r(n);
    });
  }, s = () => {
    const n = e;
    e = [], n.length && i(() => {
      o(() => {
        n.forEach((c) => {
          r(c);
        });
      });
    });
  };
  return {
    batch: (n) => {
      let c;
      t++;
      try {
        c = n();
      } finally {
        t--, t || s();
      }
      return c;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (n) => (...c) => {
      a(() => {
        n(...c);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (n) => {
      r = n;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (n) => {
      o = n;
    },
    setScheduler: (n) => {
      i = n;
    }
  };
}
var le = iE(), dg = class {
  #e;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), Hw(this.gcTime) && (this.#e = setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(e) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      e ?? (to ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    this.#e && (clearTimeout(this.#e), this.#e = void 0);
  }
}, sE = class extends dg {
  #e;
  #t;
  #r;
  #i;
  #n;
  #o;
  #a;
  constructor(e) {
    super(), this.#a = !1, this.#o = e.defaultOptions, this.setOptions(e.options), this.observers = [], this.#i = e.client, this.#r = this.#i.getQueryCache(), this.queryKey = e.queryKey, this.queryHash = e.queryHash, this.#e = aE(this.options), this.state = e.state ?? this.#e, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#n?.promise;
  }
  setOptions(e) {
    this.options = { ...this.#o, ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.#r.remove(this);
  }
  setData(e, t) {
    const r = Qw(this.state.data, e, this.options);
    return this.#s({
      data: r,
      type: "success",
      dataUpdatedAt: t?.updatedAt,
      manual: t?.manual
    }), r;
  }
  setState(e, t) {
    this.#s({ type: "setState", state: e, setStateOptions: t });
  }
  cancel(e) {
    const t = this.#n?.promise;
    return this.#n?.cancel(e), t ? t.then(Ae).catch(Ae) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(this.#e);
  }
  isActive() {
    return this.observers.some(
      (e) => Jw(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === $s || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => ec(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !Kw(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#n?.continue();
  }
  onOnline() {
    this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#n?.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), this.#r.notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((t) => t !== e), this.observers.length || (this.#n && (this.#a ? this.#n.cancel({ revert: !0 }) : this.#n.cancelRetry()), this.scheduleGc()), this.#r.notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.#s({ type: "invalidate" });
  }
  fetch(e, t) {
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && t?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (this.#n)
        return this.#n.continueRetry(), this.#n.promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const c = this.observers.find((u) => u.options.queryFn);
      c && this.setOptions(c.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), o = (c) => {
      Object.defineProperty(c, "signal", {
        enumerable: !0,
        get: () => (this.#a = !0, r.signal)
      });
    }, i = () => {
      const c = ag(this.options, t), l = (() => {
        const p = {
          client: this.#i,
          queryKey: this.queryKey,
          meta: this.meta
        };
        return o(p), p;
      })();
      return this.#a = !1, this.options.persister ? this.options.persister(
        c,
        l,
        this
      ) : c(l);
    }, s = (() => {
      const c = {
        fetchOptions: t,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#i,
        state: this.state,
        fetchFn: i
      };
      return o(c), c;
    })();
    this.options.behavior?.onFetch(s, this), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== s.fetchOptions?.meta) && this.#s({ type: "fetch", meta: s.fetchOptions?.meta });
    const n = (c) => {
      La(c) && c.silent || this.#s({
        type: "error",
        error: c
      }), La(c) || (this.#r.config.onError?.(
        c,
        this
      ), this.#r.config.onSettled?.(
        this.state.data,
        c,
        this
      )), this.scheduleGc();
    };
    return this.#n = pg({
      initialPromise: t?.initialPromise,
      fn: s.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (c) => {
        if (c === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), n(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(c);
        } catch (u) {
          n(u);
          return;
        }
        this.#r.config.onSuccess?.(c, this), this.#r.config.onSettled?.(
          c,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: n,
      onFail: (c, u) => {
        this.#s({ type: "failed", failureCount: c, error: u });
      },
      onPause: () => {
        this.#s({ type: "pause" });
      },
      onContinue: () => {
        this.#s({ type: "continue" });
      },
      retry: s.options.retry,
      retryDelay: s.options.retryDelay,
      networkMode: s.options.networkMode,
      canRun: () => !0
    }), this.#n.start();
  }
  #s(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return {
            ...r,
            fetchFailureCount: e.failureCount,
            fetchFailureReason: e.error
          };
        case "pause":
          return {
            ...r,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...r,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...r,
            ...oE(r.data, this.options),
            fetchMeta: e.meta ?? null
          };
        case "success":
          return this.#t = void 0, {
            ...r,
            data: e.data,
            dataUpdateCount: r.dataUpdateCount + 1,
            dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!e.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const o = e.error;
          return La(o) && o.revert && this.#t ? { ...this.#t, fetchStatus: "idle" } : {
            ...r,
            error: o,
            errorUpdateCount: r.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: r.fetchFailureCount + 1,
            fetchFailureReason: o,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...r,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...r,
            ...e.state
          };
      }
    };
    this.state = t(this.state), le.batch(() => {
      this.observers.forEach((r) => {
        r.onQueryUpdate();
      }), this.#r.notify({ query: this, type: "updated", action: e });
    });
  }
};
function oE(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: ug(t.networkMode) ? "fetching" : "paused",
    ...e === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function aE(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, r = t !== void 0, o = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? o ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var cE = class extends eo {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Map();
  }
  #e;
  build(e, t, r) {
    const o = t.queryKey, i = t.queryHash ?? yc(o, t);
    let a = this.get(i);
    return a || (a = new sE({
      client: e,
      queryKey: o,
      queryHash: i,
      options: e.defaultQueryOptions(t),
      state: r,
      defaultOptions: e.getQueryDefaults(o)
    }), this.add(a)), a;
  }
  add(e) {
    this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const t = this.#e.get(e.queryHash);
    t && (e.destroy(), t === e && this.#e.delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    le.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.#e.get(e);
  }
  getAll() {
    return [...this.#e.values()];
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (r) => of(t, r)
    );
  }
  findAll(e = {}) {
    const t = this.getAll();
    return Object.keys(e).length > 0 ? t.filter((r) => of(e, r)) : t;
  }
  notify(e) {
    le.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  onFocus() {
    le.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    le.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, uE = class extends dg {
  #e;
  #t;
  #r;
  constructor(e) {
    super(), this.mutationId = e.mutationId, this.#t = e.mutationCache, this.#e = [], this.state = e.state || lE(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    this.#e.includes(e) || (this.#e.push(e), this.clearGcTimeout(), this.#t.notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    this.#e = this.#e.filter((t) => t !== e), this.scheduleGc(), this.#t.notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    this.#e.length || (this.state.status === "pending" ? this.scheduleGc() : this.#t.remove(this));
  }
  continue() {
    return this.#r?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    const t = () => {
      this.#i({ type: "continue" });
    };
    this.#r = pg({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (i, a) => {
        this.#i({ type: "failed", failureCount: i, error: a });
      },
      onPause: () => {
        this.#i({ type: "pause" });
      },
      onContinue: t,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#t.canRun(this)
    });
    const r = this.state.status === "pending", o = !this.#r.canStart();
    try {
      if (r)
        t();
      else {
        this.#i({ type: "pending", variables: e, isPaused: o }), await this.#t.config.onMutate?.(
          e,
          this
        );
        const a = await this.options.onMutate?.(e);
        a !== this.state.context && this.#i({
          type: "pending",
          context: a,
          variables: e,
          isPaused: o
        });
      }
      const i = await this.#r.start();
      return await this.#t.config.onSuccess?.(
        i,
        e,
        this.state.context,
        this
      ), await this.options.onSuccess?.(i, e, this.state.context), await this.#t.config.onSettled?.(
        i,
        null,
        this.state.variables,
        this.state.context,
        this
      ), await this.options.onSettled?.(i, null, e, this.state.context), this.#i({ type: "success", data: i }), i;
    } catch (i) {
      try {
        throw await this.#t.config.onError?.(
          i,
          e,
          this.state.context,
          this
        ), await this.options.onError?.(
          i,
          e,
          this.state.context
        ), await this.#t.config.onSettled?.(
          void 0,
          i,
          this.state.variables,
          this.state.context,
          this
        ), await this.options.onSettled?.(
          void 0,
          i,
          e,
          this.state.context
        ), i;
      } finally {
        this.#i({ type: "error", error: i });
      }
    } finally {
      this.#t.runNext(this);
    }
  }
  #i(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return {
            ...r,
            failureCount: e.failureCount,
            failureReason: e.error
          };
        case "pause":
          return {
            ...r,
            isPaused: !0
          };
        case "continue":
          return {
            ...r,
            isPaused: !1
          };
        case "pending":
          return {
            ...r,
            context: e.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: e.isPaused,
            status: "pending",
            variables: e.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...r,
            data: e.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...r,
            data: void 0,
            error: e.error,
            failureCount: r.failureCount + 1,
            failureReason: e.error,
            isPaused: !1,
            status: "error"
          };
      }
    };
    this.state = t(this.state), le.batch(() => {
      this.#e.forEach((r) => {
        r.onMutationUpdate(e);
      }), this.#t.notify({
        mutation: this,
        type: "updated",
        action: e
      });
    });
  }
};
function lE() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var pE = class extends eo {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Set(), this.#t = /* @__PURE__ */ new Map(), this.#r = 0;
  }
  #e;
  #t;
  #r;
  build(e, t, r) {
    const o = new uE({
      mutationCache: this,
      mutationId: ++this.#r,
      options: e.defaultMutationOptions(t),
      state: r
    });
    return this.add(o), o;
  }
  add(e) {
    this.#e.add(e);
    const t = Ms(e);
    if (typeof t == "string") {
      const r = this.#t.get(t);
      r ? r.push(e) : this.#t.set(t, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (this.#e.delete(e)) {
      const t = Ms(e);
      if (typeof t == "string") {
        const r = this.#t.get(t);
        if (r)
          if (r.length > 1) {
            const o = r.indexOf(e);
            o !== -1 && r.splice(o, 1);
          } else r[0] === e && this.#t.delete(t);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const t = Ms(e);
    if (typeof t == "string") {
      const o = this.#t.get(t)?.find(
        (i) => i.state.status === "pending"
      );
      return !o || o === e;
    } else
      return !0;
  }
  runNext(e) {
    const t = Ms(e);
    return typeof t == "string" ? this.#t.get(t)?.find((o) => o !== e && o.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    le.batch(() => {
      this.#e.forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), this.#e.clear(), this.#t.clear();
    });
  }
  getAll() {
    return Array.from(this.#e);
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (r) => af(t, r)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((t) => af(e, t));
  }
  notify(e) {
    le.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((t) => t.state.isPaused);
    return le.batch(
      () => Promise.all(
        e.map((t) => t.continue().catch(Ae))
      )
    );
  }
};
function Ms(e) {
  return e.options.scope?.id;
}
function lf(e) {
  return {
    onFetch: (t, r) => {
      const o = t.options, i = t.fetchOptions?.meta?.fetchMore?.direction, a = t.state.data?.pages || [], s = t.state.data?.pageParams || [];
      let n = { pages: [], pageParams: [] }, c = 0;
      const u = async () => {
        let l = !1;
        const p = (f) => {
          Object.defineProperty(f, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? l = !0 : t.signal.addEventListener("abort", () => {
              l = !0;
            }), t.signal)
          });
        }, d = ag(t.options, t.fetchOptions), h = async (f, g, m) => {
          if (l)
            return Promise.reject();
          if (g == null && f.pages.length)
            return Promise.resolve(f);
          const y = (() => {
            const w = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: g,
              direction: m ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(w), w;
          })(), S = await d(y), { maxPages: C } = t.options, b = m ? Zw : Yw;
          return {
            pages: b(f.pages, S, C),
            pageParams: b(f.pageParams, g, C)
          };
        };
        if (i && a.length) {
          const f = i === "backward", g = f ? dE : pf, m = {
            pages: a,
            pageParams: s
          }, v = g(o, m);
          n = await h(m, v, f);
        } else {
          const f = e ?? a.length;
          do {
            const g = c === 0 ? s[0] ?? o.initialPageParam : pf(o, n);
            if (c > 0 && g == null)
              break;
            n = await h(n, g), c++;
          } while (c < f);
        }
        return n;
      };
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        u,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        r
      ) : t.fetchFn = u;
    }
  };
}
function pf(e, { pages: t, pageParams: r }) {
  const o = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[o],
    t,
    r[o],
    r
  ) : void 0;
}
function dE(e, { pages: t, pageParams: r }) {
  return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, r[0], r) : void 0;
}
var hE = class {
  #e;
  #t;
  #r;
  #i;
  #n;
  #o;
  #a;
  #s;
  constructor(e = {}) {
    this.#e = e.queryCache || new cE(), this.#t = e.mutationCache || new pE(), this.#r = e.defaultOptions || {}, this.#i = /* @__PURE__ */ new Map(), this.#n = /* @__PURE__ */ new Map(), this.#o = 0;
  }
  mount() {
    this.#o++, this.#o === 1 && (this.#a = cg.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onFocus());
    }), this.#s = Vs.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onOnline());
    }));
  }
  unmount() {
    this.#o--, this.#o === 0 && (this.#a?.(), this.#a = void 0, this.#s?.(), this.#s = void 0);
  }
  isFetching(e) {
    return this.#e.findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return this.#t.findAll({ ...e, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(t.queryHash)?.state.data;
  }
  ensureQueryData(e) {
    const t = this.defaultQueryOptions(e), r = this.#e.build(this, t), o = r.state.data;
    return o === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && r.isStaleByTime(ec(t.staleTime, r)) && this.prefetchQuery(t), Promise.resolve(o));
  }
  getQueriesData(e) {
    return this.#e.findAll(e).map(({ queryKey: t, state: r }) => {
      const o = r.data;
      return [t, o];
    });
  }
  setQueryData(e, t, r) {
    const o = this.defaultQueryOptions({ queryKey: e }), a = this.#e.get(
      o.queryHash
    )?.state.data, s = Ww(t, a);
    if (s !== void 0)
      return this.#e.build(this, o).setData(s, { ...r, manual: !0 });
  }
  setQueriesData(e, t, r) {
    return le.batch(
      () => this.#e.findAll(e).map(({ queryKey: o }) => [
        o,
        this.setQueryData(o, t, r)
      ])
    );
  }
  getQueryState(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(
      t.queryHash
    )?.state;
  }
  removeQueries(e) {
    const t = this.#e;
    le.batch(() => {
      t.findAll(e).forEach((r) => {
        t.remove(r);
      });
    });
  }
  resetQueries(e, t) {
    const r = this.#e;
    return le.batch(() => (r.findAll(e).forEach((o) => {
      o.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...e
      },
      t
    )));
  }
  cancelQueries(e, t = {}) {
    const r = { revert: !0, ...t }, o = le.batch(
      () => this.#e.findAll(e).map((i) => i.cancel(r))
    );
    return Promise.all(o).then(Ae).catch(Ae);
  }
  invalidateQueries(e, t = {}) {
    return le.batch(() => (this.#e.findAll(e).forEach((r) => {
      r.invalidate();
    }), e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...e,
        type: e?.refetchType ?? e?.type ?? "active"
      },
      t
    )));
  }
  refetchQueries(e, t = {}) {
    const r = {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }, o = le.batch(
      () => this.#e.findAll(e).filter((i) => !i.isDisabled() && !i.isStatic()).map((i) => {
        let a = i.fetch(void 0, r);
        return r.throwOnError || (a = a.catch(Ae)), i.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(o).then(Ae);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const r = this.#e.build(this, t);
    return r.isStaleByTime(
      ec(t.staleTime, r)
    ) ? r.fetch(t) : Promise.resolve(r.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(Ae).catch(Ae);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = lf(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(Ae).catch(Ae);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = lf(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return Vs.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return this.#e;
  }
  getMutationCache() {
    return this.#t;
  }
  getDefaultOptions() {
    return this.#r;
  }
  setDefaultOptions(e) {
    this.#r = e;
  }
  setQueryDefaults(e, t) {
    this.#i.set(gs(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...this.#i.values()], r = {};
    return t.forEach((o) => {
      ms(e, o.queryKey) && Object.assign(r, o.defaultOptions);
    }), r;
  }
  setMutationDefaults(e, t) {
    this.#n.set(gs(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...this.#n.values()], r = {};
    return t.forEach((o) => {
      ms(e, o.mutationKey) && Object.assign(r, o.defaultOptions);
    }), r;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...this.#r.queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = yc(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === $s && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e?._defaulted ? e : {
      ...this.#r.mutations,
      ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    this.#e.clear(), this.#t.clear();
  }
};
async function fE(e) {
  if (!e.ok) {
    const t = await e.text() || e.statusText;
    throw new Error(`${e.status}: ${t}`);
  }
}
function vE() {
  return "https://developmentapis.azure-api.net/sandbox/v1/";
}
const gE = ({ on401: e }) => async ({ queryKey: t }) => {
  const r = t[0], o = r.startsWith("http") ? r : `${vE()}${r}`, i = await fetch(o, {
    credentials: "include"
  });
  return await fE(i), await i.json();
};
new hE({
  defaultOptions: {
    queries: {
      queryFn: gE({ on401: "throw" }),
      refetchInterval: !1,
      refetchOnWindowFocus: !1,
      staleTime: 1 / 0,
      retry: !1
    },
    mutations: {
      retry: !1
    }
  }
});
const mE = "Welcome to Your Personal AI Medical Concierge", yE = "Your intelligent health assistant will ask you key questions to understand your needs and build a personalized profile to support your well-being and care journey.", SE = { title: "How It Works", steps: ["Your AI concierge asks you questions to find out how {{brand}} can help you succeed", "The concierge will personalize recommendations based on your needs", "Access tailored resources, courses, and marketplace options"] }, CE = { resetChat: "Reset Chat", retry: "Retry", continue: "Continue", upload: "Upload", uploading: "Uploading..." }, RE = { yourAIConcierge: "Your AI Concierge", chooseAvatar: "Choose Your Avatar", startConversation: "Start Conversation" }, PE = { chooseAvatarTitle: "Choose Your Avatar", chooseAvatarMessage: "Please select an avatar from the left panel to start your conversation with your AI Concierge.", mode: "Chat Mode", modes: { care: "Care", clear: "Clear", clinical: "Clinical" } }, bE = {
  title: mE,
  description: yE,
  howItWorks: SE,
  buttons: CE,
  avatar: RE,
  chat: PE
}, wE = "Bienvenido a tu Asistente de IA Personal de Salud", EE = "Tu asistente digital inteligente te har preguntas clave para entender tus necesidades y crear un perfil personalizado para apoyarte en tu viaje de bienestar y cuidado.", IE = { title: "Cmo Funciona", steps: ["Tu asistente de IA te har preguntas para averiguar cmo {{brand}} puede ayudarte a tener xito", "El asistente personalizar recomendaciones basadas en tus necesidades", "Accede a recursos, cursos y opciones de mercado personalizados"] }, AE = { resetChat: "Restablecer Chat", retry: "Reintentar", continue: "Continuar", upload: "Cargar", uploading: "Cargando..." }, TE = { yourAIConcierge: "Tu Asistente de IA", chooseAvatar: "Elige tu Avatar", startConversation: "Iniciar Conversacin" }, _E = { chooseAvatarTitle: "Elige tu Avatar", chooseAvatarMessage: "Por favor, selecciona un avatar de la izquierda para iniciar tu conversacin con tu Asistente de IA.", mode: "Modo de Chat", modes: { care: "Cuidado", clear: "Claro", clinical: "Clnico" } }, kE = {
  title: wE,
  description: EE,
  howItWorks: IE,
  buttons: AE,
  avatar: TE,
  chat: _E
}, OE = "Bienvenue chez votre Assistant IA de Sant", ME = "Votre assistant numrique intelligent vous posera des questions cls pour comprendre vos besoins et crer un profil personnalis pour vous aider dans votre parcours de bien-tre et de soins.", DE = { title: "Comment a Marche", steps: ["Votre assistant IA vous pose des questions pour savoir comment {{brand}} peut vous aider", "L'assistant personnalise des recommandations selon vos besoins", "Accdez  des ressources, cours et options adaptes"] }, NE = { resetChat: "Rinitialiser le Chat", retry: "Ressayer", continue: "Continuer", upload: "Tlcharger", uploading: "Tlchargement..." }, xE = { yourAIConcierge: "Votre Assistant IA", chooseAvatar: "Choisissez votre Avatar", startConversation: "Dmarrer la Conversation" }, zE = { chooseAvatarTitle: "Choisissez votre Avatar", chooseAvatarMessage: "Veuillez slectionner un avatar de la gauche pour dmarrer votre conversation avec votre Assistant IA.", mode: "Mode de Chat", modes: { care: "Soins", clear: "Clair", clinical: "Clinique" } }, LE = {
  title: OE,
  description: ME,
  howItWorks: DE,
  buttons: NE,
  avatar: xE,
  chat: zE
}, jE = "Willkommen bei Ihrem persnlichen KI-Medizin-Assistenten", qE = "Ihr intelligenter digitaler Assistent stellt Fragen, um Ihre Bedrfnisse zu verstehen und ein persnliches Profil zu erstellen, um Ihre Gesundheit und Pflege zu untersttzen.", FE = { title: "So funktioniert es", steps: ["Ihr KI-Assistent stellt Fragen, um herauszufinden, wie {{brand}} Sie untersttzen kann", "Der Assistent personalisiert Empfehlungen basierend auf Ihren Bedrfnissen", "Zugriff auf mageschneiderte Ressourcen, Kurse und Marktplatzoptionen"] }, BE = { resetChat: "Chat zurcksetzen", retry: "Wiederholen", continue: "Fortfahren", upload: "Datei hochladen", uploading: "Hochladen..." }, UE = { yourAIConcierge: "Ihr KI-Assistent", chooseAvatar: "Whlen Sie Ihren Avatar", startConversation: "Konversation starten" }, $E = { chooseAvatarTitle: "Whlen Sie Ihren Avatar", chooseAvatarMessage: "Bitte whlen Sie einen Avatar aus der linken Leiste, um mit Ihrem KI-Assistenten zu beginnen.", mode: "Chat-Modus", modes: { care: "Betreuung", clear: "Klar", clinical: "Klinisch" } }, VE = {
  title: jE,
  description: qE,
  howItWorks: FE,
  buttons: BE,
  avatar: UE,
  chat: $E
}, WE = ["Analyzing your request", "Gathering insights", "Processing information", "Preparing response", "Almost there", "Finalizing thoughts", "Crafting the perfect response", "Connecting the dots", "Synthesizing information", "Optimizing recommendations"], HE = {
  loadingMessages: WE
}, KE = ["Analizando tu solicitud", "Recopilando informacin", "Procesando informacin", "Preparando respuesta", "Casi listo", "Finalizando pensamientos", "Elaborando la respuesta perfecta", "Conectando los puntos", "Sintetizando informacin", "Optimizando recomendaciones"], JE = {
  loadingMessages: KE
}, GE = ["Analyse de votre demande", "Collecte d'informations", "Traitement des informations", "Prparation de la rponse", "Presque termin", "Finalisation des rflexions", "laboration de la rponse parfaite", "Connexion des points", "Synthse des informations", "Optimisation des recommandations"], QE = {
  loadingMessages: GE
}, YE = ["Analysiere Ihre Anfrage", "Sammle Erkenntnisse", "Verarbeite Informationen", "Bereite Antwort vor", "Fast fertig", "Finalisiere Gedanken", "Erstelle die perfekte Antwort", "Verbinde die Punkte", "Synthetisiere Informationen", "Optimiere Empfehlungen"], ZE = {
  loadingMessages: YE
}, XE = {
  en: {
    concierge: bE,
    common: {
      loadingMessages: HE
    }
  },
  es: {
    concierge: kE,
    common: {
      loadingMessages: JE
    }
  },
  fr: {
    concierge: LE,
    common: {
      loadingMessages: QE
    }
  },
  de: {
    concierge: VE,
    common: {
      loadingMessages: ZE
    }
  }
};
ce.use(Wg).init({
  resources: XE,
  lng: "en",
  // Default language
  fallbackLng: "en",
  interpolation: {
    escapeValue: !1
    // React already handles escaping
  }
});
const eI = [
  { code: "en", name: "English" },
  { code: "es", name: "Spanish" },
  { code: "fr", name: "French" },
  { code: "de", name: "German" }
], hg = {
  region: "",
  apiBaseUrl: "",
  speechKey: "",
  azureTranslatorKey: "",
  azureTranslatorEndpoint: "",
  azureTranslatorRegion: "",
  tavusApiKey: ""
}, fg = hf(hg), tI = () => ff(fg), rI = ({ value: e, children: t }) => {
  const r = { ...hg, ...e };
  return /* @__PURE__ */ P(fg.Provider, { value: r, children: t });
}, nI = Cg(
  ({
    replicaId: e = "r82081c7f26d",
    personaId: t = "pc9cb547c05e",
    personaName: r = "Concierge",
    conversationName: o = "Demo Conversation",
    conversationalContext: i,
    customGreeting: a,
    platform: s = "home",
    buttonText: n,
    videoMode: c,
    chatVisible: u,
    toggleChat: l,
    learningPrompts: p = [],
    onPromptClick: d,
    width: h = "100%",
    height: f = "100%",
    maxWidth: g = "2xl",
    className: m = "",
    setVoiceMode: v,
    setConversationStarted: y,
    setConversationId: S,
    setConversationUrl: C,
    setInterruptReplica: b,
    currentScript: w,
    setCurrentScript: I,
    interruptReplica: E,
    setIsSpeaking: N,
    setSpokenText: R,
    region: M,
    speechKey: T,
    config: L
  }, U) => {
    const [Q, ee] = D("welcome"), [re, he] = D(null), [W, ie] = D(!1), [K, Ne] = D(!1), nt = Ve(null), [He, xe] = D([]), [it, qt] = D("16:9"), { tavusApiKey: Ke } = tI(), [_e, st] = D("en");
    B(() => {
      typeof window < "u" && st(localStorage.getItem("lang") || "en");
    }, []);
    const Gt = eI.find((F) => F.code === _e)?.name || "English", Je = Ve("en");
    B(() => {
      typeof window < "u" && (Je.current = localStorage.getItem("lang") || "en");
    }, []), B(() => {
      (async () => {
        if (He.length === 0)
          try {
            const te = await ig();
            te?.Success && te.Data && xe(te.Data);
          } catch (te) {
            console.error("Error fetching avatars:", te);
          }
      })();
    }, [He.length]);
    const ot = He.find((F) => F.ExternalId === e);
    B(() => {
      _e && _e !== "en" && _e !== Je.current && (Je.current = _e, at());
    }, [_e]), B(() => {
      (async () => {
        if (ot?.ImageUrl) {
          const te = new Image();
          te.onload = () => {
            const ct = te.width / te.height;
            Math.abs(ct - 1.7777777777777777) < Math.abs(ct - 0.5625) ? qt("16:9") : qt("9:16");
          }, te.onerror = () => {
            qt("16:9");
          }, te.src = ot.ImageUrl;
        }
      })();
    }, [ot?.ImageUrl]), B(() => () => {
      re && Wh({
        conversationId: re.conversation_id,
        apiKey: Ke
      });
    }, [re]), B(() => {
      s === "concierge" && fe();
    }, [s]);
    const fe = async () => {
      try {
        Ne(!1), ie(!0), v(!0), y(!0), nt.current && nt.current.pause();
        const F = await Iw({
          replicaId: e || "r82081c7f26d",
          personaId: t || "pc9cb547c05e",
          conversationName: o || "Demo Conversation",
          conversationalContext: i ?? "",
          customGreeting: a ?? "",
          language: Gt,
          apiKey: Ke
        });
        if (F?.conversation_id && F.conversation_url)
          he(F), S(F.conversation_id), C(F.conversation_url), ee("hairCheck");
        else
          throw new Error("Failed to start conversation");
      } catch (F) {
        console.error("Conversation error:", F);
      } finally {
        ie(!1);
      }
    }, at = async () => {
      Ne(!0), y(!1);
      try {
        if (!re) return;
        await Wh({ conversationId: re.conversation_id, apiKey: Ke });
      } catch (F) {
        console.error(F);
      } finally {
        he(null), ee("welcome");
      }
    }, bs = () => {
      ee("call");
    };
    Rg(U, () => ({
      handleEnd: at,
      handleStart: fe
    }));
    const ws = (F) => typeof F == "string" ? F : F ? `${F}px` : "100%", Qt = (F) => typeof F == "string" ? F : F ? `${F}px` : "100%", Yt = ws(h), Pe = Qt(f), be = (F) => {
      if (!F) return;
      const te = typeof F == "string" ? F : `${F}px`;
      return te.includes("sm") || parseInt(te) < 350 ? "sm" : te.includes("lg") || parseInt(te) > 600 ? "lg" : "md";
    }, Se = typeof g == "string" ? g : g ? `${g}px` : void 0, Ge = Se && !Se.includes("px") && !Se.includes("%") ? `max-w-${Se} mx-auto` : "";
    return /* @__PURE__ */ P("main", { className: `${m} relative w-full h-full`, style: { width: Yt, height: Pe }, children: /* @__PURE__ */ P($g, { children: /* @__PURE__ */ k("div", { className: `h-full w-full ${Ge}`, style: Se && Se.includes("px") ? { maxWidth: Se } : {}, children: [
      Q === "welcome" && /* @__PURE__ */ P(
        Rw,
        {
          onStart: fe,
          loading: W,
          buttonText: n,
          platform: s || "home",
          replicaId: e || "r82081c7f26d",
          containerClassName: m,
          imageHeight: Pe === "100%" ? "auto" : Pe,
          buttonSize: be(h) || "md",
          learningPrompts: p,
          onPromptClick: d,
          userCredits: 100,
          avatars: He,
          config: L,
          personaName: r
        }
      ),
      Q === "hairCheck" && /* @__PURE__ */ P(
        Pw,
        {
          handleEnd: at,
          handleJoin: bs,
          setScreen: ee,
          platform: s || "home",
          containerClassName: m,
          videoDimensions: {
            width: Yt,
            height: Pe === "100%" ? "auto" : Pe
          },
          buttonsSize: be(h) || "md"
        }
      ),
      Q === "call" && re && /* @__PURE__ */ P("div", { className: "w-full h-full", children: /* @__PURE__ */ P(
        Ew,
        {
          conversation: re,
          handleEnd: at,
          platform: s || "home",
          videoMode: c ?? "full",
          endConv: K,
          chatVisible: u ?? !1,
          toggleChat: l,
          containerClassName: m,
          videoHeight: Pe === "100%" ? "auto" : Pe,
          controlsSize: be(h) || "md",
          aspectRatio: it,
          setInterruptReplica: b,
          currentScript: w,
          setCurrentScript: I,
          interruptReplica: E,
          setIsSpeaking: N,
          setSpokenText: R,
          region: M,
          speechKey: T,
          config: L,
          personaName: r
        }
      ) })
    ] }) }) });
  }
), iI = async (e, t, r, o, i = !1, a = !1) => {
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      UserId: e,
      CourseId: t,
      Query: r,
      Answer: o,
      Avatar: i,
      STT: a
    })
  };
  let c;
  try {
    const u = mc("/api/User/education/chathistory/post"), l = await fetch(u, n);
    if (!l.ok) {
      let p = {};
      const d = l.headers.get("content-type");
      throw d && d.includes("application/json") ? p = await l.json() : p = { message: await l.text() }, console.error("Error details:", p), new Error(
        `Failed to post chat history: ${l.status} ${l.statusText} - ${JSON.stringify(p)}`
      );
    }
    return c = l.headers.get("content-length") === "0" ? { Data: !0, Success: !0, Message: "Ok" } : await l.json(), c;
  } catch (u) {
    return console.error("Error posting chat history:", u), {
      Success: !1,
      Message: u instanceof Error ? u.message : "Unknown error occurred",
      Data: null
    };
  }
}, df = ({
  children: e,
  fallback: t = /* @__PURE__ */ P("div", { children: "Loading..." })
}) => {
  const [r, o] = D(!1);
  return B(() => {
    o(!0);
  }, []), r ? /* @__PURE__ */ P(zs, { children: e }) : /* @__PURE__ */ P(zs, { children: t });
}, sI = [
  { id: 1, text: "Explain my report", icon: Og },
  { id: 5, text: "Analyze my medical reports.", icon: Mg },
  { id: 6, text: "Answer my questions like a personal coach", icon: Dg }
], oI = "r397c808f1cf";
function aI({
  brandName: e = "Growth Hub",
  personaName: t = "Personal AI Concierge",
  suggestedPrompts: r = sI,
  welcomeMessage: o = "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload any lab test or medical report. If you dont have one, lets just talk.",
  language: i = "en",
  navigateTo: a = "",
  file: s,
  onFileChange: n,
  onApiResponse: c,
  config: u = {
    region: "",
    apiBaseUrl: "",
    speechKey: "",
    azureTranslatorKey: "",
    azureTranslatorEndpoint: "",
    azureTranslatorRegion: ""
  }
}) {
  const [l, p] = D([]), [d, h] = D(null), [f, g] = D("chat"), [m, v] = D(!1), [y, S] = D(!1), [C, b] = D(!1), [w, I] = D([]), [E, N] = D(!1), [R, M] = D({}), [T, L] = D(""), [U, Q] = D(!1), [ee, re] = D(!1), [he, W] = D(!1), [ie, K] = D(!1), [Ne, nt] = D(""), He = Ve(null), [xe, it] = D(""), [qt, Ke] = D(!1), [_e, st] = D(!1), [Gt, Je] = D(!1), [ot, fe] = D(""), [at, bs] = D(""), [ws, Qt] = D(""), [Yt, Pe] = D(""), [be, Se] = D(!1), Ge = Ve(null), F = Ve(null), [te, ct] = D([]), [ne, Es] = D({
    avatar: {
      chooseAvatar: `Choose Your ${t}`,
      startConversation: "Start Conversation",
      yourAIHealthNavigator: `Your ${t}`,
      description: "I'm here to help you with your health and wellness."
    },
    buttons: {
      resetChat: "Reset Chat",
      retry: "Retry",
      continue: "Continue",
      signUp: "Sign Up Free",
      uploading: "Uploading...",
      upload: "Upload report",
      buyNow: "Buy now"
    },
    howItWorks: {
      title: "How It Works",
      steps: [
        `Your AI ${t} asks you questions to find out how ${e} can help you.`,
        `The ${t} will personalize recommendations based on your needs`,
        "Access tailored resources, courses, and marketplace options."
      ]
    }
  });
  B(() => {
    typeof window < "u" && window.scrollTo(0, 0);
  }, []), B(() => {
    (async () => {
      try {
        const X = await ig();
        if (X?.Success && X.Data) {
          const V = X.Data.find((H) => H.ExternalId === oI);
          V && (p([V]), h(V));
        }
      } catch (X) {
        console.error("Error fetching avatar:", X);
      }
    })();
  }, []), B(() => {
    g(be ? "voice" : "chat");
  }, [be]), B(() => {
    if (!(!!u?.azureTranslatorKey && !!u?.azureTranslatorEndpoint && !!u?.azureTranslatorRegion)) {
      console.warn("Azure translation config is not yet ready.");
      return;
    }
    (async () => {
      if (i !== "en" && Ge.current !== i) {
        const [
          V,
          H,
          ze,
          G,
          ve,
          Ce,
          Xt,
          so,
          oo,
          ao,
          co,
          uo,
          lo,
          po,
          ho
        ] = await Qs(
          [
            `Choose Your ${t}`,
            "Start Conversation",
            `Your ${t}`,
            `I'm here to help you with ${e}.`,
            "Reset Chat",
            "Retry",
            "Continue",
            "Sign Up Free",
            "Uploading...",
            "Upload Report",
            "Buy Now",
            "How It Works",
            `Your AI ${t} asks you questions to find out how ${e} can help you.`,
            `The ${t} will personalize recommendations based on your needs`,
            "Access tailored resources, courses, and marketplace options."
          ],
          i,
          "en",
          u.azureTranslatorKey,
          u.azureTranslatorEndpoint,
          u.azureTranslatorRegion
        );
        v(!1), L(""), I([]), Es({
          avatar: {
            chooseAvatar: V,
            startConversation: H,
            yourAIHealthNavigator: ze,
            description: G
          },
          buttons: {
            resetChat: ve,
            retry: Ce,
            continue: Xt,
            signUp: so,
            uploading: oo,
            upload: ao,
            buyNow: co
          },
          howItWorks: {
            title: uo,
            steps: [lo, po, ho]
          }
        }), Ge.current = i;
      }
      i === "en" && Ge.current !== "en" && (v(!1), L(""), I([]), Es({
        avatar: {
          chooseAvatar: `Choose Your ${t}`,
          startConversation: "Start Conversation",
          yourAIHealthNavigator: `Your ${t}`,
          description: `I'm here to help you with ${e}.`
        },
        buttons: {
          resetChat: "Reset Chat",
          retry: "Retry",
          continue: "Continue",
          signUp: "Sign Up Free",
          uploading: "Uploading...",
          upload: "Upload Report",
          buyNow: "Buy Now"
        },
        howItWorks: {
          title: "How It Works",
          steps: [
            `Your AI ${t} asks you questions to find out how ${e} can help you.`,
            `The ${t} will personalize recommendations based on your needs`,
            "Access tailored resources, courses, and marketplace options."
          ]
        }
      }), Ge.current = "en");
    })();
  }, [
    i,
    u?.azureTranslatorKey,
    u?.azureTranslatorEndpoint,
    u?.azureTranslatorRegion,
    t,
    e
  ]), B(() => {
    s && (ct([s]), Qe(`Uploaded file: ${s.name}`, [s]));
  }, [s]), nc(
    async ($) => {
      S(!0);
      const V = await Vh(
        "I am user",
        "",
        "",
        "interview",
        T,
        0,
        1,
        i
      );
      return V.Success && V.Data?.Message ? V.Data.Message.includes("ERROR") ? (S(!1), fe(`Hello there! I'm ${$?.Name}, your ${t}. I'm here to help you with ${e}. Can you tell me your name?`), {
        id: "welcome-message",
        sender: "ai",
        text: `Hello there! I'm ${$?.Name}, your ${t}. I'm here to help you with ${e}. Can you tell me a little about yourself?`,
        timestamp: /* @__PURE__ */ new Date()
      }) : (S(!1), L(V.Data.SessionId || ""), fe(V.Data.Message), {
        id: "welcome-message",
        sender: "ai",
        text: V.Data.Message,
        timestamp: /* @__PURE__ */ new Date()
      }) : (S(!1), {
        id: "welcome-message",
        sender: "ai",
        text: `Hello there! I'm ${$?.Name}, your ${t}. I'm here to help you with ${e}. Can you tell me a little about yourself?`,
        timestamp: /* @__PURE__ */ new Date()
      });
    },
    [e]
  ), B(() => {
    Je(!0);
  }, []), B(() => {
    xe && xe.trim() !== "" && (Qe(xe), it(""));
  }, [xe]), B(() => {
    v(!!be);
  }, [be]);
  const Qe = async ($, X = []) => {
    ie && K(!1);
    const V = {
      id: Date.now().toString(),
      sender: "user",
      text: $ === "yes, continue" ? "Yes" : $,
      timestamp: /* @__PURE__ */ new Date()
    };
    nt($), I((G) => [...G, V]), S(!0);
    let H = `${$}`;
    const ze = [...te, ...X];
    ze.length > 0 && (H += "Summarize this file in 34 very simple sentences, as if you are explaining to a 3rd grader. Only include the most important points. Also, list anything in the file that should be double-checked or reviewed."), $ === "yes, continue" && (H += "Start the interview. User clicked continue.");
    try {
      const G = await Vh(
        H,
        "52533633434137384342",
        // Send user ID instead of email - for testing hardcoding the userID
        "",
        // Business ID
        "interview",
        // Intent
        T,
        0,
        1,
        i,
        ze.length > 0 ? ze[0] : void 0
        // Only send last file
      );
      if (G.Success && G.Data?.Message) {
        if (G?.Data?.Message?.includes("ERROR") || G?.Data?.Type === "error") {
          S(!1);
          const Ce = {
            id: (Date.now() + 1).toString(),
            sender: "ai",
            text: "Sorry, I couldn't process your request at the moment. Please try again.",
            timestamp: /* @__PURE__ */ new Date()
          };
          I((Xt) => [...Xt, Ce]), fe(Ce.text), K(!0);
          return;
        }
        const ve = {
          id: (Date.now() + 1).toString(),
          sender: "ai",
          text: G.Data.Message,
          timestamp: /* @__PURE__ */ new Date()
        };
        I((Ce) => [...Ce, ve]), T || L(G?.Data?.SessionId || ""), fe(G.Data.Message), (G.Data.Message.toLowerCase().includes("click continue") || G.Data.Message.toLowerCase().includes("continue")) && Q(!0), (G.Data.Message.toLowerCase().includes("sign up") || G.Data.Message.toLowerCase().includes("thank you for choosing") || G.Data.Message.toLowerCase().includes("ready to connect")) && re(!0), (G.Data.Message.toLowerCase().includes("buy now") || G.Data.Message.toLowerCase().includes("ready to get your test kit")) && W(!0), c && c(G), await iI(
          "",
          "AIHealthNavigator",
          $,
          G.Data.Message || "",
          f === "voice",
          //isUserUsingAvatar
          $ === xe
          // isUserSpeaking
        ), nt("");
      } else {
        const ve = {
          id: (Date.now() + 1).toString(),
          sender: "ai",
          text: "Sorry, I couldn't process your request. Please try again.",
          timestamp: /* @__PURE__ */ new Date()
        };
        I((Ce) => [...Ce, ve]), fe(ve.text), K(!0);
      }
    } catch (G) {
      console.error("Error fetching response from LLM: ", G);
      const ve = {
        id: (Date.now() + 1).toString(),
        sender: "ai",
        text: "Sorry, I couldn't connect to the AI service. Please try again later.",
        timestamp: /* @__PURE__ */ new Date()
      };
      I((Ce) => [...Ce, ve]), fe(ve.text), K(!0);
    } finally {
      S(!1);
    }
  }, ro = () => {
    console.log("Toggle chat visibility");
  }, Zt = () => {
    Q(!1), Qe("yes, continue", []);
  }, oe = () => {
    W(!1), typeof window < "u" && (window.location.href = "/account");
  }, no = () => {
    typeof window < "u" && (a ? window.location.href = a : window.location.href = "https://growth-hub-git-feature-whitelabeljun25v1-real-business.vercel.app/auth/register");
  }, Is = () => {
    I([]);
  }, As = ($, X) => {
    const V = X === "like";
    M((H) => ({
      ...H,
      [$.id]: X
    })), Cw(
      $.text,
      "",
      "",
      V
    ).then((H) => {
    }).catch((H) => {
      console.error("Error sending feedback:", H);
    });
  }, io = async ($) => {
    b(!0);
    const X = Array.from($.target.files || []);
    if (X.length > 0) {
      const V = X[0];
      ct([V]), n && n(V), b(!1), await Qe(`Uploaded file: ${V.name}`, [V]);
    }
    $.target && ($.target.value = "");
  }, Ts = () => {
    F.current?.click();
  };
  return /* @__PURE__ */ k("div", { className: "w-full h-full", children: [
    /* @__PURE__ */ P("div", { className: "container max-w-5xl mx-auto px-4 sm:px-6 lg:px-8 py-8", children: /* @__PURE__ */ k("div", { className: "relative", children: [
      /* @__PURE__ */ P("div", { className: "relative z-10", children: /* @__PURE__ */ k(
        vf.div,
        {
          initial: { opacity: 0, y: 20 },
          animate: { opacity: 1, y: 0 },
          transition: { duration: 0.5 },
          className: "rounded-lg shadow-2xl border border-primary/20 overflow-hidden",
          children: [
            /* @__PURE__ */ k("div", { className: "p-4 sm:p-6 bg-neutral border-b border-primary/20", children: [
              /* @__PURE__ */ k("div", { className: "flex flex-row items-center justify-between gap-4", children: [
                /* @__PURE__ */ k("div", { className: "flex items-center flex-shrink min-w-0", children: [
                  /* @__PURE__ */ P("div", { className: "h-10 w-10 sm:h-12 sm:w-12 rounded-full overflow-hidden mr-3 sm:mr-4 flex-shrink-0", children: /* @__PURE__ */ P(
                    "img",
                    {
                      src: d?.ImageUrl,
                      alt: d?.Name,
                      className: "h-full w-full object-cover"
                    }
                  ) }),
                  /* @__PURE__ */ k("div", { className: "min-w-0", children: [
                    /* @__PURE__ */ P("h1", { className: "text-lg sm:text-2xl font-bold text-primary leading-tight truncate", children: ne.avatar.yourAIHealthNavigator }),
                    /* @__PURE__ */ P("p", { className: "text-xs sm:text-sm text-secondary truncate", children: ne.avatar.description })
                  ] })
                ] }),
                /* @__PURE__ */ k("div", { className: "hidden md:flex gap-2 flex-wrap ml-4", children: [
                  e !== "CareNexa" && /* @__PURE__ */ k(
                    ke,
                    {
                      variant: "outline",
                      size: "sm",
                      className: "text-xs text-primary border-primary/30 hover:bg-neutral",
                      onClick: Ts,
                      disabled: C,
                      children: [
                        /* @__PURE__ */ P(Rc, { className: "h-3 w-3 mr-1" }),
                        C ? ne.buttons.uploading : ne.buttons.upload
                      ]
                    }
                  ),
                  /* @__PURE__ */ P(
                    ke,
                    {
                      variant: "outline",
                      size: "sm",
                      className: "text-xs text-primary border-primary/30 hover:bg-neutral",
                      onClick: Is,
                      children: ne.buttons.resetChat
                    }
                  )
                ] }),
                /* @__PURE__ */ P("div", { className: "flex md:hidden items-center ml-2", children: /* @__PURE__ */ P(
                  "button",
                  {
                    className: "p-2 rounded-md border border-primary/20 bg-white text-primary focus:outline-none",
                    onClick: () => N(!E),
                    "aria-label": "Open menu",
                    children: E ? /* @__PURE__ */ P(Tg, { className: "h-6 w-6" }) : /* @__PURE__ */ P(_g, { className: "h-6 w-6" })
                  }
                ) })
              ] }),
              E && /* @__PURE__ */ k("div", { className: "md:hidden mt-2 flex flex-col gap-2 animate-fadeIn", children: [
                /* @__PURE__ */ k(
                  ke,
                  {
                    variant: "outline",
                    size: "sm",
                    className: "text-xs text-primary border-primary/30 hover:bg-neutral",
                    onClick: () => {
                      Ts(), N(!1);
                    },
                    disabled: C,
                    children: [
                      /* @__PURE__ */ P(Rc, { className: "h-3 w-3 mr-1" }),
                      C ? ne.buttons.uploading : ne.buttons.upload
                    ]
                  }
                ),
                /* @__PURE__ */ P(
                  ke,
                  {
                    variant: "outline",
                    size: "sm",
                    className: "text-xs text-primary border-primary/30 hover:bg-neutral",
                    onClick: () => {
                      Is(), N(!1);
                    },
                    children: ne.buttons.resetChat
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ k("div", { className: `grid grid-cols-1 md:grid-cols-2 \r
                h-[70vh] md:h-[600px]\r
                max-h-[100vh]`, children: [
              /* @__PURE__ */ P("div", { className: `\r
                  flex flex-col\r
                  basis=[35%] md:basis-auto\r
                  min-h-0\r
                  overflow-y-auto\r
                  p-4 md:p-6\r
                  border-b md:border-b-0 md:border-r border-primary/20\r
                `, children: /* @__PURE__ */ P("div", { className: "h-full w-full", children: m ? /* @__PURE__ */ P("div", { className: "h-full w-full rounded-xl overflow-hidden bg-gradient-to-br from-neutral to-white border border-primary/20", children: d && /* @__PURE__ */ P(df, { fallback: /* @__PURE__ */ P("div", { className: "w-full h-full bg-gray-200 rounded animate-pulse flex items-center justify-center", children: "Loading conversation..." }), children: /* @__PURE__ */ P(
                nI,
                {
                  ref: He,
                  replicaId: d?.ExternalId || "",
                  personaId: "pb5d44035dbd",
                  personaName: t,
                  conversationName: `Conversation with ${d?.Name || "your" + t} ${(/* @__PURE__ */ new Date()).toISOString()}`,
                  conversationalContext: "Initial medical consultation",
                  customGreeting: w.length > 0 && w[w.length - 1].sender === "ai" ? w[w.length - 1].text : o,
                  platform: "concierge",
                  buttonText: ne.avatar.startConversation,
                  videoMode: "minimal",
                  chatVisible: !1,
                  toggleChat: ro,
                  width: "100%",
                  height: "100%",
                  className: "w-full h-full",
                  setVoiceMode: Je,
                  setConversationStarted: Se,
                  setConversationId: Qt,
                  setConversationUrl: Pe,
                  setInterruptReplica: st,
                  currentScript: ot,
                  setCurrentScript: fe,
                  interruptReplica: _e,
                  setIsSpeaking: Ke,
                  setSpokenText: it,
                  region: u?.region || "",
                  speechKey: u?.speechKey || "",
                  config: u
                }
              ) }) }) : /* @__PURE__ */ k("div", { className: "h-full w-full flex flex-col items-center justify-center", children: [
                /* @__PURE__ */ P("h3", { className: "text-lg font-semibold text-center mb-4 text-primary", children: t }),
                /* @__PURE__ */ P("div", { className: "mb-6 flex items-center justify-center gap-2 text-sm text-secondary", children: /* @__PURE__ */ k("div", { className: "relative group", children: [
                  /* @__PURE__ */ k("div", { className: "flex items-center gap-2 cursor-help", children: [
                    /* @__PURE__ */ P(kg, { className: "h-4 w-4 text-primary hover:text-secondary transition-colors" }),
                    /* @__PURE__ */ P("span", { children: ne.howItWorks.title })
                  ] }),
                  /* @__PURE__ */ k("div", { className: "absolute left-1 -translate-x-1 bottom-full mb-2 w-64 p-3 bg-white rounded-lg shadow-lg border border-primary/20 opacity-0 invisible group-hover:opacity-100 group-hover:visible transition-all duration-200 z-10", children: [
                    /* @__PURE__ */ P("h4", { className: "font-medium text-primary mb-2", children: ne.howItWorks.title }),
                    ne.howItWorks.steps.map(($, X) => /* @__PURE__ */ k("li", { className: "flex items-start gap-2", children: [
                      /* @__PURE__ */ k("span", { className: "font-bold flex-shrink-0", children: [
                        X + 1,
                        "."
                      ] }),
                      /* @__PURE__ */ P("span", { className: "break-words", children: $ })
                    ] }, X))
                  ] })
                ] }) }),
                /* @__PURE__ */ P("div", { className: "w-64 h-64 md:w-48 md:h-48 rounded-xl overflow-hidden mb-4 bg-gradient-to-br from-neutral to-white border border-primary/20", children: /* @__PURE__ */ P(
                  "img",
                  {
                    src: d?.ImageUrl,
                    alt: d?.Name,
                    className: "w-full h-full object-cover"
                  }
                ) }),
                /* @__PURE__ */ P(
                  ke,
                  {
                    onClick: () => v(!0),
                    className: "w-full bg-primary hover:bg-secondary text-white py-3 px-6 rounded-lg font-semibold shadow-md transition",
                    children: ne.avatar.startConversation
                  }
                )
              ] }) }) }),
              /* @__PURE__ */ P("div", { className: `\r
                 flex flex-col\r
                  basis=[65%] md:basis-auto\r
                  min-h-0\r
                  overflow-y-auto\r
                  p-4 md:p-6\r
                `, children: /* @__PURE__ */ P("div", { className: "flex-1 min-h-0 overflow-y-auto", children: /* @__PURE__ */ P(
                oC,
                {
                  language: i,
                  config: u,
                  setInterruptReplica: st,
                  messages: w,
                  welcomeMessage: o,
                  onSendMessage: Qe,
                  className: "h-full",
                  isLoading: y,
                  rightElement: /* @__PURE__ */ P(df, { fallback: /* @__PURE__ */ P("div", { className: "w-10 h-10 bg-gray-200 rounded animate-pulse" }), children: /* @__PURE__ */ P(
                    rg,
                    {
                      avatarName: d?.Name || "AI Health Navigator",
                      disabled: y,
                      voiceMode: Gt,
                      setSpokenText: it,
                      setIsSpeaking: Ke,
                      setInterruptReplica: st,
                      region: u?.region || "",
                      speechKey: u?.speechKey || ""
                    }
                  ) }),
                  suggestedPrompts: r,
                  renderMessage: ($, X) => {
                    if ($.sender === "ai" && $.id !== "welcome-message") {
                      const V = X === w.length - 1;
                      return /* @__PURE__ */ k("div", { className: "relative", children: [
                        /* @__PURE__ */ P(
                          qa,
                          {
                            remarkPlugins: [$a],
                            components: {
                              p: ({ children: H }) => /* @__PURE__ */ P("p", { className: "text-sm mb-2", children: H }),
                              ol: ({ children: H }) => /* @__PURE__ */ P("ol", { style: { listStyleType: "circle" }, className: "ml-6 mb-2", children: H }),
                              ul: ({ children: H }) => /* @__PURE__ */ P("ul", { className: "list-disc ml-6 mb-2", children: H }),
                              li: ({ children: H }) => /* @__PURE__ */ P("li", { className: "mb-1", children: H }),
                              strong: ({ children: H }) => /* @__PURE__ */ P("strong", { className: "font-semibold", children: H }),
                              a: ({ href: H, children: ze }) => /* @__PURE__ */ P(
                                "a",
                                {
                                  href: H,
                                  target: "_blank",
                                  rel: "noopener noreferrer",
                                  className: "text-blue-600 underline",
                                  children: ze
                                }
                              )
                            },
                            children: $.text
                          }
                        ),
                        /* @__PURE__ */ k("div", { className: "flex justify-end gap-2 mt-2", children: [
                          /* @__PURE__ */ P(
                            "button",
                            {
                              className: `p-1 rounded-full transition-colors ${R[$.id] === "like" ? "bg-green-100 text-green-600" : "hover:bg-gray-200 text-gray-600"}`,
                              onClick: () => As($, "like"),
                              children: /* @__PURE__ */ P(Ng, { className: "h-4 w-4" })
                            }
                          ),
                          /* @__PURE__ */ P(
                            "button",
                            {
                              className: `p-1 rounded-full transition-colors ${R[$.id] === "dislike" ? "bg-red-100 text-red-600" : "hover:bg-gray-200 text-gray-600"}`,
                              onClick: () => As($, "dislike"),
                              children: /* @__PURE__ */ P(xg, { className: "h-4 w-4" })
                            }
                          )
                        ] }),
                        ie && V && /* @__PURE__ */ P("div", { className: "mt-4 flex", children: /* @__PURE__ */ P(
                          "button",
                          {
                            className: "bg-primary hover:bg-secondary text-white px-6 py-3 rounded-lg font-semibold shadow-md transition",
                            onClick: () => {
                              Qe(Ne), K(!1);
                            },
                            children: ne.buttons.retry
                          }
                        ) }),
                        V && U && /* @__PURE__ */ P("div", { className: "mt-4 flex justify-center", children: /* @__PURE__ */ P(
                          "button",
                          {
                            className: "bg-primary hover:bg-secondary text-white px-6 py-3 rounded-lg font-semibold shadow-md transition",
                            onClick: Zt,
                            children: ne.buttons.continue
                          }
                        ) }),
                        V && ee && /* @__PURE__ */ P("div", { className: "mt-4 flex justify-center", children: /* @__PURE__ */ P(
                          "button",
                          {
                            className: "bg-primary hover:bg-secondary text-white px-6 py-3 rounded-lg font-semibold shadow-md transition",
                            onClick: no,
                            children: ne.buttons.signUp
                          }
                        ) }),
                        V && he && /* @__PURE__ */ P("div", { className: "mt-4 flex justify-center", children: /* @__PURE__ */ P(
                          "button",
                          {
                            className: "bg-primary hover:bg-secondary text-white px-6 py-3 rounded-lg font-semibold shadow-md transition",
                            onClick: oe,
                            children: ne.buttons.buyNow
                          }
                        ) })
                      ] });
                    }
                    return /* @__PURE__ */ P(
                      qa,
                      {
                        remarkPlugins: [$a],
                        components: {
                          p: ({ children: V }) => /* @__PURE__ */ P("p", { className: "text-sm whitespace-pre-line", children: V })
                        },
                        children: $.text
                      }
                    );
                  }
                }
              ) }) })
            ] })
          ]
        }
      ) }),
      /* @__PURE__ */ P("div", { className: "absolute -top-4 -right-4 w-72 h-72 bg-primary/20 rounded-full blur-3xl" }),
      /* @__PURE__ */ P("div", { className: "absolute -bottom-8 -left-8 w-96 h-96 bg-secondary/10 rounded-full blur-3xl" })
    ] }) }),
    /* @__PURE__ */ P(
      "input",
      {
        type: "file",
        ref: F,
        onChange: io,
        accept: ".pdf,.doc,.docx,.jpg,.jpeg,.png,.txt",
        style: { display: "none" }
      }
    )
  ] });
}
function MT(e) {
  return /* @__PURE__ */ P(rI, { value: e.config || {}, children: /* @__PURE__ */ P(aI, { ...e }) });
}
const vg = hf(void 0), DT = ({ children: e, value: t }) => /* @__PURE__ */ P(vg.Provider, { value: t, children: e }), NT = () => {
  const e = ff(vg);
  if (!e)
    throw new Error("useConciergeContext must be used within a ConciergeProvider");
  return e;
};
function xT(e, t) {
  const [r, o] = D(() => {
    if (typeof window > "u")
      return t;
    try {
      const a = window.localStorage.getItem(e);
      return a ? JSON.parse(a) : t;
    } catch (a) {
      return console.log(a), t;
    }
  });
  return [r, (a) => {
    try {
      const s = a instanceof Function ? a(r) : a;
      o(s), typeof window < "u" && window.localStorage.setItem(e, JSON.stringify(s));
    } catch (s) {
      console.log(s);
    }
  }];
}
export {
  MT as ConciergeModule,
  aI as ConciergeModuleRaw,
  DT as ConciergeProvider,
  nI as ConversationComponent,
  df as SSRSafeWrapper,
  rg as SpeechComponent,
  NT as useConciergeContext,
  xT as useLocalStorage
};
