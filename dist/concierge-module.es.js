import { jsx as w, jsxs as k, Fragment as et } from "react/jsx-runtime";
import * as Z from "react";
import { useState as O, useRef as We, useEffect as U, useCallback as sc, createContext as gf, useContext as mf, forwardRef as Eg, useImperativeHandle as Ig } from "react";
import { Bot as Rc, RotateCcw as Ag, Loader2 as Fa, ChevronDown as Tg, ChevronUp as _g, Send as kg, Mic as Og, MicOff as Mg, PhoneOff as Dg, CheckCircle as Pc, GraduationCap as xg, Sparkles as Ng, MessageSquare as zg, ThumbsUp as Lg, ThumbsDown as jg } from "lucide-react";
import Ba from "react-markdown";
import * as Ss from "@radix-ui/react-tooltip";
import { motion as qg } from "framer-motion";
import { useVideoTrack as yf, DailyVideo as Fg, useLocalSessionId as Sf, useDaily as Ws, useDevices as Bg, useAudioTrack as Ug, useDailyEvent as $g, useParticipantIds as Vg, useAppMessage as Wg, DailyAudio as Hg, DailyProvider as Kg } from "@daily-co/daily-react";
import { initReactI18next as Jg } from "react-i18next";
import { useMediaQuery as Gg } from "@mui/material";
function wc(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Qg(...e) {
  return (t) => {
    let r = !1;
    const o = e.map((i) => {
      const a = wc(i, t);
      return !r && typeof a == "function" && (r = !0), a;
    });
    if (r)
      return () => {
        for (let i = 0; i < o.length; i++) {
          const a = o[i];
          typeof a == "function" ? a() : wc(e[i], null);
        }
      };
  };
}
// @__NO_SIDE_EFFECTS__
function Yg(e) {
  const t = /* @__PURE__ */ Xg(e), r = Z.forwardRef((o, i) => {
    const { children: a, ...s } = o, n = Z.Children.toArray(a), c = n.find(tm);
    if (c) {
      const u = c.props.children, l = n.map((p) => p === c ? Z.Children.count(u) > 1 ? Z.Children.only(null) : Z.isValidElement(u) ? u.props.children : null : p);
      return /* @__PURE__ */ w(t, { ...s, ref: i, children: Z.isValidElement(u) ? Z.cloneElement(u, void 0, l) : null });
    }
    return /* @__PURE__ */ w(t, { ...s, ref: i, children: a });
  });
  return r.displayName = `${e}.Slot`, r;
}
var Zg = /* @__PURE__ */ Yg("Slot");
// @__NO_SIDE_EFFECTS__
function Xg(e) {
  const t = Z.forwardRef((r, o) => {
    const { children: i, ...a } = r;
    if (Z.isValidElement(i)) {
      const s = nm(i), n = rm(a, i.props);
      return i.type !== Z.Fragment && (n.ref = o ? Qg(o, s) : s), Z.cloneElement(i, n);
    }
    return Z.Children.count(i) > 1 ? Z.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var em = Symbol("radix.slottable");
function tm(e) {
  return Z.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === em;
}
function rm(e, t) {
  const r = { ...t };
  for (const o in t) {
    const i = e[o], a = t[o];
    /^on[A-Z]/.test(o) ? i && a ? r[o] = (...n) => {
      const c = a(...n);
      return i(...n), c;
    } : i && (r[o] = i) : o === "style" ? r[o] = { ...i, ...a } : o === "className" && (r[o] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...r };
}
function nm(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
function Cf(e) {
  var t, r, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = Cf(e[t])) && (o && (o += " "), o += r);
  } else for (r in e) e[r] && (o && (o += " "), o += r);
  return o;
}
function Rf() {
  for (var e, t, r = 0, o = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = Cf(e)) && (o && (o += " "), o += t);
  return o;
}
const bc = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Ec = Rf, im = (e, t) => (r) => {
  var o;
  if (t?.variants == null) return Ec(e, r?.class, r?.className);
  const { variants: i, defaultVariants: a } = t, s = Object.keys(i).map((u) => {
    const l = r?.[u], p = a?.[u];
    if (l === null) return null;
    const h = bc(l) || bc(p);
    return i[u][h];
  }), n = r && Object.entries(r).reduce((u, l) => {
    let [p, h] = l;
    return h === void 0 || (u[p] = h), u;
  }, {}), c = t == null || (o = t.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((u, l) => {
    let { class: p, className: h, ...d } = l;
    return Object.entries(d).every((f) => {
      let [g, m] = f;
      return Array.isArray(m) ? m.includes({
        ...a,
        ...n
      }[g]) : {
        ...a,
        ...n
      }[g] === m;
    }) ? [
      ...u,
      p,
      h
    ] : u;
  }, []);
  return Ec(e, s, c, r?.class, r?.className);
}, oc = "-", sm = (e) => {
  const t = am(e), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: o
  } = e;
  return {
    getClassGroupId: (s) => {
      const n = s.split(oc);
      return n[0] === "" && n.length !== 1 && n.shift(), Pf(n, t) || om(s);
    },
    getConflictingClassGroupIds: (s, n) => {
      const c = r[s] || [];
      return n && o[s] ? [...c, ...o[s]] : c;
    }
  };
}, Pf = (e, t) => {
  if (e.length === 0)
    return t.classGroupId;
  const r = e[0], o = t.nextPart.get(r), i = o ? Pf(e.slice(1), o) : void 0;
  if (i)
    return i;
  if (t.validators.length === 0)
    return;
  const a = e.join(oc);
  return t.validators.find(({
    validator: s
  }) => s(a))?.classGroupId;
}, Ic = /^\[(.+)\]$/, om = (e) => {
  if (Ic.test(e)) {
    const t = Ic.exec(e)[1], r = t?.substring(0, t.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, am = (e) => {
  const {
    theme: t,
    prefix: r
  } = e, o = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return um(Object.entries(e.classGroups), r).forEach(([a, s]) => {
    Ua(s, o, a, t);
  }), o;
}, Ua = (e, t, r, o) => {
  e.forEach((i) => {
    if (typeof i == "string") {
      const a = i === "" ? t : Ac(t, i);
      a.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (cm(i)) {
        Ua(i(o), t, r, o);
        return;
      }
      t.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([a, s]) => {
      Ua(s, Ac(t, a), r, o);
    });
  });
}, Ac = (e, t) => {
  let r = e;
  return t.split(oc).forEach((o) => {
    r.nextPart.has(o) || r.nextPart.set(o, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(o);
  }), r;
}, cm = (e) => e.isThemeGetter, um = (e, t) => t ? e.map(([r, o]) => {
  const i = o.map((a) => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([s, n]) => [t + s, n])) : a);
  return [r, i];
}) : e, lm = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  const i = (a, s) => {
    r.set(a, s), t++, t > e && (t = 0, o = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(a) {
      let s = r.get(a);
      if (s !== void 0)
        return s;
      if ((s = o.get(a)) !== void 0)
        return i(a, s), s;
    },
    set(a, s) {
      r.has(a) ? r.set(a, s) : i(a, s);
    }
  };
}, wf = "!", pm = (e) => {
  const {
    separator: t,
    experimentalParseClassName: r
  } = e, o = t.length === 1, i = t[0], a = t.length, s = (n) => {
    const c = [];
    let u = 0, l = 0, p;
    for (let m = 0; m < n.length; m++) {
      let v = n[m];
      if (u === 0) {
        if (v === i && (o || n.slice(m, m + a) === t)) {
          c.push(n.slice(l, m)), l = m + a;
          continue;
        }
        if (v === "/") {
          p = m;
          continue;
        }
      }
      v === "[" ? u++ : v === "]" && u--;
    }
    const h = c.length === 0 ? n : n.substring(l), d = h.startsWith(wf), f = d ? h.substring(1) : h, g = p && p > l ? p - l : void 0;
    return {
      modifiers: c,
      hasImportantModifier: d,
      baseClassName: f,
      maybePostfixModifierPosition: g
    };
  };
  return r ? (n) => r({
    className: n,
    parseClassName: s
  }) : s;
}, dm = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let r = [];
  return e.forEach((o) => {
    o[0] === "[" ? (t.push(...r.sort(), o), r = []) : r.push(o);
  }), t.push(...r.sort()), t;
}, hm = (e) => ({
  cache: lm(e.cacheSize),
  parseClassName: pm(e),
  ...sm(e)
}), fm = /\s+/, vm = (e, t) => {
  const {
    parseClassName: r,
    getClassGroupId: o,
    getConflictingClassGroupIds: i
  } = t, a = [], s = e.trim().split(fm);
  let n = "";
  for (let c = s.length - 1; c >= 0; c -= 1) {
    const u = s[c], {
      modifiers: l,
      hasImportantModifier: p,
      baseClassName: h,
      maybePostfixModifierPosition: d
    } = r(u);
    let f = !!d, g = o(f ? h.substring(0, d) : h);
    if (!g) {
      if (!f) {
        n = u + (n.length > 0 ? " " + n : n);
        continue;
      }
      if (g = o(h), !g) {
        n = u + (n.length > 0 ? " " + n : n);
        continue;
      }
      f = !1;
    }
    const m = dm(l).join(":"), v = p ? m + wf : m, y = v + g;
    if (a.includes(y))
      continue;
    a.push(y);
    const S = i(g, f);
    for (let C = 0; C < S.length; ++C) {
      const P = S[C];
      a.push(v + P);
    }
    n = u + (n.length > 0 ? " " + n : n);
  }
  return n;
};
function gm() {
  let e = 0, t, r, o = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (r = bf(t)) && (o && (o += " "), o += r);
  return o;
}
const bf = (e) => {
  if (typeof e == "string")
    return e;
  let t, r = "";
  for (let o = 0; o < e.length; o++)
    e[o] && (t = bf(e[o])) && (r && (r += " "), r += t);
  return r;
};
function mm(e, ...t) {
  let r, o, i, a = s;
  function s(c) {
    const u = t.reduce((l, p) => p(l), e());
    return r = hm(u), o = r.cache.get, i = r.cache.set, a = n, n(c);
  }
  function n(c) {
    const u = o(c);
    if (u)
      return u;
    const l = vm(c, r);
    return i(c, l), l;
  }
  return function() {
    return a(gm.apply(null, arguments));
  };
}
const K = (e) => {
  const t = (r) => r[e] || [];
  return t.isThemeGetter = !0, t;
}, Ef = /^\[(?:([a-z-]+):)?(.+)\]$/i, ym = /^\d+\/\d+$/, Sm = /* @__PURE__ */ new Set(["px", "full", "screen"]), Cm = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Rm = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Pm = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, wm = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, bm = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, je = (e) => Vt(e) || Sm.has(e) || ym.test(e), Ge = (e) => Ht(e, "length", Mm), Vt = (e) => !!e && !Number.isNaN(Number(e)), vo = (e) => Ht(e, "number", Vt), tr = (e) => !!e && Number.isInteger(Number(e)), Em = (e) => e.endsWith("%") && Vt(e.slice(0, -1)), L = (e) => Ef.test(e), Qe = (e) => Cm.test(e), Im = /* @__PURE__ */ new Set(["length", "size", "percentage"]), Am = (e) => Ht(e, Im, If), Tm = (e) => Ht(e, "position", If), _m = /* @__PURE__ */ new Set(["image", "url"]), km = (e) => Ht(e, _m, xm), Om = (e) => Ht(e, "", Dm), rr = () => !0, Ht = (e, t, r) => {
  const o = Ef.exec(e);
  return o ? o[1] ? typeof t == "string" ? o[1] === t : t.has(o[1]) : r(o[2]) : !1;
}, Mm = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Rm.test(e) && !Pm.test(e)
), If = () => !1, Dm = (e) => wm.test(e), xm = (e) => bm.test(e), Nm = () => {
  const e = K("colors"), t = K("spacing"), r = K("blur"), o = K("brightness"), i = K("borderColor"), a = K("borderRadius"), s = K("borderSpacing"), n = K("borderWidth"), c = K("contrast"), u = K("grayscale"), l = K("hueRotate"), p = K("invert"), h = K("gap"), d = K("gradientColorStops"), f = K("gradientColorStopPositions"), g = K("inset"), m = K("margin"), v = K("opacity"), y = K("padding"), S = K("saturate"), C = K("scale"), P = K("sepia"), b = K("skew"), A = K("space"), E = K("translate"), D = () => ["auto", "contain", "none"], R = () => ["auto", "hidden", "clip", "visible", "scroll"], j = () => ["auto", L, t], T = () => [L, t], x = () => ["", je, Ge], q = () => ["auto", Vt, L], pe = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], W = () => ["solid", "dashed", "dotted", "double", "none"], G = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], ne = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], oe = () => ["", "0", L], ye = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], V = () => [Vt, L];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [rr],
      spacing: [je, Ge],
      blur: ["none", "", Qe, L],
      brightness: V(),
      borderColor: [e],
      borderRadius: ["none", "", "full", Qe, L],
      borderSpacing: T(),
      borderWidth: x(),
      contrast: V(),
      grayscale: oe(),
      hueRotate: V(),
      invert: oe(),
      gap: T(),
      gradientColorStops: [e],
      gradientColorStopPositions: [Em, Ge],
      inset: j(),
      margin: j(),
      opacity: V(),
      padding: T(),
      saturate: V(),
      scale: V(),
      sepia: oe(),
      skew: V(),
      space: T(),
      translate: T()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", L]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Qe]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": ye()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": ye()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...pe(), L]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: R()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": R()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": R()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: D()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": D()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": D()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", tr, L]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: j()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", L]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: oe()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: oe()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", tr, L]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [rr]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", tr, L]
        }, L]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": q()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": q()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [rr]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [tr, L]
        }, L]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": q()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": q()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", L]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", L]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [h]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [h]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [h]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...ne()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...ne(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...ne(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [y]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [y]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [y]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [y]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [y]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [y]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [y]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [y]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [y]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [m]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [m]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [m]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [m]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [m]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [m]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [m]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [m]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [m]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [A]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [A]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", L, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [L, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [L, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [Qe]
        }, Qe]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [L, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [L, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [L, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [L, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Qe, Ge]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", vo]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [rr]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", L]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Vt, vo]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", je, L]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", L]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", L]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [v]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [v]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...W(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", je, Ge]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", je, L]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: T()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", L]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", L]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [v]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...pe(), Tm]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Am]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, km]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [f]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [f]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [f]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [d]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [d]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [d]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [n]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [n]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [n]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [n]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [n]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [n]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [n]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [n]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [n]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [v]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...W(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [n]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [n]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [v]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: W()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...W()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [je, L]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [je, Ge]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: x()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [v]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [je, Ge]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Qe, Om]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [rr]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [v]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...G(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": G()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [o]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [c]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Qe, L]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [u]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [l]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [S]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [P]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [o]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [c]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [u]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [l]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [v]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [S]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [P]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [s]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [s]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [s]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", L]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: V()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", L]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: V()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", L]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [C]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [C]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [C]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [tr, L]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [E]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [E]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [b]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [b]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", L]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", L]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": T()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": T()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": T()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": T()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": T()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": T()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": T()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": T()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": T()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": T()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": T()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": T()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": T()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": T()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": T()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": T()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": T()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": T()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", L]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [je, Ge, vo]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, zm = /* @__PURE__ */ mm(Nm);
function Pe(...e) {
  return zm(Rf(e));
}
const Lm = im(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Wt = Z.forwardRef(
  ({ className: e, variant: t, size: r, asChild: o = !1, ...i }, a) => /* @__PURE__ */ w(
    o ? Zg : "button",
    {
      className: Pe(Lm({ variant: t, size: r, className: e })),
      ref: a,
      ...i
    }
  )
);
Wt.displayName = "Button";
function Tc(e, t) {
  const r = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let o = 0, i = r.indexOf(t);
  for (; i !== -1; )
    o++, i = r.indexOf(t, i + t.length);
  return o;
}
const hs = Ks(/[A-Za-z]/), ac = Ks(/[\dA-Za-z]/);
function jm(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
function $t(e) {
  return e !== null && e < -2;
}
function fe(e) {
  return e !== null && (e < 0 || e === 32);
}
function $e(e) {
  return e === -2 || e === -1 || e === 32;
}
const Hs = Ks(new RegExp("\\p{P}|\\p{S}", "u")), xt = Ks(/\s/);
function Ks(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function qm(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const Js = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return $m;
    if (typeof e == "function")
      return Gs(e);
    if (typeof e == "object")
      return Array.isArray(e) ? Fm(e) : Bm(e);
    if (typeof e == "string")
      return Um(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function Fm(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = Js(e[r]);
  return Gs(o);
  function o(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function Bm(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Gs(r);
  function r(o) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      o
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function Um(e) {
  return Gs(t);
  function t(r) {
    return r && r.type === e;
  }
}
function Gs(e) {
  return t;
  function t(r, o, i) {
    return !!(Vm(r) && e.call(
      this,
      r,
      typeof o == "number" ? o : void 0,
      i || void 0
    ));
  }
}
function $m() {
  return !0;
}
function Vm(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const Af = [], Wm = !0, $a = !1, Hm = "skip";
function Tf(e, t, r, o) {
  let i;
  typeof t == "function" && typeof r != "function" ? (o = r, r = t) : i = t;
  const a = Js(i), s = o ? -1 : 1;
  n(e, void 0, [])();
  function n(c, u, l) {
    const p = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof p.type == "string") {
      const d = (
        // `hast`
        typeof p.tagName == "string" ? p.tagName : (
          // `xast`
          typeof p.name == "string" ? p.name : void 0
        )
      );
      Object.defineProperty(h, "name", {
        value: "node (" + (c.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return h;
    function h() {
      let d = Af, f, g, m;
      if ((!t || a(c, u, l[l.length - 1] || void 0)) && (d = Km(r(c, l)), d[0] === $a))
        return d;
      if ("children" in c && c.children) {
        const v = (
          /** @type {UnistParent} */
          c
        );
        if (v.children && d[0] !== Hm)
          for (g = (o ? v.children.length : -1) + s, m = l.concat(v); g > -1 && g < v.children.length; ) {
            const y = v.children[g];
            if (f = n(y, g, m)(), f[0] === $a)
              return f;
            g = typeof f[1] == "number" ? f[1] : g + s;
          }
      }
      return d;
    }
  }
}
function Km(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [Wm, e] : e == null ? Af : [e];
}
function Jm(e, t, r) {
  const i = Js((r || {}).ignore || []), a = Gm(t);
  let s = -1;
  for (; ++s < a.length; )
    Tf(e, "text", n);
  function n(u, l) {
    let p = -1, h;
    for (; ++p < l.length; ) {
      const d = l[p], f = h ? h.children : void 0;
      if (i(
        d,
        f ? f.indexOf(d) : void 0,
        h
      ))
        return;
      h = d;
    }
    if (h)
      return c(u, l);
  }
  function c(u, l) {
    const p = l[l.length - 1], h = a[s][0], d = a[s][1];
    let f = 0;
    const m = p.children.indexOf(u);
    let v = !1, y = [];
    h.lastIndex = 0;
    let S = h.exec(u.value);
    for (; S; ) {
      const C = S.index, P = {
        index: S.index,
        input: S.input,
        stack: [...l, u]
      };
      let b = d(...S, P);
      if (typeof b == "string" && (b = b.length > 0 ? { type: "text", value: b } : void 0), b === !1 ? h.lastIndex = C + 1 : (f !== C && y.push({
        type: "text",
        value: u.value.slice(f, C)
      }), Array.isArray(b) ? y.push(...b) : b && y.push(b), f = C + S[0].length, v = !0), !h.global)
        break;
      S = h.exec(u.value);
    }
    return v ? (f < u.value.length && y.push({ type: "text", value: u.value.slice(f) }), p.children.splice(m, 1, ...y)) : y = [u], m + y.length;
  }
}
function Gm(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const r = !e[0] || Array.isArray(e[0]) ? e : [e];
  let o = -1;
  for (; ++o < r.length; ) {
    const i = r[o];
    t.push([Qm(i[0]), Ym(i[1])]);
  }
  return t;
}
function Qm(e) {
  return typeof e == "string" ? new RegExp(qm(e), "g") : e;
}
function Ym(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const go = "phrasing", mo = ["autolink", "link", "image", "label"];
function Zm() {
  return {
    transforms: [sy],
    enter: {
      literalAutolink: ey,
      literalAutolinkEmail: yo,
      literalAutolinkHttp: yo,
      literalAutolinkWww: yo
    },
    exit: {
      literalAutolink: iy,
      literalAutolinkEmail: ny,
      literalAutolinkHttp: ty,
      literalAutolinkWww: ry
    }
  };
}
function Xm() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: go,
        notInConstruct: mo
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: go,
        notInConstruct: mo
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: go,
        notInConstruct: mo
      }
    ]
  };
}
function ey(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function yo(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function ty(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function ry(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function ny(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function iy(e) {
  this.exit(e);
}
function sy(e) {
  Jm(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, oy],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), ay]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function oy(e, t, r, o, i) {
  let a = "";
  if (!_f(i) || (/^w/i.test(t) && (r = t + r, t = "", a = "http://"), !cy(r)))
    return !1;
  const s = uy(r + o);
  if (!s[0]) return !1;
  const n = {
    type: "link",
    title: null,
    url: a + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [n, { type: "text", value: s[1] }] : n;
}
function ay(e, t, r, o) {
  return (
    // Not an expected previous character.
    !_f(o, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(r) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + r,
      children: [{ type: "text", value: t + "@" + r }]
    }
  );
}
function cy(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function uy(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let r = t[0], o = r.indexOf(")");
  const i = Tc(e, "(");
  let a = Tc(e, ")");
  for (; o !== -1 && i > a; )
    e += r.slice(0, o + 1), r = r.slice(o + 1), o = r.indexOf(")"), a++;
  return [e, r];
}
function _f(e, t) {
  const r = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || xt(r) || Hs(r)) && // If it’s an email, the previous character should not be a slash.
  (!t || r !== 47);
}
function Cs(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
kf.peek = yy;
function ly() {
  this.buffer();
}
function py(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function dy() {
  this.buffer();
}
function hy(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function fy(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = Cs(
    this.sliceSerialize(e)
  ).toLowerCase(), r.label = t;
}
function vy(e) {
  this.exit(e);
}
function gy(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = Cs(
    this.sliceSerialize(e)
  ).toLowerCase(), r.label = t;
}
function my(e) {
  this.exit(e);
}
function yy() {
  return "[";
}
function kf(e, t, r, o) {
  const i = r.createTracker(o);
  let a = i.move("[^");
  const s = r.enter("footnoteReference"), n = r.enter("reference");
  return a += i.move(
    r.safe(r.associationId(e), { after: "]", before: a })
  ), n(), s(), a += i.move("]"), a;
}
function Sy() {
  return {
    enter: {
      gfmFootnoteCallString: ly,
      gfmFootnoteCall: py,
      gfmFootnoteDefinitionLabelString: dy,
      gfmFootnoteDefinition: hy
    },
    exit: {
      gfmFootnoteCallString: fy,
      gfmFootnoteCall: vy,
      gfmFootnoteDefinitionLabelString: gy,
      gfmFootnoteDefinition: my
    }
  };
}
function Cy(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: r, footnoteReference: kf },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function r(o, i, a, s) {
    const n = a.createTracker(s);
    let c = n.move("[^");
    const u = a.enter("footnoteDefinition"), l = a.enter("label");
    return c += n.move(
      a.safe(a.associationId(o), { before: c, after: "]" })
    ), l(), c += n.move("]:"), o.children && o.children.length > 0 && (n.shift(4), c += n.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(o, n.current()),
        t ? Of : Ry
      )
    )), u(), c;
  }
}
function Ry(e, t, r) {
  return t === 0 ? e : Of(e, t, r);
}
function Of(e, t, r) {
  return (r ? "" : "    ") + e;
}
const Py = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Mf.peek = Ay;
function wy() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Ey },
    exit: { strikethrough: Iy }
  };
}
function by() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Py
      }
    ],
    handlers: { delete: Mf }
  };
}
function Ey(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Iy(e) {
  this.exit(e);
}
function Mf(e, t, r, o) {
  const i = r.createTracker(o), a = r.enter("strikethrough");
  let s = i.move("~~");
  return s += r.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), a(), s;
}
function Ay() {
  return "~";
}
function Ty(e) {
  return e.length;
}
function _y(e, t) {
  const r = t || {}, o = (r.align || []).concat(), i = r.stringLength || Ty, a = [], s = [], n = [], c = [];
  let u = 0, l = -1;
  for (; ++l < e.length; ) {
    const g = [], m = [];
    let v = -1;
    for (e[l].length > u && (u = e[l].length); ++v < e[l].length; ) {
      const y = ky(e[l][v]);
      if (r.alignDelimiters !== !1) {
        const S = i(y);
        m[v] = S, (c[v] === void 0 || S > c[v]) && (c[v] = S);
      }
      g.push(y);
    }
    s[l] = g, n[l] = m;
  }
  let p = -1;
  if (typeof o == "object" && "length" in o)
    for (; ++p < u; )
      a[p] = _c(o[p]);
  else {
    const g = _c(o);
    for (; ++p < u; )
      a[p] = g;
  }
  p = -1;
  const h = [], d = [];
  for (; ++p < u; ) {
    const g = a[p];
    let m = "", v = "";
    g === 99 ? (m = ":", v = ":") : g === 108 ? m = ":" : g === 114 && (v = ":");
    let y = r.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[p] - m.length - v.length
    );
    const S = m + "-".repeat(y) + v;
    r.alignDelimiters !== !1 && (y = m.length + y + v.length, y > c[p] && (c[p] = y), d[p] = y), h[p] = S;
  }
  s.splice(1, 0, h), n.splice(1, 0, d), l = -1;
  const f = [];
  for (; ++l < s.length; ) {
    const g = s[l], m = n[l];
    p = -1;
    const v = [];
    for (; ++p < u; ) {
      const y = g[p] || "";
      let S = "", C = "";
      if (r.alignDelimiters !== !1) {
        const P = c[p] - (m[p] || 0), b = a[p];
        b === 114 ? S = " ".repeat(P) : b === 99 ? P % 2 ? (S = " ".repeat(P / 2 + 0.5), C = " ".repeat(P / 2 - 0.5)) : (S = " ".repeat(P / 2), C = S) : C = " ".repeat(P);
      }
      r.delimiterStart !== !1 && !p && v.push("|"), r.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(r.alignDelimiters === !1 && y === "") && (r.delimiterStart !== !1 || p) && v.push(" "), r.alignDelimiters !== !1 && v.push(S), v.push(y), r.alignDelimiters !== !1 && v.push(C), r.padding !== !1 && v.push(" "), (r.delimiterEnd !== !1 || p !== u - 1) && v.push("|");
    }
    f.push(
      r.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join("")
    );
  }
  return f.join(`
`);
}
function ky(e) {
  return e == null ? "" : String(e);
}
function _c(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function Oy(e, t, r, o) {
  const i = r.enter("blockquote"), a = r.createTracker(o);
  a.move("> "), a.shift(2);
  const s = r.indentLines(
    r.containerFlow(e, a.current()),
    My
  );
  return i(), s;
}
function My(e, t, r) {
  return ">" + (r ? "" : " ") + e;
}
function Dy(e, t) {
  return kc(e, t.inConstruct, !0) && !kc(e, t.notInConstruct, !1);
}
function kc(e, t, r) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return r;
  let o = -1;
  for (; ++o < t.length; )
    if (e.includes(t[o]))
      return !0;
  return !1;
}
function Oc(e, t, r, o) {
  let i = -1;
  for (; ++i < r.unsafe.length; )
    if (r.unsafe[i].character === `
` && Dy(r.stack, r.unsafe[i]))
      return /[ \t]/.test(o.before) ? "" : " ";
  return `\\
`;
}
function xy(e, t) {
  const r = String(e);
  let o = r.indexOf(t), i = o, a = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; o !== -1; )
    o === i ? ++a > s && (s = a) : a = 1, i = o + t.length, o = r.indexOf(t, i);
  return s;
}
function Ny(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function zy(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Ly(e, t, r, o) {
  const i = zy(r), a = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (Ny(e, r)) {
    const p = r.enter("codeIndented"), h = r.indentLines(a, jy);
    return p(), h;
  }
  const n = r.createTracker(o), c = i.repeat(Math.max(xy(a, i) + 1, 3)), u = r.enter("codeFenced");
  let l = n.move(c);
  if (e.lang) {
    const p = r.enter(`codeFencedLang${s}`);
    l += n.move(
      r.safe(e.lang, {
        before: l,
        after: " ",
        encode: ["`"],
        ...n.current()
      })
    ), p();
  }
  if (e.lang && e.meta) {
    const p = r.enter(`codeFencedMeta${s}`);
    l += n.move(" "), l += n.move(
      r.safe(e.meta, {
        before: l,
        after: `
`,
        encode: ["`"],
        ...n.current()
      })
    ), p();
  }
  return l += n.move(`
`), a && (l += n.move(a + `
`)), l += n.move(c), u(), l;
}
function jy(e, t, r) {
  return (r ? "" : "    ") + e;
}
function cc(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function qy(e, t, r, o) {
  const i = cc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.enter("definition");
  let n = r.enter("label");
  const c = r.createTracker(o);
  let u = c.move("[");
  return u += c.move(
    r.safe(r.associationId(e), {
      before: u,
      after: "]",
      ...c.current()
    })
  ), u += c.move("]: "), n(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (n = r.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    r.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (n = r.enter("destinationRaw"), u += c.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), n(), e.title && (n = r.enter(`title${a}`), u += c.move(" " + i), u += c.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), n()), s(), u;
}
function Fy(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function fs(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function js(e) {
  if (e === null || fe(e) || xt(e))
    return 1;
  if (Hs(e))
    return 2;
}
function qs(e, t, r) {
  const o = js(e), i = js(t);
  return o === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    r === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : o === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Df.peek = By;
function Df(e, t, r, o) {
  const i = Fy(r), a = r.enter("emphasis"), s = r.createTracker(o), n = s.move(i);
  let c = s.move(
    r.containerPhrasing(e, {
      after: i,
      before: n,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), l = qs(
    o.before.charCodeAt(o.before.length - 1),
    u,
    i
  );
  l.inside && (c = fs(u) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), h = qs(o.after.charCodeAt(0), p, i);
  h.inside && (c = c.slice(0, -1) + fs(p));
  const d = s.move(i);
  return a(), r.attentionEncodeSurroundingInfo = {
    after: h.outside,
    before: l.outside
  }, n + c + d;
}
function By(e, t, r) {
  return r.options.emphasis || "*";
}
function Uy(e, t, r, o) {
  let i, a, s;
  typeof t == "function" && typeof r != "function" ? (a = void 0, s = t, i = r) : (a = t, s = r, i = o), Tf(e, a, n, i);
  function n(c, u) {
    const l = u[u.length - 1], p = l ? l.children.indexOf(c) : void 0;
    return s(c, p, l);
  }
}
const $y = {};
function xf(e, t) {
  const r = $y, o = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, i = typeof r.includeHtml == "boolean" ? r.includeHtml : !0;
  return Nf(e, o, i);
}
function Nf(e, t, r) {
  if (Vy(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Mc(e.children, t, r);
  }
  return Array.isArray(e) ? Mc(e, t, r) : "";
}
function Mc(e, t, r) {
  const o = [];
  let i = -1;
  for (; ++i < e.length; )
    o[i] = Nf(e[i], t, r);
  return o.join("");
}
function Vy(e) {
  return !!(e && typeof e == "object");
}
function Wy(e, t) {
  let r = !1;
  return Uy(e, function(o) {
    if ("value" in o && /\r?\n|\r/.test(o.value) || o.type === "break")
      return r = !0, $a;
  }), !!((!e.depth || e.depth < 3) && xf(e) && (t.options.setext || r));
}
function Hy(e, t, r, o) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = r.createTracker(o);
  if (Wy(e, r)) {
    const l = r.enter("headingSetext"), p = r.enter("phrasing"), h = r.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return p(), l(), h + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      h.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(h.lastIndexOf("\r"), h.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), n = r.enter("headingAtx"), c = r.enter("phrasing");
  a.move(s + " ");
  let u = r.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(u) && (u = fs(u.charCodeAt(0)) + u.slice(1)), u = u ? s + " " + u : s, r.options.closeAtx && (u += " " + s), c(), n(), u;
}
zf.peek = Ky;
function zf(e) {
  return e.value || "";
}
function Ky() {
  return "<";
}
Lf.peek = Jy;
function Lf(e, t, r, o) {
  const i = cc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.enter("image");
  let n = r.enter("label");
  const c = r.createTracker(o);
  let u = c.move("![");
  return u += c.move(
    r.safe(e.alt, { before: u, after: "]", ...c.current() })
  ), u += c.move("]("), n(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (n = r.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    r.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (n = r.enter("destinationRaw"), u += c.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), n(), e.title && (n = r.enter(`title${a}`), u += c.move(" " + i), u += c.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), n()), u += c.move(")"), s(), u;
}
function Jy() {
  return "!";
}
jf.peek = Gy;
function jf(e, t, r, o) {
  const i = e.referenceType, a = r.enter("imageReference");
  let s = r.enter("label");
  const n = r.createTracker(o);
  let c = n.move("![");
  const u = r.safe(e.alt, {
    before: c,
    after: "]",
    ...n.current()
  });
  c += n.move(u + "]["), s();
  const l = r.stack;
  r.stack = [], s = r.enter("reference");
  const p = r.safe(r.associationId(e), {
    before: c,
    after: "]",
    ...n.current()
  });
  return s(), r.stack = l, a(), i === "full" || !u || u !== p ? c += n.move(p + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += n.move("]"), c;
}
function Gy() {
  return "!";
}
qf.peek = Qy;
function qf(e, t, r) {
  let o = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(o); )
    i += "`";
  for (/[^ \r\n]/.test(o) && (/^[ \r\n]/.test(o) && /[ \r\n]$/.test(o) || /^`|`$/.test(o)) && (o = " " + o + " "); ++a < r.unsafe.length; ) {
    const s = r.unsafe[a], n = r.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = n.exec(o); ) {
        let u = c.index;
        o.charCodeAt(u) === 10 && o.charCodeAt(u - 1) === 13 && u--, o = o.slice(0, u) + " " + o.slice(c.index + 1);
      }
  }
  return i + o + i;
}
function Qy() {
  return "`";
}
function Ff(e, t) {
  const r = xf(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (r === e.url || "mailto:" + r === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
Bf.peek = Yy;
function Bf(e, t, r, o) {
  const i = cc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.createTracker(o);
  let n, c;
  if (Ff(e, r)) {
    const l = r.stack;
    r.stack = [], n = r.enter("autolink");
    let p = s.move("<");
    return p += s.move(
      r.containerPhrasing(e, {
        before: p,
        after: ">",
        ...s.current()
      })
    ), p += s.move(">"), n(), r.stack = l, p;
  }
  n = r.enter("link"), c = r.enter("label");
  let u = s.move("[");
  return u += s.move(
    r.containerPhrasing(e, {
      before: u,
      after: "](",
      ...s.current()
    })
  ), u += s.move("]("), c(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = r.enter("destinationLiteral"), u += s.move("<"), u += s.move(
    r.safe(e.url, { before: u, after: ">", ...s.current() })
  ), u += s.move(">")) : (c = r.enter("destinationRaw"), u += s.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = r.enter(`title${a}`), u += s.move(" " + i), u += s.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...s.current()
    })
  ), u += s.move(i), c()), u += s.move(")"), n(), u;
}
function Yy(e, t, r) {
  return Ff(e, r) ? "<" : "[";
}
Uf.peek = Zy;
function Uf(e, t, r, o) {
  const i = e.referenceType, a = r.enter("linkReference");
  let s = r.enter("label");
  const n = r.createTracker(o);
  let c = n.move("[");
  const u = r.containerPhrasing(e, {
    before: c,
    after: "]",
    ...n.current()
  });
  c += n.move(u + "]["), s();
  const l = r.stack;
  r.stack = [], s = r.enter("reference");
  const p = r.safe(r.associationId(e), {
    before: c,
    after: "]",
    ...n.current()
  });
  return s(), r.stack = l, a(), i === "full" || !u || u !== p ? c += n.move(p + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += n.move("]"), c;
}
function Zy() {
  return "[";
}
function uc(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function Xy(e) {
  const t = uc(e), r = e.options.bulletOther;
  if (!r)
    return t === "*" ? "-" : "*";
  if (r !== "*" && r !== "+" && r !== "-")
    throw new Error(
      "Cannot serialize items with `" + r + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (r === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + r + "`) to be different"
    );
  return r;
}
function eS(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function $f(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function tS(e, t, r, o) {
  const i = r.enter("list"), a = r.bulletCurrent;
  let s = e.ordered ? eS(r) : uc(r);
  const n = e.ordered ? s === "." ? ")" : "." : Xy(r);
  let c = t && r.bulletLastUsed ? s === r.bulletLastUsed : !1;
  if (!e.ordered) {
    const l = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      l && (!l.children || !l.children[0]) && // Directly in two other list items:
      r.stack[r.stack.length - 1] === "list" && r.stack[r.stack.length - 2] === "listItem" && r.stack[r.stack.length - 3] === "list" && r.stack[r.stack.length - 4] === "listItem" && // That are each the first child.
      r.indexStack[r.indexStack.length - 1] === 0 && r.indexStack[r.indexStack.length - 2] === 0 && r.indexStack[r.indexStack.length - 3] === 0 && (c = !0), $f(r) === s && l
    ) {
      let p = -1;
      for (; ++p < e.children.length; ) {
        const h = e.children[p];
        if (h && h.type === "listItem" && h.children && h.children[0] && h.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = n), r.bulletCurrent = s;
  const u = r.containerFlow(e, o);
  return r.bulletLastUsed = s, r.bulletCurrent = a, i(), u;
}
function rS(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function nS(e, t, r, o) {
  const i = rS(r);
  let a = r.bulletCurrent || uc(r);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (r.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let s = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const n = r.createTracker(o);
  n.move(a + " ".repeat(s - a.length)), n.shift(s);
  const c = r.enter("listItem"), u = r.indentLines(
    r.containerFlow(e, n.current()),
    l
  );
  return c(), u;
  function l(p, h, d) {
    return h ? (d ? "" : " ".repeat(s)) + p : (d ? a : a + " ".repeat(s - a.length)) + p;
  }
}
function iS(e, t, r, o) {
  const i = r.enter("paragraph"), a = r.enter("phrasing"), s = r.containerPhrasing(e, o);
  return a(), i(), s;
}
const sS = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Js([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function oS(e, t, r, o) {
  return (e.children.some(function(s) {
    return sS(s);
  }) ? r.containerPhrasing : r.containerFlow).call(r, e, o);
}
function aS(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
Vf.peek = cS;
function Vf(e, t, r, o) {
  const i = aS(r), a = r.enter("strong"), s = r.createTracker(o), n = s.move(i + i);
  let c = s.move(
    r.containerPhrasing(e, {
      after: i,
      before: n,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), l = qs(
    o.before.charCodeAt(o.before.length - 1),
    u,
    i
  );
  l.inside && (c = fs(u) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), h = qs(o.after.charCodeAt(0), p, i);
  h.inside && (c = c.slice(0, -1) + fs(p));
  const d = s.move(i + i);
  return a(), r.attentionEncodeSurroundingInfo = {
    after: h.outside,
    before: l.outside
  }, n + c + d;
}
function cS(e, t, r) {
  return r.options.strong || "*";
}
function uS(e, t, r, o) {
  return r.safe(e.value, o);
}
function lS(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function pS(e, t, r) {
  const o = ($f(r) + (r.options.ruleSpaces ? " " : "")).repeat(lS(r));
  return r.options.ruleSpaces ? o.slice(0, -1) : o;
}
const Wf = {
  blockquote: Oy,
  break: Oc,
  code: Ly,
  definition: qy,
  emphasis: Df,
  hardBreak: Oc,
  heading: Hy,
  html: zf,
  image: Lf,
  imageReference: jf,
  inlineCode: qf,
  link: Bf,
  linkReference: Uf,
  list: tS,
  listItem: nS,
  paragraph: iS,
  root: oS,
  strong: Vf,
  text: uS,
  thematicBreak: pS
};
function dS() {
  return {
    enter: {
      table: hS,
      tableData: Dc,
      tableHeader: Dc,
      tableRow: vS
    },
    exit: {
      codeText: gS,
      table: fS,
      tableData: So,
      tableHeader: So,
      tableRow: So
    }
  };
}
function hS(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(r) {
        return r === "none" ? null : r;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function fS(e) {
  this.exit(e), this.data.inTable = void 0;
}
function vS(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function So(e) {
  this.exit(e);
}
function Dc(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function gS(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, mS));
  const r = this.stack[this.stack.length - 1];
  r.type, r.value = t, this.exit(e);
}
function mS(e, t) {
  return t === "|" ? t : e;
}
function yS(e) {
  const t = e || {}, r = t.tableCellPadding, o = t.tablePipeAlign, i = t.stringLength, a = r ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: h,
      table: s,
      tableCell: c,
      tableRow: n
    }
  };
  function s(d, f, g, m) {
    return u(l(d, g, m), d.align);
  }
  function n(d, f, g, m) {
    const v = p(d, g, m), y = u([v]);
    return y.slice(0, y.indexOf(`
`));
  }
  function c(d, f, g, m) {
    const v = g.enter("tableCell"), y = g.enter("phrasing"), S = g.containerPhrasing(d, {
      ...m,
      before: a,
      after: a
    });
    return y(), v(), S;
  }
  function u(d, f) {
    return _y(d, {
      align: f,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: o,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function l(d, f, g) {
    const m = d.children;
    let v = -1;
    const y = [], S = f.enter("table");
    for (; ++v < m.length; )
      y[v] = p(m[v], f, g);
    return S(), y;
  }
  function p(d, f, g) {
    const m = d.children;
    let v = -1;
    const y = [], S = f.enter("tableRow");
    for (; ++v < m.length; )
      y[v] = c(m[v], d, f, g);
    return S(), y;
  }
  function h(d, f, g) {
    let m = Wf.inlineCode(d, f, g);
    return g.stack.includes("tableCell") && (m = m.replace(/\|/g, "\\$&")), m;
  }
}
function SS() {
  return {
    exit: {
      taskListCheckValueChecked: xc,
      taskListCheckValueUnchecked: xc,
      paragraph: RS
    }
  };
}
function CS() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: PS }
  };
}
function xc(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function RS(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const r = this.stack[this.stack.length - 1];
    r.type;
    const o = r.children[0];
    if (o && o.type === "text") {
      const i = t.children;
      let a = -1, s;
      for (; ++a < i.length; ) {
        const n = i[a];
        if (n.type === "paragraph") {
          s = n;
          break;
        }
      }
      s === r && (o.value = o.value.slice(1), o.value.length === 0 ? r.children.shift() : r.position && o.position && typeof o.position.start.offset == "number" && (o.position.start.column++, o.position.start.offset++, r.position.start = Object.assign({}, o.position.start)));
    }
  }
  this.exit(e);
}
function PS(e, t, r, o) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", n = r.createTracker(o);
  a && n.move(s);
  let c = Wf.listItem(e, t, r, {
    ...o,
    ...n.current()
  });
  return a && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
  function u(l) {
    return l + s;
  }
}
function wS() {
  return [
    Zm(),
    Sy(),
    wy(),
    dS(),
    SS()
  ];
}
function bS(e) {
  return {
    extensions: [
      Xm(),
      Cy(e),
      by(),
      yS(e),
      CS()
    ]
  };
}
function Ns(e, t, r, o) {
  const i = e.length;
  let a = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, r = r > 0 ? r : 0, o.length < 1e4)
    s = Array.from(o), s.unshift(t, r), e.splice(...s);
  else
    for (r && e.splice(t, r); a < o.length; )
      s = o.slice(a, a + 1e4), s.unshift(t, 0), e.splice(...s), a += 1e4, t += 1e4;
}
const Nc = {}.hasOwnProperty;
function ES(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    IS(t, e[r]);
  return t;
}
function IS(e, t) {
  let r;
  for (r in t) {
    const i = (Nc.call(e, r) ? e[r] : void 0) || (e[r] = {}), a = t[r];
    let s;
    if (a)
      for (s in a) {
        Nc.call(i, s) || (i[s] = []);
        const n = a[s];
        AS(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(n) ? n : n ? [n] : []
        );
      }
  }
}
function AS(e, t) {
  let r = -1;
  const o = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : o).push(t[r]);
  Ns(e, 0, 0, o);
}
const TS = {
  tokenize: xS,
  partial: !0
}, Hf = {
  tokenize: NS,
  partial: !0
}, Kf = {
  tokenize: zS,
  partial: !0
}, Jf = {
  tokenize: LS,
  partial: !0
}, _S = {
  tokenize: jS,
  partial: !0
}, Gf = {
  name: "wwwAutolink",
  tokenize: MS,
  previous: Yf
}, Qf = {
  name: "protocolAutolink",
  tokenize: DS,
  previous: Zf
}, He = {
  name: "emailAutolink",
  tokenize: OS,
  previous: Xf
}, De = {};
function kS() {
  return {
    text: De
  };
}
let at = 48;
for (; at < 123; )
  De[at] = He, at++, at === 58 ? at = 65 : at === 91 && (at = 97);
De[43] = He;
De[45] = He;
De[46] = He;
De[95] = He;
De[72] = [He, Qf];
De[104] = [He, Qf];
De[87] = [He, Gf];
De[119] = [He, Gf];
function OS(e, t, r) {
  const o = this;
  let i, a;
  return s;
  function s(p) {
    return !Va(p) || !Xf.call(o, o.previous) || lc(o.events) ? r(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), n(p));
  }
  function n(p) {
    return Va(p) ? (e.consume(p), n) : p === 64 ? (e.consume(p), c) : r(p);
  }
  function c(p) {
    return p === 46 ? e.check(_S, l, u)(p) : p === 45 || p === 95 || ac(p) ? (a = !0, e.consume(p), c) : l(p);
  }
  function u(p) {
    return e.consume(p), i = !0, c;
  }
  function l(p) {
    return a && i && hs(o.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : r(p);
  }
}
function MS(e, t, r) {
  const o = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !Yf.call(o, o.previous) || lc(o.events) ? r(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(TS, e.attempt(Hf, e.attempt(Kf, a), r), r)(s));
  }
  function a(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function DS(e, t, r) {
  const o = this;
  let i = "", a = !1;
  return s;
  function s(p) {
    return (p === 72 || p === 104) && Zf.call(o, o.previous) && !lc(o.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(p), e.consume(p), n) : r(p);
  }
  function n(p) {
    if (hs(p) && i.length < 5)
      return i += String.fromCodePoint(p), e.consume(p), n;
    if (p === 58) {
      const h = i.toLowerCase();
      if (h === "http" || h === "https")
        return e.consume(p), c;
    }
    return r(p);
  }
  function c(p) {
    return p === 47 ? (e.consume(p), a ? u : (a = !0, c)) : r(p);
  }
  function u(p) {
    return p === null || jm(p) || fe(p) || xt(p) || Hs(p) ? r(p) : e.attempt(Hf, e.attempt(Kf, l), r)(p);
  }
  function l(p) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
  }
}
function xS(e, t, r) {
  let o = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && o < 3 ? (o++, e.consume(s), i) : s === 46 && o === 3 ? (e.consume(s), a) : r(s);
  }
  function a(s) {
    return s === null ? r(s) : t(s);
  }
}
function NS(e, t, r) {
  let o, i, a;
  return s;
  function s(u) {
    return u === 46 || u === 95 ? e.check(Jf, c, n)(u) : u === null || fe(u) || xt(u) || u !== 45 && Hs(u) ? c(u) : (a = !0, e.consume(u), s);
  }
  function n(u) {
    return u === 95 ? o = !0 : (i = o, o = void 0), e.consume(u), s;
  }
  function c(u) {
    return i || o || !a ? r(u) : t(u);
  }
}
function zS(e, t) {
  let r = 0, o = 0;
  return i;
  function i(s) {
    return s === 40 ? (r++, e.consume(s), i) : s === 41 && o < r ? a(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(Jf, t, a)(s) : s === null || fe(s) || xt(s) ? t(s) : (e.consume(s), i);
  }
  function a(s) {
    return s === 41 && o++, e.consume(s), i;
  }
}
function LS(e, t, r) {
  return o;
  function o(n) {
    return n === 33 || n === 34 || n === 39 || n === 41 || n === 42 || n === 44 || n === 46 || n === 58 || n === 59 || n === 63 || n === 95 || n === 126 ? (e.consume(n), o) : n === 38 ? (e.consume(n), a) : n === 93 ? (e.consume(n), i) : (
      // `<` is an end.
      n === 60 || // So is whitespace.
      n === null || fe(n) || xt(n) ? t(n) : r(n)
    );
  }
  function i(n) {
    return n === null || n === 40 || n === 91 || fe(n) || xt(n) ? t(n) : o(n);
  }
  function a(n) {
    return hs(n) ? s(n) : r(n);
  }
  function s(n) {
    return n === 59 ? (e.consume(n), o) : hs(n) ? (e.consume(n), s) : r(n);
  }
}
function jS(e, t, r) {
  return o;
  function o(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return ac(a) ? r(a) : t(a);
  }
}
function Yf(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || fe(e);
}
function Zf(e) {
  return !hs(e);
}
function Xf(e) {
  return !(e === 47 || Va(e));
}
function Va(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || ac(e);
}
function lc(e) {
  let t = e.length, r = !1;
  for (; t--; ) {
    const o = e[t][1];
    if ((o.type === "labelLink" || o.type === "labelImage") && !o._balanced) {
      r = !0;
      break;
    }
    if (o._gfmAutolinkLiteralWalkedInto) {
      r = !1;
      break;
    }
  }
  return e.length > 0 && !r && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), r;
}
function qS(e, t, r) {
  const o = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !o.includes(a) && (t = a(t, r), o.push(a));
  }
  return t;
}
function Ve(e, t, r, o) {
  const i = o ? o - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return s;
  function s(c) {
    return $e(c) ? (e.enter(r), n(c)) : t(c);
  }
  function n(c) {
    return $e(c) && a++ < i ? (e.consume(c), n) : (e.exit(r), t(c));
  }
}
const FS = {
  partial: !0,
  tokenize: BS
};
function BS(e, t, r) {
  return o;
  function o(a) {
    return $e(a) ? Ve(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || $t(a) ? t(a) : r(a);
  }
}
const US = {
  tokenize: QS,
  partial: !0
};
function $S() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: KS,
        continuation: {
          tokenize: JS
        },
        exit: GS
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: HS
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: VS,
        resolveTo: WS
      }
    }
  };
}
function VS(e, t, r) {
  const o = this;
  let i = o.events.length;
  const a = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const c = o.events[i][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return n;
  function n(c) {
    if (!s || !s._balanced)
      return r(c);
    const u = Cs(o.sliceSerialize({
      start: s.end,
      end: o.now()
    }));
    return u.codePointAt(0) !== 94 || !a.includes(u.slice(1)) ? r(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function WS(e, t) {
  let r = e.length;
  for (; r--; )
    if (e[r][1].type === "labelImage" && e[r][0] === "enter") {
      e[r][1];
      break;
    }
  e[r + 1][1].type = "data", e[r + 3][1].type = "gfmFootnoteCallLabelMarker";
  const o = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[r + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[r + 3][1].end),
    end: Object.assign({}, e[r + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, n = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[r + 1],
    e[r + 2],
    ["enter", o, t],
    // The `[`
    e[r + 3],
    e[r + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", o, t]
  ];
  return e.splice(r, e.length - r + 1, ...n), e;
}
function HS(e, t, r) {
  const o = this, i = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let a = 0, s;
  return n;
  function n(p) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(p) {
    return p !== 94 ? r(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(p) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      p === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || fe(p)
    )
      return r(p);
    if (p === 93) {
      e.exit("chunkString");
      const h = e.exit("gfmFootnoteCallString");
      return i.includes(Cs(o.sliceSerialize(h))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : r(p);
    }
    return fe(p) || (s = !0), a++, e.consume(p), p === 92 ? l : u;
  }
  function l(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, u) : u(p);
  }
}
function KS(e, t, r) {
  const o = this, i = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let a, s = 0, n;
  return c;
  function c(f) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(f) {
    return f === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", l) : r(f);
  }
  function l(f) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      f === 93 && !n || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || fe(f)
    )
      return r(f);
    if (f === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteDefinitionLabelString");
      return a = Cs(o.sliceSerialize(g)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), h;
    }
    return fe(f) || (n = !0), s++, e.consume(f), f === 92 ? p : l;
  }
  function p(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), s++, l) : l(f);
  }
  function h(f) {
    return f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), i.includes(a) || i.push(a), Ve(e, d, "gfmFootnoteDefinitionWhitespace")) : r(f);
  }
  function d(f) {
    return t(f);
  }
}
function JS(e, t, r) {
  return e.check(FS, t, e.attempt(US, t, r));
}
function GS(e) {
  e.exit("gfmFootnoteDefinition");
}
function QS(e, t, r) {
  const o = this;
  return Ve(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const s = o.events[o.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(a) : r(a);
  }
}
function YS(e) {
  let r = (e || {}).singleTilde;
  const o = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return r == null && (r = !0), {
    text: {
      126: o
    },
    insideSpan: {
      null: [o]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, n) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let u = c;
        for (; u--; )
          if (s[u][0] === "exit" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[u][1].end.offset - s[u][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[u][1].type = "strikethroughSequence";
            const l = {
              type: "strikethrough",
              start: Object.assign({}, s[u][1].start),
              end: Object.assign({}, s[c][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, s[u][1].end),
              end: Object.assign({}, s[c][1].start)
            }, h = [["enter", l, n], ["enter", s[u][1], n], ["exit", s[u][1], n], ["enter", p, n]], d = n.parser.constructs.insideSpan.null;
            d && Ns(h, h.length, 0, qS(d, s.slice(u + 1, c), n)), Ns(h, h.length, 0, [["exit", p, n], ["enter", s[c][1], n], ["exit", s[c][1], n], ["exit", l, n]]), Ns(s, u - 1, c - u + 3, h), c = u + h.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function a(s, n, c) {
    const u = this.previous, l = this.events;
    let p = 0;
    return h;
    function h(f) {
      return u === 126 && l[l.length - 1][1].type !== "characterEscape" ? c(f) : (s.enter("strikethroughSequenceTemporary"), d(f));
    }
    function d(f) {
      const g = js(u);
      if (f === 126)
        return p > 1 ? c(f) : (s.consume(f), p++, d);
      if (p < 2 && !r) return c(f);
      const m = s.exit("strikethroughSequenceTemporary"), v = js(f);
      return m._open = !v || v === 2 && !!g, m._close = !g || g === 2 && !!v, n(f);
    }
  }
}
class ZS {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, r, o) {
    XS(this, t, r, o);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, s) {
      return a[0] - s[0];
    }), this.map.length === 0)
      return;
    let r = this.map.length;
    const o = [];
    for (; r > 0; )
      r -= 1, o.push(t.slice(this.map[r][0] + this.map[r][1]), this.map[r][2]), t.length = this.map[r][0];
    o.push(t.slice()), t.length = 0;
    let i = o.pop();
    for (; i; ) {
      for (const a of i)
        t.push(a);
      i = o.pop();
    }
    this.map.length = 0;
  }
}
function XS(e, t, r, o) {
  let i = 0;
  if (!(r === 0 && o.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += r, e.map[i][2].push(...o);
        return;
      }
      i += 1;
    }
    e.map.push([t, r, o]);
  }
}
function eC(e, t) {
  let r = !1;
  const o = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (r) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && o.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = o.length - 1;
          o[a] = o[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (r = !0);
    t += 1;
  }
  return o;
}
function tC() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: rC,
        resolveAll: nC
      }
    }
  };
}
function rC(e, t, r) {
  const o = this;
  let i = 0, a = 0, s;
  return n;
  function n(R) {
    let j = o.events.length - 1;
    for (; j > -1; ) {
      const q = o.events[j][1].type;
      if (q === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      q === "linePrefix") j--;
      else break;
    }
    const T = j > -1 ? o.events[j][1].type : null, x = T === "tableHead" || T === "tableRow" ? b : c;
    return x === b && o.parser.lazy[o.now().line] ? r(R) : x(R);
  }
  function c(R) {
    return e.enter("tableHead"), e.enter("tableRow"), u(R);
  }
  function u(R) {
    return R === 124 || (s = !0, a += 1), l(R);
  }
  function l(R) {
    return R === null ? r(R) : $t(R) ? a > 1 ? (a = 0, o.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), d) : r(R) : $e(R) ? Ve(e, l, "whitespace")(R) : (a += 1, s && (s = !1, i += 1), R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), s = !0, l) : (e.enter("data"), p(R)));
  }
  function p(R) {
    return R === null || R === 124 || fe(R) ? (e.exit("data"), l(R)) : (e.consume(R), R === 92 ? h : p);
  }
  function h(R) {
    return R === 92 || R === 124 ? (e.consume(R), p) : p(R);
  }
  function d(R) {
    return o.interrupt = !1, o.parser.lazy[o.now().line] ? r(R) : (e.enter("tableDelimiterRow"), s = !1, $e(R) ? Ve(e, f, "linePrefix", o.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : f(R));
  }
  function f(R) {
    return R === 45 || R === 58 ? m(R) : R === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), g) : P(R);
  }
  function g(R) {
    return $e(R) ? Ve(e, m, "whitespace")(R) : m(R);
  }
  function m(R) {
    return R === 58 ? (a += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), v) : R === 45 ? (a += 1, v(R)) : R === null || $t(R) ? C(R) : P(R);
  }
  function v(R) {
    return R === 45 ? (e.enter("tableDelimiterFiller"), y(R)) : P(R);
  }
  function y(R) {
    return R === 45 ? (e.consume(R), y) : R === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), S) : (e.exit("tableDelimiterFiller"), S(R));
  }
  function S(R) {
    return $e(R) ? Ve(e, C, "whitespace")(R) : C(R);
  }
  function C(R) {
    return R === 124 ? f(R) : R === null || $t(R) ? !s || i !== a ? P(R) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(R)) : P(R);
  }
  function P(R) {
    return r(R);
  }
  function b(R) {
    return e.enter("tableRow"), A(R);
  }
  function A(R) {
    return R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), A) : R === null || $t(R) ? (e.exit("tableRow"), t(R)) : $e(R) ? Ve(e, A, "whitespace")(R) : (e.enter("data"), E(R));
  }
  function E(R) {
    return R === null || R === 124 || fe(R) ? (e.exit("data"), A(R)) : (e.consume(R), R === 92 ? D : E);
  }
  function D(R) {
    return R === 92 || R === 124 ? (e.consume(R), E) : E(R);
  }
}
function nC(e, t) {
  let r = -1, o = !0, i = 0, a = [0, 0, 0, 0], s = [0, 0, 0, 0], n = !1, c = 0, u, l, p;
  const h = new ZS();
  for (; ++r < e.length; ) {
    const d = e[r], f = d[1];
    d[0] === "enter" ? f.type === "tableHead" ? (n = !1, c !== 0 && (zc(h, t, c, u, l), l = void 0, c = 0), u = {
      type: "table",
      start: Object.assign({}, f.start),
      // Note: correct end is set later.
      end: Object.assign({}, f.end)
    }, h.add(r, 0, [["enter", u, t]])) : f.type === "tableRow" || f.type === "tableDelimiterRow" ? (o = !0, p = void 0, a = [0, 0, 0, 0], s = [0, r + 1, 0, 0], n && (n = !1, l = {
      type: "tableBody",
      start: Object.assign({}, f.start),
      // Note: correct end is set later.
      end: Object.assign({}, f.end)
    }, h.add(r, 0, [["enter", l, t]])), i = f.type === "tableDelimiterRow" ? 2 : l ? 3 : 1) : i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") ? (o = !1, s[2] === 0 && (a[1] !== 0 && (s[0] = s[1], p = Os(h, t, a, i, void 0, p), a = [0, 0, 0, 0]), s[2] = r)) : f.type === "tableCellDivider" && (o ? o = !1 : (a[1] !== 0 && (s[0] = s[1], p = Os(h, t, a, i, void 0, p)), a = s, s = [a[1], r, 0, 0])) : f.type === "tableHead" ? (n = !0, c = r) : f.type === "tableRow" || f.type === "tableDelimiterRow" ? (c = r, a[1] !== 0 ? (s[0] = s[1], p = Os(h, t, a, i, r, p)) : s[1] !== 0 && (p = Os(h, t, s, i, r, p)), i = 0) : i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") && (s[3] = r);
  }
  for (c !== 0 && zc(h, t, c, u, l), h.consume(t.events), r = -1; ++r < t.events.length; ) {
    const d = t.events[r];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = eC(t.events, r));
  }
  return e;
}
function Os(e, t, r, o, i, a) {
  const s = o === 1 ? "tableHeader" : o === 2 ? "tableDelimiter" : "tableData", n = "tableContent";
  r[0] !== 0 && (a.end = Object.assign({}, Ut(t.events, r[0])), e.add(r[0], 0, [["exit", a, t]]));
  const c = Ut(t.events, r[1]);
  if (a = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(r[1], 0, [["enter", a, t]]), r[2] !== 0) {
    const u = Ut(t.events, r[2]), l = Ut(t.events, r[3]), p = {
      type: n,
      start: Object.assign({}, u),
      end: Object.assign({}, l)
    };
    if (e.add(r[2], 0, [["enter", p, t]]), o !== 2) {
      const h = t.events[r[2]], d = t.events[r[3]];
      if (h[1].end = Object.assign({}, d[1].end), h[1].type = "chunkText", h[1].contentType = "text", r[3] > r[2] + 1) {
        const f = r[2] + 1, g = r[3] - r[2] - 1;
        e.add(f, g, []);
      }
    }
    e.add(r[3] + 1, 0, [["exit", p, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Ut(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function zc(e, t, r, o, i) {
  const a = [], s = Ut(t.events, r);
  i && (i.end = Object.assign({}, s), a.push(["exit", i, t])), o.end = Object.assign({}, s), a.push(["exit", o, t]), e.add(r + 1, 0, a);
}
function Ut(e, t) {
  const r = e[t], o = r[0] === "enter" ? "start" : "end";
  return r[1][o];
}
const iC = {
  name: "tasklistCheck",
  tokenize: oC
};
function sC() {
  return {
    text: {
      91: iC
    }
  };
}
function oC(e, t, r) {
  const o = this;
  return i;
  function i(c) {
    return (
      // Exit if there’s stuff before.
      o.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !o._gfmTasklistFirstContentOfListItem ? r(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(c) {
    return fe(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : r(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), n) : r(c);
  }
  function n(c) {
    return $t(c) ? t(c) : $e(c) ? e.check({
      tokenize: aC
    }, t, r)(c) : r(c);
  }
}
function aC(e, t, r) {
  return Ve(e, o, "whitespace");
  function o(i) {
    return i === null ? r(i) : t(i);
  }
}
function cC(e) {
  return ES([
    kS(),
    $S(),
    YS(e),
    tC(),
    sC()
  ]);
}
const uC = {};
function ev(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), r = e || uC, o = t.data(), i = o.micromarkExtensions || (o.micromarkExtensions = []), a = o.fromMarkdownExtensions || (o.fromMarkdownExtensions = []), s = o.toMarkdownExtensions || (o.toMarkdownExtensions = []);
  i.push(cC(r)), a.push(wS()), s.push(bS(r));
}
const Qs = async (e, t, r = "en", o, i, a) => {
  try {
    const n = `${i.replace(/\/+$/, "")}/translate?api-version=3.0&from=${r}&to=${t}`, c = await fetch(
      n,
      {
        method: "POST",
        headers: {
          "Ocp-Apim-Subscription-Key": o,
          "Ocp-Apim-Subscription-Region": a,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(e.map((l) => ({ Text: l })))
      }
    );
    if (!c.ok)
      throw new Error(`Translation failed: ${c.statusText}`);
    return (await c.json()).map((l) => l.translations?.[0]?.text || "");
  } catch (s) {
    return console.error("Batch translation error:", s), e;
  }
};
function lC({
  messages: e,
  welcomeMessage: t,
  onSendMessage: r,
  className: o = "",
  isLoading: i = !1,
  rightElement: a,
  suggestedPrompts: s,
  renderMessage: n,
  showRetryButton: c = !1,
  handleRetry: u,
  setInterruptReplica: l,
  language: p,
  config: h
}) {
  const [d, f] = O(""), g = We(null), [m, v] = O(!0), y = We(null), S = We(null), [C, P] = O({ insufficientCredits: "Insufficient Credits", insufficientCreditsDescription: "Please purchase more credits to continue.", placeholder: "Type your message...", suggestedPrompts: "Suggested Prompts", thinking: "Thinking...", retry: "Retry" });
  U(() => {
    setTimeout(() => {
      if (g.current) {
        const R = g.current.closest("[data-radix-scroll-area-viewport]") || y.current;
        R && (R.scrollTop = R.scrollHeight);
      }
    }, 0);
  }, [e, i]), U(() => {
    setTimeout(() => {
      if (g.current) {
        const R = g.current.closest("[data-radix-scroll-area-viewport]") || y.current;
        R && (R.scrollTop = R.scrollHeight);
      }
    }, 0);
  }, []), U(() => {
    (async () => {
      if (p !== "en" && S.current !== p) {
        const [j, T, x, q, pe, W] = await Qs(["Insufficient Credits", "Please purchase more credits to continue.", "Type your message...", "Suggested Prompts", "Thinking...", "Retry", "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload any lab test or medical report. If you don’t have one, lets just talk."], p, "en", h?.azureTranslatorKey || "", h?.azureTranslatorEndpoint || "", h?.azureTranslatorRegion || "");
        P({ insufficientCredits: j, insufficientCreditsDescription: T, placeholder: x, suggestedPrompts: q, thinking: pe, retry: W }), S.current = p;
      }
      p === "en" && S.current !== "en" && (P({ insufficientCredits: "Insufficient Credits", insufficientCreditsDescription: "Please purchase more credits to continue.", placeholder: "Type your message...", suggestedPrompts: "Suggested Prompts", thinking: "Thinking...", retry: "Retry" }), S.current = "en");
    })();
  }, [p, h]);
  const b = () => {
    d.trim() === "" || i || (r(d), f(""));
  }, A = (R) => {
    R.key === "Enter" && !R.shiftKey && (R.preventDefault(), b());
  }, E = (R) => {
    f(R);
  }, D = () => {
    v(!m);
  };
  return /* @__PURE__ */ k("div", { className: `flex flex-col h-full min-h-0 bg-white rounded-lg border border-primary/20 overflow-hidden ${o}`, children: [
    /* @__PURE__ */ w("div", { ref: y, className: "flex-1 min-h-0 overflow-y-auto p-3 bg-white/80", children: /* @__PURE__ */ k("div", { className: "space-y-3", children: [
      e?.length === 0 ? /* @__PURE__ */ k("div", { className: "flex items-start", children: [
        /* @__PURE__ */ w("div", { className: "w-8 h-8 rounded-full bg-[#3f62ec] flex items-center justify-center text-white flex-shrink-0", children: /* @__PURE__ */ w(Rc, { size: 14 }) }),
        /* @__PURE__ */ w("div", { className: "ml-2 px-3 py-2 rounded-lg bg-secondary/10", children: /* @__PURE__ */ w("div", { className: "text-sm text-[#3f62ec]", children: t }) })
      ] }) : e?.map((R, j) => {
        const x = j === e.length - 1 && R.sender === "ai", q = c && x && u && R.sender === "ai";
        return /* @__PURE__ */ w(
          "div",
          {
            className: Pe(
              "flex",
              R.sender === "user" ? "justify-end" : "justify-start",
              "mb-4"
            ),
            children: /* @__PURE__ */ k(
              "div",
              {
                className: Pe(
                  "max-w-[80%] rounded-lg p-3",
                  R.sender === "user" ? "bg-[#3f62ec] text-white" : "bg-gradient-to-r from-blue-50 to-teal-50 text-[#3f62ec]"
                ),
                children: [
                  n ? n(R, j) : R.sender === "user" ? /* @__PURE__ */ w("div", { className: "text-sm", children: R.text }) : /* @__PURE__ */ w("div", { className: "text-sm", children: /* @__PURE__ */ w(Ba, { remarkPlugins: [ev], children: R.text }) }),
                  q && /* @__PURE__ */ w("div", { className: "mt-2 flex justify-end", children: /* @__PURE__ */ k(
                    Wt,
                    {
                      variant: "ghost",
                      size: "sm",
                      onClick: u,
                      className: "h-6 px-2 text-xs hover:bg-secondary/20",
                      children: [
                        /* @__PURE__ */ w(Ag, { className: "h-3 w-3 mr-1" }),
                        C.retry
                      ]
                    }
                  ) })
                ]
              }
            )
          },
          R.id
        );
      }),
      i && /* @__PURE__ */ k("div", { className: "flex items-start", children: [
        /* @__PURE__ */ w("div", { className: "w-8 h-8 rounded-full bg-[#3f62ec] flex items-center justify-center text-white flex-shrink-0", children: /* @__PURE__ */ w(Rc, { size: 14 }) }),
        /* @__PURE__ */ k("div", { className: "ml-2 px-3 py-2 rounded-lg bg-bg-gradient-to-r from-blue-50 flex items-center", children: [
          /* @__PURE__ */ w(Fa, { className: "h-4 w-4 animate-spin mr-2 text-[#3f62ec]" }),
          /* @__PURE__ */ w("span", { className: "text-sm text-[#3f62ec]", children: C.thinking })
        ] })
      ] }),
      /* @__PURE__ */ w("div", { ref: g })
    ] }) }),
    /* @__PURE__ */ k("div", { className: "p-3 border-t border-light bg-white shrink-0", children: [
      s && s?.length > 0 && /* @__PURE__ */ k("div", { className: "bg-white border-b border-light flex-shrink-0", children: [
        /* @__PURE__ */ k(
          "button",
          {
            onClick: D,
            className: "w-full p-2 flex items-center justify-center hover:bg-secondary/10 transition-colors",
            children: [
              /* @__PURE__ */ w("span", { className: "text-sm font-medium text-secondary", children: C.suggestedPrompts }),
              m ? /* @__PURE__ */ w(Tg, { className: "h-4 w-4 text-secondary" }) : /* @__PURE__ */ w(_g, { className: "h-4 w-4 text-secondary" })
            ]
          }
        ),
        !m && /* @__PURE__ */ w("div", { className: "p-3 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2", children: s.map(({ id: R, text: j, icon: T }) => /* @__PURE__ */ k(
          Wt,
          {
            variant: "outline",
            className: Pe(
              "w-full justify-start text-left text-sm h-auto min-h-[40px] py-2 px-3",
              "whitespace-normal break-words"
            ),
            onClick: () => E(j),
            children: [
              /* @__PURE__ */ w(T, { className: "h-4 w-4 mr-2 text-primary flex-shrink-0" }),
              /* @__PURE__ */ w("span", { className: "text-left", children: j })
            ]
          },
          R
        )) })
      ] }),
      /* @__PURE__ */ k("div", { className: "flex items-end", children: [
        /* @__PURE__ */ w(
          "textarea",
          {
            value: d,
            onChange: (R) => {
              f(R.target.value), l(!0), R.target.style.height = "auto", R.target.style.height = Math.min(R.target.scrollHeight, 120) + "px";
            },
            onKeyDown: A,
            placeholder: C.placeholder,
            className: "flex-1 rounded-l-lg rounded-r-none focus-visible:ring-0 focus-visible:ring-offset-0 text-[#3f62ec] border-r-0 resize-none min-h-[40px] max-h-[120px] p-3 text-sm border border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
            disabled: i || !1,
            rows: 1
          }
        ),
        /* @__PURE__ */ w(
          Wt,
          {
            onClick: b,
            className: "rounded-l-none bg-primary hover:bg-secondary h-[40px]",
            disabled: d.trim() === "" || i,
            children: i ? /* @__PURE__ */ w(Fa, { className: "h-5 w-5 animate-spin" }) : /* @__PURE__ */ w(kg, { size: 18 })
          }
        ),
        a && /* @__PURE__ */ w("div", { className: "ml-2", children: a })
      ] })
    ] })
  ] });
}
const tv = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ w(
  "div",
  {
    ref: r,
    className: Pe(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      e
    ),
    ...t
  }
));
tv.displayName = "Card";
const pC = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ w(
  "div",
  {
    ref: r,
    className: Pe("flex flex-col space-y-1.5 p-6", e),
    ...t
  }
));
pC.displayName = "CardHeader";
const dC = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ w(
  "h3",
  {
    ref: r,
    className: Pe(
      "text-2xl font-semibold leading-none tracking-tight",
      e
    ),
    ...t
  }
));
dC.displayName = "CardTitle";
const hC = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ w(
  "p",
  {
    ref: r,
    className: Pe("text-sm text-muted-foreground", e),
    ...t
  }
));
hC.displayName = "CardDescription";
const rv = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ w("div", { ref: r, className: Pe("p-6 pt-0", e), ...t }));
rv.displayName = "CardContent";
const fC = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ w(
  "div",
  {
    ref: r,
    className: Pe("flex items-center p-6 pt-0", e),
    ...t
  }
));
fC.displayName = "CardFooter";
function vC(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function gC(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function o() {
      var i = !1;
      try {
        i = this instanceof o;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(o) {
    var i = Object.getOwnPropertyDescriptor(e, o);
    Object.defineProperty(r, o, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[o];
      }
    });
  }), r;
}
var ct = {}, ut = {}, nr = {}, lt = {}, Q = {}, Co = {}, pt = {}, Ro = {}, ir = {}, Ms = {}, Lc;
function nv() {
  if (Lc) return Ms;
  Lc = 1, Object.defineProperty(Ms, "__esModule", {
    value: !0
  }), Ms.default = r;
  let e;
  const t = new Uint8Array(16);
  function r() {
    if (!e && (e = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !e))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return e(t);
  }
  return Ms;
}
var Ft = {}, sr = {}, or = {}, jc;
function mC() {
  if (jc) return or;
  jc = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.default = void 0;
  var e = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  return or.default = e, or;
}
var qc;
function Ys() {
  if (qc) return sr;
  qc = 1, Object.defineProperty(sr, "__esModule", {
    value: !0
  }), sr.default = void 0;
  var e = t(/* @__PURE__ */ mC());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    return typeof i == "string" && e.default.test(i);
  }
  var o = r;
  return sr.default = o, sr;
}
var Fc;
function Zs() {
  if (Fc) return Ft;
  Fc = 1, Object.defineProperty(Ft, "__esModule", {
    value: !0
  }), Ft.default = void 0, Ft.unsafeStringify = o;
  var e = t(/* @__PURE__ */ Ys());
  function t(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = [];
  for (let s = 0; s < 256; ++s)
    r.push((s + 256).toString(16).slice(1));
  function o(s, n = 0) {
    return r[s[n + 0]] + r[s[n + 1]] + r[s[n + 2]] + r[s[n + 3]] + "-" + r[s[n + 4]] + r[s[n + 5]] + "-" + r[s[n + 6]] + r[s[n + 7]] + "-" + r[s[n + 8]] + r[s[n + 9]] + "-" + r[s[n + 10]] + r[s[n + 11]] + r[s[n + 12]] + r[s[n + 13]] + r[s[n + 14]] + r[s[n + 15]];
  }
  function i(s, n = 0) {
    const c = o(s, n);
    if (!(0, e.default)(c))
      throw TypeError("Stringified UUID is invalid");
    return c;
  }
  var a = i;
  return Ft.default = a, Ft;
}
var Bc;
function yC() {
  if (Bc) return ir;
  Bc = 1, Object.defineProperty(ir, "__esModule", {
    value: !0
  }), ir.default = void 0;
  var e = r(/* @__PURE__ */ nv()), t = /* @__PURE__ */ Zs();
  function r(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let o, i, a = 0, s = 0;
  function n(u, l, p) {
    let h = l && p || 0;
    const d = l || new Array(16);
    u = u || {};
    let f = u.node || o, g = u.clockseq !== void 0 ? u.clockseq : i;
    if (f == null || g == null) {
      const P = u.random || (u.rng || e.default)();
      f == null && (f = o = [P[0] | 1, P[1], P[2], P[3], P[4], P[5]]), g == null && (g = i = (P[6] << 8 | P[7]) & 16383);
    }
    let m = u.msecs !== void 0 ? u.msecs : Date.now(), v = u.nsecs !== void 0 ? u.nsecs : s + 1;
    const y = m - a + (v - s) / 1e4;
    if (y < 0 && u.clockseq === void 0 && (g = g + 1 & 16383), (y < 0 || m > a) && u.nsecs === void 0 && (v = 0), v >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    a = m, s = v, i = g, m += 122192928e5;
    const S = ((m & 268435455) * 1e4 + v) % 4294967296;
    d[h++] = S >>> 24 & 255, d[h++] = S >>> 16 & 255, d[h++] = S >>> 8 & 255, d[h++] = S & 255;
    const C = m / 4294967296 * 1e4 & 268435455;
    d[h++] = C >>> 8 & 255, d[h++] = C & 255, d[h++] = C >>> 24 & 15 | 16, d[h++] = C >>> 16 & 255, d[h++] = g >>> 8 | 128, d[h++] = g & 255;
    for (let P = 0; P < 6; ++P)
      d[h + P] = f[P];
    return l || (0, t.unsafeStringify)(d);
  }
  var c = n;
  return ir.default = c, ir;
}
var ar = {}, Ye = {}, cr = {}, Uc;
function iv() {
  if (Uc) return cr;
  Uc = 1, Object.defineProperty(cr, "__esModule", {
    value: !0
  }), cr.default = void 0;
  var e = t(/* @__PURE__ */ Ys());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    if (!(0, e.default)(i))
      throw TypeError("Invalid UUID");
    let a;
    const s = new Uint8Array(16);
    return s[0] = (a = parseInt(i.slice(0, 8), 16)) >>> 24, s[1] = a >>> 16 & 255, s[2] = a >>> 8 & 255, s[3] = a & 255, s[4] = (a = parseInt(i.slice(9, 13), 16)) >>> 8, s[5] = a & 255, s[6] = (a = parseInt(i.slice(14, 18), 16)) >>> 8, s[7] = a & 255, s[8] = (a = parseInt(i.slice(19, 23), 16)) >>> 8, s[9] = a & 255, s[10] = (a = parseInt(i.slice(24, 36), 16)) / 1099511627776 & 255, s[11] = a / 4294967296 & 255, s[12] = a >>> 24 & 255, s[13] = a >>> 16 & 255, s[14] = a >>> 8 & 255, s[15] = a & 255, s;
  }
  var o = r;
  return cr.default = o, cr;
}
var $c;
function sv() {
  if ($c) return Ye;
  $c = 1, Object.defineProperty(Ye, "__esModule", {
    value: !0
  }), Ye.URL = Ye.DNS = void 0, Ye.default = s;
  var e = /* @__PURE__ */ Zs(), t = r(/* @__PURE__ */ iv());
  function r(n) {
    return n && n.__esModule ? n : { default: n };
  }
  function o(n) {
    n = unescape(encodeURIComponent(n));
    const c = [];
    for (let u = 0; u < n.length; ++u)
      c.push(n.charCodeAt(u));
    return c;
  }
  const i = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  Ye.DNS = i;
  const a = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  Ye.URL = a;
  function s(n, c, u) {
    function l(p, h, d, f) {
      var g;
      if (typeof p == "string" && (p = o(p)), typeof h == "string" && (h = (0, t.default)(h)), ((g = h) === null || g === void 0 ? void 0 : g.length) !== 16)
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let m = new Uint8Array(16 + p.length);
      if (m.set(h), m.set(p, h.length), m = u(m), m[6] = m[6] & 15 | c, m[8] = m[8] & 63 | 128, d) {
        f = f || 0;
        for (let v = 0; v < 16; ++v)
          d[f + v] = m[v];
        return d;
      }
      return (0, e.unsafeStringify)(m);
    }
    try {
      l.name = n;
    } catch {
    }
    return l.DNS = i, l.URL = a, l;
  }
  return Ye;
}
var ur = {}, Vc;
function SC() {
  if (Vc) return ur;
  Vc = 1, Object.defineProperty(ur, "__esModule", {
    value: !0
  }), ur.default = void 0;
  function e(d) {
    if (typeof d == "string") {
      const f = unescape(encodeURIComponent(d));
      d = new Uint8Array(f.length);
      for (let g = 0; g < f.length; ++g)
        d[g] = f.charCodeAt(g);
    }
    return t(o(i(d), d.length * 8));
  }
  function t(d) {
    const f = [], g = d.length * 32, m = "0123456789abcdef";
    for (let v = 0; v < g; v += 8) {
      const y = d[v >> 5] >>> v % 32 & 255, S = parseInt(m.charAt(y >>> 4 & 15) + m.charAt(y & 15), 16);
      f.push(S);
    }
    return f;
  }
  function r(d) {
    return (d + 64 >>> 9 << 4) + 14 + 1;
  }
  function o(d, f) {
    d[f >> 5] |= 128 << f % 32, d[r(f) - 1] = f;
    let g = 1732584193, m = -271733879, v = -1732584194, y = 271733878;
    for (let S = 0; S < d.length; S += 16) {
      const C = g, P = m, b = v, A = y;
      g = c(g, m, v, y, d[S], 7, -680876936), y = c(y, g, m, v, d[S + 1], 12, -389564586), v = c(v, y, g, m, d[S + 2], 17, 606105819), m = c(m, v, y, g, d[S + 3], 22, -1044525330), g = c(g, m, v, y, d[S + 4], 7, -176418897), y = c(y, g, m, v, d[S + 5], 12, 1200080426), v = c(v, y, g, m, d[S + 6], 17, -1473231341), m = c(m, v, y, g, d[S + 7], 22, -45705983), g = c(g, m, v, y, d[S + 8], 7, 1770035416), y = c(y, g, m, v, d[S + 9], 12, -1958414417), v = c(v, y, g, m, d[S + 10], 17, -42063), m = c(m, v, y, g, d[S + 11], 22, -1990404162), g = c(g, m, v, y, d[S + 12], 7, 1804603682), y = c(y, g, m, v, d[S + 13], 12, -40341101), v = c(v, y, g, m, d[S + 14], 17, -1502002290), m = c(m, v, y, g, d[S + 15], 22, 1236535329), g = u(g, m, v, y, d[S + 1], 5, -165796510), y = u(y, g, m, v, d[S + 6], 9, -1069501632), v = u(v, y, g, m, d[S + 11], 14, 643717713), m = u(m, v, y, g, d[S], 20, -373897302), g = u(g, m, v, y, d[S + 5], 5, -701558691), y = u(y, g, m, v, d[S + 10], 9, 38016083), v = u(v, y, g, m, d[S + 15], 14, -660478335), m = u(m, v, y, g, d[S + 4], 20, -405537848), g = u(g, m, v, y, d[S + 9], 5, 568446438), y = u(y, g, m, v, d[S + 14], 9, -1019803690), v = u(v, y, g, m, d[S + 3], 14, -187363961), m = u(m, v, y, g, d[S + 8], 20, 1163531501), g = u(g, m, v, y, d[S + 13], 5, -1444681467), y = u(y, g, m, v, d[S + 2], 9, -51403784), v = u(v, y, g, m, d[S + 7], 14, 1735328473), m = u(m, v, y, g, d[S + 12], 20, -1926607734), g = l(g, m, v, y, d[S + 5], 4, -378558), y = l(y, g, m, v, d[S + 8], 11, -2022574463), v = l(v, y, g, m, d[S + 11], 16, 1839030562), m = l(m, v, y, g, d[S + 14], 23, -35309556), g = l(g, m, v, y, d[S + 1], 4, -1530992060), y = l(y, g, m, v, d[S + 4], 11, 1272893353), v = l(v, y, g, m, d[S + 7], 16, -155497632), m = l(m, v, y, g, d[S + 10], 23, -1094730640), g = l(g, m, v, y, d[S + 13], 4, 681279174), y = l(y, g, m, v, d[S], 11, -358537222), v = l(v, y, g, m, d[S + 3], 16, -722521979), m = l(m, v, y, g, d[S + 6], 23, 76029189), g = l(g, m, v, y, d[S + 9], 4, -640364487), y = l(y, g, m, v, d[S + 12], 11, -421815835), v = l(v, y, g, m, d[S + 15], 16, 530742520), m = l(m, v, y, g, d[S + 2], 23, -995338651), g = p(g, m, v, y, d[S], 6, -198630844), y = p(y, g, m, v, d[S + 7], 10, 1126891415), v = p(v, y, g, m, d[S + 14], 15, -1416354905), m = p(m, v, y, g, d[S + 5], 21, -57434055), g = p(g, m, v, y, d[S + 12], 6, 1700485571), y = p(y, g, m, v, d[S + 3], 10, -1894986606), v = p(v, y, g, m, d[S + 10], 15, -1051523), m = p(m, v, y, g, d[S + 1], 21, -2054922799), g = p(g, m, v, y, d[S + 8], 6, 1873313359), y = p(y, g, m, v, d[S + 15], 10, -30611744), v = p(v, y, g, m, d[S + 6], 15, -1560198380), m = p(m, v, y, g, d[S + 13], 21, 1309151649), g = p(g, m, v, y, d[S + 4], 6, -145523070), y = p(y, g, m, v, d[S + 11], 10, -1120210379), v = p(v, y, g, m, d[S + 2], 15, 718787259), m = p(m, v, y, g, d[S + 9], 21, -343485551), g = a(g, C), m = a(m, P), v = a(v, b), y = a(y, A);
    }
    return [g, m, v, y];
  }
  function i(d) {
    if (d.length === 0)
      return [];
    const f = d.length * 8, g = new Uint32Array(r(f));
    for (let m = 0; m < f; m += 8)
      g[m >> 5] |= (d[m / 8] & 255) << m % 32;
    return g;
  }
  function a(d, f) {
    const g = (d & 65535) + (f & 65535);
    return (d >> 16) + (f >> 16) + (g >> 16) << 16 | g & 65535;
  }
  function s(d, f) {
    return d << f | d >>> 32 - f;
  }
  function n(d, f, g, m, v, y) {
    return a(s(a(a(f, d), a(m, y)), v), g);
  }
  function c(d, f, g, m, v, y, S) {
    return n(f & g | ~f & m, d, f, v, y, S);
  }
  function u(d, f, g, m, v, y, S) {
    return n(f & m | g & ~m, d, f, v, y, S);
  }
  function l(d, f, g, m, v, y, S) {
    return n(f ^ g ^ m, d, f, v, y, S);
  }
  function p(d, f, g, m, v, y, S) {
    return n(g ^ (f | ~m), d, f, v, y, S);
  }
  var h = e;
  return ur.default = h, ur;
}
var Wc;
function CC() {
  if (Wc) return ar;
  Wc = 1, Object.defineProperty(ar, "__esModule", {
    value: !0
  }), ar.default = void 0;
  var e = r(/* @__PURE__ */ sv()), t = r(/* @__PURE__ */ SC());
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = (0, e.default)("v3", 48, t.default);
  return ar.default = i, ar;
}
var lr = {}, pr = {}, Hc;
function RC() {
  if (Hc) return pr;
  Hc = 1, Object.defineProperty(pr, "__esModule", {
    value: !0
  }), pr.default = void 0;
  var t = {
    randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  };
  return pr.default = t, pr;
}
var Kc;
function PC() {
  if (Kc) return lr;
  Kc = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.default = void 0;
  var e = o(/* @__PURE__ */ RC()), t = o(/* @__PURE__ */ nv()), r = /* @__PURE__ */ Zs();
  function o(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s, n, c) {
    if (e.default.randomUUID && !n && !s)
      return e.default.randomUUID();
    s = s || {};
    const u = s.random || (s.rng || t.default)();
    if (u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, n) {
      c = c || 0;
      for (let l = 0; l < 16; ++l)
        n[c + l] = u[l];
      return n;
    }
    return (0, r.unsafeStringify)(u);
  }
  var a = i;
  return lr.default = a, lr;
}
var dr = {}, hr = {}, Jc;
function wC() {
  if (Jc) return hr;
  Jc = 1, Object.defineProperty(hr, "__esModule", {
    value: !0
  }), hr.default = void 0;
  function e(i, a, s, n) {
    switch (i) {
      case 0:
        return a & s ^ ~a & n;
      case 1:
        return a ^ s ^ n;
      case 2:
        return a & s ^ a & n ^ s & n;
      case 3:
        return a ^ s ^ n;
    }
  }
  function t(i, a) {
    return i << a | i >>> 32 - a;
  }
  function r(i) {
    const a = [1518500249, 1859775393, 2400959708, 3395469782], s = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof i == "string") {
      const l = unescape(encodeURIComponent(i));
      i = [];
      for (let p = 0; p < l.length; ++p)
        i.push(l.charCodeAt(p));
    } else Array.isArray(i) || (i = Array.prototype.slice.call(i));
    i.push(128);
    const n = i.length / 4 + 2, c = Math.ceil(n / 16), u = new Array(c);
    for (let l = 0; l < c; ++l) {
      const p = new Uint32Array(16);
      for (let h = 0; h < 16; ++h)
        p[h] = i[l * 64 + h * 4] << 24 | i[l * 64 + h * 4 + 1] << 16 | i[l * 64 + h * 4 + 2] << 8 | i[l * 64 + h * 4 + 3];
      u[l] = p;
    }
    u[c - 1][14] = (i.length - 1) * 8 / Math.pow(2, 32), u[c - 1][14] = Math.floor(u[c - 1][14]), u[c - 1][15] = (i.length - 1) * 8 & 4294967295;
    for (let l = 0; l < c; ++l) {
      const p = new Uint32Array(80);
      for (let v = 0; v < 16; ++v)
        p[v] = u[l][v];
      for (let v = 16; v < 80; ++v)
        p[v] = t(p[v - 3] ^ p[v - 8] ^ p[v - 14] ^ p[v - 16], 1);
      let h = s[0], d = s[1], f = s[2], g = s[3], m = s[4];
      for (let v = 0; v < 80; ++v) {
        const y = Math.floor(v / 20), S = t(h, 5) + e(y, d, f, g) + m + a[y] + p[v] >>> 0;
        m = g, g = f, f = t(d, 30) >>> 0, d = h, h = S;
      }
      s[0] = s[0] + h >>> 0, s[1] = s[1] + d >>> 0, s[2] = s[2] + f >>> 0, s[3] = s[3] + g >>> 0, s[4] = s[4] + m >>> 0;
    }
    return [s[0] >> 24 & 255, s[0] >> 16 & 255, s[0] >> 8 & 255, s[0] & 255, s[1] >> 24 & 255, s[1] >> 16 & 255, s[1] >> 8 & 255, s[1] & 255, s[2] >> 24 & 255, s[2] >> 16 & 255, s[2] >> 8 & 255, s[2] & 255, s[3] >> 24 & 255, s[3] >> 16 & 255, s[3] >> 8 & 255, s[3] & 255, s[4] >> 24 & 255, s[4] >> 16 & 255, s[4] >> 8 & 255, s[4] & 255];
  }
  var o = r;
  return hr.default = o, hr;
}
var Gc;
function bC() {
  if (Gc) return dr;
  Gc = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.default = void 0;
  var e = r(/* @__PURE__ */ sv()), t = r(/* @__PURE__ */ wC());
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = (0, e.default)("v5", 80, t.default);
  return dr.default = i, dr;
}
var fr = {}, Qc;
function EC() {
  if (Qc) return fr;
  Qc = 1, Object.defineProperty(fr, "__esModule", {
    value: !0
  }), fr.default = void 0;
  var e = "00000000-0000-0000-0000-000000000000";
  return fr.default = e, fr;
}
var vr = {}, Yc;
function IC() {
  if (Yc) return vr;
  Yc = 1, Object.defineProperty(vr, "__esModule", {
    value: !0
  }), vr.default = void 0;
  var e = t(/* @__PURE__ */ Ys());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    if (!(0, e.default)(i))
      throw TypeError("Invalid UUID");
    return parseInt(i.slice(14, 15), 16);
  }
  var o = r;
  return vr.default = o, vr;
}
var Zc;
function AC() {
  return Zc || (Zc = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "NIL", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(e, "v1", {
      enumerable: !0,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(e, "v3", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "v4", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "v5", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    });
    var t = l(/* @__PURE__ */ yC()), r = l(/* @__PURE__ */ CC()), o = l(/* @__PURE__ */ PC()), i = l(/* @__PURE__ */ bC()), a = l(/* @__PURE__ */ EC()), s = l(/* @__PURE__ */ IC()), n = l(/* @__PURE__ */ Ys()), c = l(/* @__PURE__ */ Zs()), u = l(/* @__PURE__ */ iv());
    function l(p) {
      return p && p.__esModule ? p : { default: p };
    }
  }(Ro)), Ro;
}
var Xc;
function Nt() {
  if (Xc) return pt;
  Xc = 1, Object.defineProperty(pt, "__esModule", { value: !0 }), pt.createNoDashGuid = pt.createGuid = void 0;
  const e = /* @__PURE__ */ AC(), t = () => (0, e.v4)();
  pt.createGuid = t;
  const r = () => t().replace(new RegExp("-", "g"), "").toUpperCase();
  return pt.createNoDashGuid = r, pt;
}
var eu;
function Rs() {
  return eu || (eu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PlatformEvent = e.EventType = void 0;
    const t = /* @__PURE__ */ Nt();
    (function(o) {
      o[o.Debug = 0] = "Debug", o[o.Info = 1] = "Info", o[o.Warning = 2] = "Warning", o[o.Error = 3] = "Error", o[o.None = 4] = "None";
    })(e.EventType || (e.EventType = {}));
    class r {
      constructor(i, a) {
        this.privName = i, this.privEventId = (0, t.createNoDashGuid)(), this.privEventTime = (/* @__PURE__ */ new Date()).toISOString(), this.privEventType = a, this.privMetadata = {};
      }
      get name() {
        return this.privName;
      }
      get eventId() {
        return this.privEventId;
      }
      get eventTime() {
        return this.privEventTime;
      }
      get eventType() {
        return this.privEventType;
      }
      get metadata() {
        return this.privMetadata;
      }
    }
    e.PlatformEvent = r;
  }(Co)), Co;
}
var tu;
function TC() {
  if (tu) return Q;
  tu = 1, Object.defineProperty(Q, "__esModule", { value: !0 }), Q.AudioStreamNodeErrorEvent = Q.AudioStreamNodeDetachedEvent = Q.AudioStreamNodeAttachedEvent = Q.AudioStreamNodeAttachingEvent = Q.AudioStreamNodeEvent = Q.AudioSourceErrorEvent = Q.AudioSourceOffEvent = Q.AudioSourceReadyEvent = Q.AudioSourceInitializingEvent = Q.AudioSourceEvent = void 0;
  const e = /* @__PURE__ */ Rs();
  class t extends e.PlatformEvent {
    constructor(h, d, f = e.EventType.Info) {
      super(h, f), this.privAudioSourceId = d;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
  }
  Q.AudioSourceEvent = t;
  class r extends t {
    constructor(h) {
      super("AudioSourceInitializingEvent", h);
    }
  }
  Q.AudioSourceInitializingEvent = r;
  class o extends t {
    constructor(h) {
      super("AudioSourceReadyEvent", h);
    }
  }
  Q.AudioSourceReadyEvent = o;
  class i extends t {
    constructor(h) {
      super("AudioSourceOffEvent", h);
    }
  }
  Q.AudioSourceOffEvent = i;
  class a extends t {
    constructor(h, d) {
      super("AudioSourceErrorEvent", h, e.EventType.Error), this.privError = d;
    }
    get error() {
      return this.privError;
    }
  }
  Q.AudioSourceErrorEvent = a;
  class s extends t {
    constructor(h, d, f) {
      super(h, d), this.privAudioNodeId = f;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  Q.AudioStreamNodeEvent = s;
  class n extends s {
    constructor(h, d) {
      super("AudioStreamNodeAttachingEvent", h, d);
    }
  }
  Q.AudioStreamNodeAttachingEvent = n;
  class c extends s {
    constructor(h, d) {
      super("AudioStreamNodeAttachedEvent", h, d);
    }
  }
  Q.AudioStreamNodeAttachedEvent = c;
  class u extends s {
    constructor(h, d) {
      super("AudioStreamNodeDetachedEvent", h, d);
    }
  }
  Q.AudioStreamNodeDetachedEvent = u;
  class l extends s {
    constructor(h, d, f) {
      super("AudioStreamNodeErrorEvent", h, d), this.privError = f;
    }
    get error() {
      return this.privError;
    }
  }
  return Q.AudioStreamNodeErrorEvent = l, Q;
}
var Y = {}, ru;
function _C() {
  if (ru) return Y;
  ru = 1, Object.defineProperty(Y, "__esModule", { value: !0 }), Y.ConnectionRedirectEvent = Y.ConnectionMessageSentEvent = Y.ConnectionMessageReceivedEvent = Y.ConnectionEstablishErrorEvent = Y.ConnectionErrorEvent = Y.ConnectionClosedEvent = Y.ConnectionEstablishedEvent = Y.ConnectionStartEvent = Y.ConnectionEvent = Y.ServiceEvent = void 0;
  const e = /* @__PURE__ */ Rs();
  class t extends e.PlatformEvent {
    constructor(h, d, f = e.EventType.Info) {
      super(h, f), this.privJsonResult = d;
    }
    get jsonString() {
      return this.privJsonResult;
    }
  }
  Y.ServiceEvent = t;
  class r extends e.PlatformEvent {
    constructor(h, d, f = e.EventType.Info) {
      super(h, f), this.privConnectionId = d;
    }
    get connectionId() {
      return this.privConnectionId;
    }
  }
  Y.ConnectionEvent = r;
  class o extends r {
    constructor(h, d, f) {
      super("ConnectionStartEvent", h), this.privUri = d, this.privHeaders = f;
    }
    get uri() {
      return this.privUri;
    }
    get headers() {
      return this.privHeaders;
    }
  }
  Y.ConnectionStartEvent = o;
  class i extends r {
    constructor(h) {
      super("ConnectionEstablishedEvent", h);
    }
  }
  Y.ConnectionEstablishedEvent = i;
  class a extends r {
    constructor(h, d, f) {
      super("ConnectionClosedEvent", h, e.EventType.Debug), this.privReason = f, this.privStatusCode = d;
    }
    get reason() {
      return this.privReason;
    }
    get statusCode() {
      return this.privStatusCode;
    }
  }
  Y.ConnectionClosedEvent = a;
  class s extends r {
    constructor(h, d, f) {
      super("ConnectionErrorEvent", h, e.EventType.Debug), this.privMessage = d, this.privType = f;
    }
    get message() {
      return this.privMessage;
    }
    get type() {
      return this.privType;
    }
  }
  Y.ConnectionErrorEvent = s;
  class n extends r {
    constructor(h, d, f) {
      super("ConnectionEstablishErrorEvent", h, e.EventType.Error), this.privStatusCode = d, this.privReason = f;
    }
    get reason() {
      return this.privReason;
    }
    get statusCode() {
      return this.privStatusCode;
    }
  }
  Y.ConnectionEstablishErrorEvent = n;
  class c extends r {
    constructor(h, d, f) {
      super("ConnectionMessageReceivedEvent", h), this.privNetworkReceivedTime = d, this.privMessage = f;
    }
    get networkReceivedTime() {
      return this.privNetworkReceivedTime;
    }
    get message() {
      return this.privMessage;
    }
  }
  Y.ConnectionMessageReceivedEvent = c;
  class u extends r {
    constructor(h, d, f) {
      super("ConnectionMessageSentEvent", h), this.privNetworkSentTime = d, this.privMessage = f;
    }
    get networkSentTime() {
      return this.privNetworkSentTime;
    }
    get message() {
      return this.privMessage;
    }
  }
  Y.ConnectionMessageSentEvent = u;
  class l extends r {
    constructor(h, d, f, g) {
      super("ConnectionRedirectEvent", h, e.EventType.Info), this.privRedirectUrl = d, this.privOriginalUrl = f, this.privContext = g;
    }
    get redirectUrl() {
      return this.privRedirectUrl;
    }
    get originalUrl() {
      return this.privOriginalUrl;
    }
    get context() {
      return this.privContext;
    }
  }
  return Y.ConnectionRedirectEvent = l, Y;
}
var Po = {}, qe = {}, nu;
function xe() {
  if (nu) return qe;
  nu = 1, Object.defineProperty(qe, "__esModule", { value: !0 }), qe.ObjectDisposedError = qe.InvalidOperationError = qe.ArgumentNullError = void 0;
  class e extends Error {
    /**
     * Creates an instance of ArgumentNullError.
     *
     * @param {string} argumentName - Name of the argument that is null
     *
     * @memberOf ArgumentNullError
     */
    constructor(i) {
      super(i), this.name = "ArgumentNull", this.message = i;
    }
  }
  qe.ArgumentNullError = e;
  class t extends Error {
    /**
     * Creates an instance of InvalidOperationError.
     *
     * @param {string} error - The error
     *
     * @memberOf InvalidOperationError
     */
    constructor(i) {
      super(i), this.name = "InvalidOperation", this.message = i;
    }
  }
  qe.InvalidOperationError = t;
  class r extends Error {
    /**
     * Creates an instance of ObjectDisposedError.
     *
     * @param {string} objectName - The object that is disposed
     * @param {string} error - The error
     *
     * @memberOf ObjectDisposedError
     */
    constructor(i, a) {
      super(a), this.name = i + "ObjectDisposed", this.message = a;
    }
  }
  return qe.ObjectDisposedError = r, qe;
}
var iu;
function ov() {
  return iu || (iu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionMessage = e.MessageType = void 0;
    const t = /* @__PURE__ */ xe(), r = /* @__PURE__ */ Nt();
    var o;
    (function(a) {
      a[a.Text = 0] = "Text", a[a.Binary = 1] = "Binary";
    })(o = e.MessageType || (e.MessageType = {}));
    class i {
      constructor(s, n, c, u) {
        if (this.privBody = null, s === o.Text && n && typeof n != "string")
          throw new t.InvalidOperationError("Payload must be a string");
        if (s === o.Binary && n && !(n instanceof ArrayBuffer))
          throw new t.InvalidOperationError("Payload must be ArrayBuffer");
        switch (this.privMessageType = s, this.privBody = n, this.privHeaders = c || {}, this.privId = u || (0, r.createNoDashGuid)(), this.messageType) {
          case o.Binary:
            this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
            break;
          case o.Text:
            this.privSize = this.textBody.length;
        }
      }
      get messageType() {
        return this.privMessageType;
      }
      get headers() {
        return this.privHeaders;
      }
      get body() {
        return this.privBody;
      }
      get textBody() {
        if (this.privMessageType === o.Binary)
          throw new t.InvalidOperationError("Not supported for binary message");
        return this.privBody;
      }
      get binaryBody() {
        if (this.privMessageType === o.Text)
          throw new t.InvalidOperationError("Not supported for text message");
        return this.privBody;
      }
      get id() {
        return this.privId;
      }
    }
    e.ConnectionMessage = i;
  }(Po)), Po;
}
var gr = {}, su;
function kC() {
  if (su) return gr;
  su = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.ConnectionOpenResponse = void 0;
  let e = class {
    constructor(r, o) {
      this.privStatusCode = r, this.privReason = o;
    }
    get statusCode() {
      return this.privStatusCode;
    }
    get reason() {
      return this.privReason;
    }
  };
  return gr.ConnectionOpenResponse = e, gr;
}
var mr = {}, ou;
function OC() {
  if (ou) return mr;
  ou = 1, Object.defineProperty(mr, "__esModule", { value: !0 }), mr.DeferralMap = void 0;
  let e = class {
    constructor() {
      this.privMap = {};
    }
    add(r, o) {
      this.privMap[r] = o;
    }
    getId(r) {
      return this.privMap[r];
    }
    complete(r, o) {
      try {
        this.privMap[r].resolve(o);
      } catch (i) {
        this.privMap[r].reject(i);
      } finally {
        this.privMap[r] = void 0;
      }
    }
  };
  return mr.DeferralMap = e, mr;
}
var dt = {}, au;
function av() {
  if (au) return dt;
  au = 1, Object.defineProperty(dt, "__esModule", { value: !0 }), dt.SendingAgentContextMessageEvent = dt.DialogEvent = void 0;
  const e = /* @__PURE__ */ Rs();
  class t extends e.PlatformEvent {
    constructor(i, a = e.EventType.Info) {
      super(i, a);
    }
  }
  dt.DialogEvent = t;
  class r extends t {
    constructor(i) {
      super("SendingAgentContextMessageEvent"), this.privAgentConfig = i;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
  }
  return dt.SendingAgentContextMessageEvent = r, dt;
}
var yr = {}, Sr = {}, cu;
function cv() {
  if (cu) return Sr;
  cu = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.EventSource = void 0;
  const e = /* @__PURE__ */ xe(), t = /* @__PURE__ */ Nt();
  let r = class {
    constructor(i) {
      this.privEventListeners = {}, this.privIsDisposed = !1, this.privConsoleListener = void 0, this.privMetadata = i;
    }
    onEvent(i) {
      if (this.isDisposed())
        throw new e.ObjectDisposedError("EventSource");
      if (this.metadata)
        for (const a in this.metadata)
          a && i.metadata && (i.metadata[a] || (i.metadata[a] = this.metadata[a]));
      for (const a in this.privEventListeners)
        a && this.privEventListeners[a] && this.privEventListeners[a](i);
    }
    attach(i) {
      const a = (0, t.createNoDashGuid)();
      return this.privEventListeners[a] = i, {
        detach: () => (delete this.privEventListeners[a], Promise.resolve())
      };
    }
    attachListener(i) {
      return this.attach((a) => i.onEvent(a));
    }
    attachConsoleListener(i) {
      return this.privConsoleListener && this.privConsoleListener.detach(), this.privConsoleListener = this.attach((a) => i.onEvent(a)), this.privConsoleListener;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.privEventListeners = null, this.privIsDisposed = !0;
    }
    get metadata() {
      return this.privMetadata;
    }
  };
  return Sr.EventSource = r, Sr;
}
var uu;
function MC() {
  if (uu) return yr;
  uu = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.Events = void 0;
  const e = /* @__PURE__ */ xe(), t = /* @__PURE__ */ cv();
  let r = class Wa {
    static setEventSource(i) {
      if (!i)
        throw new e.ArgumentNullError("eventSource");
      Wa.privInstance = i;
    }
    static get instance() {
      return Wa.privInstance;
    }
  };
  return yr.Events = r, r.privInstance = new t.EventSource(), yr;
}
var wo = {}, lu;
function DC() {
  return lu || (lu = 1, Object.defineProperty(wo, "__esModule", { value: !0 })), wo;
}
var bo = {}, pu;
function xC() {
  return pu || (pu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionState = void 0, function(t) {
      t[t.None = 0] = "None", t[t.Connected = 1] = "Connected", t[t.Connecting = 2] = "Connecting", t[t.Disconnected = 3] = "Disconnected";
    }(e.ConnectionState || (e.ConnectionState = {}));
  }(bo)), bo;
}
var Eo = {}, du;
function NC() {
  return du || (du = 1, Object.defineProperty(Eo, "__esModule", { value: !0 })), Eo;
}
var Io = {}, hu;
function zC() {
  return hu || (hu = 1, Object.defineProperty(Io, "__esModule", { value: !0 })), Io;
}
var Ao = {}, fu;
function LC() {
  return fu || (fu = 1, Object.defineProperty(Ao, "__esModule", { value: !0 })), Ao;
}
var To = {}, vu;
function jC() {
  return vu || (vu = 1, Object.defineProperty(To, "__esModule", { value: !0 })), To;
}
var _o = {}, gu;
function qC() {
  return gu || (gu = 1, Object.defineProperty(_o, "__esModule", { value: !0 })), _o;
}
var ko = {}, mu;
function FC() {
  return mu || (mu = 1, Object.defineProperty(ko, "__esModule", { value: !0 })), ko;
}
var Oo = {}, yu;
function BC() {
  return yu || (yu = 1, Object.defineProperty(Oo, "__esModule", { value: !0 })), Oo;
}
var Mo = {}, Su;
function UC() {
  return Su || (Su = 1, Object.defineProperty(Mo, "__esModule", { value: !0 })), Mo;
}
var Cr = {}, Cu;
function uv() {
  if (Cu) return Cr;
  Cu = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.List = void 0;
  const e = /* @__PURE__ */ xe();
  let t = class Ot {
    constructor(o) {
      if (this.privSubscriptionIdCounter = 0, this.privAddSubscriptions = {}, this.privRemoveSubscriptions = {}, this.privDisposedSubscriptions = {}, this.privDisposeReason = null, this.privList = [], o)
        for (const i of o)
          this.privList.push(i);
    }
    get(o) {
      return this.throwIfDisposed(), this.privList[o];
    }
    first() {
      return this.get(0);
    }
    last() {
      return this.get(this.length() - 1);
    }
    add(o) {
      this.throwIfDisposed(), this.insertAt(this.privList.length, o);
    }
    insertAt(o, i) {
      this.throwIfDisposed(), o === 0 ? this.privList.unshift(i) : o === this.privList.length ? this.privList.push(i) : this.privList.splice(o, 0, i), this.triggerSubscriptions(this.privAddSubscriptions);
    }
    removeFirst() {
      return this.throwIfDisposed(), this.removeAt(0);
    }
    removeLast() {
      return this.throwIfDisposed(), this.removeAt(this.length() - 1);
    }
    removeAt(o) {
      return this.throwIfDisposed(), this.remove(o, 1)[0];
    }
    remove(o, i) {
      this.throwIfDisposed();
      const a = this.privList.splice(o, i);
      return this.triggerSubscriptions(this.privRemoveSubscriptions), a;
    }
    clear() {
      this.throwIfDisposed(), this.remove(0, this.length());
    }
    length() {
      return this.throwIfDisposed(), this.privList.length;
    }
    onAdded(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privAddSubscriptions[i] = o, {
        detach: () => (delete this.privAddSubscriptions[i], Promise.resolve())
      };
    }
    onRemoved(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privRemoveSubscriptions[i] = o, {
        detach: () => (delete this.privRemoveSubscriptions[i], Promise.resolve())
      };
    }
    onDisposed(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privDisposedSubscriptions[i] = o, {
        detach: () => (delete this.privDisposedSubscriptions[i], Promise.resolve())
      };
    }
    join(o) {
      return this.throwIfDisposed(), this.privList.join(o);
    }
    toArray() {
      const o = Array();
      return this.privList.forEach((i) => {
        o.push(i);
      }), o;
    }
    any(o) {
      return this.throwIfDisposed(), o ? this.where(o).length() > 0 : this.length() > 0;
    }
    all(o) {
      return this.throwIfDisposed(), this.where(o).length() === this.length();
    }
    forEach(o) {
      this.throwIfDisposed();
      for (let i = 0; i < this.length(); i++)
        o(this.privList[i], i);
    }
    select(o) {
      this.throwIfDisposed();
      const i = [];
      for (let a = 0; a < this.privList.length; a++)
        i.push(o(this.privList[a], a));
      return new Ot(i);
    }
    where(o) {
      this.throwIfDisposed();
      const i = new Ot();
      for (let a = 0; a < this.privList.length; a++)
        o(this.privList[a], a) && i.add(this.privList[a]);
      return i;
    }
    orderBy(o) {
      this.throwIfDisposed();
      const a = this.toArray().sort(o);
      return new Ot(a);
    }
    orderByDesc(o) {
      return this.throwIfDisposed(), this.orderBy((i, a) => o(a, i));
    }
    clone() {
      return this.throwIfDisposed(), new Ot(this.toArray());
    }
    concat(o) {
      return this.throwIfDisposed(), new Ot(this.privList.concat(o.toArray()));
    }
    concatArray(o) {
      return this.throwIfDisposed(), new Ot(this.privList.concat(o));
    }
    isDisposed() {
      return this.privList == null;
    }
    dispose(o) {
      this.isDisposed() || (this.privDisposeReason = o, this.privList = null, this.privAddSubscriptions = null, this.privRemoveSubscriptions = null, this.triggerSubscriptions(this.privDisposedSubscriptions));
    }
    throwIfDisposed() {
      if (this.isDisposed())
        throw new e.ObjectDisposedError("List", this.privDisposeReason);
    }
    triggerSubscriptions(o) {
      if (o)
        for (const i in o)
          i && o[i]();
    }
  };
  return Cr.List = t, Cr;
}
var Do = {}, Ru;
function lv() {
  return Ru || (Ru = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.marshalPromiseToCallbacks = e.Sink = e.Deferred = e.PromiseResultEventSource = e.PromiseResult = e.PromiseState = void 0;
    var t;
    (function(n) {
      n[n.None = 0] = "None", n[n.Resolved = 1] = "Resolved", n[n.Rejected = 2] = "Rejected";
    })(t = e.PromiseState || (e.PromiseState = {}));
    class r {
      constructor(c) {
        this.throwIfError = () => {
          if (this.isError)
            throw this.error;
        }, c.on((u) => {
          this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !1, this.privResult = u);
        }, (u) => {
          this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !0, this.privError = u);
        });
      }
      get isCompleted() {
        return this.privIsCompleted;
      }
      get isError() {
        return this.privIsError;
      }
      get error() {
        return this.privError;
      }
      get result() {
        return this.privResult;
      }
    }
    e.PromiseResult = r;
    class o {
      constructor() {
        this.setResult = (c) => {
          this.privOnSetResult(c);
        }, this.setError = (c) => {
          this.privOnSetError(c);
        }, this.on = (c, u) => {
          this.privOnSetResult = c, this.privOnSetError = u;
        };
      }
    }
    e.PromiseResultEventSource = o;
    class i {
      constructor() {
        this.resolve = (c) => (this.privResolve(c), this), this.reject = (c) => (this.privReject(c), this), this.privPromise = new Promise((c, u) => {
          this.privResolve = c, this.privReject = u;
        });
      }
      get promise() {
        return this.privPromise;
      }
    }
    e.Deferred = i;
    class a {
      constructor() {
        this.privState = t.None, this.privPromiseResult = null, this.privPromiseResultEvents = null, this.privSuccessHandlers = [], this.privErrorHandlers = [], this.privPromiseResultEvents = new o(), this.privPromiseResult = new r(this.privPromiseResultEvents);
      }
      get state() {
        return this.privState;
      }
      get result() {
        return this.privPromiseResult;
      }
      resolve(c) {
        if (this.privState !== t.None)
          throw new Error("'Cannot resolve a completed promise'");
        this.privState = t.Resolved, this.privPromiseResultEvents.setResult(c);
        for (let u = 0; u < this.privSuccessHandlers.length; u++)
          this.executeSuccessCallback(c, this.privSuccessHandlers[u], this.privErrorHandlers[u]);
        this.detachHandlers();
      }
      reject(c) {
        if (this.privState !== t.None)
          throw new Error("'Cannot reject a completed promise'");
        this.privState = t.Rejected, this.privPromiseResultEvents.setError(c);
        for (const u of this.privErrorHandlers)
          this.executeErrorCallback(c, u);
        this.detachHandlers();
      }
      on(c, u) {
        c == null && (c = () => {
        }), this.privState === t.None ? (this.privSuccessHandlers.push(c), this.privErrorHandlers.push(u)) : (this.privState === t.Resolved ? this.executeSuccessCallback(this.privPromiseResult.result, c, u) : this.privState === t.Rejected && this.executeErrorCallback(this.privPromiseResult.error, u), this.detachHandlers());
      }
      executeSuccessCallback(c, u, l) {
        try {
          u(c);
        } catch (p) {
          this.executeErrorCallback(`'Unhandled callback error: ${p}'`, l);
        }
      }
      executeErrorCallback(c, u) {
        if (u)
          try {
            u(c);
          } catch (l) {
            throw new Error(`'Unhandled callback error: ${l}. InnerError: ${c}'`);
          }
        else
          throw new Error(`'Unhandled error: ${c}'`);
      }
      detachHandlers() {
        this.privErrorHandlers = [], this.privSuccessHandlers = [];
      }
    }
    e.Sink = a;
    function s(n, c, u) {
      n.then((l) => {
        try {
          c && c(l);
        } catch (p) {
          if (u)
            try {
              if (p instanceof Error) {
                const h = p;
                u(h.name + ": " + h.message);
              } else
                u(p);
            } catch {
            }
        }
      }, (l) => {
        if (u)
          try {
            if (l instanceof Error) {
              const p = l;
              u(p.name + ": " + p.message);
            } else
              u(l);
          } catch {
          }
      });
    }
    e.marshalPromiseToCallbacks = s;
  }(Do)), Do;
}
var Rr = {}, Pu;
function pv() {
  if (Pu) return Rr;
  Pu = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.Queue = void 0;
  const e = /* @__PURE__ */ xe(), t = /* @__PURE__ */ uv(), r = /* @__PURE__ */ lv();
  var o;
  (function(a) {
    a[a.Dequeue = 0] = "Dequeue", a[a.Peek = 1] = "Peek";
  })(o || (o = {}));
  let i = class {
    constructor(s) {
      this.privPromiseStore = new t.List(), this.privIsDrainInProgress = !1, this.privIsDisposing = !1, this.privDisposeReason = null, this.privList = s || new t.List(), this.privDetachables = [], this.privSubscribers = new t.List(), this.privDetachables.push(this.privList.onAdded(() => this.drain()));
    }
    enqueue(s) {
      this.throwIfDispose(), this.enqueueFromPromise(new Promise((n) => n(s)));
    }
    enqueueFromPromise(s) {
      this.throwIfDispose(), s.then((n) => {
        this.privList.add(n);
      }, () => {
      });
    }
    dequeue() {
      this.throwIfDispose();
      const s = new r.Deferred();
      return this.privSubscribers && (this.privSubscribers.add({ deferral: s, type: o.Dequeue }), this.drain()), s.promise;
    }
    peek() {
      this.throwIfDispose();
      const s = new r.Deferred();
      return this.privSubscribers && (this.privSubscribers.add({ deferral: s, type: o.Peek }), this.drain()), s.promise;
    }
    length() {
      return this.throwIfDispose(), this.privList.length();
    }
    isDisposed() {
      return this.privSubscribers == null;
    }
    async drainAndDispose(s, n) {
      if (!this.isDisposed() && !this.privIsDisposing) {
        this.privDisposeReason = n, this.privIsDisposing = !0;
        const c = this.privSubscribers;
        if (c) {
          for (; c.length() > 0; )
            c.removeFirst().deferral.resolve(void 0);
          this.privSubscribers === c && (this.privSubscribers = c);
        }
        for (const u of this.privDetachables)
          await u.detach();
        if (this.privPromiseStore.length() > 0 && s) {
          const u = [];
          return this.privPromiseStore.toArray().forEach((l) => {
            u.push(l);
          }), Promise.all(u).finally(() => {
            this.privSubscribers = null, this.privList.forEach((l) => {
              s(l);
            }), this.privList = null;
          }).then();
        } else
          this.privSubscribers = null, this.privList = null;
      }
    }
    async dispose(s) {
      await this.drainAndDispose(null, s);
    }
    drain() {
      if (!this.privIsDrainInProgress && !this.privIsDisposing) {
        this.privIsDrainInProgress = !0;
        const s = this.privSubscribers, n = this.privList;
        if (s && n) {
          for (; n.length() > 0 && s.length() > 0 && !this.privIsDisposing; ) {
            const c = s.removeFirst();
            if (c.type === o.Peek)
              c.deferral.resolve(n.first());
            else {
              const u = n.removeFirst();
              c.deferral.resolve(u);
            }
          }
          this.privSubscribers === s && (this.privSubscribers = s), this.privList === n && (this.privList = n);
        }
        this.privIsDrainInProgress = !1;
      }
    }
    throwIfDispose() {
      if (this.isDisposed())
        throw this.privDisposeReason ? new e.InvalidOperationError(this.privDisposeReason) : new e.ObjectDisposedError("Queue");
      if (this.privIsDisposing)
        throw new e.InvalidOperationError("Queue disposing");
    }
  };
  return Rr.Queue = i, Rr;
}
var Pr = {}, wu;
function $C() {
  if (wu) return Pr;
  wu = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.RawWebsocketMessage = void 0;
  const e = /* @__PURE__ */ ov(), t = /* @__PURE__ */ xe(), r = /* @__PURE__ */ Nt();
  let o = class {
    constructor(a, s, n) {
      if (this.privPayload = null, !s)
        throw new t.ArgumentNullError("payload");
      if (a === e.MessageType.Binary && Object.getPrototypeOf(s).constructor.name !== "ArrayBuffer")
        throw new t.InvalidOperationError("Payload must be ArrayBuffer");
      if (a === e.MessageType.Text && typeof s != "string")
        throw new t.InvalidOperationError("Payload must be a string");
      this.privMessageType = a, this.privPayload = s, this.privId = n || (0, r.createNoDashGuid)();
    }
    get messageType() {
      return this.privMessageType;
    }
    get payload() {
      return this.privPayload;
    }
    get textContent() {
      if (this.privMessageType === e.MessageType.Binary)
        throw new t.InvalidOperationError("Not supported for binary message");
      return this.privPayload;
    }
    get binaryContent() {
      if (this.privMessageType === e.MessageType.Text)
        throw new t.InvalidOperationError("Not supported for text message");
      return this.privPayload;
    }
    get id() {
      return this.privId;
    }
  };
  return Pr.RawWebsocketMessage = o, Pr;
}
var wr = {}, bu;
function VC() {
  if (bu) return wr;
  bu = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.RiffPcmEncoder = void 0;
  let e = class {
    constructor(r, o) {
      this.privActualSampleRate = r, this.privDesiredSampleRate = o;
    }
    encode(r) {
      const o = this.downSampleAudioFrame(r, this.privActualSampleRate, this.privDesiredSampleRate);
      if (!o)
        return null;
      const i = o.length * 2, a = new ArrayBuffer(i), s = new DataView(a);
      return this.floatTo16BitPCM(s, 0, o), a;
    }
    setString(r, o, i) {
      for (let a = 0; a < i.length; a++)
        r.setUint8(o + a, i.charCodeAt(a));
    }
    floatTo16BitPCM(r, o, i) {
      for (let a = 0; a < i.length; a++, o += 2) {
        const s = Math.max(-1, Math.min(1, i[a]));
        r.setInt16(o, s < 0 ? s * 32768 : s * 32767, !0);
      }
    }
    downSampleAudioFrame(r, o, i) {
      if (!r)
        return null;
      if (i === o || i > o)
        return r;
      const a = o / i, s = Math.round(r.length / a), n = new Float32Array(s);
      let c = 0, u = 0;
      for (; u < s; ) {
        const l = Math.round((u + 1) * a);
        let p = 0, h = 0;
        for (; c < l && c < r.length; )
          p += r[c++], h++;
        n[u++] = p / h;
      }
      return n;
    }
  };
  return wr.RiffPcmEncoder = e, wr;
}
var br = {}, Eu;
function WC() {
  if (Eu) return br;
  Eu = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.Stream = void 0;
  const e = /* @__PURE__ */ xe(), t = /* @__PURE__ */ Nt(), r = /* @__PURE__ */ pv();
  let o = class {
    constructor(a) {
      this.privIsWriteEnded = !1, this.privIsReadEnded = !1, this.privId = a || (0, t.createNoDashGuid)(), this.privReaderQueue = new r.Queue();
    }
    get isClosed() {
      return this.privIsWriteEnded;
    }
    get isReadEnded() {
      return this.privIsReadEnded;
    }
    get id() {
      return this.privId;
    }
    close() {
      this.privIsWriteEnded || (this.writeStreamChunk({
        buffer: null,
        isEnd: !0,
        timeReceived: Date.now()
      }), this.privIsWriteEnded = !0);
    }
    writeStreamChunk(a) {
      if (this.throwIfClosed(), !this.privReaderQueue.isDisposed())
        try {
          this.privReaderQueue.enqueue(a);
        } catch {
        }
    }
    read() {
      if (this.privIsReadEnded)
        throw new e.InvalidOperationError("Stream read has already finished");
      return this.privReaderQueue.dequeue().then(async (a) => ((a === void 0 || a.isEnd) && await this.privReaderQueue.dispose("End of stream reached"), a));
    }
    readEnded() {
      this.privIsReadEnded || (this.privIsReadEnded = !0, this.privReaderQueue = new r.Queue());
    }
    throwIfClosed() {
      if (this.privIsWriteEnded)
        throw new e.InvalidOperationError("Stream closed");
    }
  };
  return br.Stream = o, br;
}
var xo = {}, Iu;
function pc() {
  return Iu || (Iu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TranslationStatus = void 0, function(t) {
      t[t.Success = 0] = "Success", t[t.Error = 1] = "Error";
    }(e.TranslationStatus || (e.TranslationStatus = {}));
  }(xo)), xo;
}
var Er = {}, Au;
function HC() {
  if (Au) return Er;
  Au = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.ChunkedArrayBufferStream = void 0;
  const e = /* @__PURE__ */ M();
  let t = class extends e.Stream {
    constructor(o, i) {
      super(i), this.privTargetChunkSize = Math.round(o), this.privNextBufferReadyBytes = 0;
    }
    writeStreamChunk(o) {
      if (o.isEnd || this.privNextBufferReadyBytes === 0 && o.buffer.byteLength === this.privTargetChunkSize) {
        super.writeStreamChunk(o);
        return;
      }
      let i = 0;
      for (; i < o.buffer.byteLength; ) {
        this.privNextBufferToWrite === void 0 && (this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize), this.privNextBufferStartTime = o.timeReceived);
        const a = Math.min(o.buffer.byteLength - i, this.privTargetChunkSize - this.privNextBufferReadyBytes), s = new Uint8Array(this.privNextBufferToWrite), n = new Uint8Array(o.buffer.slice(i, a + i));
        s.set(n, this.privNextBufferReadyBytes), this.privNextBufferReadyBytes += a, i += a, this.privNextBufferReadyBytes === this.privTargetChunkSize && (super.writeStreamChunk({
          buffer: this.privNextBufferToWrite,
          isEnd: !1,
          timeReceived: this.privNextBufferStartTime
        }), this.privNextBufferReadyBytes = 0, this.privNextBufferToWrite = void 0);
      }
    }
    close() {
      this.privNextBufferReadyBytes !== 0 && !this.isClosed && super.writeStreamChunk({
        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
        isEnd: !1,
        timeReceived: this.privNextBufferStartTime
      }), super.close();
    }
  };
  return Er.ChunkedArrayBufferStream = t, Er;
}
var No = {}, Tu;
function KC() {
  return Tu || (Tu = 1, Object.defineProperty(No, "__esModule", { value: !0 })), No;
}
var Ir = {}, _u;
function JC() {
  if (_u) return Ir;
  _u = 1, Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.Timeout = void 0;
  let e = class Ze {
    static load() {
      const r = /* @__PURE__ */ new Map([[0, () => {
      }]]), o = /* @__PURE__ */ new Map(), a = "data:text/javascript;base64," + btoa(`!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id "'.concat(e,'".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error('The given method "'.concat(e.method,'" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`), s = new Worker(a);
      return s.addEventListener("message", ({ data: u }) => {
        if (Ze.isCallNotification(u)) {
          const { params: { timerId: l } } = u, p = r.get(l);
          if (typeof p == "number") {
            const h = o.get(p);
            if (h === void 0 || h !== l)
              throw new Error("The timer is in an undefined state.");
          } else if (typeof p < "u")
            p(), r.delete(l);
          else
            throw new Error("The timer is in an undefined state.");
        } else if (Ze.isClearResponse(u)) {
          const { id: l } = u, p = o.get(l);
          if (p === void 0)
            throw new Error("The timer is in an undefined state.");
          o.delete(l), r.delete(p);
        } else {
          const { error: { message: l } } = u;
          throw new Error(l);
        }
      }), {
        clearTimeout: (u) => {
          const l = Math.random();
          o.set(l, u), r.set(u, l), s.postMessage({
            id: l,
            method: "clear",
            params: { timerId: u }
          });
        },
        setTimeout: (u, l) => {
          const p = Math.random();
          return r.set(p, u), s.postMessage({
            id: null,
            method: "set",
            params: {
              delay: l,
              now: performance.now(),
              timerId: p
            }
          }), p;
        }
      };
    }
    static loadWorkerTimers() {
      return () => (Ze.workerTimers !== null || (Ze.workerTimers = Ze.load()), Ze.workerTimers);
    }
    static isCallNotification(r) {
      return r.method !== void 0 && r.method === "call";
    }
    static isClearResponse(r) {
      return r.error === null && typeof r.id == "number";
    }
  };
  return Ir.Timeout = e, e.workerTimers = null, e.clearTimeout = (t) => e.timers().clearTimeout(t), e.setTimeout = (t, r) => e.timers().setTimeout(t, r), e.timers = e.loadWorkerTimers(), Ir;
}
var B = {}, ku;
function GC() {
  if (ku) return B;
  ku = 1, Object.defineProperty(B, "__esModule", { value: !0 }), B.OCSPCacheUpdateErrorEvent = B.OCSPResponseRetrievedEvent = B.OCSPCacheFetchErrorEvent = B.OCSPVerificationFailedEvent = B.OCSPCacheHitEvent = B.OCSPCacheEntryNeedsRefreshEvent = B.OCSPCacheEntryExpiredEvent = B.OCSPWSUpgradeStartedEvent = B.OCSPStapleReceivedEvent = B.OCSPCacheUpdateCompleteEvent = B.OCSPDiskCacheStoreEvent = B.OCSPMemoryCacheStoreEvent = B.OCSPCacheUpdateNeededEvent = B.OCSPDiskCacheHitEvent = B.OCSPCacheMissEvent = B.OCSPMemoryCacheHitEvent = B.OCSPEvent = void 0;
  const e = /* @__PURE__ */ Rs();
  class t extends e.PlatformEvent {
    constructor(S, C, P) {
      super(S, C), this.privSignature = P;
    }
  }
  B.OCSPEvent = t;
  class r extends t {
    constructor(S) {
      super("OCSPMemoryCacheHitEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPMemoryCacheHitEvent = r;
  class o extends t {
    constructor(S) {
      super("OCSPCacheMissEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPCacheMissEvent = o;
  class i extends t {
    constructor(S) {
      super("OCSPDiskCacheHitEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPDiskCacheHitEvent = i;
  class a extends t {
    constructor(S) {
      super("OCSPCacheUpdateNeededEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPCacheUpdateNeededEvent = a;
  class s extends t {
    constructor(S) {
      super("OCSPMemoryCacheStoreEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPMemoryCacheStoreEvent = s;
  class n extends t {
    constructor(S) {
      super("OCSPDiskCacheStoreEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPDiskCacheStoreEvent = n;
  class c extends t {
    constructor(S) {
      super("OCSPCacheUpdateCompleteEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPCacheUpdateCompleteEvent = c;
  class u extends t {
    constructor() {
      super("OCSPStapleReceivedEvent", e.EventType.Debug, "");
    }
  }
  B.OCSPStapleReceivedEvent = u;
  class l extends t {
    constructor(S) {
      super("OCSPWSUpgradeStartedEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPWSUpgradeStartedEvent = l;
  class p extends t {
    constructor(S, C) {
      super("OCSPCacheEntryExpiredEvent", e.EventType.Debug, S), this.privExpireTime = C;
    }
  }
  B.OCSPCacheEntryExpiredEvent = p;
  class h extends t {
    constructor(S, C, P) {
      super("OCSPCacheEntryNeedsRefreshEvent", e.EventType.Debug, S), this.privExpireTime = P, this.privStartTime = C;
    }
  }
  B.OCSPCacheEntryNeedsRefreshEvent = h;
  class d extends t {
    constructor(S, C, P) {
      super("OCSPCacheHitEvent", e.EventType.Debug, S), this.privExpireTime = P, this.privExpireTimeString = new Date(P).toLocaleDateString(), this.privStartTime = C, this.privStartTimeString = new Date(C).toLocaleTimeString();
    }
  }
  B.OCSPCacheHitEvent = d;
  class f extends t {
    constructor(S, C) {
      super("OCSPVerificationFailedEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  B.OCSPVerificationFailedEvent = f;
  class g extends t {
    constructor(S, C) {
      super("OCSPCacheFetchErrorEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  B.OCSPCacheFetchErrorEvent = g;
  class m extends t {
    constructor(S) {
      super("OCSPResponseRetrievedEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPResponseRetrievedEvent = m;
  class v extends t {
    constructor(S, C) {
      super("OCSPCacheUpdateErrorEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  return B.OCSPCacheUpdateErrorEvent = v, B;
}
var Ar = {}, Ou;
function QC() {
  if (Ou) return Ar;
  Ou = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.BackgroundEvent = void 0;
  const e = /* @__PURE__ */ M();
  class t extends e.PlatformEvent {
    constructor(o) {
      super("BackgroundEvent", e.EventType.Error), this.privError = o;
    }
    get error() {
      return this.privError;
    }
  }
  return Ar.BackgroundEvent = t, Ar;
}
var Mu;
function M() {
  return Mu || (Mu = 1, function(e) {
    var t = lt && lt.__createBinding || (Object.create ? function(i, a, s, n) {
      n === void 0 && (n = s), Object.defineProperty(i, n, { enumerable: !0, get: function() {
        return a[s];
      } });
    } : function(i, a, s, n) {
      n === void 0 && (n = s), i[n] = a[s];
    }), r = lt && lt.__exportStar || function(i, a) {
      for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(a, s) && t(a, i, s);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TranslationStatus = void 0, r(/* @__PURE__ */ TC(), e), r(/* @__PURE__ */ _C(), e), r(/* @__PURE__ */ ov(), e), r(/* @__PURE__ */ kC(), e), r(/* @__PURE__ */ OC(), e), r(/* @__PURE__ */ av(), e), r(/* @__PURE__ */ xe(), e), r(/* @__PURE__ */ MC(), e), r(/* @__PURE__ */ cv(), e), r(/* @__PURE__ */ Nt(), e), r(/* @__PURE__ */ DC(), e), r(/* @__PURE__ */ xC(), e), r(/* @__PURE__ */ NC(), e), r(/* @__PURE__ */ zC(), e), r(/* @__PURE__ */ LC(), e), r(/* @__PURE__ */ jC(), e), r(/* @__PURE__ */ qC(), e), r(/* @__PURE__ */ FC(), e), r(/* @__PURE__ */ BC(), e), r(/* @__PURE__ */ UC(), e), r(/* @__PURE__ */ uv(), e), r(/* @__PURE__ */ Rs(), e), r(/* @__PURE__ */ lv(), e), r(/* @__PURE__ */ pv(), e), r(/* @__PURE__ */ $C(), e), r(/* @__PURE__ */ VC(), e), r(/* @__PURE__ */ WC(), e);
    var o = /* @__PURE__ */ pc();
    Object.defineProperty(e, "TranslationStatus", { enumerable: !0, get: function() {
      return o.TranslationStatus;
    } }), r(/* @__PURE__ */ HC(), e), r(/* @__PURE__ */ KC(), e), r(/* @__PURE__ */ JC(), e), r(/* @__PURE__ */ GC(), e), r(/* @__PURE__ */ QC(), e);
  }(lt)), lt;
}
var Tr = {}, Du;
function le() {
  if (Du) return Tr;
  Du = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.HeaderNames = void 0;
  let e = class {
  };
  return Tr.HeaderNames = e, e.AuthKey = "Ocp-Apim-Subscription-Key", e.Authorization = "Authorization", e.SpIDAuthKey = "Apim-Subscription-Id", e.ConnectionId = "X-ConnectionId", e.ContentType = "Content-Type", e.CustomCommandsAppId = "X-CommandsAppId", e.Path = "Path", e.RequestId = "X-RequestId", e.RequestStreamId = "X-StreamId", e.RequestTimestamp = "X-Timestamp", Tr;
}
var _r = {}, xu;
function dc() {
  if (xu) return _r;
  xu = 1, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.AuthInfo = void 0;
  class e {
    constructor(r, o) {
      this.privHeaderName = r, this.privToken = o;
    }
    get headerName() {
      return this.privHeaderName;
    }
    get token() {
      return this.privToken;
    }
  }
  return _r.AuthInfo = e, _r;
}
var Nu;
function YC() {
  if (Nu) return nr;
  Nu = 1, Object.defineProperty(nr, "__esModule", { value: !0 }), nr.CognitiveSubscriptionKeyAuthentication = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ le(), r = /* @__PURE__ */ dc();
  let o = class {
    /**
     * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
     * @constructor
     * @param {string} subscriptionKey - The subscription key
     */
    constructor(a) {
      if (!a)
        throw new e.ArgumentNullError("subscriptionKey");
      this.privAuthInfo = new r.AuthInfo(t.HeaderNames.AuthKey, a);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fetch(a) {
      return Promise.resolve(this.privAuthInfo);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fetchOnExpiry(a) {
      return Promise.resolve(this.privAuthInfo);
    }
  };
  return nr.CognitiveSubscriptionKeyAuthentication = o, nr;
}
var kr = {}, zu;
function ZC() {
  if (zu) return kr;
  zu = 1, Object.defineProperty(kr, "__esModule", { value: !0 }), kr.CognitiveTokenAuthentication = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ dc(), r = /* @__PURE__ */ le();
  let o = class Ha {
    constructor(a, s) {
      if (!a)
        throw new e.ArgumentNullError("fetchCallback");
      if (!s)
        throw new e.ArgumentNullError("fetchOnExpiryCallback");
      this.privFetchCallback = a, this.privFetchOnExpiryCallback = s;
    }
    fetch(a) {
      return this.privFetchCallback(a).then((s) => new t.AuthInfo(r.HeaderNames.Authorization, s === void 0 ? void 0 : Ha.privTokenPrefix + s));
    }
    fetchOnExpiry(a) {
      return this.privFetchOnExpiryCallback(a).then((s) => new t.AuthInfo(r.HeaderNames.Authorization, s === void 0 ? void 0 : Ha.privTokenPrefix + s));
    }
  };
  return kr.CognitiveTokenAuthentication = o, o.privTokenPrefix = "Bearer ", kr;
}
var zo = {}, Lu;
function XC() {
  return Lu || (Lu = 1, Object.defineProperty(zo, "__esModule", { value: !0 })), zo;
}
var Lo = {}, ju;
function eR() {
  return ju || (ju = 1, Object.defineProperty(Lo, "__esModule", { value: !0 })), Lo;
}
var Or = {}, ht = {}, Ie = {};
const tR = {}, rR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: tR
}, Symbol.toStringTag, { value: "Module" })), Dt = /* @__PURE__ */ gC(rR);
var jo = {}, qu;
function dv() {
  return qu || (qu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LogLevel = void 0;
    const t = /* @__PURE__ */ M();
    Object.defineProperty(e, "LogLevel", { enumerable: !0, get: function() {
      return t.EventType;
    } });
  }(jo)), jo;
}
var Mr = {}, Fu;
function z() {
  if (Fu) return Mr;
  Fu = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.Contracts = void 0;
  let e = class Mt {
    static throwIfNullOrUndefined(r, o) {
      if (r == null)
        throw new Error("throwIfNullOrUndefined:" + o);
    }
    static throwIfNull(r, o) {
      if (r === null)
        throw new Error("throwIfNull:" + o);
    }
    static throwIfNullOrWhitespace(r, o) {
      if (Mt.throwIfNullOrUndefined(r, o), ("" + r).trim().length < 1)
        throw new Error("throwIfNullOrWhitespace:" + o);
    }
    static throwIfNullOrTooLong(r, o, i) {
      if (Mt.throwIfNullOrUndefined(r, o), ("" + r).length > i)
        throw new Error("throwIfNullOrTooLong:" + o + " (more than " + i.toString() + " characters)");
    }
    static throwIfNullOrTooShort(r, o, i) {
      if (Mt.throwIfNullOrUndefined(r, o), ("" + r).length < i)
        throw new Error("throwIfNullOrTooShort:" + o + " (less than " + i.toString() + " characters)");
    }
    static throwIfDisposed(r) {
      if (r)
        throw new Error("the object is already disposed");
    }
    static throwIfArrayEmptyOrWhitespace(r, o) {
      if (Mt.throwIfNullOrUndefined(r, o), r.length === 0)
        throw new Error("throwIfArrayEmptyOrWhitespace:" + o);
      for (const i of r)
        Mt.throwIfNullOrWhitespace(i, o);
    }
    static throwIfFileDoesNotExist(r, o) {
      Mt.throwIfNullOrWhitespace(r, o);
    }
    static throwIfNotUndefined(r, o) {
      if (r !== void 0)
        throw new Error("throwIfNotUndefined:" + o);
    }
  };
  return Mr.Contracts = e, Mr;
}
var Bu;
function nR() {
  if (Bu) return Ie;
  Bu = 1;
  var e = Ie && Ie.__createBinding || (Object.create ? function(n, c, u, l) {
    l === void 0 && (l = u), Object.defineProperty(n, l, { enumerable: !0, get: function() {
      return c[u];
    } });
  } : function(n, c, u, l) {
    l === void 0 && (l = u), n[l] = c[u];
  }), t = Ie && Ie.__setModuleDefault || (Object.create ? function(n, c) {
    Object.defineProperty(n, "default", { enumerable: !0, value: c });
  } : function(n, c) {
    n.default = c;
  }), r = Ie && Ie.__importStar || function(n) {
    if (n && n.__esModule) return n;
    var c = {};
    if (n != null) for (var u in n) u !== "default" && Object.prototype.hasOwnProperty.call(n, u) && e(c, n, u);
    return t(c, n), c;
  };
  Object.defineProperty(Ie, "__esModule", { value: !0 }), Ie.ConsoleLoggingListener = void 0;
  const o = r(Dt), i = /* @__PURE__ */ dv(), a = /* @__PURE__ */ z();
  let s = class {
    constructor(c = i.LogLevel.None) {
      this.privLogPath = void 0, this.privEnableConsoleOutput = !0, this.privLogLevelFilter = c;
    }
    set logPath(c) {
      a.Contracts.throwIfNullOrUndefined(o.openSync, `
File System access not available`), this.privLogPath = c;
    }
    set enableConsoleOutput(c) {
      this.privEnableConsoleOutput = c;
    }
    onEvent(c) {
      if (c.eventType >= this.privLogLevelFilter) {
        const u = this.toString(c);
        if (this.logCallback && this.logCallback(u), this.privLogPath && o.writeFileSync(this.privLogPath, u + `
`, { flag: "a+" }), this.privEnableConsoleOutput)
          switch (c.eventType) {
            case i.LogLevel.Debug:
              console.debug(u);
              break;
            case i.LogLevel.Info:
              console.info(u);
              break;
            case i.LogLevel.Warning:
              console.warn(u);
              break;
            case i.LogLevel.Error:
              console.error(u);
              break;
            default:
              console.log(u);
              break;
          }
      }
    }
    toString(c) {
      const u = [
        `${c.eventTime}`,
        `${c.name}`
      ], l = c;
      for (const p in l)
        if (p && c.hasOwnProperty(p) && p !== "eventTime" && p !== "eventType" && p !== "eventId" && p !== "name" && p !== "constructor") {
          const h = l[p];
          let d = "<NULL>";
          h != null && (typeof h == "number" || typeof h == "string" ? d = h.toString() : d = JSON.stringify(h)), u.push(`${p}: ${d}`);
        }
      return u.join(" | ");
    }
  };
  return Ie.ConsoleLoggingListener = s, Ie;
}
var qo = {}, Uu;
function iR() {
  return Uu || (Uu = 1, Object.defineProperty(qo, "__esModule", { value: !0 })), qo;
}
var Fo = {}, Bo = {}, $u;
function zt() {
  return $u || ($u = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AudioStreamFormatImpl = e.AudioStreamFormat = e.AudioFormatTag = void 0;
    var t;
    (function(i) {
      i[i.PCM = 1] = "PCM", i[i.MuLaw = 2] = "MuLaw", i[i.Siren = 3] = "Siren", i[i.MP3 = 4] = "MP3", i[i.SILKSkype = 5] = "SILKSkype", i[i.OGG_OPUS = 6] = "OGG_OPUS", i[i.WEBM_OPUS = 7] = "WEBM_OPUS", i[i.ALaw = 8] = "ALaw", i[i.FLAC = 9] = "FLAC", i[i.OPUS = 10] = "OPUS", i[i.AMR_WB = 11] = "AMR_WB", i[i.G722 = 12] = "G722";
    })(t = e.AudioFormatTag || (e.AudioFormatTag = {}));
    class r {
      /**
       * Creates an audio stream format object representing the default audio stream
       * format (16KHz 16bit mono PCM).
       * @member AudioStreamFormat.getDefaultInputFormat
       * @function
       * @public
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getDefaultInputFormat() {
        return o.getDefaultInputFormat();
      }
      /**
       * Creates an audio stream format object with the specified format characteristics.
       * @member AudioStreamFormat.getWaveFormat
       * @function
       * @public
       * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
       * @param {number} bitsPerSample - Bits per sample, typically 16.
       * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
       * uses one channel and stereo data uses two channels.
       * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getWaveFormat(a, s, n, c) {
        return new o(a, s, n, c);
      }
      /**
       * Creates an audio stream format object with the specified pcm waveformat characteristics.
       * @member AudioStreamFormat.getWaveFormatPCM
       * @function
       * @public
       * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
       * @param {number} bitsPerSample - Bits per sample, typically 16.
       * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
       * uses one channel and stereo data uses two channels.
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getWaveFormatPCM(a, s, n) {
        return new o(a, s, n);
      }
    }
    e.AudioStreamFormat = r;
    class o extends r {
      /**
       * Creates an instance with the given values.
       * @constructor
       * @param {number} samplesPerSec - Samples per second.
       * @param {number} bitsPerSample - Bits per sample.
       * @param {number} channels - Number of channels.
       * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
       */
      constructor(a = 16e3, s = 16, n = 1, c = t.PCM) {
        super();
        let u = !0;
        switch (c) {
          case t.PCM:
            this.formatTag = 1;
            break;
          case t.ALaw:
            this.formatTag = 6;
            break;
          case t.MuLaw:
            this.formatTag = 7;
            break;
          default:
            u = !1;
        }
        if (this.bitsPerSample = s, this.samplesPerSec = a, this.channels = n, this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8), this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8), u) {
          this.privHeader = new ArrayBuffer(44);
          const l = new DataView(this.privHeader);
          this.setString(l, 0, "RIFF"), l.setUint32(4, 0, !0), this.setString(l, 8, "WAVEfmt "), l.setUint32(16, 16, !0), l.setUint16(20, this.formatTag, !0), l.setUint16(22, this.channels, !0), l.setUint32(24, this.samplesPerSec, !0), l.setUint32(28, this.avgBytesPerSec, !0), l.setUint16(32, this.channels * (this.bitsPerSample / 8), !0), l.setUint16(34, this.bitsPerSample, !0), this.setString(l, 36, "data"), l.setUint32(40, 0, !0);
        }
      }
      /**
       * Retrieves the default input format.
       * @member AudioStreamFormatImpl.getDefaultInputFormat
       * @function
       * @public
       * @returns {AudioStreamFormatImpl} The default input format.
       */
      static getDefaultInputFormat() {
        return new o();
      }
      /**
       * Creates an audio context appropriate to current browser
       * @member AudioStreamFormatImpl.getAudioContext
       * @function
       * @public
       * @returns {AudioContext} An audio context instance
       */
      /* eslint-disable */
      static getAudioContext(a) {
        const s = window.AudioContext || window.webkitAudioContext || !1;
        if (s)
          return a !== void 0 && navigator.mediaDevices.getSupportedConstraints().sampleRate ? new s({ sampleRate: a }) : new s();
        throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
      }
      /* eslint-enable */
      /**
       * Closes the configuration object.
       * @member AudioStreamFormatImpl.prototype.close
       * @function
       * @public
       */
      close() {
      }
      get header() {
        return this.privHeader;
      }
      setString(a, s, n) {
        for (let c = 0; c < n.length; c++)
          a.setUint8(s + c, n.charCodeAt(c));
      }
    }
    e.AudioStreamFormatImpl = o;
  }(Bo)), Bo;
}
var Vu;
function sR() {
  return Vu || (Vu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MicAudioSource = e.AudioWorkletSourceURLPropertyName = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ M(), o = /* @__PURE__ */ zt();
    e.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
    class i {
      constructor(s, n, c, u) {
        this.privRecorder = s, this.deviceId = n, this.privStreams = {}, this.privOutputChunkSize = i.AUDIOFORMAT.avgBytesPerSec / 10, this.privId = c || (0, r.createNoDashGuid)(), this.privEvents = new r.EventSource(), this.privMediaStream = u || null, this.privIsClosing = !1;
      }
      get format() {
        return Promise.resolve(i.AUDIOFORMAT);
      }
      turnOn() {
        if (this.privInitializeDeferral)
          return this.privInitializeDeferral.promise;
        this.privInitializeDeferral = new r.Deferred();
        try {
          this.createAudioContext();
        } catch (c) {
          if (c instanceof Error) {
            const u = c;
            this.privInitializeDeferral.reject(u.name + ": " + u.message);
          } else
            this.privInitializeDeferral.reject(c);
          return this.privInitializeDeferral.promise;
        }
        const s = window.navigator;
        let n = (
          // eslint-disable-next-line
          s.getUserMedia || s.webkitGetUserMedia || s.mozGetUserMedia || s.msGetUserMedia
        );
        if (s.mediaDevices && (n = (c, u, l) => {
          s.mediaDevices.getUserMedia(c).then(u).catch(l);
        }), n) {
          const c = () => {
            this.onEvent(new r.AudioSourceInitializingEvent(this.privId)), this.privMediaStream && this.privMediaStream.active ? (this.onEvent(new r.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve()) : n({ audio: this.deviceId ? { deviceId: this.deviceId } : !0, video: !1 }, (u) => {
              this.privMediaStream = u, this.onEvent(new r.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve();
            }, (u) => {
              const l = `Error occurred during microphone initialization: ${u}`;
              this.privInitializeDeferral.reject(l), this.onEvent(new r.AudioSourceErrorEvent(this.privId, l));
            });
          };
          this.privContext.state === "suspended" ? this.privContext.resume().then(c).catch((u) => {
            this.privInitializeDeferral.reject(`Failed to initialize audio context: ${u}`);
          }) : c();
        } else {
          const c = "Browser does not support getUserMedia.";
          this.privInitializeDeferral.reject(c), this.onEvent(new r.AudioSourceErrorEvent(c, ""));
        }
        return this.privInitializeDeferral.promise;
      }
      id() {
        return this.privId;
      }
      attach(s) {
        return this.onEvent(new r.AudioStreamNodeAttachingEvent(this.privId, s)), this.listen(s).then((n) => (this.onEvent(new r.AudioStreamNodeAttachedEvent(this.privId, s)), {
          detach: async () => (n.readEnded(), delete this.privStreams[s], this.onEvent(new r.AudioStreamNodeDetachedEvent(this.privId, s)), this.turnOff()),
          id: () => s,
          read: () => n.read()
        }));
      }
      detach(s) {
        s && this.privStreams[s] && (this.privStreams[s].close(), delete this.privStreams[s], this.onEvent(new r.AudioStreamNodeDetachedEvent(this.privId, s)));
      }
      async turnOff() {
        for (const s in this.privStreams)
          if (s) {
            const n = this.privStreams[s];
            n && n.close();
          }
        this.onEvent(new r.AudioSourceOffEvent(this.privId)), this.privInitializeDeferral && (await this.privInitializeDeferral, this.privInitializeDeferral = null), await this.destroyAudioContext();
      }
      get events() {
        return this.privEvents;
      }
      get deviceInfo() {
        return this.getMicrophoneLabel().then((s) => ({
          bitspersample: i.AUDIOFORMAT.bitsPerSample,
          channelcount: i.AUDIOFORMAT.channels,
          connectivity: t.connectivity.Unknown,
          manufacturer: "Speech SDK",
          model: s,
          samplerate: i.AUDIOFORMAT.samplesPerSec,
          type: t.type.Microphones
        }));
      }
      setProperty(s, n) {
        if (s === e.AudioWorkletSourceURLPropertyName)
          this.privRecorder.setWorkletUrl(n);
        else
          throw new Error("Property '" + s + "' is not supported on Microphone.");
      }
      getMicrophoneLabel() {
        const s = "microphone";
        if (this.privMicrophoneLabel !== void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        if (this.privMediaStream === void 0 || !this.privMediaStream.active)
          return Promise.resolve(s);
        this.privMicrophoneLabel = s;
        const n = this.privMediaStream.getTracks()[0].getSettings().deviceId;
        if (n === void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        const c = new r.Deferred();
        return navigator.mediaDevices.enumerateDevices().then((u) => {
          for (const l of u)
            if (l.deviceId === n) {
              this.privMicrophoneLabel = l.label;
              break;
            }
          c.resolve(this.privMicrophoneLabel);
        }, () => c.resolve(this.privMicrophoneLabel)), c.promise;
      }
      async listen(s) {
        await this.turnOn();
        const n = new r.ChunkedArrayBufferStream(this.privOutputChunkSize, s);
        this.privStreams[s] = n;
        try {
          this.privRecorder.record(this.privContext, this.privMediaStream, n);
        } catch (u) {
          throw this.onEvent(new r.AudioStreamNodeErrorEvent(this.privId, s, u)), u;
        }
        return n;
      }
      onEvent(s) {
        this.privEvents.onEvent(s), r.Events.instance.onEvent(s);
      }
      createAudioContext() {
        this.privContext || (this.privContext = o.AudioStreamFormatImpl.getAudioContext(i.AUDIOFORMAT.samplesPerSec));
      }
      async destroyAudioContext() {
        if (!this.privContext)
          return;
        this.privRecorder.releaseMediaResources(this.privContext);
        let s = !1;
        "close" in this.privContext && (s = !0), s ? this.privIsClosing || (this.privIsClosing = !0, await this.privContext.close(), this.privContext = null, this.privIsClosing = !1) : this.privContext !== null && this.privContext.state === "running" && await this.privContext.suspend();
      }
    }
    e.MicAudioSource = i, i.AUDIOFORMAT = o.AudioStreamFormat.getDefaultInputFormat();
  }(Fo)), Fo;
}
var Dr = {}, Wu;
function oR() {
  if (Wu) return Dr;
  Wu = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.FileAudioSource = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ zt();
  let o = class {
    constructor(a, s, n) {
      this.privStreams = {}, this.privHeaderEnd = 44, this.privId = n || (0, t.createNoDashGuid)(), this.privEvents = new t.EventSource(), this.privSource = a, typeof window < "u" && typeof Blob < "u" && this.privSource instanceof Blob ? this.privFilename = a.name : this.privFilename = s || "unknown.wav", this.privAudioFormatPromise = this.readHeader();
    }
    get format() {
      return this.privAudioFormatPromise;
    }
    turnOn() {
      if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
        const a = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
        return this.onEvent(new t.AudioSourceErrorEvent(a, "")), Promise.reject(a);
      }
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    id() {
      return this.privId;
    }
    async attach(a) {
      this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, a));
      const s = await this.upload(a);
      return this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, a)), Promise.resolve({
        detach: async () => {
          s.readEnded(), delete this.privStreams[a], this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, a)), await this.turnOff();
        },
        id: () => a,
        read: () => s.read()
      });
    }
    detach(a) {
      a && this.privStreams[a] && (this.privStreams[a].close(), delete this.privStreams[a], this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, a)));
    }
    turnOff() {
      for (const a in this.privStreams)
        if (a) {
          const s = this.privStreams[a];
          s && !s.isClosed && s.close();
        }
      return this.onEvent(new t.AudioSourceOffEvent(this.privId)), Promise.resolve();
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return this.privAudioFormatPromise.then((a) => Promise.resolve({
        bitspersample: a.bitsPerSample,
        channelcount: a.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "File",
        samplerate: a.samplesPerSec,
        type: e.type.File
      }));
    }
    readHeader() {
      const s = this.privSource.slice(0, 4296), n = new t.Deferred(), c = (u) => {
        const l = new DataView(u), p = (v) => String.fromCharCode(l.getUint8(v), l.getUint8(v + 1), l.getUint8(v + 2), l.getUint8(v + 3));
        if (p(0) !== "RIFF") {
          n.reject("Invalid WAV header in file, RIFF was not found");
          return;
        }
        if (p(8) !== "WAVE" || p(12) !== "fmt ") {
          n.reject("Invalid WAV header in file, WAVEfmt was not found");
          return;
        }
        const h = l.getInt32(16, !0), d = l.getUint16(22, !0), f = l.getUint32(24, !0), g = l.getUint16(34, !0);
        let m = 36 + Math.max(h - 16, 0);
        for (; p(m) !== "data"; m += 2)
          if (m > 4288) {
            n.reject("Invalid WAV header in file, data block was not found");
            return;
          }
        this.privHeaderEnd = m + 8, n.resolve(r.AudioStreamFormat.getWaveFormatPCM(f, g, d));
      };
      if (typeof window < "u" && typeof Blob < "u" && s instanceof Blob) {
        const u = new FileReader();
        u.onload = (l) => {
          const p = l.target.result;
          c(p);
        }, u.readAsArrayBuffer(s);
      } else {
        const u = s;
        c(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
      }
      return n.promise;
    }
    async upload(a) {
      const s = (n) => {
        const c = `Error occurred while processing '${this.privFilename}'. ${n}`;
        throw this.onEvent(new t.AudioStreamNodeErrorEvent(this.privId, a, c)), new Error(c);
      };
      try {
        await this.turnOn();
        const n = await this.privAudioFormatPromise, c = new t.ChunkedArrayBufferStream(n.avgBytesPerSec / 10, a);
        this.privStreams[a] = c;
        const u = this.privSource.slice(this.privHeaderEnd), l = (p) => {
          c.isClosed || (c.writeStreamChunk({
            buffer: p,
            isEnd: !1,
            timeReceived: Date.now()
          }), c.close());
        };
        if (typeof window < "u" && typeof Blob < "u" && u instanceof Blob) {
          const p = new FileReader();
          p.onerror = (h) => s(h.toString()), p.onload = (h) => {
            const d = h.target.result;
            l(d);
          }, p.readAsArrayBuffer(u);
        } else {
          const p = u;
          l(p.buffer.slice(p.byteOffset, p.byteOffset + p.byteLength));
        }
        return c;
      } catch (n) {
        s(n);
      }
    }
    onEvent(a) {
      this.privEvents.onEvent(a), t.Events.instance.onEvent(a);
    }
  };
  return Dr.FileAudioSource = o, Dr;
}
var xr = {}, Hu;
function aR() {
  if (Hu) return xr;
  Hu = 1, Object.defineProperty(xr, "__esModule", { value: !0 }), xr.PcmRecorder = void 0;
  const e = /* @__PURE__ */ M();
  class t {
    constructor(o) {
      this.privStopInputOnRelease = o;
    }
    record(o, i, a) {
      const n = new e.RiffPcmEncoder(o.sampleRate, 16e3), c = o.createMediaStreamSource(i), u = () => {
        const p = (() => {
          let h = 0;
          try {
            return o.createScriptProcessor(h, 1, 1);
          } catch {
            h = 2048;
            let f = o.sampleRate;
            for (; h < 16384 && f >= 32e3; )
              h <<= 1, f >>= 1;
            return o.createScriptProcessor(h, 1, 1);
          }
        })();
        p.onaudioprocess = (h) => {
          const d = h.inputBuffer.getChannelData(0);
          if (a && !a.isClosed) {
            const f = n.encode(d);
            f && a.writeStreamChunk({
              buffer: f,
              isEnd: !1,
              timeReceived: Date.now()
            });
          }
        }, c.connect(p), p.connect(o.destination), this.privMediaResources = {
          scriptProcessorNode: p,
          source: c,
          stream: i
        };
      }, l = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === "ignore";
      if (o.audioWorklet && !l) {
        if (!this.privSpeechProcessorScript) {
          const p = `class SP extends AudioWorkletProcessor {
                    constructor(options) {
                      super(options);
                    }
                    process(inputs, outputs) {
                      const input = inputs[0];
                      const output = [];
                      for (let channel = 0; channel < input.length; channel += 1) {
                        output[channel] = input[channel];
                      }
                      this.port.postMessage(output[0]);
                      return true;
                    }
                  }
                  registerProcessor('speech-processor', SP);`, h = new Blob([p], { type: "application/javascript; charset=utf-8" });
          this.privSpeechProcessorScript = URL.createObjectURL(h);
        }
        o.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {
          const p = new AudioWorkletNode(o, "speech-processor");
          p.port.onmessage = (h) => {
            const d = h.data;
            if (a && !a.isClosed) {
              const f = n.encode(d);
              f && a.writeStreamChunk({
                buffer: f,
                isEnd: !1,
                timeReceived: Date.now()
              });
            }
          }, c.connect(p), p.connect(o.destination), this.privMediaResources = {
            scriptProcessorNode: p,
            source: c,
            stream: i
          };
        }).catch(() => {
          u();
        });
      } else
        try {
          u();
        } catch (p) {
          throw new Error(`Unable to start audio worklet node for PCMRecorder: ${p}`);
        }
    }
    releaseMediaResources(o) {
      this.privMediaResources && (this.privMediaResources.scriptProcessorNode && (this.privMediaResources.scriptProcessorNode.disconnect(o.destination), this.privMediaResources.scriptProcessorNode = null), this.privMediaResources.source && (this.privMediaResources.source.disconnect(), this.privStopInputOnRelease && this.privMediaResources.stream.getTracks().forEach((i) => i.stop()), this.privMediaResources.source = null));
    }
    setWorkletUrl(o) {
      this.privSpeechProcessorScript = o;
    }
  }
  return xr.PcmRecorder = t, xr;
}
var Nr = {}, ve = {}, Ku;
function hv() {
  if (Ku) return ve;
  Ku = 1;
  var e = ve && ve.__createBinding || (Object.create ? function(h, d, f, g) {
    g === void 0 && (g = f), Object.defineProperty(h, g, { enumerable: !0, get: function() {
      return d[f];
    } });
  } : function(h, d, f, g) {
    g === void 0 && (g = f), h[g] = d[f];
  }), t = ve && ve.__setModuleDefault || (Object.create ? function(h, d) {
    Object.defineProperty(h, "default", { enumerable: !0, value: d });
  } : function(h, d) {
    h.default = d;
  }), r = ve && ve.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var d = {};
    if (h != null) for (var f in h) f !== "default" && Object.prototype.hasOwnProperty.call(h, f) && e(d, h, f);
    return t(d, h), d;
  }, o = ve && ve.__importDefault || function(h) {
    return h && h.__esModule ? h : { default: h };
  };
  Object.defineProperty(ve, "__esModule", { value: !0 }), ve.WebsocketMessageAdapter = void 0;
  const i = r(Dt), a = r(Dt), s = o(Dt), n = o(Dt), c = o(Dt), u = /* @__PURE__ */ le(), l = /* @__PURE__ */ M();
  let p = class Ka {
    constructor(d, f, g, m, v, y) {
      if (!d)
        throw new l.ArgumentNullError("uri");
      if (!g)
        throw new l.ArgumentNullError("messageFormatter");
      this.proxyInfo = m, this.privConnectionEvents = new l.EventSource(), this.privConnectionId = f, this.privMessageFormatter = g, this.privConnectionState = l.ConnectionState.None, this.privUri = d, this.privHeaders = v, this.privEnableCompression = y, this.privHeaders[u.HeaderNames.ConnectionId] = this.privConnectionId, this.privHeaders.connectionId = this.privConnectionId, this.privLastErrorReceived = "";
    }
    get state() {
      return this.privConnectionState;
    }
    open() {
      if (this.privConnectionState === l.ConnectionState.Disconnected)
        return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
      if (this.privConnectionEstablishDeferral)
        return this.privConnectionEstablishDeferral.promise;
      this.privConnectionEstablishDeferral = new l.Deferred(), this.privCertificateValidatedDeferral = new l.Deferred(), this.privConnectionState = l.ConnectionState.Connecting;
      try {
        if (typeof WebSocket < "u" && !Ka.forceNpmWebSocket)
          this.privCertificateValidatedDeferral.resolve(), this.privWebsocketClient = new WebSocket(this.privUri);
        else {
          let f = new URL(this.privUri).protocol;
          f?.toLocaleLowerCase() === "wss:" ? f = "https:" : f?.toLocaleLowerCase() === "ws:" && (f = "http:");
          const g = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression, followRedirects: f.toLocaleLowerCase() === "https:" };
          this.privCertificateValidatedDeferral.resolve(), g.agent = this.getAgent(), g.agent.protocol = f, this.privWebsocketClient = new c.default(this.privUri, g), this.privWebsocketClient.on("redirect", (m) => {
            const v = new l.ConnectionRedirectEvent(this.privConnectionId, m, this.privUri, `Getting redirect URL from endpoint ${this.privUri} with redirect URL '${m}'`);
            l.Events.instance.onEvent(v);
          });
        }
        this.privWebsocketClient.binaryType = "arraybuffer", this.privReceivingMessageQueue = new l.Queue(), this.privDisconnectDeferral = new l.Deferred(), this.privSendMessageQueue = new l.Queue(), this.processSendQueue().catch((d) => {
          l.Events.instance.onEvent(new l.BackgroundEvent(d));
        });
      } catch (d) {
        return this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(500, d)), this.privConnectionEstablishDeferral.promise;
      }
      return this.onEvent(new l.ConnectionStartEvent(this.privConnectionId, this.privUri)), this.privWebsocketClient.onopen = () => {
        this.privCertificateValidatedDeferral.promise.then(() => {
          this.privConnectionState = l.ConnectionState.Connected, this.onEvent(new l.ConnectionEstablishedEvent(this.privConnectionId)), this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(200, ""));
        }, (d) => {
          this.privConnectionEstablishDeferral.reject(d);
        });
      }, this.privWebsocketClient.onerror = (d) => {
        this.onEvent(new l.ConnectionErrorEvent(this.privConnectionId, d.message, d.type)), this.privLastErrorReceived = d.message;
      }, this.privWebsocketClient.onclose = (d) => {
        this.privConnectionState === l.ConnectionState.Connecting ? (this.privConnectionState = l.ConnectionState.Disconnected, this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(d.code, d.reason + " " + this.privLastErrorReceived))) : (this.privConnectionState = l.ConnectionState.Disconnected, this.privWebsocketClient = null, this.onEvent(new l.ConnectionClosedEvent(this.privConnectionId, d.code, d.reason))), this.onClose(d.code, d.reason).catch((f) => {
          l.Events.instance.onEvent(new l.BackgroundEvent(f));
        });
      }, this.privWebsocketClient.onmessage = (d) => {
        const f = (/* @__PURE__ */ new Date()).toISOString();
        if (this.privConnectionState === l.ConnectionState.Connected) {
          const g = new l.Deferred();
          if (this.privReceivingMessageQueue.enqueueFromPromise(g.promise), d.data instanceof ArrayBuffer) {
            const m = new l.RawWebsocketMessage(l.MessageType.Binary, d.data);
            this.privMessageFormatter.toConnectionMessage(m).then((v) => {
              this.onEvent(new l.ConnectionMessageReceivedEvent(this.privConnectionId, f, v)), g.resolve(v);
            }, (v) => {
              g.reject(`Invalid binary message format. Error: ${v}`);
            });
          } else {
            const m = new l.RawWebsocketMessage(l.MessageType.Text, d.data);
            this.privMessageFormatter.toConnectionMessage(m).then((v) => {
              this.onEvent(new l.ConnectionMessageReceivedEvent(this.privConnectionId, f, v)), g.resolve(v);
            }, (v) => {
              g.reject(`Invalid text message format. Error: ${v}`);
            });
          }
        }
      }, this.privConnectionEstablishDeferral.promise;
    }
    send(d) {
      if (this.privConnectionState !== l.ConnectionState.Connected)
        return Promise.reject(`Cannot send on connection that is in ${l.ConnectionState[this.privConnectionState]} state`);
      const f = new l.Deferred(), g = new l.Deferred();
      return this.privSendMessageQueue.enqueueFromPromise(g.promise), this.privMessageFormatter.fromConnectionMessage(d).then((m) => {
        g.resolve({
          Message: d,
          RawWebsocketMessage: m,
          sendStatusDeferral: f
        });
      }, (m) => {
        g.reject(`Error formatting the message. ${m}`);
      }), f.promise;
    }
    read() {
      return this.privConnectionState !== l.ConnectionState.Connected ? Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`) : this.privReceivingMessageQueue.dequeue();
    }
    close(d) {
      if (this.privWebsocketClient)
        this.privConnectionState !== l.ConnectionState.Disconnected && this.privWebsocketClient.close(1e3, d || "Normal closure by client");
      else
        return Promise.resolve();
      return this.privDisconnectDeferral.promise;
    }
    get events() {
      return this.privConnectionEvents;
    }
    sendRawMessage(d) {
      try {
        if (!d)
          return Promise.resolve();
        if (this.onEvent(new l.ConnectionMessageSentEvent(this.privConnectionId, (/* @__PURE__ */ new Date()).toISOString(), d.Message)), this.isWebsocketOpen)
          this.privWebsocketClient.send(d.RawWebsocketMessage.payload);
        else
          return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + d.Message.id + " " + new Error().stack);
        return Promise.resolve();
      } catch (f) {
        return Promise.reject(`websocket send error: ${f}`);
      }
    }
    async onClose(d, f) {
      const g = `Connection closed. ${d}: ${f}`;
      this.privConnectionState = l.ConnectionState.Disconnected, this.privDisconnectDeferral.resolve(), await this.privReceivingMessageQueue.drainAndDispose(() => {
      }, g), await this.privSendMessageQueue.drainAndDispose((m) => {
        m.sendStatusDeferral.reject(g);
      }, g);
    }
    async processSendQueue() {
      for (; ; ) {
        const f = await this.privSendMessageQueue.dequeue();
        if (!f)
          return;
        try {
          await this.sendRawMessage(f), f.sendStatusDeferral.resolve();
        } catch (g) {
          f.sendStatusDeferral.reject(g);
        }
      }
    }
    onEvent(d) {
      this.privConnectionEvents.onEvent(d), l.Events.instance.onEvent(d);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAgent() {
      const d = new s.default.Agent(this.createConnection);
      return this.proxyInfo !== void 0 && this.proxyInfo.HostName !== void 0 && this.proxyInfo.Port > 0 && (d.proxyInfo = this.proxyInfo), d;
    }
    static GetProxyAgent(d) {
      const f = {
        host: d.HostName,
        port: d.Port
      };
      return d.UserName ? f.headers = {
        "Proxy-Authentication": "Basic " + new Buffer(`${d.UserName}:${d.Password === void 0 ? "" : d.Password}`).toString("base64")
      } : f.headers = {}, f.headers.requestOCSP = "true", new n.default(f);
    }
    createConnection(d, f) {
      let g;
      if (f = {
        ...f,
        requestOCSP: !0,
        servername: f.host
      }, this.proxyInfo) {
        const v = Ka.GetProxyAgent(this.proxyInfo);
        g = new Promise((y, S) => {
          v.callback(d, f, (C, P) => {
            C ? S(C) : y(P);
          });
        });
      } else
        f.secureEndpoint ? g = Promise.resolve(a.connect(f)) : g = Promise.resolve(i.connect(f));
      return g;
    }
    get isWebsocketOpen() {
      return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
    }
  };
  return ve.WebsocketMessageAdapter = p, p.forceNpmWebSocket = !1, ve;
}
var Ju;
function cR() {
  if (Ju) return Nr;
  Ju = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.WebsocketConnection = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ hv();
  let r = class {
    constructor(i, a, s, n, c, u = !1, l) {
      if (this.privIsDisposed = !1, !i)
        throw new e.ArgumentNullError("uri");
      if (!n)
        throw new e.ArgumentNullError("messageFormatter");
      this.privMessageFormatter = n;
      let p = "", h = 0;
      if (a) {
        for (const d in a)
          if (d) {
            p += h === 0 && i.indexOf("?") === -1 ? "?" : "&";
            const f = encodeURIComponent(d);
            p += f;
            let g = a[d];
            g && (g = encodeURIComponent(g), p += `=${g}`), h++;
          }
      }
      if (s) {
        for (const d in s)
          if (d) {
            p += h === 0 && i.indexOf("?") === -1 ? "?" : "&";
            const f = encodeURIComponent(s[d]);
            p += `${d}=${f}`, h++;
          }
      }
      this.privUri = i + p, this.privId = l || (0, e.createNoDashGuid)(), this.privConnectionMessageAdapter = new t.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, c, s, u);
    }
    async dispose() {
      this.privIsDisposed = !0, this.privConnectionMessageAdapter && await this.privConnectionMessageAdapter.close();
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    get id() {
      return this.privId;
    }
    get uri() {
      return this.privUri;
    }
    state() {
      return this.privConnectionMessageAdapter.state;
    }
    open() {
      return this.privConnectionMessageAdapter.open();
    }
    send(i) {
      return this.privConnectionMessageAdapter.send(i);
    }
    read() {
      return this.privConnectionMessageAdapter.read();
    }
    get events() {
      return this.privConnectionMessageAdapter.events;
    }
  };
  return Nr.WebsocketConnection = r, Nr;
}
var zr = {}, Gu;
function uR() {
  if (Gu) return zr;
  Gu = 1, Object.defineProperty(zr, "__esModule", { value: !0 }), zr.ReplayableAudioNode = void 0;
  let e = class {
    constructor(o, i) {
      this.privBuffers = [], this.privReplayOffset = 0, this.privLastShrinkOffset = 0, this.privBufferStartOffset = 0, this.privBufferSerial = 0, this.privBufferedBytes = 0, this.privReplay = !1, this.privLastChunkAcquiredTime = 0, this.privAudioNode = o, this.privBytesPerSecond = i;
    }
    id() {
      return this.privAudioNode.id();
    }
    // Reads and returns the next chunk of audio buffer.
    // If replay of existing buffers are needed, read() will first seek and replay
    // existing content, and upoin completion it will read new content from the underlying
    // audio node, saving that content into the replayable buffers.
    read() {
      if (this.privReplay && this.privBuffers.length !== 0) {
        const o = this.privReplayOffset - this.privBufferStartOffset;
        let i = Math.round(o * this.privBytesPerSecond * 1e-7);
        i % 2 !== 0 && i++;
        let a = 0;
        for (; a < this.privBuffers.length && i >= this.privBuffers[a].chunk.buffer.byteLength; )
          i -= this.privBuffers[a++].chunk.buffer.byteLength;
        if (a < this.privBuffers.length) {
          const s = this.privBuffers[a].chunk.buffer.slice(i);
          return this.privReplayOffset += s.byteLength / this.privBytesPerSecond * 1e7, a === this.privBuffers.length - 1 && (this.privReplay = !1), Promise.resolve({
            buffer: s,
            isEnd: !1,
            timeReceived: this.privBuffers[a].chunk.timeReceived
          });
        }
      }
      return this.privAudioNode.read().then((o) => (o && o.buffer && this.privBuffers && (this.privBuffers.push(new t(o, this.privBufferSerial++, this.privBufferedBytes)), this.privBufferedBytes += o.buffer.byteLength), o));
    }
    detach() {
      return this.privBuffers = void 0, this.privAudioNode.detach();
    }
    replay() {
      this.privBuffers && this.privBuffers.length !== 0 && (this.privReplay = !0, this.privReplayOffset = this.privLastShrinkOffset);
    }
    // Shrinks the existing audio buffers to start at the new offset, or at the
    // beginning of the buffer closest to the requested offset.
    // A replay request will start from the last shrink point.
    shrinkBuffers(o) {
      if (this.privBuffers === void 0 || this.privBuffers.length === 0)
        return;
      this.privLastShrinkOffset = o;
      const i = o - this.privBufferStartOffset;
      let a = Math.round(i * this.privBytesPerSecond * 1e-7), s = 0;
      for (; s < this.privBuffers.length && a >= this.privBuffers[s].chunk.buffer.byteLength; )
        a -= this.privBuffers[s++].chunk.buffer.byteLength;
      this.privBufferStartOffset = Math.round(o - a / this.privBytesPerSecond * 1e7), this.privBuffers = this.privBuffers.slice(s);
    }
    // Finds the time a buffer of audio was first seen by offset.
    findTimeAtOffset(o) {
      if (o < this.privBufferStartOffset || this.privBuffers === void 0)
        return 0;
      for (const i of this.privBuffers) {
        const a = i.byteOffset / this.privBytesPerSecond * 1e7, s = a + i.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
        if (o >= a && o <= s)
          return i.chunk.timeReceived;
      }
      return 0;
    }
  };
  zr.ReplayableAudioNode = e;
  class t {
    constructor(o, i, a) {
      this.chunk = o, this.serial = i, this.byteOffset = a;
    }
  }
  return zr;
}
var Lr = {}, Uo = {}, Fe = {}, Ae = {}, Qu;
function fv() {
  if (Qu) return Ae;
  Qu = 1;
  var e = Ae && Ae.__createBinding || (Object.create ? function(s, n, c, u) {
    u === void 0 && (u = c), Object.defineProperty(s, u, { enumerable: !0, get: function() {
      return n[c];
    } });
  } : function(s, n, c, u) {
    u === void 0 && (u = c), s[u] = n[c];
  }), t = Ae && Ae.__setModuleDefault || (Object.create ? function(s, n) {
    Object.defineProperty(s, "default", { enumerable: !0, value: n });
  } : function(s, n) {
    s.default = n;
  }), r = Ae && Ae.__importStar || function(s) {
    if (s && s.__esModule) return s;
    var n = {};
    if (s != null) for (var c in s) c !== "default" && Object.prototype.hasOwnProperty.call(s, c) && e(n, s, c);
    return t(n, s), n;
  };
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.AudioFileWriter = void 0;
  const o = r(Dt), i = /* @__PURE__ */ z();
  let a = class {
    constructor(n) {
      i.Contracts.throwIfNullOrUndefined(o.openSync, `
File System access not available, please use Push or PullAudioOutputStream`), this.privFd = o.openSync(n, "w");
    }
    set format(n) {
      i.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set"), this.privAudioFormat = n;
      let c = 0;
      this.privAudioFormat.hasHeader && (c = this.privAudioFormat.header.byteLength), this.privFd !== void 0 && (this.privWriteStream = o.createWriteStream("", { fd: this.privFd, start: c, autoClose: !1 }));
    }
    write(n) {
      i.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing."), this.privWriteStream !== void 0 && this.privWriteStream.write(new Uint8Array(n.slice(0)));
    }
    close() {
      this.privFd !== void 0 && (this.privWriteStream.on("finish", () => {
        this.privAudioFormat.hasHeader && (this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten), o.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0)), o.closeSync(this.privFd), this.privFd = void 0;
      }), this.privWriteStream.end());
    }
    id() {
      return this.privId;
    }
  };
  return Ae.AudioFileWriter = a, Ae;
}
var ge = {}, Yu;
function vv() {
  if (Yu) return ge;
  Yu = 1, Object.defineProperty(ge, "__esModule", { value: !0 }), ge.PullAudioInputStreamImpl = ge.PullAudioInputStream = ge.PushAudioInputStreamImpl = ge.PushAudioInputStream = ge.AudioInputStream = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ Nt(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ zt();
  let a = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member AudioInputStream.createPushStream
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The audio input stream being created.
     */
    static createPushStream(p) {
      return s.create(p);
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
     * and close() methods.
     * @member AudioInputStream.createPullStream
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
     * PullAudioInputStreamCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The audio input stream being created.
     */
    static createPullStream(p, h) {
      return c.create(p, h);
    }
  };
  ge.AudioInputStream = a;
  class s extends a {
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member PushAudioInputStream.create
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The push audio input stream being created.
     */
    static create(p) {
      return new n(p);
    }
  }
  ge.PushAudioInputStream = s;
  class n extends s {
    /**
     * Creates and initalizes an instance with the given values.
     * @constructor
     * @param {AudioStreamFormat} format - The audio stream format.
     */
    constructor(p) {
      super(), p === void 0 ? this.privFormat = i.AudioStreamFormatImpl.getDefaultInputFormat() : this.privFormat = p, this.privEvents = new t.EventSource(), this.privId = (0, r.createNoDashGuid)(), this.privStream = new t.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PushAudioInputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(p) {
      this.privStream.writeStreamChunk({
        buffer: p,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PushAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    async attach(p) {
      this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, p)), await this.turnOn();
      const h = this.privStream;
      return this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, p)), {
        detach: async () => (this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p)), this.turnOff()),
        id: () => p,
        read: () => h.read()
      };
    }
    detach(p) {
      this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PushStream",
        samplerate: this.privFormat.samplesPerSec,
        type: e.type.Stream
      });
    }
    onEvent(p) {
      this.privEvents.onEvent(p), t.Events.instance.onEvent(p);
    }
    toBuffer(p) {
      const h = Buffer.alloc(p.byteLength), d = new Uint8Array(p);
      for (let f = 0; f < h.length; ++f)
        h[f] = d[f];
      return h;
    }
  }
  ge.PushAudioInputStreamImpl = n;
  class c extends a {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @member PullAudioInputStream.create
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The push audio input stream being created.
     */
    static create(p, h) {
      return new u(p, h);
    }
  }
  ge.PullAudioInputStream = c;
  class u extends c {
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @constructor
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     */
    constructor(p, h) {
      super(), h === void 0 ? this.privFormat = o.AudioStreamFormat.getDefaultInputFormat() : this.privFormat = h, this.privEvents = new t.EventSource(), this.privId = (0, r.createNoDashGuid)(), this.privCallback = p, this.privIsClosed = !1, this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Closes the stream.
     * @member PullAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privIsClosed = !0, this.privCallback.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    async attach(p) {
      return this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, p)), await this.turnOn(), this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, p)), {
        detach: () => (this.privCallback.close(), this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p)), this.turnOff()),
        id: () => p,
        read: () => {
          let h = 0, d;
          for (; h < this.privBufferSize; ) {
            const f = new ArrayBuffer(this.privBufferSize - h), g = this.privCallback.read(f);
            if (d === void 0 ? d = f : new Int8Array(d).set(new Int8Array(f), h), g === 0)
              break;
            h += g;
          }
          return Promise.resolve({
            buffer: d.slice(0, h),
            isEnd: this.privIsClosed || h === 0,
            timeReceived: Date.now()
          });
        }
      };
    }
    detach(p) {
      this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PullStream",
        samplerate: this.privFormat.samplesPerSec,
        type: e.type.Stream
      });
    }
    onEvent(p) {
      this.privEvents.onEvent(p), t.Events.instance.onEvent(p);
    }
  }
  return ge.PullAudioInputStreamImpl = u, ge;
}
var me = {}, jr = {}, $o = {}, Zu;
function gv() {
  return Zu || (Zu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeechSynthesisOutputFormat = void 0, function(t) {
      t[t.Raw8Khz8BitMonoMULaw = 0] = "Raw8Khz8BitMonoMULaw", t[t.Riff16Khz16KbpsMonoSiren = 1] = "Riff16Khz16KbpsMonoSiren", t[t.Audio16Khz16KbpsMonoSiren = 2] = "Audio16Khz16KbpsMonoSiren", t[t.Audio16Khz32KBitRateMonoMp3 = 3] = "Audio16Khz32KBitRateMonoMp3", t[t.Audio16Khz128KBitRateMonoMp3 = 4] = "Audio16Khz128KBitRateMonoMp3", t[t.Audio16Khz64KBitRateMonoMp3 = 5] = "Audio16Khz64KBitRateMonoMp3", t[t.Audio24Khz48KBitRateMonoMp3 = 6] = "Audio24Khz48KBitRateMonoMp3", t[t.Audio24Khz96KBitRateMonoMp3 = 7] = "Audio24Khz96KBitRateMonoMp3", t[t.Audio24Khz160KBitRateMonoMp3 = 8] = "Audio24Khz160KBitRateMonoMp3", t[t.Raw16Khz16BitMonoTrueSilk = 9] = "Raw16Khz16BitMonoTrueSilk", t[t.Riff16Khz16BitMonoPcm = 10] = "Riff16Khz16BitMonoPcm", t[t.Riff8Khz16BitMonoPcm = 11] = "Riff8Khz16BitMonoPcm", t[t.Riff24Khz16BitMonoPcm = 12] = "Riff24Khz16BitMonoPcm", t[t.Riff8Khz8BitMonoMULaw = 13] = "Riff8Khz8BitMonoMULaw", t[t.Raw16Khz16BitMonoPcm = 14] = "Raw16Khz16BitMonoPcm", t[t.Raw24Khz16BitMonoPcm = 15] = "Raw24Khz16BitMonoPcm", t[t.Raw8Khz16BitMonoPcm = 16] = "Raw8Khz16BitMonoPcm", t[t.Ogg16Khz16BitMonoOpus = 17] = "Ogg16Khz16BitMonoOpus", t[t.Ogg24Khz16BitMonoOpus = 18] = "Ogg24Khz16BitMonoOpus", t[t.Raw48Khz16BitMonoPcm = 19] = "Raw48Khz16BitMonoPcm", t[t.Riff48Khz16BitMonoPcm = 20] = "Riff48Khz16BitMonoPcm", t[t.Audio48Khz96KBitRateMonoMp3 = 21] = "Audio48Khz96KBitRateMonoMp3", t[t.Audio48Khz192KBitRateMonoMp3 = 22] = "Audio48Khz192KBitRateMonoMp3", t[t.Ogg48Khz16BitMonoOpus = 23] = "Ogg48Khz16BitMonoOpus", t[t.Webm16Khz16BitMonoOpus = 24] = "Webm16Khz16BitMonoOpus", t[t.Webm24Khz16BitMonoOpus = 25] = "Webm24Khz16BitMonoOpus", t[t.Raw24Khz16BitMonoTrueSilk = 26] = "Raw24Khz16BitMonoTrueSilk", t[t.Raw8Khz8BitMonoALaw = 27] = "Raw8Khz8BitMonoALaw", t[t.Riff8Khz8BitMonoALaw = 28] = "Riff8Khz8BitMonoALaw", t[t.Webm24Khz16Bit24KbpsMonoOpus = 29] = "Webm24Khz16Bit24KbpsMonoOpus", t[t.Audio16Khz16Bit32KbpsMonoOpus = 30] = "Audio16Khz16Bit32KbpsMonoOpus", t[t.Audio24Khz16Bit48KbpsMonoOpus = 31] = "Audio24Khz16Bit48KbpsMonoOpus", t[t.Audio24Khz16Bit24KbpsMonoOpus = 32] = "Audio24Khz16Bit24KbpsMonoOpus", t[t.Raw22050Hz16BitMonoPcm = 33] = "Raw22050Hz16BitMonoPcm", t[t.Riff22050Hz16BitMonoPcm = 34] = "Riff22050Hz16BitMonoPcm", t[t.Raw44100Hz16BitMonoPcm = 35] = "Raw44100Hz16BitMonoPcm", t[t.Riff44100Hz16BitMonoPcm = 36] = "Riff44100Hz16BitMonoPcm", t[t.AmrWb16000Hz = 37] = "AmrWb16000Hz", t[t.G72216Khz64Kbps = 38] = "G72216Khz64Kbps";
    }(e.SpeechSynthesisOutputFormat || (e.SpeechSynthesisOutputFormat = {}));
  }($o)), $o;
}
var Xu;
function Ps() {
  if (Xu) return jr;
  Xu = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.AudioOutputFormatImpl = void 0;
  const e = /* @__PURE__ */ gv(), t = /* @__PURE__ */ zt();
  class r extends t.AudioStreamFormatImpl {
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param formatTag
     * @param {number} channels - Number of channels.
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} avgBytesPerSec - Average bytes per second.
     * @param {number} blockAlign - Block alignment.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {string} audioFormatString - Audio format string
     * @param {string} requestAudioFormatString - Audio format string sent to service.
     * @param {boolean} hasHeader - If the format has header or not.
     */
    constructor(i, a, s, n, c, u, l, p, h) {
      super(s, u, a, i), this.formatTag = i, this.avgBytesPerSec = n, this.blockAlign = c, this.priAudioFormatString = l, this.priRequestAudioFormatString = p, this.priHasHeader = h;
    }
    static fromSpeechSynthesisOutputFormat(i) {
      return i === void 0 ? r.getDefaultOutputFormat() : r.fromSpeechSynthesisOutputFormatString(r.SpeechSynthesisOutputFormatToString[i]);
    }
    static fromSpeechSynthesisOutputFormatString(i) {
      switch (i) {
        case "raw-8khz-8bit-mono-mulaw":
          return new r(t.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, i, i, !1);
        case "riff-16khz-16kbps-mono-siren":
          return new r(t.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, i, "audio-16khz-16kbps-mono-siren", !0);
        case "audio-16khz-16kbps-mono-siren":
          return new r(t.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, i, i, !1);
        case "audio-16khz-32kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 4096, 2, 16, i, i, !1);
        case "audio-16khz-128kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 16384, 2, 16, i, i, !1);
        case "audio-16khz-64kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 8192, 2, 16, i, i, !1);
        case "audio-24khz-48kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 6144, 2, 16, i, i, !1);
        case "audio-24khz-96kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 12288, 2, 16, i, i, !1);
        case "audio-24khz-160kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 20480, 2, 16, i, i, !1);
        case "raw-16khz-16bit-mono-truesilk":
          return new r(t.AudioFormatTag.SILKSkype, 1, 16e3, 32e3, 2, 16, i, i, !1);
        case "riff-8khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, i, "raw-8khz-16bit-mono-pcm", !0);
        case "riff-24khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, i, "raw-24khz-16bit-mono-pcm", !0);
        case "riff-8khz-8bit-mono-mulaw":
          return new r(t.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, i, "raw-8khz-8bit-mono-mulaw", !0);
        case "raw-16khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, i, "raw-16khz-16bit-mono-pcm", !1);
        case "raw-24khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, i, "raw-24khz-16bit-mono-pcm", !1);
        case "raw-8khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, i, "raw-8khz-16bit-mono-pcm", !1);
        case "ogg-16khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 16e3, 8192, 2, 16, i, i, !1);
        case "ogg-24khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 24e3, 8192, 2, 16, i, i, !1);
        case "raw-48khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, i, "raw-48khz-16bit-mono-pcm", !1);
        case "riff-48khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, i, "raw-48khz-16bit-mono-pcm", !0);
        case "audio-48khz-96kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 48e3, 12288, 2, 16, i, i, !1);
        case "audio-48khz-192kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 48e3, 24576, 2, 16, i, i, !1);
        case "ogg-48khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 48e3, 12e3, 2, 16, i, i, !1);
        case "webm-16khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 16e3, 4e3, 2, 16, i, i, !1);
        case "webm-24khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 24e3, 6e3, 2, 16, i, i, !1);
        case "webm-24khz-16bit-24kbps-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 24e3, 3e3, 2, 16, i, i, !1);
        case "audio-16khz-16bit-32kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 16e3, 4e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-48kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 24e3, 6e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-24kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 24e3, 3e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-mono-flac":
          return new r(t.AudioFormatTag.FLAC, 1, 24e3, 24e3, 2, 16, i, i, !1);
        case "audio-48khz-16bit-mono-flac":
          return new r(t.AudioFormatTag.FLAC, 1, 48e3, 3e4, 2, 16, i, i, !1);
        case "raw-24khz-16bit-mono-truesilk":
          return new r(t.AudioFormatTag.SILKSkype, 1, 24e3, 48e3, 2, 16, i, i, !1);
        case "raw-8khz-8bit-mono-alaw":
          return new r(t.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, i, i, !1);
        case "riff-8khz-8bit-mono-alaw":
          return new r(t.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, i, "raw-8khz-8bit-mono-alaw", !0);
        case "raw-22050hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, i, i, !1);
        case "riff-22050hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, i, "raw-22050hz-16bit-mono-pcm", !0);
        case "raw-44100hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, i, i, !1);
        case "riff-44100hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, i, "raw-44100hz-16bit-mono-pcm", !0);
        case "amr-wb-16000h":
          return new r(t.AudioFormatTag.AMR_WB, 1, 16e3, 3052, 2, 16, i, i, !1);
        case "g722-16khz-64kbps":
          return new r(t.AudioFormatTag.G722, 1, 16e3, 8e3, 2, 16, i, i, !1);
        case "riff-16khz-16bit-mono-pcm":
        default:
          return new r(t.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", !0);
      }
    }
    static getDefaultOutputFormat() {
      return r.fromSpeechSynthesisOutputFormatString(typeof window < "u" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
    }
    /**
     * Specifies if this audio output format has a header
     * @boolean AudioOutputFormatImpl.prototype.hasHeader
     * @function
     * @public
     */
    get hasHeader() {
      return this.priHasHeader;
    }
    /**
     * Specifies the header of this format
     * @ArrayBuffer AudioOutputFormatImpl.prototype.header
     * @function
     * @public
     */
    get header() {
      if (this.hasHeader)
        return this.privHeader;
    }
    /**
     * Updates the header based on the audio length
     * @member AudioOutputFormatImpl.updateHeader
     * @function
     * @public
     * @param {number} audioLength - the audio length
     */
    updateHeader(i) {
      if (this.priHasHeader) {
        const a = new DataView(this.privHeader);
        a.setUint32(4, i + this.privHeader.byteLength - 8, !0), a.setUint32(40, i, !0);
      }
    }
    /**
     * Specifies the audio format string to be sent to the service
     * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
     * @function
     * @public
     */
    get requestAudioFormatString() {
      return this.priRequestAudioFormatString;
    }
    /**
     * Adds audio header
     * @param audio the raw audio without header
     * @returns the audio with header if applicable
     */
    addHeader(i) {
      if (!this.hasHeader)
        return i;
      this.updateHeader(i.byteLength);
      const a = new Uint8Array(i.byteLength + this.header.byteLength);
      return a.set(new Uint8Array(this.header), 0), a.set(new Uint8Array(i), this.header.byteLength), a.buffer;
    }
  }
  return jr.AudioOutputFormatImpl = r, r.SpeechSynthesisOutputFormatToString = {
    [e.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
    [e.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
    [e.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
    [e.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
    [e.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
    [e.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
    [e.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
    [e.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
    [e.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.AmrWb16000Hz]: "amr-wb-16000hz",
    [e.SpeechSynthesisOutputFormat.G72216Khz64Kbps]: "g722-16khz-64kbps"
  }, jr;
}
var el;
function Kt() {
  if (el) return me;
  el = 1, Object.defineProperty(me, "__esModule", { value: !0 }), me.PushAudioOutputStreamImpl = me.PushAudioOutputStream = me.PullAudioOutputStreamImpl = me.PullAudioOutputStream = me.AudioOutputStream = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ Ps();
  let o = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member AudioOutputStream.createPullStream
     * @function
     * @public
     * @returns {PullAudioOutputStream} The audio output stream being created.
     */
    static createPullStream() {
      return i.create();
    }
  };
  me.AudioOutputStream = o;
  class i extends o {
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member PullAudioOutputStream.create
     * @function
     * @public
     * @returns {PullAudioOutputStream} The push audio output stream being created.
     */
    static create() {
      return new a();
    }
  }
  me.PullAudioOutputStream = i;
  class a extends i {
    /**
     * Creates and initializes an instance with the given values.
     * @constructor
     */
    constructor() {
      super(), this.privId = (0, e.createNoDashGuid)(), this.privStream = new e.Stream();
    }
    /**
     * Sets the format information to the stream. For internal use only.
     * @param {AudioStreamFormat} format - the format to be set.
     */
    set format(u) {
      u == null && (this.privFormat = r.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privFormat = u;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privFormat;
    }
    /**
     * Checks if the stream is closed
     * @member PullAudioOutputStreamImpl.prototype.isClosed
     * @property
     * @public
     */
    get isClosed() {
      return this.privStream.isClosed;
    }
    /**
     * Gets the id of the stream
     * @member PullAudioOutputStreamImpl.prototype.id
     * @property
     * @public
     */
    id() {
      return this.privId;
    }
    /**
     * Reads audio data from the internal buffer.
     * @member PullAudioOutputStreamImpl.prototype.read
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
     * @returns {Promise<number>} - Audio buffer length has been read.
     */
    async read(u) {
      const l = new Int8Array(u);
      let p = 0;
      if (this.privLastChunkView !== void 0) {
        if (this.privLastChunkView.length > u.byteLength)
          return l.set(this.privLastChunkView.slice(0, u.byteLength)), this.privLastChunkView = this.privLastChunkView.slice(u.byteLength), Promise.resolve(u.byteLength);
        l.set(this.privLastChunkView), p = this.privLastChunkView.length, this.privLastChunkView = void 0;
      }
      for (; p < u.byteLength && !this.privStream.isReadEnded; ) {
        const h = await this.privStream.read();
        if (h !== void 0 && !h.isEnd) {
          let d;
          h.buffer.byteLength > u.byteLength - p ? (d = h.buffer.slice(0, u.byteLength - p), this.privLastChunkView = new Int8Array(h.buffer.slice(u.byteLength - p))) : d = h.buffer, l.set(new Int8Array(d), p), p += d.byteLength;
        } else
          this.privStream.readEnded();
      }
      return p;
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PullAudioOutputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(u) {
      t.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing"), this.privStream.writeStreamChunk({
        buffer: u,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PullAudioOutputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
  }
  me.PullAudioOutputStreamImpl = a;
  class s extends o {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * write() and close() methods.
     * @member PushAudioOutputStream.create
     * @function
     * @public
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     * @returns {PushAudioOutputStream} The push audio output stream being created.
     */
    static create(u) {
      return new n(u);
    }
  }
  me.PushAudioOutputStream = s;
  class n extends s {
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * read() and close() methods.
     * @constructor
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     */
    constructor(u) {
      super(), this.privId = (0, e.createNoDashGuid)(), this.privCallback = u;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set format(u) {
    }
    write(u) {
      this.privCallback.write && this.privCallback.write(u);
    }
    close() {
      this.privCallback.close && this.privCallback.close();
    }
    id() {
      return this.privId;
    }
  }
  return me.PushAudioOutputStreamImpl = n, me;
}
var tl;
function yv() {
  if (tl) return Fe;
  tl = 1, Object.defineProperty(Fe, "__esModule", { value: !0 }), Fe.AudioOutputConfigImpl = Fe.AudioConfigImpl = Fe.AudioConfig = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ fv(), i = /* @__PURE__ */ vv(), a = /* @__PURE__ */ Kt();
  let s = class mv {
    /**
     * Creates an AudioConfig object representing the default microphone on the system.
     * @member AudioConfig.fromDefaultMicrophoneInput
     * @function
     * @public
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromDefaultMicrophoneInput() {
      const l = new e.PcmRecorder(!0);
      return new n(new e.MicAudioSource(l));
    }
    /**
     * Creates an AudioConfig object representing a microphone with the specified device ID.
     * @member AudioConfig.fromMicrophoneInput
     * @function
     * @public
     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
     * Default microphone is used the value is omitted.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromMicrophoneInput(l) {
      const p = new e.PcmRecorder(!0);
      return new n(new e.MicAudioSource(p, l));
    }
    /**
     * Creates an AudioConfig object representing the specified file.
     * @member AudioConfig.fromWavFileInput
     * @function
     * @public
     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromWavFileInput(l, p = "unnamedBuffer.wav") {
      return new n(new e.FileAudioSource(l, p));
    }
    /**
     * Creates an AudioConfig object representing the specified stream.
     * @member AudioConfig.fromStreamInput
     * @function
     * @public
     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
     * stream. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromStreamInput(l) {
      if (l instanceof r.PullAudioInputStreamCallback)
        return new n(new i.PullAudioInputStreamImpl(l));
      if (l instanceof r.AudioInputStream)
        return new n(l);
      if (typeof MediaStream < "u" && l instanceof MediaStream) {
        const p = new e.PcmRecorder(!1);
        return new n(new e.MicAudioSource(p, null, null, l));
      }
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing the default speaker.
     * @member AudioConfig.fromDefaultSpeakerOutput
     * @function
     * @public
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromDefaultSpeakerOutput() {
      return new c(new r.SpeakerAudioDestination());
    }
    /**
     * Creates an AudioConfig object representing the custom IPlayer object.
     * You can use the IPlayer object to control pause, resume, etc.
     * @member AudioConfig.fromSpeakerOutput
     * @function
     * @public
     * @param {IPlayer} player - the IPlayer object for playback.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.12.0
     */
    static fromSpeakerOutput(l) {
      if (l === void 0)
        return mv.fromDefaultSpeakerOutput();
      if (l instanceof r.SpeakerAudioDestination)
        return new c(l);
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing a specified output audio file
     * @member AudioConfig.fromAudioFileOutput
     * @function
     * @public
     * @param {PathLike} filename - the filename of the output audio file
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromAudioFileOutput(l) {
      return new c(new o.AudioFileWriter(l));
    }
    /**
     * Creates an AudioConfig object representing a specified audio output stream
     * @member AudioConfig.fromStreamOutput
     * @function
     * @public
     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
     * stream.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromStreamOutput(l) {
      if (l instanceof r.PushAudioOutputStreamCallback)
        return new c(new a.PushAudioOutputStreamImpl(l));
      if (l instanceof r.PushAudioOutputStream)
        return new c(l);
      if (l instanceof r.PullAudioOutputStream)
        return new c(l);
      throw new Error("Not Supported Type");
    }
  };
  Fe.AudioConfig = s;
  class n extends s {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioSource} source - An audio source.
     */
    constructor(l) {
      super(), this.privSource = l;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privSource.format;
    }
    /**
     * @member AudioConfigImpl.prototype.close
     * @function
     * @public
     */
    close(l, p) {
      this.privSource.turnOff().then(() => {
        l && l();
      }, (h) => {
        p && p(h);
      });
    }
    /**
     * @member AudioConfigImpl.prototype.id
     * @function
     * @public
     */
    id() {
      return this.privSource.id();
    }
    /**
     * @member AudioConfigImpl.prototype.turnOn
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOn() {
      return this.privSource.turnOn();
    }
    /**
     * @member AudioConfigImpl.prototype.attach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     * @returns {Promise<IAudioStreamNode>} A promise.
     */
    attach(l) {
      return this.privSource.attach(l);
    }
    /**
     * @member AudioConfigImpl.prototype.detach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     */
    detach(l) {
      return this.privSource.detach(l);
    }
    /**
     * @member AudioConfigImpl.prototype.turnOff
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOff() {
      return this.privSource.turnOff();
    }
    /**
     * @member AudioConfigImpl.prototype.events
     * @function
     * @public
     * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
     */
    get events() {
      return this.privSource.events;
    }
    setProperty(l, p) {
      if (t.Contracts.throwIfNull(p, "value"), this.privSource.setProperty !== void 0)
        this.privSource.setProperty(l, p);
      else
        throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty(l, p) {
      if (this.privSource.getProperty !== void 0)
        return this.privSource.getProperty(l, p);
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
    get deviceInfo() {
      return this.privSource.deviceInfo;
    }
  }
  Fe.AudioConfigImpl = n;
  class c extends s {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioDestination} destination - An audio destination.
     */
    constructor(l) {
      super(), this.privDestination = l;
    }
    set format(l) {
      this.privDestination.format = l;
    }
    write(l) {
      this.privDestination.write(l);
    }
    close() {
      this.privDestination.close();
    }
    id() {
      return this.privDestination.id();
    }
    setProperty() {
      throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty() {
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
  }
  return Fe.AudioOutputConfigImpl = c, Fe;
}
var Vo = {}, rl;
function lR() {
  return rl || (rl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationReason = void 0, function(t) {
      t[t.Error = 0] = "Error", t[t.EndOfStream = 1] = "EndOfStream";
    }(e.CancellationReason || (e.CancellationReason = {}));
  }(Vo)), Vo;
}
var qr = {}, nl;
function pR() {
  if (nl) return qr;
  nl = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.PullAudioInputStreamCallback = void 0;
  let e = class {
  };
  return qr.PullAudioInputStreamCallback = e, qr;
}
var Fr = {}, il;
function dR() {
  if (il) return Fr;
  il = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.PushAudioOutputStreamCallback = void 0;
  let e = class {
  };
  return Fr.PushAudioOutputStreamCallback = e, Fr;
}
var Br = {}, sl;
function hR() {
  if (sl) return Br;
  sl = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.KeywordRecognitionModel = void 0;
  const e = /* @__PURE__ */ z();
  let t = class {
    /**
     * Create and initializes a new instance.
     * @constructor
     */
    constructor() {
      this.privDisposed = !1;
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromFile
     * @function
     * @public
     * @param {string} fileName - A string that represents file name for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model
     * will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */
    static fromFile(o) {
      throw e.Contracts.throwIfFileDoesNotExist(o, "fileName"), new Error("Not yet implemented.");
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromStream
     * @function
     * @public
     * @param {string} file - A File that represents file for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */
    static fromStream(o) {
      throw e.Contracts.throwIfNull(o, "file"), new Error("Not yet implemented.");
    }
    /**
     * Dispose of associated resources.
     * @member KeywordRecognitionModel.prototype.close
     * @function
     * @public
     */
    close() {
      this.privDisposed || (this.privDisposed = !0);
    }
  };
  return Br.KeywordRecognitionModel = t, Br;
}
var Ur = {}, ol;
function fR() {
  if (ol) return Ur;
  ol = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.SessionEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionId - The session id.
     */
    constructor(r) {
      this.privSessionId = r;
    }
    /**
     * Represents the session identifier.
     * @member SessionEventArgs.prototype.sessionId
     * @function
     * @public
     * @returns {string} Represents the session identifier.
     */
    get sessionId() {
      return this.privSessionId;
    }
  };
  return Ur.SessionEventArgs = e, Ur;
}
var $r = {}, al;
function vR() {
  if (al) return $r;
  al = 1, Object.defineProperty($r, "__esModule", { value: !0 }), $r.RecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i) {
      super(i), this.privOffset = o;
    }
    /**
     * Represents the message offset
     * @member RecognitionEventArgs.prototype.offset
     * @function
     * @public
     */
    get offset() {
      return this.privOffset;
    }
  };
  return $r.RecognitionEventArgs = t, $r;
}
var Wo = {}, cl;
function gR() {
  return cl || (cl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OutputFormat = void 0, function(t) {
      t[t.Simple = 0] = "Simple", t[t.Detailed = 1] = "Detailed";
    }(e.OutputFormat || (e.OutputFormat = {}));
  }(Wo)), Wo;
}
var Vr = {}, ul;
function mR() {
  if (ul) return Vr;
  ul = 1, Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.IntentRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param result - The result of the intent recognition.
     * @param offset - The offset.
     * @param sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Represents the intent recognition result.
     * @member IntentRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {IntentRecognitionResult} Represents the intent recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Vr.IntentRecognitionEventArgs = t, Vr;
}
var Wr = {}, ll;
function yR() {
  if (ll) return Wr;
  ll = 1, Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.RecognitionResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, o, i, a, s, n, c, u, l, p) {
      this.privResultId = r, this.privReason = o, this.privText = i, this.privDuration = a, this.privOffset = s, this.privLanguage = n, this.privLanguageDetectionConfidence = c, this.privErrorDetails = u, this.privJson = l, this.privProperties = p;
    }
    /**
     * Specifies the result identifier.
     * @member RecognitionResult.prototype.resultId
     * @function
     * @public
     * @returns {string} Specifies the result identifier.
     */
    get resultId() {
      return this.privResultId;
    }
    /**
     * Specifies status of the result.
     * @member RecognitionResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} Specifies status of the result.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * Presents the recognized text in the result.
     * @member RecognitionResult.prototype.text
     * @function
     * @public
     * @returns {string} Presents the recognized text in the result.
     */
    get text() {
      return this.privText;
    }
    /**
     * Duration of recognized speech in 100 nano second increments.
     * @member RecognitionResult.prototype.duration
     * @function
     * @public
     * @returns {number} Duration of recognized speech in 100 nano second increments.
     */
    get duration() {
      return this.privDuration;
    }
    /**
     * Offset of recognized speech in 100 nano second increments.
     * @member RecognitionResult.prototype.offset
     * @function
     * @public
     * @returns {number} Offset of recognized speech in 100 nano second increments.
     */
    get offset() {
      return this.privOffset;
    }
    /**
     * Primary Language detected.
     * @member RecognitionResult.prototype.language
     * @function
     * @public
     * @returns {string} language detected.
     */
    get language() {
      return this.privLanguage;
    }
    /**
     * Primary Language detection confidence (Unknown, Low, Medium, High).
     * @member RecognitionResult.prototype.languageDetectionConfidence
     * @function
     * @public
     * @returns {string} detection confidence strength.
     */
    get languageDetectionConfidence() {
      return this.privLanguageDetectionConfidence;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member RecognitionResult.prototype.errorDetails
     * @function
     * @public
     * @returns {string} a brief description of an error.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * A string containing Json serialized recognition result as it was received from the service.
     * @member RecognitionResult.prototype.json
     * @function
     * @private
     * @returns {string} Json serialized representation of the result.
     */
    get json() {
      return this.privJson;
    }
    /**
     * The set of properties exposed in the result.
     * @member RecognitionResult.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The set of properties exposed in the result.
     */
    get properties() {
      return this.privProperties;
    }
  };
  return Wr.RecognitionResult = e, Wr;
}
var Hr = {}, pl;
function SR() {
  if (pl) return Hr;
  pl = 1, Object.defineProperty(Hr, "__esModule", { value: !0 }), Hr.SpeechRecognitionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription, if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(o, i, a, s, n, c, u, p, h, d), this.privSpeakerId = l;
    }
    /**
     * speaker id from conversation transcription/id scenarios
     * @member SpeechRecognitionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return Hr.SpeechRecognitionResult = t, Hr;
}
var Kr = {}, dl;
function CR() {
  if (dl) return Kr;
  dl = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.IntentRecognitionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param intentId - The intent id.
     * @param resultId - The result id.
     * @param reason - The reason.
     * @param text - The recognized text.
     * @param duration - The duration.
     * @param offset - The offset into the stream.
     * @param language - Primary Language detected, if provided.
     * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param errorDetails - Error details, if provided.
     * @param json - Additional Json, if provided.
     * @param properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(i, a, s, n, c, u, l, void 0, p, h, d), this.privIntentId = o;
    }
    /**
     * A String that represents the intent identifier being recognized.
     * @member IntentRecognitionResult.prototype.intentId
     * @function
     * @public
     * @returns {string} A String that represents the intent identifier being recognized.
     */
    get intentId() {
      return this.privIntentId;
    }
  };
  return Kr.IntentRecognitionResult = t, Kr;
}
var ft = {}, hl;
function RR() {
  if (hl) return ft;
  hl = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.LanguageUnderstandingModelImpl = ft.LanguageUnderstandingModel = void 0;
  const e = /* @__PURE__ */ z();
  let t = class {
    /**
     * Creates and initializes a new instance
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates an language understanding model using the specified endpoint.
     * @member LanguageUnderstandingModel.fromEndpoint
     * @function
     * @public
     * @param {URL} uri - A String that represents the endpoint of the language understanding model.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromEndpoint(i) {
      e.Contracts.throwIfNull(i, "uri"), e.Contracts.throwIfNullOrWhitespace(i.hostname, "uri");
      const a = new r(), s = i.host.indexOf(".");
      if (s === -1)
        throw new Error("Could not determine region from endpoint");
      a.region = i.host.substr(0, s);
      const n = i.pathname.lastIndexOf("/") + 1;
      if (n === -1)
        throw new Error("Could not determine appId from endpoint");
      if (a.appId = i.pathname.substr(n), a.subscriptionKey = i.searchParams.get("subscription-key"), a.subscriptionKey === void 0)
        throw new Error("Could not determine subscription key from endpoint");
      return a;
    }
    /**
     * Creates an language understanding model using the application id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromAppId
     * @function
     * @public
     * @param {string} appId - A String that represents the application id of Language Understanding service.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromAppId(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "appId");
      const a = new r();
      return a.appId = i, a;
    }
    /**
     * Creates a language understanding model using hostname, subscription key and application
     * id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - A String that represents the subscription key of
     * Language Understanding service.
     * @param {string} appId - A String that represents the application id of Language
     * Understanding service.
     * @param {LanguageUnderstandingModel} region - A String that represents the region
     * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromSubscription(i, a, s) {
      e.Contracts.throwIfNullOrWhitespace(i, "subscriptionKey"), e.Contracts.throwIfNullOrWhitespace(a, "appId"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const n = new r();
      return n.appId = a, n.region = s, n.subscriptionKey = i, n;
    }
  };
  ft.LanguageUnderstandingModel = t;
  class r extends t {
  }
  return ft.LanguageUnderstandingModelImpl = r, ft;
}
var Be = {}, fl;
function PR() {
  if (fl) return Be;
  fl = 1, Object.defineProperty(Be, "__esModule", { value: !0 }), Be.MeetingTranscriptionEventArgs = Be.ConversationTranscriptionEventArgs = Be.SpeechRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechRecognitionResult} result - The speech recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(a, s, n) {
      super(s, n), this.privResult = a;
    }
    /**
     * Specifies the recognition result.
     * @member SpeechRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  Be.SpeechRecognitionEventArgs = t;
  class r extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranscriptionResult} result - The conversation transcription result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(a, s, n) {
      super(s, n), this.privResult = a;
    }
    /**
     * Specifies the transcription result.
     * @member ConversationTranscription1EventArgs.prototype.result
     * @function
     * @public
     * @returns {ConversationTranscriptionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  }
  Be.ConversationTranscriptionEventArgs = r;
  class o extends t {
  }
  return Be.MeetingTranscriptionEventArgs = o, Be;
}
var Jr = {}, Gr = {}, vl;
function ws() {
  if (vl) return Gr;
  vl = 1, Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.CancellationEventArgsBase = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a, s, n) {
      super(s, n), this.privReason = o, this.privErrorDetails = i, this.privErrorCode = a;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationEventArgsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful operation.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful operation, provides details of the occurred error.
     * @member CancellationEventArgsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return Gr.CancellationEventArgsBase = t, Gr;
}
var gl;
function wR() {
  if (gl) return Jr;
  gl = 1, Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.SpeechRecognitionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ ws();
  let t = class extends e.CancellationEventArgsBase {
  };
  return Jr.SpeechRecognitionCanceledEventArgs = t, Jr;
}
var Qr = {}, ml;
function bR() {
  if (ml) return Qr;
  ml = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.TranslationRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationRecognitionResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Qr.TranslationRecognitionEventArgs = t, Qr;
}
var Yr = {}, yl;
function ER() {
  if (yl) return Yr;
  yl = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.TranslationSynthesisEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationSynthesisResult} result - The translation synthesis result.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i) {
      super(i), this.privResult = o;
    }
    /**
     * Specifies the translation synthesis result.
     * @member TranslationSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Yr.TranslationSynthesisEventArgs = t, Yr;
}
var Zr = {}, Sl;
function Cv() {
  if (Sl) return Zr;
  Sl = 1, Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.TranslationRecognitionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class Sv extends e.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {Translations} translations - The translations.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(i, a, s, n, c, u, l, void 0, p, h, d), this.privTranslations = o;
    }
    static fromSpeechRecognitionResult(o) {
      return new Sv(void 0, o.resultId, o.reason, o.text, o.duration, o.offset, o.language, o.languageDetectionConfidence, o.errorDetails, o.json, o.properties);
    }
    /**
     * Presents the translation results. Each item in the dictionary represents
     * a translation result in one of target languages, where the key is the name
     * of the target language, in BCP-47 format, and the value is the translation
     * text in the specified language.
     * @member TranslationRecognitionResult.prototype.translations
     * @function
     * @public
     * @returns {Translations} the current translation map that holds all translations requested.
     */
    get translations() {
      return this.privTranslations;
    }
  };
  return Zr.TranslationRecognitionResult = t, Zr;
}
var Xr = {}, Cl;
function IR() {
  if (Cl) return Xr;
  Cl = 1, Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.TranslationSynthesisResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ResultReason} reason - The synthesis reason.
     * @param {ArrayBuffer} audio - The audio data.
     */
    constructor(r, o) {
      this.privReason = r, this.privAudio = o;
    }
    /**
     * Translated text in the target language.
     * @member TranslationSynthesisResult.prototype.audio
     * @function
     * @public
     * @returns {ArrayBuffer} Translated audio in the target language.
     */
    get audio() {
      return this.privAudio;
    }
    /**
     * The synthesis status.
     * @member TranslationSynthesisResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} The synthesis status.
     */
    get reason() {
      return this.privReason;
    }
  };
  return Xr.TranslationSynthesisResult = e, Xr;
}
var Ho = {}, Rl;
function AR() {
  return Rl || (Rl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ResultReason = void 0, function(t) {
      t[t.NoMatch = 0] = "NoMatch", t[t.Canceled = 1] = "Canceled", t[t.RecognizingSpeech = 2] = "RecognizingSpeech", t[t.RecognizedSpeech = 3] = "RecognizedSpeech", t[t.RecognizedKeyword = 4] = "RecognizedKeyword", t[t.RecognizingIntent = 5] = "RecognizingIntent", t[t.RecognizedIntent = 6] = "RecognizedIntent", t[t.TranslatingSpeech = 7] = "TranslatingSpeech", t[t.TranslatedSpeech = 8] = "TranslatedSpeech", t[t.SynthesizingAudio = 9] = "SynthesizingAudio", t[t.SynthesizingAudioCompleted = 10] = "SynthesizingAudioCompleted", t[t.SynthesizingAudioStarted = 11] = "SynthesizingAudioStarted", t[t.EnrollingVoiceProfile = 12] = "EnrollingVoiceProfile", t[t.EnrolledVoiceProfile = 13] = "EnrolledVoiceProfile", t[t.RecognizedSpeakers = 14] = "RecognizedSpeakers", t[t.RecognizedSpeaker = 15] = "RecognizedSpeaker", t[t.ResetVoiceProfile = 16] = "ResetVoiceProfile", t[t.DeletedVoiceProfile = 17] = "DeletedVoiceProfile", t[t.VoicesListRetrieved = 18] = "VoicesListRetrieved", t[t.TranslatingParticipantSpeech = 19] = "TranslatingParticipantSpeech", t[t.TranslatedParticipantSpeech = 20] = "TranslatedParticipantSpeech", t[t.TranslatedInstantMessage = 21] = "TranslatedInstantMessage", t[t.TranslatedParticipantInstantMessage = 22] = "TranslatedParticipantInstantMessage";
    }(e.ResultReason || (e.ResultReason = {}));
  }(Ho)), Ho;
}
var vt = {}, Pl;
function TR() {
  if (Pl) return vt;
  Pl = 1, Object.defineProperty(vt, "__esModule", { value: !0 }), vt.SpeechConfigImpl = vt.SpeechConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I();
  let o = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * @member SpeechConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} The speech factory
     */
    static fromSubscription(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "subscriptionKey"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c.setProperty(r.PropertyId.SpeechServiceConnection_IntentRegion, n), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c;
    }
    /**
     * Internal implementation of fromEndpoint() overloads. Accepts either a subscription key or a TokenCredential.
     * @private
     */
    static fromEndpoint(s, n) {
      t.Contracts.throwIfNull(s, "endpoint");
      const c = typeof n == "string" && n.trim().length > 0, u = typeof n == "object" && n !== null && typeof n.getToken == "function";
      if (n !== void 0 && !c && !u)
        throw new Error("Invalid 'auth' parameter: must be a non-empty key string or a valid TokenCredential object.");
      const l = typeof n == "object" ? new i(n) : new i();
      return l.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, s.href), typeof n == "string" && n.trim().length > 0 && l.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), l;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(s, n) {
      t.Contracts.throwIfNull(s, "hostName");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Host, s.protocol + "//" + s.hostname + (s.port === "" ? "" : ":" + s.port)), c.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), n !== void 0 && c.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), c;
    }
    /**
     * Creates an instance of the speech factory with specified initial authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
     * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
     * the new token value will not apply to recognizers that have already been created. For recognizers
     * that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The initial authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromAuthorizationToken(s, n) {
      t.Contracts.throwIfNull(s, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c.setProperty(r.PropertyId.SpeechServiceConnection_IntentRegion, n), c.authorizationToken = s, c;
    }
    /**
     * Closes the configuration.
     * @member SpeechConfig.prototype.close
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    close() {
    }
  };
  vt.SpeechConfig = o;
  class i extends o {
    constructor(s) {
      super(), this.privProperties = new r.PropertyCollection(), this.speechRecognitionLanguage = "en-US", this.outputFormat = r.OutputFormat.Simple, this.privTokenCredential = s;
    }
    get properties() {
      return this.privProperties;
    }
    get endPoint() {
      return new URL(this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint));
    }
    get subscriptionKey() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Key);
    }
    get region() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Region);
    }
    get authorizationToken() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    get speechRecognitionLanguage() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    set speechRecognitionLanguage(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, s);
    }
    get autoDetectSourceLanguages() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
    }
    set autoDetectSourceLanguages(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, s);
    }
    get outputFormat() {
      return r.OutputFormat[this.privProperties.getProperty(e.OutputFormatPropertyName, void 0)];
    }
    set outputFormat(s) {
      this.privProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[s]);
    }
    get endpointId() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId);
    }
    set endpointId(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_EndpointId, s);
    }
    get tokenCredential() {
      return this.privTokenCredential;
    }
    setProperty(s, n) {
      t.Contracts.throwIfNull(n, "value"), this.privProperties.setProperty(s, n);
    }
    getProperty(s, n) {
      return this.privProperties.getProperty(s, n);
    }
    setProxy(s, n, c, u) {
      this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyHostName], s), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPort], n), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    setServiceProperty(s, n) {
      const c = JSON.parse(this.privProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
      c[s] = n, this.privProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_ProfanityOption, r.ProfanityOption[s]);
    }
    enableAudioLogging() {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true"), this.privProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Detailed]);
    }
    enableDictation() {
      this.privProperties.setProperty(e.ForceDictationPropertyName, "true");
    }
    clone() {
      const s = new i(this.tokenCredential);
      return s.privProperties = this.privProperties.clone(), s;
    }
    get speechSynthesisLanguage() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, s);
    }
    get speechSynthesisVoiceName() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, s);
    }
    get speechSynthesisOutputFormat() {
      return r.SpeechSynthesisOutputFormat[this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, r.SpeechSynthesisOutputFormat[s]);
    }
  }
  return vt.SpeechConfigImpl = i, vt;
}
var gt = {}, wl;
function _R() {
  if (wl) return gt;
  wl = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.SpeechTranslationConfigImpl = gt.SpeechTranslationConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I();
  let o = class extends r.SpeechConfig {
    /**
     * Creates an instance of recognizer config.
     */
    constructor() {
      super();
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
     * @member SpeechTranslationConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromSubscription(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "subscriptionKey"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by setting the property authorizationToken with a new
     * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
     * will encounter errors during recognition.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply
     * to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechTranslationConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromAuthorizationToken(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s), c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(s, n) {
      t.Contracts.throwIfNull(s, "hostName");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Host, s.protocol + "//" + s.hostname + (s.port === "" ? "" : ":" + s.port)), n !== void 0 && c.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), c;
    }
    /**
     * Internal implementation of fromEndpoint() overloads. Accepts either a subscription key or a TokenCredential.
     * @private
     */
    static fromEndpoint(s, n) {
      t.Contracts.throwIfNull(s, "endpoint");
      const c = typeof n == "string" && n.trim().length > 0, u = typeof n == "object" && n !== null && typeof n.getToken == "function";
      if (n !== void 0 && !c && !u)
        throw new Error("Invalid 'auth' parameter: must be a non-empty key string or a valid TokenCredential object.");
      const l = typeof n == "object" ? new i(n) : new i();
      return l.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, s.href), typeof n == "string" && n.trim().length > 0 && l.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), l;
    }
  };
  gt.SpeechTranslationConfig = o;
  class i extends o {
    constructor(s) {
      super(), this.privSpeechProperties = new r.PropertyCollection(), this.outputFormat = r.OutputFormat.Simple, this.privTokenCredential = s;
    }
    /**
     * Gets/Sets the authorization token.
     * If this is set, subscription key is ignored.
     * User needs to make sure the provided authorization token is valid and not expired.
     * @member SpeechTranslationConfigImpl.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set authorizationToken(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    /**
     * Sets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set speechRecognitionLanguage(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, s);
    }
    /**
     * Gets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @return {string} The speechRecognitionLanguage.
     */
    get speechRecognitionLanguage() {
      return this.privSpeechProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
     * @function
     * @public
     */
    get subscriptionKey() {
      return this.privSpeechProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_Key]);
    }
    /**
     * Gets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    get outputFormat() {
      return r.OutputFormat[this.privSpeechProperties.getProperty(e.OutputFormatPropertyName, void 0)];
    }
    /**
     * Gets/Sets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    set outputFormat(s) {
      this.privSpeechProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[s]);
    }
    /**
     * Gets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    get endpointId() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId);
    }
    /**
     * Gets/Sets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    set endpointId(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_EndpointId, s);
    }
    /**
     * Add a (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    addTargetLanguage(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value");
      const n = this.targetLanguages;
      n.includes(s) || (n.push(s), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, n.join(",")));
    }
    /**
     * Gets the (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.targetLanguages
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    get targetLanguages() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",") : [];
    }
    /**
     * Gets the voice name.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     */
    get voiceName() {
      return this.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_TranslationVoice]);
    }
    /**
     * Gets/Sets the voice of the translated language, enable voice synthesis output.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     * @param {string} value - The name of the voice.
     */
    set voiceName(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, s);
    }
    /**
     * Provides the region.
     * @member SpeechTranslationConfigImpl.prototype.region
     * @function
     * @public
     * @returns {string} The region.
     */
    get region() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_Region);
    }
    get tokenCredential() {
      return this.privTokenCredential;
    }
    setProxy(s, n, c, u) {
      this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyHostName], s), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPort], n), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    /**
     * Gets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {string} name - The name of the property.
     * @param {string} def - The default value of the property in case it is not set.
     * @returns {string} The value of the property.
     */
    getProperty(s, n) {
      return this.privSpeechProperties.getProperty(s, n);
    }
    /**
     * Gets/Sets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {string | PropertyId} name - The name of the property to set.
     * @param {string} value - The value of the property.
     */
    setProperty(s, n) {
      this.privSpeechProperties.setProperty(s, n);
    }
    /**
     * Provides access to custom properties.
     * @member SpeechTranslationConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechProperties;
    }
    /**
     * Dispose of associated resources.
     * @member SpeechTranslationConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
    setServiceProperty(s, n) {
      const c = JSON.parse(this.privSpeechProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
      c[s] = n, this.privSpeechProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceResponse_ProfanityOption, r.ProfanityOption[s]);
    }
    enableAudioLogging() {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    }
    enableDictation() {
      this.privSpeechProperties.setProperty(e.ForceDictationPropertyName, "true");
    }
    get speechSynthesisLanguage() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, s);
    }
    get speechSynthesisVoiceName() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, s);
    }
    get speechSynthesisOutputFormat() {
      return r.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, r.SpeechSynthesisOutputFormat[s]);
    }
  }
  return gt.SpeechTranslationConfigImpl = i, gt;
}
var en = {}, bl;
function Pv() {
  if (bl) return en;
  bl = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.PropertyCollection = void 0;
  const e = /* @__PURE__ */ I();
  let t = class Rv {
    constructor() {
      this.privKeys = [], this.privValues = [];
    }
    /**
     * Returns the property value in type String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member PropertyCollection.prototype.getProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string | number | boolean} def - The default value which is returned if the parameter
     * is not available in the collection.
     * @returns {string} value of the parameter.
     */
    getProperty(o, i) {
      let a;
      typeof o == "string" ? a = o : a = e.PropertyId[o];
      for (let s = 0; s < this.privKeys.length; s++)
        if (this.privKeys[s] === a)
          return this.privValues[s];
      if (i !== void 0)
        return String(i);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member PropertyCollection.prototype.setProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    setProperty(o, i) {
      let a;
      typeof o == "string" ? a = o : a = e.PropertyId[o];
      for (let s = 0; s < this.privKeys.length; s++)
        if (this.privKeys[s] === a) {
          this.privValues[s] = i;
          return;
        }
      this.privKeys.push(a), this.privValues.push(i);
    }
    /**
     * Clones the collection.
     * @member PropertyCollection.prototype.clone
     * @function
     * @public
     * @returns {PropertyCollection} A copy of the collection.
     */
    clone() {
      const o = new Rv();
      for (let i = 0; i < this.privKeys.length; i++)
        o.privKeys.push(this.privKeys[i]), o.privValues.push(this.privValues[i]);
      return o;
    }
    /**
     * Merges this set of properties into another, no overwrites.
     * @member PropertyCollection.prototype.mergeTo
     * @function
     * @public
     * @param {PropertyCollection}  destinationCollection - The collection to merge into.
     */
    mergeTo(o) {
      this.privKeys.forEach((i) => {
        if (o.getProperty(i, void 0) === void 0) {
          const a = this.getProperty(i);
          o.setProperty(i, a);
        }
      });
    }
    /**
     * Get the keys in Property Collection.
     * @member PropertyCollection.prototype.keys
     * @function
     * @public
     * @returns {string []} Keys in the collection.
     */
    get keys() {
      return this.privKeys;
    }
  };
  return en.PropertyCollection = t, en;
}
var Ko = {}, El;
function hc() {
  return El || (El = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PropertyId = void 0, function(t) {
      t[t.SpeechServiceConnection_Key = 0] = "SpeechServiceConnection_Key", t[t.SpeechServiceConnection_Endpoint = 1] = "SpeechServiceConnection_Endpoint", t[t.SpeechServiceConnection_Region = 2] = "SpeechServiceConnection_Region", t[t.SpeechServiceAuthorization_Token = 3] = "SpeechServiceAuthorization_Token", t[t.SpeechServiceAuthorization_Type = 4] = "SpeechServiceAuthorization_Type", t[t.SpeechServiceConnection_EndpointId = 5] = "SpeechServiceConnection_EndpointId", t[t.SpeechServiceConnection_TranslationToLanguages = 6] = "SpeechServiceConnection_TranslationToLanguages", t[t.SpeechServiceConnection_TranslationVoice = 7] = "SpeechServiceConnection_TranslationVoice", t[t.SpeechServiceConnection_TranslationFeatures = 8] = "SpeechServiceConnection_TranslationFeatures", t[t.SpeechServiceConnection_TranslationCategoryId = 9] = "SpeechServiceConnection_TranslationCategoryId", t[t.SpeechServiceConnection_IntentRegion = 10] = "SpeechServiceConnection_IntentRegion", t[t.SpeechServiceConnection_ProxyHostName = 11] = "SpeechServiceConnection_ProxyHostName", t[t.SpeechServiceConnection_ProxyPort = 12] = "SpeechServiceConnection_ProxyPort", t[t.SpeechServiceConnection_ProxyUserName = 13] = "SpeechServiceConnection_ProxyUserName", t[t.SpeechServiceConnection_ProxyPassword = 14] = "SpeechServiceConnection_ProxyPassword", t[t.SpeechServiceConnection_RecoMode = 15] = "SpeechServiceConnection_RecoMode", t[t.SpeechServiceConnection_RecoLanguage = 16] = "SpeechServiceConnection_RecoLanguage", t[t.Speech_SessionId = 17] = "Speech_SessionId", t[t.SpeechServiceConnection_SynthLanguage = 18] = "SpeechServiceConnection_SynthLanguage", t[t.SpeechServiceConnection_SynthVoice = 19] = "SpeechServiceConnection_SynthVoice", t[t.SpeechServiceConnection_SynthOutputFormat = 20] = "SpeechServiceConnection_SynthOutputFormat", t[t.SpeechServiceConnection_AutoDetectSourceLanguages = 21] = "SpeechServiceConnection_AutoDetectSourceLanguages", t[t.SpeechServiceResponse_RequestDetailedResultTrueFalse = 22] = "SpeechServiceResponse_RequestDetailedResultTrueFalse", t[t.SpeechServiceResponse_RequestProfanityFilterTrueFalse = 23] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse", t[t.SpeechServiceResponse_JsonResult = 24] = "SpeechServiceResponse_JsonResult", t[t.SpeechServiceResponse_JsonErrorDetails = 25] = "SpeechServiceResponse_JsonErrorDetails", t[t.CancellationDetails_Reason = 26] = "CancellationDetails_Reason", t[t.CancellationDetails_ReasonText = 27] = "CancellationDetails_ReasonText", t[t.CancellationDetails_ReasonDetailedText = 28] = "CancellationDetails_ReasonDetailedText", t[t.LanguageUnderstandingServiceResponse_JsonResult = 29] = "LanguageUnderstandingServiceResponse_JsonResult", t[t.SpeechServiceConnection_Url = 30] = "SpeechServiceConnection_Url", t[t.SpeechServiceConnection_InitialSilenceTimeoutMs = 31] = "SpeechServiceConnection_InitialSilenceTimeoutMs", t[t.SpeechServiceConnection_EndSilenceTimeoutMs = 32] = "SpeechServiceConnection_EndSilenceTimeoutMs", t[t.Speech_SegmentationSilenceTimeoutMs = 33] = "Speech_SegmentationSilenceTimeoutMs", t[t.Speech_SegmentationMaximumTimeMs = 34] = "Speech_SegmentationMaximumTimeMs", t[t.Speech_SegmentationStrategy = 35] = "Speech_SegmentationStrategy", t[t.SpeechServiceConnection_EnableAudioLogging = 36] = "SpeechServiceConnection_EnableAudioLogging", t[t.SpeechServiceConnection_LanguageIdMode = 37] = "SpeechServiceConnection_LanguageIdMode", t[t.SpeechServiceConnection_RecognitionEndpointVersion = 38] = "SpeechServiceConnection_RecognitionEndpointVersion", t[t.SpeechServiceConnection_SpeakerIdMode = 39] = "SpeechServiceConnection_SpeakerIdMode", t[t.SpeechServiceResponse_ProfanityOption = 40] = "SpeechServiceResponse_ProfanityOption", t[t.SpeechServiceResponse_PostProcessingOption = 41] = "SpeechServiceResponse_PostProcessingOption", t[t.SpeechServiceResponse_RequestWordLevelTimestamps = 42] = "SpeechServiceResponse_RequestWordLevelTimestamps", t[t.SpeechServiceResponse_StablePartialResultThreshold = 43] = "SpeechServiceResponse_StablePartialResultThreshold", t[t.SpeechServiceResponse_OutputFormatOption = 44] = "SpeechServiceResponse_OutputFormatOption", t[t.SpeechServiceResponse_TranslationRequestStablePartialResult = 45] = "SpeechServiceResponse_TranslationRequestStablePartialResult", t[t.SpeechServiceResponse_RequestWordBoundary = 46] = "SpeechServiceResponse_RequestWordBoundary", t[t.SpeechServiceResponse_RequestPunctuationBoundary = 47] = "SpeechServiceResponse_RequestPunctuationBoundary", t[t.SpeechServiceResponse_RequestSentenceBoundary = 48] = "SpeechServiceResponse_RequestSentenceBoundary", t[t.SpeechServiceResponse_DiarizeIntermediateResults = 49] = "SpeechServiceResponse_DiarizeIntermediateResults", t[t.Conversation_ApplicationId = 50] = "Conversation_ApplicationId", t[t.Conversation_DialogType = 51] = "Conversation_DialogType", t[t.Conversation_Initial_Silence_Timeout = 52] = "Conversation_Initial_Silence_Timeout", t[t.Conversation_From_Id = 53] = "Conversation_From_Id", t[t.Conversation_Conversation_Id = 54] = "Conversation_Conversation_Id", t[t.Conversation_Custom_Voice_Deployment_Ids = 55] = "Conversation_Custom_Voice_Deployment_Ids", t[t.Conversation_Speech_Activity_Template = 56] = "Conversation_Speech_Activity_Template", t[t.Conversation_Request_Bot_Status_Messages = 57] = "Conversation_Request_Bot_Status_Messages", t[t.Conversation_Agent_Connection_Id = 58] = "Conversation_Agent_Connection_Id", t[t.SpeechServiceConnection_Host = 59] = "SpeechServiceConnection_Host", t[t.ConversationTranslator_Host = 60] = "ConversationTranslator_Host", t[t.ConversationTranslator_Name = 61] = "ConversationTranslator_Name", t[t.ConversationTranslator_CorrelationId = 62] = "ConversationTranslator_CorrelationId", t[t.ConversationTranslator_Token = 63] = "ConversationTranslator_Token", t[t.PronunciationAssessment_ReferenceText = 64] = "PronunciationAssessment_ReferenceText", t[t.PronunciationAssessment_GradingSystem = 65] = "PronunciationAssessment_GradingSystem", t[t.PronunciationAssessment_Granularity = 66] = "PronunciationAssessment_Granularity", t[t.PronunciationAssessment_EnableMiscue = 67] = "PronunciationAssessment_EnableMiscue", t[t.PronunciationAssessment_Json = 68] = "PronunciationAssessment_Json", t[t.PronunciationAssessment_Params = 69] = "PronunciationAssessment_Params", t[t.SpeakerRecognition_Api_Version = 70] = "SpeakerRecognition_Api_Version", t[t.WebWorkerLoadType = 71] = "WebWorkerLoadType", t[t.TalkingAvatarService_WebRTC_SDP = 72] = "TalkingAvatarService_WebRTC_SDP";
    }(e.PropertyId || (e.PropertyId = {}));
  }(Ko)), Ko;
}
var tn = {}, Il;
function kR() {
  if (Il) return tn;
  Il = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.Recognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class wv {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     * @param {PropertyCollection} properties - A set of properties to set on the recognizer
     * @param {IConnectionFactory} connectionFactory - The factory class used to create a custom IConnection for the recognizer
     */
    constructor(s, n, c, u) {
      this.audioConfig = s !== void 0 ? s : o.AudioConfig.fromDefaultMicrophoneInput(), this.privDisposed = !1, this.privProperties = n.clone(), this.privConnectionFactory = c, this.tokenCredential = u, this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */
    close(s, n) {
      r.Contracts.throwIfDisposed(this.privDisposed), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), s, n);
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privReco;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(s) {
      this.privDisposed || (this.privDisposed = !0, s && this.privReco && (await this.privReco.audioSource.turnOff(), await this.privReco.dispose()));
    }
    /**
     * This method returns the current state of the telemetry setting.
     * @member Recognizer.prototype.telemetryEnabled
     * @function
     * @public
     * @returns true if the telemetry is enabled, false otherwise.
     */
    static get telemetryEnabled() {
      return e.ServiceRecognizerBase.telemetryDataEnabled;
    }
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */
    static enableTelemetry(s) {
      e.ServiceRecognizerBase.telemetryDataEnabled = s;
    }
    // Does the generic recognizer setup that is common across all recognizer types.
    implCommonRecognizerSetup() {
      let s = typeof window < "u" ? "Browser" : "Node", n = "unknown", c = "unknown";
      typeof navigator < "u" && (s = s + "/" + navigator.platform, n = navigator.userAgent, c = navigator.appVersion);
      const u = this.createRecognizerConfig(new e.SpeechServiceConfig(new e.Context(new e.OS(s, n, c))));
      this.privReco = this.createServiceRecognizer(wv.getAuth(this.privProperties, this.tokenCredential), this.privConnectionFactory, this.audioConfig, u);
    }
    async recognizeOnceAsyncImpl(s) {
      r.Contracts.throwIfDisposed(this.privDisposed);
      const n = new t.Deferred();
      await this.implRecognizerStop(), await this.privReco.recognize(s, n.resolve, n.reject);
      const c = await n.promise;
      return await this.implRecognizerStop(), c;
    }
    async startContinuousRecognitionAsyncImpl(s) {
      r.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop(), await this.privReco.recognize(s, void 0, void 0);
    }
    async stopContinuousRecognitionAsyncImpl() {
      r.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop();
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    static getAuth(s, n) {
      const c = s.getProperty(o.PropertyId.SpeechServiceConnection_Key, void 0);
      return c && c !== "" ? new e.CognitiveSubscriptionKeyAuthentication(c) : n ? new e.CognitiveTokenAuthentication(async () => {
        try {
          return (await n.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (u) {
          throw u;
        }
      }, async () => {
        try {
          return (await n.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (u) {
          throw u;
        }
      }) : new e.CognitiveTokenAuthentication(() => {
        const u = s.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      }, () => {
        const u = s.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      });
    }
  };
  return tn.Recognizer = i, tn;
}
var rn = {}, Jo = {}, Al;
function we() {
  return Al || (Al = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionMode = void 0, function(t) {
      t.Interactive = "Interactive", t.Dictation = "Dictation", t.Conversation = "Conversation", t.None = "None";
    }(e.RecognitionMode || (e.RecognitionMode = {}));
  }(Jo)), Jo;
}
var Tl;
function OR() {
  if (Tl) return rn;
  Tl = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.SpeechRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ we(), r = /* @__PURE__ */ M(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ I();
  let a = class bv extends i.Recognizer {
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      o.Contracts.throwIfNull(u, "speechConfig"), o.Contracts.throwIfNullOrWhitespace(u.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new e.SpeechConnectionFactory(), n.tokenCredential), this.privDisposedRecognizer = !1;
    }
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(n, c, u) {
      const l = n;
      return c.properties.mergeTo(l.properties), new bv(n, u);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for speech recognition.
     * @member SpeechRecognizer.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      o.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * Gets the spoken language of recognition.
     * @member SpeechRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of recognition.
     * @member SpeechRecognizer.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of recognition.
     */
    get outputFormat() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(e.OutputFormatPropertyName, i.OutputFormat[i.OutputFormat.Simple]) === i.OutputFormat[i.OutputFormat.Simple] ? i.OutputFormat.Simple : i.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this SpeechRecognizer.
     * @member SpeechRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts speech recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition
     * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member SpeechRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the SpeechRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), n, c);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(this.properties.getProperty(e.ForceDictationPropertyName, void 0) === void 0 ? t.RecognitionMode.Conversation : t.RecognitionMode.Dictation), n, c);
    }
    /**
     * Stops continuous speech recognition.
     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * Starts speech recognition with keyword spotting, until
     * stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model The keyword recognition model that
     * specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(n, c, u) {
      o.Contracts.throwIfNull(n, "model"), u && u("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(n) {
      n && n();
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member SpeechRecognizer.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new e.SpeechServiceRecognizer(n, c, p, l, this);
    }
  };
  return rn.SpeechRecognizer = a, rn;
}
var nn = {}, _l;
function MR() {
  if (_l) return nn;
  _l = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.IntentRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ we(), r = /* @__PURE__ */ M(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ I();
  let a = class extends i.Recognizer {
    /**
     * Initializes an instance of the IntentRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(n, c) {
      o.Contracts.throwIfNullOrUndefined(n, "speechConfig");
      const u = n;
      o.Contracts.throwIfNullOrUndefined(u, "speechConfig"), super(c, u.properties, new e.IntentConnectionFactory()), this.privAddedIntents = [], this.privAddedLmIntents = {}, this.privDisposedIntentRecognizer = !1, this.privProperties = u.properties, o.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * Gets the spoken language of recognition.
     * @member IntentRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} the spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(n) {
      this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * The collection of properties and their values defined for this IntentRecognizer.
     * @member IntentRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their
     * values defined for this IntentRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts intent recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text and intent as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition like command or query.
     * For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member IntentRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(n, c) {
      if (o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const u = this.buildSpeechContext();
        this.privReco.speechContext.getContext().intent = u.Intent, this.privReco.dynamicGrammar.addReferenceGrammar(u.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), n, c);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(n, c) {
      if (Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const u = this.buildSpeechContext();
        this.privReco.speechContext.getContext().intent = u.Intent, this.privReco.dynamicGrammar.addReferenceGrammar(u.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), n, c);
    }
    /**
     * Stops continuous intent recognition.
     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(n, c, u) {
      o.Contracts.throwIfNull(n, "model"), u && u("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(n, c) {
      if (n)
        try {
          n();
        } catch (u) {
          c && c(u);
        }
    }
    /**
     * Adds a phrase that should be recognized as intent.
     * @member IntentRecognizer.prototype.addIntent
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
     * @param {string} phrase - A String that specifies the phrase representing the intent.
     */
    addIntent(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), o.Contracts.throwIfNullOrWhitespace(c, "intentId"), o.Contracts.throwIfNullOrWhitespace(n, "simplePhrase"), this.privAddedIntents.push([c, n]);
    }
    /**
     * Adds an intent from Language Understanding service for recognition.
     * @member IntentRecognizer.prototype.addIntentWithLanguageModel
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent
     * to be recognized. Ignored if intentName is empty.
     * @param {string} model - The intent model from Language Understanding service.
     * @param {string} intentName - The intent name defined in the intent model. If it
     * is empty, all intent names defined in the model will be added.
     */
    addIntentWithLanguageModel(n, c, u) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), o.Contracts.throwIfNullOrWhitespace(n, "intentId"), o.Contracts.throwIfNull(c, "model");
      const l = c;
      o.Contracts.throwIfNullOrWhitespace(l.appId, "model.appId"), this.privAddedLmIntents[n] = new e.AddedLmIntent(l, u);
    }
    /**
     * @summary Adds all intents from the specified Language Understanding Model.
     * @member IntentRecognizer.prototype.addAllIntents
     * @function
     * @public
     * @function
     * @public
     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
     */
    addAllIntents(n, c) {
      o.Contracts.throwIfNull(n, "model");
      const u = n;
      o.Contracts.throwIfNullOrWhitespace(u.appId, "model.appId"), this.privUmbrellaIntent = new e.AddedLmIntent(u, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member IntentRecognizer.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new e.IntentServiceRecognizer(n, c, p, l, this);
    }
    async dispose(n) {
      this.privDisposedIntentRecognizer || n && (this.privDisposedIntentRecognizer = !0, await super.dispose(n));
    }
    buildSpeechContext() {
      let n, c, u;
      const l = [];
      this.privUmbrellaIntent !== void 0 && (n = this.privUmbrellaIntent.modelImpl.appId, c = this.privUmbrellaIntent.modelImpl.region, u = this.privUmbrellaIntent.modelImpl.subscriptionKey);
      for (const p of Object.keys(this.privAddedLmIntents)) {
        const h = this.privAddedLmIntents[p];
        if (n === void 0)
          n = h.modelImpl.appId;
        else if (n !== h.modelImpl.appId)
          throw new Error("Intents must all be from the same LUIS model");
        if (c === void 0)
          c = h.modelImpl.region;
        else if (c !== h.modelImpl.region)
          throw new Error("Intents must all be from the same LUIS model in a single region");
        if (u === void 0)
          u = h.modelImpl.subscriptionKey;
        else if (u !== h.modelImpl.subscriptionKey)
          throw new Error("Intents must all use the same subscription key");
        const d = "luis/" + n + "-PRODUCTION#" + p;
        l.push(d);
      }
      return {
        Intent: {
          id: n,
          key: u === void 0 ? this.privProperties.getProperty(i.PropertyId[i.PropertyId.SpeechServiceConnection_Key]) : u,
          provider: "LUIS"
        },
        ReferenceGrammars: this.privUmbrellaIntent === void 0 ? l : ["luis/" + n + "-PRODUCTION"]
      };
    }
  };
  return nn.IntentRecognizer = a, nn;
}
var Go = {}, kl;
function DR() {
  return kl || (kl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.VoiceProfileType = void 0, function(t) {
      t[t.TextIndependentIdentification = 0] = "TextIndependentIdentification", t[t.TextDependentVerification = 1] = "TextDependentVerification", t[t.TextIndependentVerification = 2] = "TextIndependentVerification";
    }(e.VoiceProfileType || (e.VoiceProfileType = {}));
  }(Go)), Go;
}
var sn = {}, on = {}, mt = {}, Ol;
function Ev() {
  if (Ol) return mt;
  Ol = 1, Object.defineProperty(mt, "__esModule", { value: !0 }), mt.ConnectionMessageImpl = mt.ConnectionMessage = void 0;
  const e = /* @__PURE__ */ le(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ Pv(), o = /* @__PURE__ */ hc();
  let i = class {
  };
  mt.ConnectionMessage = i;
  class a {
    constructor(n) {
      this.privConnectionMessage = n, this.privProperties = new r.PropertyCollection(), this.privConnectionMessage.headers[e.HeaderNames.ConnectionId] && this.privProperties.setProperty(o.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[e.HeaderNames.ConnectionId]), Object.keys(this.privConnectionMessage.headers).forEach((c) => {
        this.privProperties.setProperty(c, this.privConnectionMessage.headers[c]);
      });
    }
    /**
     * The message path.
     */
    get path() {
      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((n) => n.toLowerCase() === "path".toLowerCase())];
    }
    /**
     * Checks to see if the ConnectionMessage is a text message.
     * See also IsBinaryMessage().
     */
    get isTextMessage() {
      return this.privConnectionMessage.messageType === t.MessageType.Text;
    }
    /**
     * Checks to see if the ConnectionMessage is a binary message.
     * See also GetBinaryMessage().
     */
    get isBinaryMessage() {
      return this.privConnectionMessage.messageType === t.MessageType.Binary;
    }
    /**
     * Gets the text message payload. Typically the text message content-type is
     * application/json. To determine other content-types use
     * Properties.GetProperty("Content-Type").
     */
    get TextMessage() {
      return this.privConnectionMessage.textBody;
    }
    /**
     * Gets the binary message payload.
     */
    get binaryMessage() {
      return this.privConnectionMessage.binaryBody;
    }
    /**
     * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
     * Message headers can be accessed via this collection (e.g. "Content-Type").
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Returns a string that represents the connection message.
     */
    toString() {
      return "";
    }
  }
  return mt.ConnectionMessageImpl = a, mt;
}
var Ml;
function Iv() {
  if (Ml) return on;
  Ml = 1, Object.defineProperty(on, "__esModule", { value: !0 }), on.Connection = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ Ev(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ I();
  let a = class Ja {
    /**
     * Gets the Connection instance from the specified recognizer.
     * @param recognizer The recognizer associated with the connection.
     * @return The Connection instance of the recognizer.
     */
    static fromRecognizer(n) {
      const c = n.internalData, u = new Ja();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Gets the Connection instance from the specified synthesizer.
     * @param synthesizer The synthesizer associated with the connection.
     * @return The Connection instance of the synthesizer.
     */
    static fromSynthesizer(n) {
      const c = n.internalData, u = new Ja();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Starts to set up connection to the service.
     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     */
    openConnection(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.connect(), n, c);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
     *
     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
     */
    closeConnection(n, c) {
      if (this.privInternalData instanceof e.SynthesisAdapterBase)
        throw new Error("Disconnecting a synthesizer's connection is currently not supported");
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.disconnect(), n, c);
    }
    /**
     * Appends a parameter in a message to service.
     * Added in version 1.12.1.
     * @param path The path of the network message.
     * @param propertyName Name of the property
     * @param propertyValue Value of the property. This is a json string.
     */
    setMessageProperty(n, c, u) {
      if (o.Contracts.throwIfNullOrWhitespace(c, "propertyName"), this.privInternalData instanceof e.ServiceRecognizerBase) {
        if (n.toLowerCase() !== "speech.context")
          throw new Error("Only speech.context message property sets are currently supported for recognizer");
        {
          const l = this.privInternalData.speechContext.getContext();
          l[c] = u;
        }
      } else if (this.privInternalData instanceof e.SynthesisAdapterBase) {
        if (n.toLowerCase() !== "synthesis.context")
          throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
        this.privInternalData.synthesisContext.setSection(c, u);
      }
    }
    /**
     * Sends a message to the speech service.
     * Added in version 1.13.0.
     * @param path The WebSocket path of the message
     * @param payload The payload of the message. This is a json string or a ArrayBuffer.
     * @param success A callback to indicate success.
     * @param error A callback to indicate an error.
     */
    sendMessageAsync(n, c, u, l) {
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.sendNetworkMessage(n, c), u, l);
    }
    /**
     * Dispose of associated resources.
     */
    close() {
    }
    setupEvents() {
      this.privEventListener = this.privInternalData.connectionEvents.attach((n) => {
        n.name === "ConnectionEstablishedEvent" ? this.connected && this.connected(new i.ConnectionEventArgs(n.connectionId)) : n.name === "ConnectionClosedEvent" ? this.disconnected && this.disconnected(new i.ConnectionEventArgs(n.connectionId)) : n.name === "ConnectionMessageSentEvent" ? this.messageSent && this.messageSent(new i.ConnectionMessageEventArgs(new r.ConnectionMessageImpl(n.message))) : n.name === "ConnectionMessageReceivedEvent" && this.messageReceived && this.messageReceived(new i.ConnectionMessageEventArgs(new r.ConnectionMessageImpl(n.message)));
      }), this.privServiceEventListener = this.privInternalData.serviceEvents.attach((n) => {
        this.receivedServiceMessage && this.receivedServiceMessage(new i.ServiceEventArgs(n.jsonString, n.name));
      });
    }
  };
  return on.Connection = a, on;
}
var Dl;
function xR() {
  if (Dl) return sn;
  Dl = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.TranslationRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ we(), r = /* @__PURE__ */ M(), o = /* @__PURE__ */ Iv(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ I();
  let s = class Av extends a.Recognizer {
    /**
     * Initializes an instance of the TranslationRecognizer.
     * @constructor
     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
     */
    constructor(c, u, l) {
      const p = c;
      i.Contracts.throwIfNull(p, "speechConfig"), super(u, p.properties, l || new e.TranslationConnectionFactory(), c.tokenCredential), this.privDisposedTranslationRecognizer = !1, this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice), a.PropertyId[a.PropertyId.SpeechServiceConnection_TranslationVoice]), i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages), a.PropertyId[a.PropertyId.SpeechServiceConnection_TranslationToLanguages]), i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage), a.PropertyId[a.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * TranslationRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(c, u, l) {
      const p = c;
      return u.properties.mergeTo(p.properties), u.properties.getProperty(a.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0) === e.AutoDetectSourceLanguagesOpenRangeOptionName && p.properties.setProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), new Av(c, l);
    }
    /**
     * Gets the language name that was set when the recognizer was created.
     * @member TranslationRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} Gets the language name that was set when the recognizer was created.
     */
    get speechRecognitionLanguage() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets target languages for translation that were set when the recognizer was created.
     * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
     * @member TranslationRecognizer.prototype.targetLanguages
     * @function
     * @public
     * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
     */
    get targetLanguages() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
    }
    /**
     * Gets the name of output voice.
     * @member TranslationRecognizer.prototype.voiceName
     * @function
     * @public
     * @returns {string} the name of output voice.
     */
    get voiceName() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
    }
    /**
     * The collection of properties and their values defined for this TranslationRecognizer.
     * @member TranslationRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(a.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(c) {
      this.properties.setProperty(a.PropertyId.SpeechServiceAuthorization_Token, c);
    }
    /**
     * Starts recognition and translation, and stops after the first utterance is recognized.
     * The task returns the translation text as result.
     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
     * for single shot recognition like command or query. For long-running recognition,
     * use startContinuousRecognitionAsync() instead.
     * @member TranslationRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the translation has completed.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(c, u) {
      i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), c, u);
    }
    /**
     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive translation results.
     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(c, u) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), c, u);
    }
    /**
     * Stops continuous recognition and translation.
     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(c, u) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), c, u);
    }
    /**
     * dynamically remove a language from list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.removeTargetLanguage
     * @function
     * @param lang - language to be removed
     * @public
     */
    removeTargetLanguage(c) {
      if (i.Contracts.throwIfNullOrUndefined(c, "language to be removed"), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        const u = this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), l = u.indexOf(c);
        l > -1 && (u.splice(l, 1), this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, u.join(",")), this.updateLanguages(u));
      }
    }
    /**
     * dynamically add a language to list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.addTargetLanguage
     * @function
     * @param lang - language to be added
     * @public
     */
    addTargetLanguage(c) {
      i.Contracts.throwIfNullOrUndefined(c, "language to be added");
      let u = [];
      this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? (u = this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), u.includes(c) || (u.push(c), this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, u.join(",")))) : (this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, c), u = [c]), this.updateLanguages(u);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member TranslationRecognizer.prototype.close
     * @function
     * @public
     */
    close(c, u) {
      i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), c, u);
    }
    /**
     * handles ConnectionEstablishedEvent for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onConnection
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onConnection() {
    }
    async dispose(c) {
      this.privDisposedTranslationRecognizer || (this.privDisposedTranslationRecognizer = !0, c && (await this.implRecognizerStop(), await super.dispose(c)));
    }
    createRecognizerConfig(c) {
      return new e.RecognizerConfig(c, this.privProperties);
    }
    createServiceRecognizer(c, u, l, p) {
      const h = l;
      return new e.TranslationServiceRecognizer(c, u, h, p, this);
    }
    updateLanguages(c) {
      const u = o.Connection.fromRecognizer(this);
      u && (u.setMessageProperty("speech.context", "translationcontext", { to: c }), u.sendMessageAsync("event", JSON.stringify({
        id: "translation",
        name: "updateLanguage",
        to: c
      })));
    }
  };
  return sn.TranslationRecognizer = s, sn;
}
var an = {}, xl;
function NR() {
  if (xl) return an;
  xl = 1, Object.defineProperty(an, "__esModule", { value: !0 }), an.Translations = void 0;
  const e = /* @__PURE__ */ I();
  let t = class {
    constructor() {
      this.privMap = new e.PropertyCollection();
    }
    /**
     * Get the languages in the object in a String array.
     * @member Translations.prototype.languages
     * @function
     * @public
     * @returns {string[]} languages in translations object.
     */
    get languages() {
      return this.privMap.keys;
    }
    /**
     * Returns the parameter value in type String. The parameter must have the same type as String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member Translations.prototype.get
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} def - The default value which is returned if the parameter is not available in the collection.
     * @returns {string} value of the parameter.
     */
    get(o, i) {
      return this.privMap.getProperty(o, i);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member Translations.prototype.set
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    set(o, i) {
      this.privMap.setProperty(o, i);
    }
  };
  return an.Translations = t, an;
}
var Qo = {}, Nl;
function zR() {
  return Nl || (Nl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NoMatchReason = void 0, function(t) {
      t[t.NotRecognized = 0] = "NotRecognized", t[t.InitialSilenceTimeout = 1] = "InitialSilenceTimeout", t[t.InitialBabbleTimeout = 2] = "InitialBabbleTimeout";
    }(e.NoMatchReason || (e.NoMatchReason = {}));
  }(Qo)), Qo;
}
var cn = {}, zl;
function LR() {
  if (zl) return cn;
  zl = 1, Object.defineProperty(cn, "__esModule", { value: !0 }), cn.NoMatchDetails = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ I();
  let r = class Tv {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {NoMatchReason} reason - The no-match reason.
     */
    constructor(i) {
      this.privReason = i;
    }
    /**
     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
     * @member NoMatchDetails.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
     * result - The recognition result that was not recognized.
     * @returns {NoMatchDetails} The no match details object being created.
     */
    static fromResult(i) {
      const a = e.SimpleSpeechPhrase.fromJSON(i.json, 0);
      let s = t.NoMatchReason.NotRecognized;
      switch (a.RecognitionStatus) {
        case e.RecognitionStatus.BabbleTimeout:
          s = t.NoMatchReason.InitialBabbleTimeout;
          break;
        case e.RecognitionStatus.InitialSilenceTimeout:
          s = t.NoMatchReason.InitialSilenceTimeout;
          break;
        default:
          s = t.NoMatchReason.NotRecognized;
          break;
      }
      return new Tv(s);
    }
    /**
     * The reason the recognition was canceled.
     * @member NoMatchDetails.prototype.reason
     * @function
     * @public
     * @returns {NoMatchReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
  };
  return cn.NoMatchDetails = r, cn;
}
var un = {}, Ll;
function jR() {
  if (Ll) return un;
  Ll = 1, Object.defineProperty(un, "__esModule", { value: !0 }), un.TranslationRecognitionCanceledEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionid - The session id.
     * @param {CancellationReason} cancellationReason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {TranslationRecognitionResult} result - The result.
     */
    constructor(r, o, i, a, s) {
      this.privCancelReason = o, this.privErrorDetails = i, this.privResult = s, this.privSessionId = r, this.privErrorCode = a;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionCanceledEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
    /**
     * Specifies the session identifier.
     * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
     * @function
     * @public
     * @returns {string} the session identifier.
     */
    get sessionId() {
      return this.privSessionId;
    }
    /**
     * The reason the recognition was canceled.
     * @member TranslationRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privCancelReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return un.TranslationRecognitionCanceledEventArgs = e, un;
}
var ln = {}, jl;
function qR() {
  if (jl) return ln;
  jl = 1, Object.defineProperty(ln, "__esModule", { value: !0 }), ln.IntentRecognitionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.IntentRecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} result - The result of the intent recognition.
     * @param {string} offset - The offset.
     * @param {IntentRecognitionResult} sessionId - The session id.
     */
    constructor(o, i, a, s, n, c) {
      super(s, n, c), this.privReason = o, this.privErrorDetails = i, this.privErrorCode = a;
    }
    /**
     * The reason the recognition was canceled.
     * @member IntentRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return ln.IntentRecognitionCanceledEventArgs = t, ln;
}
var pn = {}, ql;
function _v() {
  if (ql) return pn;
  ql = 1, Object.defineProperty(pn, "__esModule", { value: !0 }), pn.CancellationDetailsBase = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - The error details, if provided.
     */
    constructor(r, o, i) {
      this.privReason = r, this.privErrorDetails = o, this.privErrorCode = i;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationDetailsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member CancellationDetailsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get ErrorCode() {
      return this.privErrorCode;
    }
  };
  return pn.CancellationDetailsBase = e, pn;
}
var dn = {}, Fl;
function FR() {
  if (Fl) return dn;
  Fl = 1, Object.defineProperty(dn, "__esModule", { value: !0 }), dn.CancellationDetails = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ _v(), r = /* @__PURE__ */ I();
  let o = class kv extends t.CancellationDetailsBase {
    constructor(a, s, n) {
      super(a, s, n);
    }
    /**
     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
     * @member CancellationDetails.fromResult
     * @function
     * @public
     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
     * @returns {CancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      let s = r.CancellationReason.Error, n = r.CancellationErrorCode.NoError;
      if (a instanceof r.RecognitionResult && a.json) {
        const c = e.SimpleSpeechPhrase.fromJSON(a.json, 0);
        s = e.EnumTranslation.implTranslateCancelResult(c.RecognitionStatus);
      }
      return a.properties && (n = r.CancellationErrorCode[a.properties.getProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new kv(s, a.errorDetails || e.EnumTranslation.implTranslateErrorDetails(n), n);
    }
  };
  return dn.CancellationDetails = o, dn;
}
var Yo = {}, Bl;
function BR() {
  return Bl || (Bl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationErrorCode = void 0, function(t) {
      t[t.NoError = 0] = "NoError", t[t.AuthenticationFailure = 1] = "AuthenticationFailure", t[t.BadRequestParameters = 2] = "BadRequestParameters", t[t.TooManyRequests = 3] = "TooManyRequests", t[t.ConnectionFailure = 4] = "ConnectionFailure", t[t.ServiceTimeout = 5] = "ServiceTimeout", t[t.ServiceError = 6] = "ServiceError", t[t.RuntimeError = 7] = "RuntimeError", t[t.Forbidden = 8] = "Forbidden";
    }(e.CancellationErrorCode || (e.CancellationErrorCode = {}));
  }(Yo)), Yo;
}
var hn = {}, Ul;
function UR() {
  if (Ul) return hn;
  Ul = 1, Object.defineProperty(hn, "__esModule", { value: !0 }), hn.ConnectionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
  };
  return hn.ConnectionEventArgs = t, hn;
}
var fn = {}, $l;
function $R() {
  if ($l) return fn;
  $l = 1, Object.defineProperty(fn, "__esModule", { value: !0 }), fn.ServiceEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} json - json payload of the USP message.
     */
    constructor(o, i, a) {
      super(a), this.privJsonResult = o, this.privEventName = i;
    }
    get jsonString() {
      return this.privJsonResult;
    }
    get eventName() {
      return this.privEventName;
    }
  };
  return fn.ServiceEventArgs = t, fn;
}
var vn = {}, Vl;
function VR() {
  if (Vl) return vn;
  Vl = 1, Object.defineProperty(vn, "__esModule", { value: !0 }), vn.PhraseListGrammar = void 0;
  let e = class Ov {
    constructor(r) {
      this.privGrammerBuilder = r.dynamicGrammar;
    }
    /**
     * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
     * @param recognizer The recognizer to add phrase lists to.
     */
    static fromRecognizer(r) {
      const o = r.internalData;
      return new Ov(o);
    }
    /**
     * Adds a single phrase to the current recognizer.
     * @param phrase Phrase to add.
     */
    addPhrase(r) {
      this.privGrammerBuilder.addPhrase(r);
    }
    /**
     * Adds multiple phrases to the current recognizer.
     * @param phrases Array of phrases to add.
     */
    addPhrases(r) {
      this.privGrammerBuilder.addPhrase(r);
    }
    /**
     * Clears all phrases added to the current recognizer.
     */
    clear() {
      this.privGrammerBuilder.clearPhrases();
    }
  };
  return vn.PhraseListGrammar = e, vn;
}
var yt = {}, Wl;
function fc() {
  if (Wl) return yt;
  Wl = 1, Object.defineProperty(yt, "__esModule", { value: !0 }), yt.DialogServiceConfigImpl = yt.DialogServiceConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class {
    /**
     * Creates an instance of DialogService config.
     * @constructor
     */
    constructor() {
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member DialogServiceConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set applicationId(a) {
    }
    static get DialogTypes() {
      return {
        BotFramework: "bot_framework",
        CustomCommands: "custom_commands"
      };
    }
  };
  yt.DialogServiceConfig = r;
  class o extends r {
    /**
     * Creates an instance of dialogService config.
     */
    constructor() {
      super(), this.privSpeechConfig = new t.SpeechConfigImpl();
    }
    /**
     * Provides access to custom properties.
     * @member DialogServiceConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechConfig.properties;
    }
    /**
     * Gets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     */
    get speechRecognitionLanguage() {
      return this.privSpeechConfig.speechRecognitionLanguage;
    }
    /**
     * Sets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The language to set.
     */
    set speechRecognitionLanguage(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechConfig.speechRecognitionLanguage = a;
    }
    get outputFormat() {
      return this.privSpeechConfig.outputFormat;
    }
    set outputFormat(a) {
      this.privSpeechConfig.outputFormat = a;
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to set.
     * @param {string} value - The value.
     */
    setProperty(a, s) {
      this.privSpeechConfig.setProperty(a, s);
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to get.
     * @param {string} def - The default value to return in case the property is not known.
     * @returns {string} The current value, or provided default, of the given property.
     */
    getProperty(a, s) {
      return this.privSpeechConfig.getProperty(a);
    }
    /**
     * Sets the proxy configuration.
     * Only relevant in Node.js environments.
     * Added in version 1.4.0.
     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
     * @param proxyPort The port number of the proxy server.
     * @param proxyUserName The user name of the proxy server.
     * @param proxyPassword The password of the proxy server.
     */
    setProxy(a, s, n, c) {
      this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyHostName, a), this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyPort, `${s}`), n && this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyUserName, n), c && this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyPassword, c);
    }
    setServiceProperty(a, s, n) {
      this.privSpeechConfig.setServiceProperty(a, s);
    }
    /**
     * Dispose of associated resources.
     * @member DialogServiceConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
  }
  return yt.DialogServiceConfigImpl = o, yt;
}
var gn = {}, Hl;
function WR() {
  if (Hl) return gn;
  Hl = 1, Object.defineProperty(gn, "__esModule", { value: !0 }), gn.BotFrameworkConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ fc(), r = /* @__PURE__ */ I();
  let o = class extends t.DialogServiceConfigImpl {
    /**
     * Creates an instance of BotFrameworkConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates a bot framework configuration instance with the provided subscription information.
     * @member BotFrameworkConfig.fromSubscription
     * @function
     * @public
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromSubscription(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "subscription"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, s), n && c.setProperty(r.PropertyId.Conversation_ApplicationId, n), c;
    }
    /**
     * Creates a bot framework configuration instance for the specified authorization token and region.
     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
     * caller must refresh it by setting the authorizationToken property on the corresponding
     * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
     * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
     * original configuration's authorization token. Create a new configuration instance or set the
     * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
     * further DialogServiceConnectors.
     * @member BotFrameworkConfig.fromAuthorizationToken
     * @function
     * @public
     * @param authorizationToken The authorization token associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromAuthorizationToken(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, s), n && c.setProperty(r.PropertyId.Conversation_ApplicationId, n), c;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-default service host. The standard resource path will be
     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
     * property on the created BotFrameworkConfig instance.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromHost
     * @function
     * @public
     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
     * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
     * wss://{host}.convai.speech.azure.us.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromHost(a, s, n) {
      e.Contracts.throwIfNullOrUndefined(a, "host");
      const c = a instanceof URL ? a : new URL(`wss://${a}.convai.speech.azure.us`);
      e.Contracts.throwIfNullOrUndefined(c, "resolvedHost");
      const u = new t.DialogServiceConfigImpl();
      return u.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), u.setProperty(r.PropertyId.SpeechServiceConnection_Host, c.toString()), s !== void 0 && u.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), u;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
     * use the authorization token.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
     */
    static fromEndpoint(a, s) {
      e.Contracts.throwIfNull(a, "endpoint");
      const n = new t.DialogServiceConfigImpl();
      return n.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), n.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, a.toString()), s !== void 0 && n.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), n;
    }
  };
  return gn.BotFrameworkConfig = o, gn;
}
var mn = {}, Kl;
function HR() {
  if (Kl) return mn;
  Kl = 1, Object.defineProperty(mn, "__esModule", { value: !0 }), mn.CustomCommandsConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ fc(), r = /* @__PURE__ */ I();
  let o = class extends t.DialogServiceConfigImpl {
    /**
     * Creates an instance of CustomCommandsConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates an instance of the bot framework config with the specified subscription and region.
     * @member CustomCommandsConfig.fromSubscription
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new bot framework config.
     */
    static fromSubscription(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "applicationId"), e.Contracts.throwIfNullOrWhitespace(s, "subscription"), e.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(r.PropertyId.Conversation_ApplicationId, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member CustomCommandsConfig.fromAuthorizationToken
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param authorizationToken The authorization token associated with the application.
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new speech commands config.
     */
    static fromAuthorizationToken(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "applicationId"), e.Contracts.throwIfNullOrWhitespace(s, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(r.PropertyId.Conversation_ApplicationId, a), c.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    set applicationId(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.setProperty(r.PropertyId.Conversation_ApplicationId, a);
    }
    /**
     * Gets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to get.
     */
    get applicationId() {
      return this.getProperty(r.PropertyId.Conversation_ApplicationId);
    }
  };
  return mn.CustomCommandsConfig = o, mn;
}
var yn = {}, Sn = {}, Cn = {}, Rn = {}, Jl;
function tt() {
  if (Jl) return Rn;
  Jl = 1, Object.defineProperty(Rn, "__esModule", { value: !0 }), Rn.QueryParameterNames = void 0;
  let e = class {
  };
  return Rn.QueryParameterNames = e, e.BotId = "botid", e.CustomSpeechDeploymentId = "cid", e.CustomVoiceDeploymentId = "deploymentId", e.EnableAudioLogging = "storeAudio", e.EnableLanguageId = "lidEnabled", e.EnableWordLevelTimestamps = "wordLevelTimestamps", e.EndSilenceTimeoutMs = "endSilenceTimeoutMs", e.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs", e.SegmentationMaximumTimeMs = "segmentationMaximumTimeMs", e.SegmentationStrategy = "segmentationStrategy", e.Format = "format", e.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs", e.Language = "language", e.Profanity = "profanity", e.RequestBotStatusMessages = "enableBotMessageStatus", e.StableIntermediateThreshold = "stableIntermediateThreshold", e.StableTranslation = "stableTranslation", e.TestHooks = "testhooks", e.Postprocessing = "postprocessing", e.CtsMeetingId = "meetingId", e.CtsDeviceId = "deviceId", e.CtsIsParticipant = "isParticipant", e.EnableAvatar = "enableTalkingAvatar", Rn;
}
var Gl;
function ke() {
  if (Gl) return Cn;
  Gl = 1, Object.defineProperty(Cn, "__esModule", { value: !0 }), Cn.ConnectionFactoryBase = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ tt();
  let i = class {
    static getHostSuffix(s) {
      if (s) {
        if (s.toLowerCase().startsWith("china"))
          return ".azure.cn";
        if (s.toLowerCase().startsWith("usgov"))
          return ".azure.us";
      }
      return ".microsoft.com";
    }
    setCommonUrlParams(s, n, c) {
      (/* @__PURE__ */ new Map([
        [r.PropertyId.Speech_SegmentationSilenceTimeoutMs, o.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceConnection_EnableAudioLogging, o.QueryParameterNames.EnableAudioLogging],
        [r.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, o.QueryParameterNames.EndSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, o.QueryParameterNames.InitialSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceResponse_PostProcessingOption, o.QueryParameterNames.Postprocessing],
        [r.PropertyId.SpeechServiceResponse_ProfanityOption, o.QueryParameterNames.Profanity],
        [r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, o.QueryParameterNames.EnableWordLevelTimestamps],
        [r.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, o.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((p, h) => {
        this.setUrlParameter(h, p, s, n, c);
      });
      const l = JSON.parse(s.parameters.getProperty(e.ServicePropertiesPropertyName, "{}"));
      Object.keys(l).forEach((p) => {
        n[p] = l[p];
      });
    }
    setUrlParameter(s, n, c, u, l) {
      const p = c.parameters.getProperty(s, void 0);
      p && (!l || l.search(n) === -1) && (u[n] = p.toLocaleLowerCase());
    }
    static async getRedirectUrlFromEndpoint(s) {
      let n;
      if (typeof window < "u" && typeof window.fetch < "u") {
        const c = new URL(s);
        c.protocol = "https:", c.port = "443", c.searchParams.append("GenerateRedirectResponse", "true");
        const l = c.toString();
        t.Events.instance.onEvent(new t.ConnectionRedirectEvent("", l, void 0, "ConnectionFactoryBase: redirectUrl request"));
        const p = await fetch(l);
        if (p.status !== 200)
          return s;
        n = await p.text();
      } else
        n = s;
      t.Events.instance.onEvent(new t.ConnectionRedirectEvent("", n, s, "ConnectionFactoryBase: redirectUrlString"));
      try {
        return new URL(n.trim()).toString();
      } catch {
        return s;
      }
    }
  };
  return Cn.ConnectionFactoryBase = i, Cn;
}
var Ql;
function KR() {
  if (Ql) return Sn;
  Ql = 1, Object.defineProperty(Sn, "__esModule", { value: !0 }), Sn.DialogConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ ke(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ le(), s = /* @__PURE__ */ tt();
  class n extends o.ConnectionFactoryBase {
    create(u, l, p) {
      const h = u.parameters.getProperty(r.PropertyId.Conversation_ApplicationId, ""), d = u.parameters.getProperty(r.PropertyId.Conversation_DialogType), f = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region), g = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), m = u.parameters.getProperty(r.PropertyId.Conversation_Request_Bot_Status_Messages, "true"), v = {};
      v[a.HeaderNames.ConnectionId] = p, v[s.QueryParameterNames.Format] = u.parameters.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase(), v[s.QueryParameterNames.Language] = g, v[s.QueryParameterNames.RequestBotStatusMessages] = m, h && (v[s.QueryParameterNames.BotId] = h, d === r.DialogServiceConfig.DialogTypes.CustomCommands && (v[a.HeaderNames.CustomCommandsAppId] = h));
      const y = d === r.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "", S = d === r.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : d === r.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0", C = {};
      l.token != null && l.token !== "" && (C[l.headerName] = l.token);
      let P = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, "");
      if (!P) {
        const A = o.ConnectionFactoryBase.getHostSuffix(f), E = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, `wss://${f}.${n.BaseUrl}${A}`);
        P = `${E.endsWith("/") ? E : E + "/"}${y}${n.ApiKey}/${S}`;
      }
      this.setCommonUrlParams(u, v, P);
      const b = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(P, v, C, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), b, p));
    }
  }
  return Sn.DialogConnectionFactory = n, n.ApiKey = "api", n.BaseUrl = "convai.speech", Sn;
}
var Yl;
function JR() {
  if (Yl) return yn;
  Yl = 1, Object.defineProperty(yn, "__esModule", { value: !0 }), yn.DialogServiceConnector = void 0;
  const e = /* @__PURE__ */ KR(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ we(), o = /* @__PURE__ */ M(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ I(), s = /* @__PURE__ */ hc();
  let n = class extends a.Recognizer {
    /**
     * Initializes an instance of the DialogServiceConnector.
     * @constructor
     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     */
    constructor(u, l) {
      const p = u;
      i.Contracts.throwIfNull(u, "dialogConfig"), super(l, p.properties, new e.DialogConnectionFactory()), this.isTurnComplete = !0, this.privIsDisposed = !1, this.privProperties = p.properties.clone();
      const h = this.buildAgentConfig();
      this.privReco.agentConfig.set(h);
    }
    /**
     * Starts a connection to the service.
     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     * @member DialogServiceConnector.prototype.connect
     * @function
     * @public
     */
    connect(u, l) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.connect(), u, l);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
     *
     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
     */
    disconnect(u, l) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.disconnect(), u, l);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Sets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(u) {
      i.Contracts.throwIfNullOrWhitespace(u, "token"), this.properties.setProperty(s.PropertyId.SpeechServiceAuthorization_Token, u);
    }
    /**
     * The collection of properties and their values defined for this DialogServiceConnector.
     * @member DialogServiceConnector.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
     */
    get properties() {
      return this.privProperties;
    }
    /** Gets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be empty
     */
    get speechActivityTemplate() {
      return this.properties.getProperty(s.PropertyId.Conversation_Speech_Activity_Template);
    }
    /** Sets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be null or empty.
     * Note: it has to be a valid Json object.
     */
    set speechActivityTemplate(u) {
      this.properties.setProperty(s.PropertyId.Conversation_Speech_Activity_Template, u);
    }
    /**
     * Starts recognition and stops after the first utterance is recognized.
     * @member DialogServiceConnector.prototype.listenOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the reco has completed.
     * @param err - Callback invoked in case of an error.
     */
    listenOnceAsync(u, l) {
      if (this.isTurnComplete) {
        i.Contracts.throwIfDisposed(this.privIsDisposed);
        const h = (async () => {
          await this.privReco.connect(), await this.implRecognizerStop(), this.isTurnComplete = !1;
          const d = new o.Deferred();
          await this.privReco.recognize(r.RecognitionMode.Conversation, d.resolve, d.reject);
          const f = await d.promise;
          return await this.implRecognizerStop(), f;
        })();
        h.catch(() => {
          this.dispose(!0).catch(() => {
          });
        }), (0, o.marshalPromiseToCallbacks)(h.finally(() => {
          this.isTurnComplete = !0;
        }), u, l);
      }
    }
    sendActivityAsync(u, l, p) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.sendMessage(u), l, p);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member DialogServiceConnector.prototype.close
     * @function
     * @public
     */
    close(u, l) {
      i.Contracts.throwIfDisposed(this.privIsDisposed), (0, o.marshalPromiseToCallbacks)(this.dispose(!0), u, l);
    }
    async dispose(u) {
      this.privIsDisposed || u && (this.privIsDisposed = !0, await this.implRecognizerStop(), await super.dispose(u));
    }
    createRecognizerConfig(u) {
      return new t.RecognizerConfig(u, this.privProperties);
    }
    createServiceRecognizer(u, l, p, h) {
      const d = p;
      return new t.DialogServiceAdapter(u, l, d, h, this);
    }
    buildAgentConfig() {
      return {
        botInfo: {
          commType: this.properties.getProperty("Conversation_Communication_Type", "Default"),
          commandsCulture: void 0,
          connectionId: this.properties.getProperty(s.PropertyId.Conversation_Agent_Connection_Id),
          conversationId: this.properties.getProperty(s.PropertyId.Conversation_Conversation_Id, void 0),
          fromId: this.properties.getProperty(s.PropertyId.Conversation_From_Id, void 0),
          ttsAudioFormat: this.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)
        },
        version: 0.2
      };
    }
  };
  return yn.DialogServiceConnector = n, yn;
}
var Pn = {}, Zl;
function GR() {
  if (Zl) return Pn;
  Zl = 1, Object.defineProperty(Pn, "__esModule", { value: !0 }), Pn.ActivityReceivedEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {any} activity - The activity..
     */
    constructor(r, o) {
      this.privActivity = r, this.privAudioStream = o;
    }
    /**
     * Gets the received activity
     * @member ActivityReceivedEventArgs.prototype.activity
     * @function
     * @public
     * @returns {any} the received activity.
     */
    get activity() {
      return this.privActivity;
    }
    get audioStream() {
      return this.privAudioStream;
    }
  };
  return Pn.ActivityReceivedEventArgs = e, Pn;
}
var wn = {}, bn = {}, Xl;
function QR() {
  if (Xl) return bn;
  Xl = 1, Object.defineProperty(bn, "__esModule", { value: !0 }), bn.TurnStatusResponsePayload = void 0;
  class e {
    constructor(r) {
      this.privMessageStatusResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new e(r);
    }
    get interactionId() {
      return this.privMessageStatusResponse.interactionId;
    }
    get conversationId() {
      return this.privMessageStatusResponse.conversationId;
    }
    get statusCode() {
      switch (this.privMessageStatusResponse.statusCode) {
        case "Success":
          return 200;
        case "Failed":
          return 400;
        case "TimedOut":
          return 429;
        default:
          return this.privMessageStatusResponse.statusCode;
      }
    }
  }
  return bn.TurnStatusResponsePayload = e, bn;
}
var ep;
function YR() {
  if (ep) return wn;
  ep = 1, Object.defineProperty(wn, "__esModule", { value: !0 }), wn.TurnStatusReceivedEventArgs = void 0;
  const e = /* @__PURE__ */ QR();
  let t = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} turnStatus - The JSON-encoded turn status message.
     */
    constructor(o) {
      this.privTurnStatus = e.TurnStatusResponsePayload.fromJSON(o);
    }
    /**
     * Gets the interaction identifier associated with this turn status event.
     * @member TurnStatusReceivedEventArgs.prototype.interactionId
     * @function
     * @public
     * @returns {any} the received interaction id.
     */
    get interactionId() {
      return this.privTurnStatus.interactionId;
    }
    /**
     * Gets the conversation identifier associated with this turn status event.
     * @member TurnStatusReceivedEventArgs.prototype.conversationId
     * @function
     * @public
     * @returns {any} the received conversation id.
     */
    get conversationId() {
      return this.privTurnStatus.conversationId;
    }
    /**
     * Gets the received turn status code.
     * @member TurnStatusReceivedEventArgs.prototype.statusCode
     * @function
     * @public
     * @returns {number} the received turn status.
     */
    get statusCode() {
      return this.privTurnStatus.statusCode;
    }
  };
  return wn.TurnStatusReceivedEventArgs = t, wn;
}
var Zo = {}, tp;
function ZR() {
  return tp || (tp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ServicePropertyChannel = void 0, function(t) {
      t[t.UriQueryParameter = 0] = "UriQueryParameter";
    }(e.ServicePropertyChannel || (e.ServicePropertyChannel = {}));
  }(Zo)), Zo;
}
var Xo = {}, rp;
function XR() {
  return rp || (rp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ProfanityOption = void 0, function(t) {
      t[t.Masked = 0] = "Masked", t[t.Removed = 1] = "Removed", t[t.Raw = 2] = "Raw";
    }(e.ProfanityOption || (e.ProfanityOption = {}));
  }(Xo)), Xo;
}
var En = {}, np;
function eP() {
  if (np) return En;
  np = 1, Object.defineProperty(En, "__esModule", { value: !0 }), En.BaseAudioPlayer = void 0;
  const e = /* @__PURE__ */ xe(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ zt();
  let o = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
     */
    constructor(a) {
      this.audioContext = null, this.gainNode = null, this.autoUpdateBufferTimer = 0, a === void 0 && (a = t.AudioStreamFormat.getDefaultInputFormat()), this.init(a);
    }
    /**
     * play Audio sample
     * @param newAudioData audio data to be played.
     */
    playAudioSample(a, s, n) {
      try {
        this.ensureInitializedContext();
        const c = this.formatAudioData(a), u = new Float32Array(this.samples.length + c.length);
        u.set(this.samples, 0), u.set(c, this.samples.length), this.samples = u, s && s();
      } catch (c) {
        n && n(c);
      }
    }
    /**
     * stops audio and clears the buffers
     */
    stopAudio(a, s) {
      this.audioContext !== null && (this.samples = new Float32Array(), clearInterval(this.autoUpdateBufferTimer), this.audioContext.close().then(() => {
        a && a();
      }, (n) => {
        s && s(n);
      }), this.audioContext = null);
    }
    init(a) {
      this.audioFormat = a, this.samples = new Float32Array();
    }
    ensureInitializedContext() {
      if (this.audioContext === null) {
        this.createAudioContext();
        const a = 200;
        this.autoUpdateBufferTimer = setInterval(() => {
          this.updateAudioBuffer();
        }, a);
      }
    }
    createAudioContext() {
      this.audioContext = r.AudioStreamFormatImpl.getAudioContext(), this.gainNode = this.audioContext.createGain(), this.gainNode.gain.value = 1, this.gainNode.connect(this.audioContext.destination), this.startTime = this.audioContext.currentTime;
    }
    formatAudioData(a) {
      switch (this.audioFormat.bitsPerSample) {
        case 8:
          return this.formatArrayBuffer(new Int8Array(a), 128);
        case 16:
          return this.formatArrayBuffer(new Int16Array(a), 32768);
        case 32:
          return this.formatArrayBuffer(new Int32Array(a), 2147483648);
        default:
          throw new e.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
      }
    }
    formatArrayBuffer(a, s) {
      const n = new Float32Array(a.length);
      for (let c = 0; c < a.length; c++)
        n[c] = a[c] / s;
      return n;
    }
    updateAudioBuffer() {
      if (this.samples.length === 0)
        return;
      const a = this.audioFormat.channels, s = this.audioContext.createBufferSource(), n = this.samples.length / a, c = this.audioContext.createBuffer(a, n, this.audioFormat.samplesPerSec);
      for (let u = 0; u < a; u++) {
        let l = u;
        const p = c.getChannelData(u);
        for (let h = 0; h < this.samples.length; h++, l += a)
          p[h] = this.samples[l];
      }
      this.startTime < this.audioContext.currentTime && (this.startTime = this.audioContext.currentTime), s.buffer = c, s.connect(this.gainNode), s.start(this.startTime), this.startTime += c.duration, this.samples = new Float32Array();
    }
    async playAudio(a) {
      this.audioContext === null && this.createAudioContext();
      const s = this.audioContext.createBufferSource(), n = this.audioContext.destination;
      await this.audioContext.decodeAudioData(a, (c) => {
        s.buffer = c, s.connect(n), s.start(0);
      });
    }
  };
  return En.BaseAudioPlayer = o, En;
}
var In = {}, ip;
function tP() {
  if (ip) return In;
  ip = 1, Object.defineProperty(In, "__esModule", { value: !0 }), In.ConnectionMessageEventArgs = void 0;
  let e = class {
    constructor(r) {
      this.privConnectionMessage = r;
    }
    /**
     * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
     */
    get message() {
      return this.privConnectionMessage;
    }
    /**
     * Returns a string that represents the connection message event.
     */
    toString() {
      return "Message: " + this.privConnectionMessage.toString();
    }
  };
  return In.ConnectionMessageEventArgs = e, In;
}
var An = {}, sp;
function rP() {
  if (sp) return An;
  sp = 1, Object.defineProperty(An, "__esModule", { value: !0 }), An.VoiceProfile = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} profileId - profileId of this Voice Profile.
     * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
     */
    constructor(r, o) {
      this.privId = r, this.privProfileType = o;
    }
    /**
     * profileId of this Voice Profile instance
     * @member VoiceProfile.prototype.profileId
     * @function
     * @public
     * @returns {string} profileId of this Voice Profile instance.
     */
    get profileId() {
      return this.privId;
    }
    /**
     * profileType of this Voice Profile instance
     * @member VoiceProfile.prototype.profileType
     * @function
     * @public
     * @returns {VoiceProfileType} profile type of this Voice Profile instance.
     */
    get profileType() {
      return this.privProfileType;
    }
  };
  return An.VoiceProfile = e, An;
}
var St = {}, op;
function nP() {
  if (op) return St;
  op = 1, Object.defineProperty(St, "__esModule", { value: !0 }), St.VoiceProfileEnrollmentCancellationDetails = St.VoiceProfileEnrollmentResult = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ I();
  let r = class Ga {
    constructor(a, s, n) {
      this.privReason = a, this.privProperties = new t.PropertyCollection(), this.privReason !== t.ResultReason.Canceled ? s && (this.privDetails = JSON.parse(s), this.privDetails.enrollmentStatus.toLowerCase() === "enrolling" && (this.privReason = t.ResultReason.EnrollingVoiceProfile)) : (this.privErrorDetails = n, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[t.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get enrollmentsCount() {
      return this.privDetails.enrollmentsCount;
    }
    get enrollmentsLength() {
      return this.privDetails.enrollmentsLength;
    }
    get properties() {
      return this.privProperties;
    }
    get enrollmentResultDetails() {
      return this.privDetails;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
    static FromIdentificationProfileList(a) {
      const s = [];
      for (const n of a.value) {
        const c = n.enrollmentStatus.toLowerCase() === "enrolling" ? t.ResultReason.EnrollingVoiceProfile : n.enrollmentStatus.toLowerCase() === "enrolled" ? t.ResultReason.EnrolledVoiceProfile : t.ResultReason.Canceled, u = new Ga(c, null, null);
        u.privDetails = this.getIdentificationDetails(n), s.push(u);
      }
      return s;
    }
    static FromVerificationProfileList(a) {
      const s = [];
      for (const n of a.value) {
        const c = n.enrollmentStatus.toLowerCase() === "enrolling" ? t.ResultReason.EnrollingVoiceProfile : n.enrollmentStatus.toLowerCase() === "enrolled" ? t.ResultReason.EnrolledVoiceProfile : t.ResultReason.Canceled, u = new Ga(c, null, null);
        u.privDetails = this.getVerificationDetails(n), s.push(u);
      }
      return s;
    }
    static getIdentificationDetails(a) {
      return {
        audioLength: a.audioLength ? parseFloat(a.audioLength) : 0,
        audioSpeechLength: a.audioSpeechLength ? parseFloat(a.audioSpeechLength) : 0,
        enrollmentStatus: a.enrollmentStatus,
        enrollmentsCount: a.enrollmentsCount || 0,
        enrollmentsLength: a.enrollmentsLength ? parseFloat(a.enrollmentsLength) : 0,
        enrollmentsSpeechLength: a.enrollmentsSpeechLength ? parseFloat(a.enrollmentsSpeechLength) : 0,
        profileId: a.profileId || a.identificationProfileId,
        remainingEnrollmentsSpeechLength: a.remainingEnrollmentsSpeechLength ? parseFloat(a.remainingEnrollmentsSpeechLength) : 0
      };
    }
    static getVerificationDetails(a) {
      return {
        audioLength: a.audioLength ? parseFloat(a.audioLength) : 0,
        audioSpeechLength: a.audioSpeechLength ? parseFloat(a.audioSpeechLength) : 0,
        enrollmentStatus: a.enrollmentStatus,
        enrollmentsCount: a.enrollmentsCount,
        enrollmentsLength: a.enrollmentsLength ? parseFloat(a.enrollmentsLength) : 0,
        enrollmentsSpeechLength: a.enrollmentsSpeechLength ? parseFloat(a.enrollmentsSpeechLength) : 0,
        profileId: a.profileId || a.verificationProfileId,
        remainingEnrollmentsCount: a.remainingEnrollments || a.remainingEnrollmentsCount,
        remainingEnrollmentsSpeechLength: a.remainingEnrollmentsSpeechLength ? parseFloat(a.remainingEnrollmentsSpeechLength) : 0
      };
    }
  };
  St.VoiceProfileEnrollmentResult = r;
  class o extends t.CancellationDetailsBase {
    constructor(a, s, n) {
      super(a, s, n);
    }
    /**
     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
     * @member VoiceProfileEnrollmentCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      const s = t.CancellationReason.Error;
      let n = t.CancellationErrorCode.NoError;
      return a.properties && (n = t.CancellationErrorCode[a.properties.getProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[t.CancellationErrorCode.NoError])]), new o(s, a.errorDetails, n);
    }
  }
  return St.VoiceProfileEnrollmentCancellationDetails = o, St;
}
var Ct = {}, ap;
function iP() {
  if (ap) return Ct;
  ap = 1, Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.VoiceProfileCancellationDetails = Ct.VoiceProfileResult = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I();
  let o = class {
    constructor(s, n) {
      this.privReason = s, this.privProperties = new r.PropertyCollection(), s === r.ResultReason.Canceled && (t.Contracts.throwIfNullOrUndefined(n, "statusText"), this.privErrorDetails = n, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get properties() {
      return this.privProperties;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  Ct.VoiceProfileResult = o;
  class i extends r.CancellationDetailsBase {
    constructor(s, n, c) {
      super(s, n, c);
    }
    /**
     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
     * @member VoiceProfileCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileResult} result - The result that was canceled.
     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
     */
    static fromResult(s) {
      const n = r.CancellationReason.Error;
      let c = r.CancellationErrorCode.NoError;
      return s.properties && (c = r.CancellationErrorCode[s.properties.getProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new i(n, s.errorDetails, c);
    }
  }
  return Ct.VoiceProfileCancellationDetails = i, Ct;
}
var Tn = {}, cp;
function sP() {
  if (cp) return Tn;
  cp = 1, Object.defineProperty(Tn, "__esModule", { value: !0 }), Tn.VoiceProfilePhraseResult = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class extends t.VoiceProfileResult {
    constructor(i, a, s, n) {
      super(i, a), this.privPhrases = [], e.Contracts.throwIfNullOrUndefined(n, "phrase array"), this.privType = s, n && n[0] && (this.privPhrases = n);
    }
    get phrases() {
      return this.privPhrases;
    }
    get type() {
      return this.privType;
    }
  };
  return Tn.VoiceProfilePhraseResult = r, Tn;
}
var _n = {}, up;
function oP() {
  if (up) return _n;
  up = 1, Object.defineProperty(_n, "__esModule", { value: !0 }), _n.VoiceProfileClient = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ yv(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class extends o.Recognizer {
    /**
     * VoiceProfileClient constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
     */
    constructor(s) {
      r.Contracts.throwIfNullOrUndefined(s, "speechConfig");
      const n = s;
      r.Contracts.throwIfNull(n, "speechConfig"), super(t.AudioConfig.fromStreamInput(o.AudioInputStream.createPushStream()), n.properties, new e.VoiceProfileConnectionFactory()), this.privProperties = n.properties.clone(), this.privVoiceAdapter = this.privReco, this.privDisposedVoiceAdapter = !1;
    }
    /**
     * The collection of properties and their values defined for this VoiceProfileClient.
     * @member VoiceProfileClient.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(s) {
      r.Contracts.throwIfNullOrWhitespace(s, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.createProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Type of Voice Profile to be created
     * @param {string} lang Language string (locale) for Voice Profile
     * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
     */
    async createProfileAsync(s, n) {
      const c = await this.privVoiceAdapter.createProfile(s, n);
      return new o.VoiceProfile(c[0], s);
    }
    /**
     * Get current information of a voice profile
     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to retrieve info for
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async retrieveEnrollmentResultAsync(s) {
      return this.privVoiceAdapter.retrieveEnrollmentResult(s);
    }
    /**
     * Get all voice profiles on account with given voice profile type
     * @member VoiceProfileClient.prototype.getAllProfilesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
     * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
     */
    async getAllProfilesAsync(s) {
      return this.privVoiceAdapter.getAllProfiles(s);
    }
    /**
     * Get valid authorization phrases for voice profile enrollment
     * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
     * @param {string} lang Language string (locale) for Voice Profile
     */
    async getActivationPhrasesAsync(s, n) {
      return this.privVoiceAdapter.getActivationPhrases(s, n);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.enrollProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to create enrollment for
     * @param {AudioConfig} audioConfig source info from which to create enrollment
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async enrollProfileAsync(s, n) {
      const c = n;
      return r.Contracts.throwIfNullOrUndefined(c, "audioConfig"), this.audioConfig = n, this.privVoiceAdapter.SpeakerAudioSource = c, this.privVoiceAdapter.enrollProfile(s);
    }
    /**
     * Delete a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.deleteProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be deleted
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async deleteProfileAsync(s) {
      return this.privVoiceAdapter.deleteProfile(s);
    }
    /**
     * Remove all enrollments for a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.resetProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be reset
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async resetProfileAsync(s) {
      return this.privVoiceAdapter.resetProfile(s);
    }
    /**
     * Clean up object and close underlying connection
     * @member VoiceProfileClient.prototype.close
     * @function
     * @async
     * @public
     */
    async close() {
      await this.dispose(!0);
    }
    createServiceRecognizer(s, n, c, u) {
      const l = c;
      return new e.VoiceServiceRecognizer(s, n, l, u, this);
    }
    async dispose(s) {
      this.privDisposedVoiceAdapter || (this.privDisposedVoiceAdapter = !0, s && await super.dispose(s));
    }
    createRecognizerConfig(s) {
      return new e.RecognizerConfig(s, this.properties);
    }
    getResult(s, n) {
      return new o.VoiceProfileResult(s.ok ? n : o.ResultReason.Canceled, s.statusText);
    }
  };
  return _n.VoiceProfileClient = i, _n;
}
var kn = {}, lp;
function aP() {
  if (lp) return kn;
  lp = 1, Object.defineProperty(kn, "__esModule", { value: !0 }), kn.SpeakerRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I();
  let o = class extends r.Recognizer {
    /**
     * Initializes an instance of the SpeakerRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(a, s) {
      t.Contracts.throwIfNullOrUndefined(a, "speechConfig");
      const n = a;
      t.Contracts.throwIfNullOrUndefined(n, "speechConfig"), super(s, n.properties, new e.SpeakerRecognitionConnectionFactory()), this.privAudioConfigImpl = s, t.Contracts.throwIfNull(this.privAudioConfigImpl, "audioConfig"), this.privDisposedSpeakerRecognizer = !1, this.privProperties = n.properties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      t.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * The collection of properties and their values defined for this SpeakerRecognizer.
     * @member SpeakerRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Get recognition result for model using given audio
     * @member SpeakerRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @async
     * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
     * @param cb - Callback invoked once result is returned.
     * @param err - Callback invoked in case of an error.
     */
    async recognizeOnceAsync(a) {
      return t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), this.recognizeSpeakerOnceAsyncImpl(a);
    }
    /**
     * Included for compatibility
     * @member SpeakerRecognizer.prototype.close
     * @function
     * @public
     * @async
     */
    async close() {
      t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.dispose(!0);
    }
    async recognizeSpeakerOnceAsyncImpl(a) {
      t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.implRecognizerStop();
      const s = await this.privReco.recognizeSpeaker(a);
      return await this.implRecognizerStop(), s;
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    createRecognizerConfig(a) {
      return new e.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, s, n, c) {
      const u = n;
      return new e.SpeakerServiceRecognizer(a, s, u, c, this);
    }
    async dispose(a) {
      this.privDisposedSpeakerRecognizer || a && (this.privDisposedSpeakerRecognizer = !0, await super.dispose(a));
    }
  };
  return kn.SpeakerRecognizer = o, kn;
}
var On = {}, pp;
function cP() {
  if (pp) return On;
  pp = 1, Object.defineProperty(On, "__esModule", { value: !0 }), On.SpeakerIdentificationModel = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class Mv {
    constructor(i) {
      if (this.privVoiceProfiles = [], this.privProfileIds = [], e.Contracts.throwIfNullOrUndefined(i, "VoiceProfiles"), i.length === 0)
        throw new Error("Empty Voice Profiles array");
      for (const a of i) {
        if (a.profileType !== t.VoiceProfileType.TextIndependentIdentification)
          throw new Error("Identification model can only be created from Identification profile: " + a.profileId);
        this.privVoiceProfiles.push(a), this.privProfileIds.push(a.profileId);
      }
    }
    static fromProfiles(i) {
      return new Mv(i);
    }
    get voiceProfileIds() {
      return this.privProfileIds.join(",");
    }
    get profileIds() {
      return this.privProfileIds;
    }
    get scenario() {
      return "TextIndependentIdentification";
    }
  };
  return On.SpeakerIdentificationModel = r, On;
}
var Mn = {}, dp;
function uP() {
  if (dp) return Mn;
  dp = 1, Object.defineProperty(Mn, "__esModule", { value: !0 }), Mn.SpeakerVerificationModel = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class Dv {
    constructor(i) {
      if (e.Contracts.throwIfNullOrUndefined(i, "VoiceProfile"), i.profileType === t.VoiceProfileType.TextIndependentIdentification)
        throw new Error("Verification model cannot be created from Identification profile");
      this.privVoiceProfile = i;
    }
    static fromProfile(i) {
      return new Dv(i);
    }
    get voiceProfile() {
      return this.privVoiceProfile;
    }
    get profileIds() {
      return [this.voiceProfile.profileId];
    }
    get scenario() {
      return this.voiceProfile.profileType === t.VoiceProfileType.TextDependentVerification ? "TextDependentVerification" : "TextIndependentVerification";
    }
  };
  return Mn.SpeakerVerificationModel = r, Mn;
}
var Dn = {}, ea = {}, hp;
function xv() {
  return hp || (hp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LanguageIdMode = void 0, function(t) {
      t[t.AtStart = 0] = "AtStart", t[t.Continuous = 1] = "Continuous";
    }(e.LanguageIdMode || (e.LanguageIdMode = {}));
  }(ea)), ea;
}
var fp;
function lP() {
  if (fp) return Dn;
  fp = 1, Object.defineProperty(Dn, "__esModule", { value: !0 }), Dn.AutoDetectSourceLanguageConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ xv();
  let i = class zs {
    constructor() {
      this.privProperties = new r.PropertyCollection(), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart"), this.privLanguageIdMode = o.LanguageIdMode.AtStart;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromOpenRange
     * @function
     * @public
     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
     */
    static fromOpenRange() {
      const s = new zs();
      return s.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, e.AutoDetectSourceLanguagesOpenRangeOptionName), s.properties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), s;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromLanguages
     * @function
     * @public
     * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
     */
    static fromLanguages(s) {
      t.Contracts.throwIfArrayEmptyOrWhitespace(s, "languages");
      const n = new zs();
      return n.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, s.join()), n;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
     * @function
     * @public
     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
     */
    static fromSourceLanguageConfigs(s) {
      if (s.length < 1)
        throw new Error("Expected non-empty SourceLanguageConfig array.");
      const n = new zs(), c = [];
      return s.forEach((u) => {
        if (c.push(u.language), u.endpointId !== void 0 && u.endpointId !== "") {
          const l = u.language + r.PropertyId.SpeechServiceConnection_EndpointId.toString();
          n.properties.setProperty(l, u.endpointId);
        }
      }), n.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, c.join()), n;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets an auto detected language config properties
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.mode
     * @function
     * @public
     * @param {LanguageIdMode} mode LID mode desired.
     * @summary Sets LID operation to desired mode
     */
    set mode(s) {
      s === o.LanguageIdMode.Continuous ? (this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous")) : (this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart")), this.privLanguageIdMode = s;
    }
  };
  return Dn.AutoDetectSourceLanguageConfig = i, Dn;
}
var xn = {}, vp;
function pP() {
  if (vp) return xn;
  vp = 1, Object.defineProperty(xn, "__esModule", { value: !0 }), xn.AutoDetectSourceLanguageResult = void 0;
  const e = /* @__PURE__ */ z();
  let t = class Qa {
    constructor(o, i) {
      e.Contracts.throwIfNullOrUndefined(o, "language"), e.Contracts.throwIfNullOrUndefined(i, "languageDetectionConfidence"), this.privLanguage = o, this.privLanguageDetectionConfidence = i;
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
     * @member AutoDetectSourceLanguageResult.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult} result - The recognition result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */
    static fromResult(o) {
      return new Qa(o.language, o.languageDetectionConfidence);
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
     * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
     * @function
     * @public
     * @param {ConversationTranscriptionResult} result - The transcription result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */
    static fromConversationTranscriptionResult(o) {
      return new Qa(o.language, o.languageDetectionConfidence);
    }
    get language() {
      return this.privLanguage;
    }
    get languageDetectionConfidence() {
      return this.privLanguageDetectionConfidence;
    }
  };
  return xn.AutoDetectSourceLanguageResult = t, xn;
}
var Nn = {}, gp;
function dP() {
  if (gp) return Nn;
  gp = 1, Object.defineProperty(Nn, "__esModule", { value: !0 }), Nn.SourceLanguageConfig = void 0;
  const e = /* @__PURE__ */ z();
  let t = class Nv {
    constructor(o, i) {
      e.Contracts.throwIfNullOrUndefined(o, "language"), this.privLanguage = o, this.privEndpointId = i;
    }
    /**
     * @member SourceLanguageConfig.fromLanguage
     * @function
     * @public
     * @param {string} language language (eg. "en-US") value of config.
     * @param {string?} endpointId endpointId of model bound to given language of config.
     * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
     * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
     * Added in version 1.13.0.
     */
    static fromLanguage(o, i) {
      return new Nv(o, i);
    }
    get language() {
      return this.privLanguage;
    }
    get endpointId() {
      return this.privEndpointId;
    }
  };
  return Nn.SourceLanguageConfig = t, Nn;
}
var ta = {}, mp;
function hP() {
  return mp || (mp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeakerRecognitionCancellationDetails = e.SpeakerRecognitionResult = e.SpeakerRecognitionResultType = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ I();
    var o;
    (function(s) {
      s[s.Verify = 0] = "Verify", s[s.Identify = 1] = "Identify";
    })(o = e.SpeakerRecognitionResultType || (e.SpeakerRecognitionResultType = {}));
    class i {
      constructor(n, c = r.ResultReason.RecognizedSpeaker, u = r.CancellationErrorCode.NoError, l = "") {
        this.privProperties = new r.PropertyCollection();
        const p = n.scenario === "TextIndependentIdentification" ? o.Identify : o.Verify;
        this.privReason = c, this.privReason !== r.ResultReason.Canceled ? p === o.Identify ? (this.privProfileId = n.identificationResult.identifiedProfile.profileId, this.privScore = n.identificationResult.identifiedProfile.score, this.privReason = r.ResultReason.RecognizedSpeakers) : (this.privScore = n.verificationResult.score, n.verificationResult.recognitionResult.toLowerCase() !== "accept" && (this.privReason = r.ResultReason.NoMatch), n.verificationResult.profileId !== void 0 && n.verificationResult.profileId !== "" && (this.privProfileId = n.verificationResult.profileId)) : (this.privErrorDetails = l, this.privProperties.setProperty(t.CancellationErrorCodePropertyName, r.CancellationErrorCode[u])), this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(n));
      }
      get properties() {
        return this.privProperties;
      }
      get reason() {
        return this.privReason;
      }
      get profileId() {
        return this.privProfileId;
      }
      get errorDetails() {
        return this.privErrorDetails;
      }
      get score() {
        return this.privScore;
      }
    }
    e.SpeakerRecognitionResult = i;
    class a extends r.CancellationDetailsBase {
      constructor(n, c, u) {
        super(n, c, u);
      }
      /**
       * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
       * @member SpeakerRecognitionCancellationDetails.fromResult
       * @function
       * @public
       * @param {SpeakerRecognitionResult} result - The result that was canceled.
       * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
       */
      static fromResult(n) {
        const c = r.CancellationReason.Error;
        let u = r.CancellationErrorCode.NoError;
        return n.properties && (u = r.CancellationErrorCode[n.properties.getProperty(t.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new a(c, n.errorDetails, u);
      }
    }
    e.SpeakerRecognitionCancellationDetails = a;
  }(ta)), ta;
}
var ra = {}, Rt = {}, yp;
function zv() {
  if (yp) return Rt;
  yp = 1, Object.defineProperty(Rt, "__esModule", { value: !0 }), Rt.ConversationImpl = Rt.Conversation = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class {
    constructor() {
    }
    /**
     * Create a conversation
     * @param speechConfig
     * @param cb
     * @param err
     */
    static createConversationAsync(n, c, u, l) {
      r.Contracts.throwIfNullOrUndefined(n, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), r.Contracts.throwIfNullOrUndefined(n.region, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), !n.subscriptionKey && !n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceAuthorization_Token]) && r.Contracts.throwIfNullOrUndefined(n.subscriptionKey, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      let p, h, d;
      return typeof c == "string" ? (p = new a(n, c), (0, t.marshalPromiseToCallbacks)((async () => {
      })(), u, l)) : (p = new a(n), h = c, d = u, p.createConversationAsync(() => {
        h && h();
      }, (f) => {
        d && d(f);
      })), p;
    }
  };
  Rt.Conversation = i;
  class a extends i {
    /**
     * Create a conversation impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(n, c) {
      if (super(), this.privErrors = e.ConversationConnectionConfig.restErrors, this.onConnected = (p) => {
        this.privIsConnected = !0;
        try {
          this.privConversationTranslator?.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, p);
        } catch {
        }
      }, this.onDisconnected = (p) => {
        try {
          this.privConversationTranslator?.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, p);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (p, h) => {
        try {
          this.privConversationTranslator?.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, h);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.getParticipant(h.id);
          if (d !== void 0) {
            switch (h.key) {
              case e.ConversationTranslatorCommandTypes.changeNickname:
                d.displayName = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setUseTTS:
                d.isUsingTts = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setProfanityFiltering:
                d.profanity = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setMute:
                d.isMuted = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                d.translateToLanguages = h.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(d), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, [this.toParticipant(d)], h.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (p, h) => {
        try {
          this.privParticipants.participants.forEach((d) => d.isMuted = d.isHost ? !1 : h.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, this.toParticipants(!1), h.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.addOrUpdateParticipant(h.participant);
          d !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, [this.toParticipant(d)], h.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.getParticipant(h.participant.id);
          d !== void 0 && (this.privParticipants.deleteParticipant(h.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.LeftConversation, [this.toParticipant(d)], h.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (p, h) => {
        try {
          switch (h.command) {
            case e.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (p, h) => {
        try {
          if (h.sessionToken !== void 0 && h.sessionToken !== null && (this.privRoom.token = h.sessionToken), this.privParticipants.participants = [...h.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), h.sessionId)), this.me.isHost) {
            const d = this.privConversationTranslator?.properties.getProperty(o.PropertyId.ConversationTranslator_Name);
            d !== void 0 && d.length > 0 && d !== this.me.displayName && this.changeNicknameAsync(d);
          }
        } catch {
        }
      }, this.onConversationExpiration = (p, h) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, h);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new o.PropertyCollection(), this.privManager = new e.ConversationManager(), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]) || n.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage], e.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]), c)
        this.privConversationId = c;
      else {
        n.targetLanguages.length === 0 && n.addTargetLanguage(this.privLanguage), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceResponse_ProfanityOption]) || n.setProfanity(o.ProfanityOption.Masked);
        let h = n.getProperty(o.PropertyId[o.PropertyId.ConversationTranslator_Name]);
        h == null && (h = "Host"), r.Contracts.throwIfNullOrTooLong(h, "nickname", 50), r.Contracts.throwIfNullOrTooShort(h, "nickname", 2), n.setProperty(o.PropertyId[o.PropertyId.ConversationTranslator_Name], h);
      }
      this.privConfig = n;
      const l = n;
      r.Contracts.throwIfNull(l, "speechConfig"), this.privProperties = l.properties.clone(), this.privIsConnected = !1, this.privParticipants = new e.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the conversation Id
    get conversationId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      return this.privParticipants.me?.isHost ? !1 : this.privParticipants.me?.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get conversationInfo() {
      const n = this.conversationId, c = this.participants.map((p) => ({
        id: p.id,
        preferredLanguage: p.preferredLanguage,
        voice: p.voice
      })), u = {};
      for (const p of e.ConversationConnectionConfig.transcriptionEventKeys) {
        const h = this.properties.getProperty(p, "");
        h !== "" && (u[p] = h);
      }
      return { id: n, participants: c, conversationProperties: u };
    }
    get canSend() {
      return this.privIsConnected && !this.privParticipants.me?.isMuted;
    }
    get canSendAsHost() {
      return this.privIsConnected && this.privParticipants.me?.isHost;
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "authorizationToken"), this.privToken = n;
    }
    set conversationTranslator(n) {
      this.privConversationTranslator = n;
    }
    onToken(n) {
      this.privConversationTranslator.onToken(n);
    }
    /**
     * Create a new conversation as Host
     * @param cb
     * @param err
     */
    createConversationAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new conversation as host.
     * @param cb
     * @param err
     */
    startConversationAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer = e.ConversationRecognizerFactory.fromConfig(this, this.privConfig), this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a conversation as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(n, c, u) {
      r.Contracts.throwIfNullOrUndefined(n, "Participant"), (0, t.marshalPromiseToCallbacks)(this.addParticipantImplAsync(n), c, u);
    }
    /**
     * Join a conversation as a participant.
     * @param conversation
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinConversationAsync(n, c, u, l, p) {
      try {
        r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), r.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, n, (h) => {
          r.Contracts.throwIfNullOrUndefined(h, this.privErrors.permissionDeniedConnect), this.privRoom = h, this.privConfig.authorizationToken = h.cognitiveSpeechAuthToken, l && l(h.cognitiveSpeechAuthToken);
        }, (h) => {
          this.handleError(h, p);
        });
      } catch (h) {
        this.handleError(h, p);
      }
    }
    /**
     * Deletes a conversation
     * @param cb
     * @param err
     */
    deleteConversationAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.deleteConversationImplAsync(), n, c);
    }
    async deleteConversationImplAsync() {
      r.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), r.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endConversationAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.endConversationImplAsync(), n, c);
    }
    endConversationImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockConversationAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the conversation
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !0), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(n, c, u) {
      try {
        if (r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && n.hasOwnProperty("id"))
          (0, t.marshalPromiseToCallbacks)(this.removeParticipantImplAsync(n), c, u);
        else {
          r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let l = "";
          typeof n == "string" ? l = n : n.hasOwnProperty("id") ? l = n.id : n.hasOwnProperty("userId") && (l = n.userId), r.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((h) => h.id === l) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(l), () => {
            this.handleCallback(c, u);
          }, (h) => {
            this.handleError(h, u);
          });
        }
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to unlock the conversation
     * @param cb
     * @param err
     */
    unlockConversationAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the conversation
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !1), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "message")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), n.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfArrayEmptyOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "languages")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(n) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await n.enforceAudioGating(), this.privTranscriberRecognizer = n, this.privTranscriberRecognizer.conversation = this;
    }
    getKeepAlive() {
      const n = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: n,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(n) {
      if (this.privParticipants.addOrUpdateParticipant(n) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.conversationInfo;
        return u.participants = [n], this.privTranscriberRecognizer.pushConversationEvent(u, "join");
      }
    }
    removeParticipantImplAsync(n) {
      this.privParticipants.deleteParticipant(n.id);
      const c = this.conversationInfo;
      return c.participants = [n], this.privTranscriberRecognizer.pushConversationEvent(c, "leave");
    }
    async close(n) {
      try {
        this.privIsConnected = !1, await this.privConversationRecognizer?.close(), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (c) {
        throw c;
      }
      n && this.dispose();
    }
    /** Helpers */
    handleCallback(n, c) {
      if (n) {
        try {
          n();
        } catch (u) {
          c && c(u);
        }
        n = void 0;
      }
    }
    handleError(n, c) {
      if (c)
        if (n instanceof Error) {
          const u = n;
          c(u.name + ": " + u.message);
        } else
          c(n);
    }
    /** Participant Helpers */
    toParticipants(n) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return n ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(n) {
      return new o.Participant(n.id, n.avatar, n.displayName, n.isHost, n.isMuted, n.isUsingTts, n.preferredLanguage, n.voice);
    }
    getMuteAllCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMuteCommand(n, c) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getEjectCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getChangeNicknameCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "nickname"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.changeNickname,
        nickname: n,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMessageCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), r.Contracts.throwIfNullOrWhitespace(n, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: n,
        type: e.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return Rt.ConversationImpl = a, Rt;
}
var zn = {}, Sp;
function fP() {
  if (Sp) return zn;
  Sp = 1, Object.defineProperty(zn, "__esModule", { value: !0 }), zn.ConversationCommon = void 0;
  let e = class {
    constructor(r) {
      this.privAudioConfig = r;
    }
    handleCallback(r, o) {
      if (r) {
        try {
          r();
        } catch (i) {
          o && o(i);
        }
        r = void 0;
      }
    }
    handleError(r, o) {
      if (o)
        if (r instanceof Error) {
          const i = r;
          o(i.name + ": " + i.message);
        } else
          o(r);
    }
  };
  return zn.ConversationCommon = e, zn;
}
var Ln = {}, Cp;
function vP() {
  if (Cp) return Ln;
  Cp = 1, Object.defineProperty(Ln, "__esModule", { value: !0 }), Ln.ConversationExpirationEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    constructor(o, i) {
      super(i), this.privExpirationTime = o;
    }
    /** How much longer until the conversation expires (in minutes). */
    get expirationTime() {
      return this.privExpirationTime;
    }
  };
  return Ln.ConversationExpirationEventArgs = t, Ln;
}
var jn = {}, Rp;
function gP() {
  if (Rp) return jn;
  Rp = 1, Object.defineProperty(jn, "__esModule", { value: !0 }), jn.ConversationParticipantsChangedEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    constructor(o, i, a) {
      super(a), this.privReason = o, this.privParticipant = i;
    }
    get reason() {
      return this.privReason;
    }
    get participants() {
      return this.privParticipant;
    }
  };
  return jn.ConversationParticipantsChangedEventArgs = t, jn;
}
var qn = {}, Pp;
function mP() {
  if (Pp) return qn;
  Pp = 1, Object.defineProperty(qn, "__esModule", { value: !0 }), qn.ConversationTranslationCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ ws();
  let t = class extends e.CancellationEventArgsBase {
  };
  return qn.ConversationTranslationCanceledEventArgs = t, qn;
}
var Fn = {}, wp;
function yP() {
  if (wp) return Fn;
  wp = 1, Object.defineProperty(Fn, "__esModule", { value: !0 }), Fn.ConversationTranslationEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranslationResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Specifies the recognition result.
     * @returns {ConversationTranslationResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Fn.ConversationTranslationEventArgs = t, Fn;
}
var Bn = {}, bp;
function SP() {
  if (bp) return Bn;
  bp = 1, Object.defineProperty(Bn, "__esModule", { value: !0 }), Bn.ConversationTranslationResult = void 0;
  const e = /* @__PURE__ */ Cv();
  let t = class extends e.TranslationRecognitionResult {
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(i, s, n, c, u, l, void 0, void 0, p, h, d), this.privId = o, this.privOrigLang = a;
    }
    /**
     * The unique identifier for the participant this result is for.
     */
    get participantId() {
      return this.privId;
    }
    /**
     * The original language this result was in.
     */
    get originalLang() {
      return this.privOrigLang;
    }
  };
  return Bn.ConversationTranslationResult = t, Bn;
}
var na = {}, Un = {}, $n = {}, Ep;
function Lv() {
  if (Ep) return $n;
  Ep = 1, Object.defineProperty($n, "__esModule", { value: !0 }), $n.StringUtils = void 0;
  let e = class {
    /**
     * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
     * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
     * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
     * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
     * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
     */
    static formatString(r, o) {
      if (!r)
        return "";
      if (!o)
        return r;
      let i = "", a = "";
      const s = (u) => {
        i += u;
      }, n = (u) => {
        a += u;
      };
      let c = s;
      for (let u = 0; u < r.length; u++) {
        const l = r[u], p = u + 1 < r.length ? r[u + 1] : "";
        switch (l) {
          case "{":
            p === "{" ? (c("{"), u++) : c = n;
            break;
          case "}":
            p === "}" ? (c("}"), u++) : (o.hasOwnProperty(a) && (i += o[a]), c = s, a = "");
            break;
          default:
            c(l);
            break;
        }
      }
      return i;
    }
  };
  return $n.StringUtils = e, $n;
}
var Ip;
function CP() {
  if (Ip) return Un;
  Ip = 1, Object.defineProperty(Un, "__esModule", { value: !0 }), Un.ConversationTranslatorConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ Lv(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ le(), a = /* @__PURE__ */ tt(), s = /* @__PURE__ */ ke(), n = /* @__PURE__ */ _();
  let c = class jv extends s.ConnectionFactoryBase {
    constructor(l) {
      super(), r.Contracts.throwIfNullOrUndefined(l, "convGetter"), this.privConvGetter = l;
    }
    create(l, p, h) {
      const d = l.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE", f = this.privConvGetter().room, g = f.cognitiveSpeechRegion || l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Region, ""), m = {
        hostSuffix: s.ConnectionFactoryBase.getHostSuffix(g),
        path: jv.CTS_VIRT_MIC_PATH,
        region: encodeURIComponent(g)
      };
      m[a.QueryParameterNames.Language] = encodeURIComponent(l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_RecoLanguage, "")), m[a.QueryParameterNames.CtsMeetingId] = encodeURIComponent(f.roomId), m[a.QueryParameterNames.CtsDeviceId] = encodeURIComponent(f.participantId), m[a.QueryParameterNames.CtsIsParticipant] = f.isHost ? "" : "&" + a.QueryParameterNames.CtsIsParticipant;
      let v = "";
      const y = {}, S = {};
      if (d) {
        v = l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Endpoint), v || (v = "wss://" + l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}") + "{path}"), v = t.StringUtils.formatString(v, m);
        const P = new URL(v);
        P.searchParams.forEach((A, E) => {
          y[E] = A;
        }), new n.TranscriberConnectionFactory().setQueryParams(y, l, v), y[a.QueryParameterNames.CtsMeetingId] = m[a.QueryParameterNames.CtsMeetingId], y[a.QueryParameterNames.CtsDeviceId] = m[a.QueryParameterNames.CtsDeviceId], f.isHost || (y[a.QueryParameterNames.CtsIsParticipant] = ""), a.QueryParameterNames.Format in y || (y[a.QueryParameterNames.Format] = "simple"), P.searchParams.forEach((A, E) => {
          P.searchParams.set(E, y[E]), delete y[E];
        }), v = P.toString();
      } else {
        const P = new n.TranslationConnectionFactory();
        v = P.getEndpointUrl(l, !0), v = t.StringUtils.formatString(v, m), P.setQueryParams(y, l, v);
      }
      S[i.HeaderNames.ConnectionId] = h, S[e.RestConfigBase.configParams.token] = f.token, p.token && (S[p.headerName] = p.token);
      const C = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
      return Promise.resolve(new e.WebsocketConnection(v, y, S, new n.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), C, h));
    }
  };
  return Un.ConversationTranslatorConnectionFactory = c, c.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio", Un;
}
var Ap;
function RP() {
  return Ap || (Ap = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConversationTranslator = e.SpeechState = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ CP(), o = /* @__PURE__ */ M(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ I(), s = /* @__PURE__ */ zv(), n = /* @__PURE__ */ vc();
    var c;
    (function(p) {
      p[p.Inactive = 0] = "Inactive", p[p.Connecting = 1] = "Connecting", p[p.Connected = 2] = "Connected";
    })(c = e.SpeechState || (e.SpeechState = {}));
    class u extends a.TranslationRecognizer {
      constructor(h, d, f, g) {
        super(h, d, new r.ConversationTranslatorConnectionFactory(g)), this.privSpeechState = c.Inactive, f && (this.privTranslator = f, this.sessionStarted = () => {
          this.privSpeechState = c.Connected;
        }, this.sessionStopped = () => {
          this.privSpeechState = c.Inactive;
        }, this.recognizing = (m, v) => {
          this.privTranslator.recognizing && this.privTranslator.recognizing(this.privTranslator, v);
        }, this.recognized = async (m, v) => {
          v.result?.errorDetails ? (await this.cancelSpeech(), this.fireCancelEvent(v.result.errorDetails)) : this.privTranslator.recognized && this.privTranslator.recognized(this.privTranslator, v);
        }, this.canceled = async () => {
          if (this.privSpeechState !== c.Inactive)
            try {
              await this.cancelSpeech();
            } catch {
              this.privSpeechState = c.Inactive;
            }
        });
      }
      get state() {
        return this.privSpeechState;
      }
      set state(h) {
        this.privSpeechState = h;
      }
      set authentication(h) {
        this.privReco.authentication = h;
      }
      onConnection() {
        this.privSpeechState = c.Connected;
      }
      async onCancelSpeech() {
        this.privSpeechState = c.Inactive, await this.cancelSpeech();
      }
      /**
       * Fire a cancel event
       * @param error
       */
      fireCancelEvent(h) {
        try {
          if (this.privTranslator.canceled) {
            const d = new n.ConversationTranslationCanceledEventArgs(a.CancellationReason.Error, h, a.CancellationErrorCode.RuntimeError);
            this.privTranslator.canceled(this.privTranslator, d);
          }
        } catch {
        }
      }
      async cancelSpeech() {
        try {
          this.stopContinuousRecognitionAsync(), await this.privReco?.disconnect(), this.privSpeechState = c.Inactive;
        } catch {
        }
      }
    }
    class l extends n.ConversationCommon {
      constructor(h) {
        super(h), this.privErrors = t.ConversationConnectionConfig.restErrors, this.privIsDisposed = !1, this.privIsSpeaking = !1, this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345", this.privPlaceholderRegion = "westus", this.privProperties = new a.PropertyCollection();
      }
      get properties() {
        return this.privProperties;
      }
      get speechRecognitionLanguage() {
        return this.privSpeechRecognitionLanguage;
      }
      get participants() {
        return this.privConversation?.participants;
      }
      get canSpeak() {
        return !(!this.privConversation.isConnected || !this.privCTRecognizer || this.privIsSpeaking || this.privCTRecognizer.state === c.Connected || this.privCTRecognizer.state === c.Connecting || this.privConversation.isMutedByHost);
      }
      onToken(h) {
        this.privCTRecognizer.authentication = h;
      }
      setServiceProperty(h, d) {
        const f = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
        f[h] = d, this.privProperties.setProperty(t.ServicePropertiesPropertyName, JSON.stringify(f));
      }
      joinConversationAsync(h, d, f, g, m) {
        try {
          if (typeof h == "string") {
            i.Contracts.throwIfNullOrUndefined(h, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), i.Contracts.throwIfNullOrWhitespace(d, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privConversation && this.handleError(new Error(this.privErrors.permissionDeniedStart), m);
            let v = f;
            (v == null || v === "") && (v = t.ConversationConnectionConfig.defaultLanguageCode), this.privSpeechTranslationConfig = a.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion), this.privSpeechTranslationConfig.setProfanity(a.ProfanityOption.Masked), this.privSpeechTranslationConfig.addTargetLanguage(v), this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_RecoLanguage], v), this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.ConversationTranslator_Name], d);
            const y = [
              a.PropertyId.SpeechServiceConnection_Host,
              a.PropertyId.ConversationTranslator_Host,
              a.PropertyId.SpeechServiceConnection_Endpoint,
              a.PropertyId.SpeechServiceConnection_ProxyHostName,
              a.PropertyId.SpeechServiceConnection_ProxyPassword,
              a.PropertyId.SpeechServiceConnection_ProxyPort,
              a.PropertyId.SpeechServiceConnection_ProxyUserName,
              "ConversationTranslator_MultiChannelAudio",
              "ConversationTranslator_Region"
            ];
            for (const C of y) {
              const P = this.privProperties.getProperty(C);
              if (P) {
                const b = typeof C == "string" ? C : a.PropertyId[C];
                this.privSpeechTranslationConfig.setProperty(b, P);
              }
            }
            const S = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
            for (const C of Object.keys(S))
              this.privSpeechTranslationConfig.setServiceProperty(C, S[C], a.ServicePropertyChannel.UriQueryParameter);
            this.privConversation = new s.ConversationImpl(this.privSpeechTranslationConfig), this.privConversation.conversationTranslator = this, this.privConversation.joinConversationAsync(h, d, v, (C) => {
              C || this.handleError(new Error(this.privErrors.permissionDeniedConnect), m), this.privSpeechTranslationConfig.authorizationToken = C, this.privConversation.room.isHost = !1, this.privConversation.startConversationAsync(() => {
                this.handleCallback(g, m);
              }, (P) => {
                this.handleError(P, m);
              });
            }, (C) => {
              this.handleError(C, m);
            });
          } else typeof h == "object" ? (i.Contracts.throwIfNullOrUndefined(h, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), i.Contracts.throwIfNullOrWhitespace(d, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privProperties.setProperty(a.PropertyId.ConversationTranslator_Name, d), this.privConversation = h, this.privConversation.conversationTranslator = this, this.privConversation.room.isHost = !0, i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect), i.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privSpeechTranslationConfig = h.config, this.handleCallback(f, g)) : this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), g);
        } catch (v) {
          this.handleError(v, typeof f == "string" ? m : g);
        }
      }
      /**
       * Leave the conversation
       * @param cb
       * @param err
       */
      leaveConversationAsync(h, d) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          await this.cancelSpeech(), await this.privConversation.endConversationImplAsync(), await this.privConversation.deleteConversationImplAsync(), this.dispose();
        })(), h, d);
      }
      /**
       * Send a text message
       * @param message
       * @param cb
       * @param err
       */
      sendTextMessageAsync(h, d, f) {
        try {
          i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), i.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", h)), this.privConversation.sendTextMessageAsync(h, d, f);
        } catch (g) {
          this.handleError(g, f);
        }
      }
      /**
       * Start speaking
       * @param cb
       * @param err
       */
      startTranscribingAsync(h, d) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          try {
            i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), i.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privCTRecognizer === void 0 && await this.connectTranslatorRecognizer(), i.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend), this.canSpeak || this.handleError(new Error(this.privErrors.permissionDeniedSend), d), await this.startContinuousRecognition(), this.privIsSpeaking = !0;
          } catch (f) {
            throw this.privIsSpeaking = !1, await this.cancelSpeech(), f;
          }
        })(), h, d);
      }
      /**
       * Stop speaking
       * @param cb
       * @param err
       */
      stopTranscribingAsync(h, d) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          try {
            if (!this.privIsSpeaking) {
              await this.cancelSpeech();
              return;
            }
            this.privIsSpeaking = !1, await new Promise((f, g) => {
              this.privCTRecognizer.stopContinuousRecognitionAsync(f, g);
            });
          } catch {
            await this.cancelSpeech();
          }
        })(), h, d);
      }
      isDisposed() {
        return this.privIsDisposed;
      }
      dispose(h, d, f) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          this.isDisposed && !this.privIsSpeaking || (await this.cancelSpeech(), this.privIsDisposed = !0, this.privSpeechTranslationConfig.close(), this.privSpeechRecognitionLanguage = void 0, this.privProperties = void 0, this.privAudioConfig = void 0, this.privSpeechTranslationConfig = void 0, this.privConversation.dispose(), this.privConversation = void 0);
        })(), d, f);
      }
      /**
       * Cancel the speech websocket
       */
      async cancelSpeech() {
        try {
          this.privIsSpeaking = !1, await this.privCTRecognizer?.onCancelSpeech(), this.privCTRecognizer = void 0;
        } catch {
        }
      }
      /**
       * Connect to the speech translation recognizer.
       * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
       * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
       * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
       */
      async connectTranslatorRecognizer() {
        try {
          this.privAudioConfig === void 0 && (this.privAudioConfig = a.AudioConfig.fromDefaultMicrophoneInput()), this.privSpeechTranslationConfig.getProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey && this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_Key], "");
          const h = () => this.privConversation;
          this.privCTRecognizer = new u(this.privSpeechTranslationConfig, this.privAudioConfig, this, h);
        } catch (h) {
          throw await this.cancelSpeech(), h;
        }
      }
      /**
       * Handle the start speaking request
       */
      startContinuousRecognition() {
        return new Promise((h, d) => {
          this.privCTRecognizer.startContinuousRecognitionAsync(h, d);
        });
      }
    }
    e.ConversationTranslator = l;
  }(na)), na;
}
var Vn = {}, Tp;
function PP() {
  if (Tp) return Vn;
  Tp = 1, Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.ConversationTranscriber = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ we(), r = /* @__PURE__ */ M(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ I();
  let a = class qv extends i.Recognizer {
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      o.Contracts.throwIfNull(u, "speechConfig"), o.Contracts.throwIfNullOrWhitespace(u.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new e.ConversationTranscriberConnectionFactory(), n.tokenCredential), this.privProperties.setProperty(i.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privDisposedRecognizer = !1;
    }
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(n, c, u) {
      const l = n;
      return c.properties.mergeTo(l.properties), new qv(n, u);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for transcription.
     * @member ConversationTranscriber.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      o.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * Gets the spoken language of transcription.
     * @member ConversationTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of transcription.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of transcription.
     * @member ConversationTranscriber.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of transcription.
     */
    get outputFormat() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(e.OutputFormatPropertyName, i.OutputFormat[i.OutputFormat.Simple]) === i.OutputFormat[i.OutputFormat.Simple] ? i.OutputFormat.Simple : i.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this conversation transcriber.
     * @member ConversationTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts conversation transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member ConversationTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), n, c);
    }
    /**
     * Stops conversation transcription.
     * @member ConversationTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member ConversationTranscriber.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return l.isSpeakerDiarizationEnabled = !0, new e.ConversationTranscriptionServiceRecognizer(n, c, p, l, this);
    }
  };
  return Vn.ConversationTranscriber = a, Vn;
}
var Pt = {}, _p;
function wP() {
  if (_p) return Pt;
  _p = 1, Object.defineProperty(Pt, "__esModule", { value: !0 }), Pt.Participant = Pt.User = void 0;
  const e = /* @__PURE__ */ I();
  class t {
    constructor(i) {
      this.privUserId = i;
    }
    get userId() {
      return this.privUserId;
    }
  }
  Pt.User = t;
  class r {
    constructor(i, a, s, n, c, u, l, p) {
      this.privId = i, this.privAvatar = a, this.privDisplayName = s, this.privIsHost = n, this.privIsMuted = c, this.privIsUsingTts = u, this.privPreferredLanguage = l, this.privVoice = p, this.privProperties = new e.PropertyCollection();
    }
    get avatar() {
      return this.privAvatar;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get id() {
      return this.privId;
    }
    get preferredLanguage() {
      return this.privPreferredLanguage;
    }
    get isHost() {
      return this.privIsHost;
    }
    get isMuted() {
      return this.privIsMuted;
    }
    get isUsingTts() {
      return this.privIsUsingTts;
    }
    get voice() {
      return this.privVoice;
    }
    get properties() {
      return this.privProperties;
    }
    static From(i, a, s) {
      return new r(i, "", i, !1, !1, !1, a, s);
    }
  }
  return Pt.Participant = r, Pt;
}
var ia = {}, kp;
function bP() {
  return kp || (kp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ParticipantChangedReason = void 0, function(t) {
      t[t.JoinedConversation = 0] = "JoinedConversation", t[t.LeftConversation = 1] = "LeftConversation", t[t.Updated = 2] = "Updated";
    }(e.ParticipantChangedReason || (e.ParticipantChangedReason = {}));
  }(ia)), ia;
}
var wt = {}, Op;
function EP() {
  if (Op) return wt;
  Op = 1, Object.defineProperty(wt, "__esModule", { value: !0 }), wt.MeetingImpl = wt.Meeting = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class {
    constructor() {
    }
    /**
     * Create a meeting
     * @param speechConfig
     * @param meetingId
     * @param cb
     * @param err
     */
    static createMeetingAsync(n, c, u, l) {
      if (r.Contracts.throwIfNullOrUndefined(n, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), r.Contracts.throwIfNullOrUndefined(n.region, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), r.Contracts.throwIfNull(c, "meetingId"), c.length === 0)
        throw new Error("meetingId cannot be empty");
      !n.subscriptionKey && !n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceAuthorization_Token]) && r.Contracts.throwIfNullOrUndefined(n.subscriptionKey, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      const p = new a(n, c);
      return (0, t.marshalPromiseToCallbacks)((async () => {
      })(), u, l), p;
    }
  };
  wt.Meeting = i;
  class a extends i {
    /**
     * Create a Meeting impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(n, c) {
      super(), this.privErrors = e.ConversationConnectionConfig.restErrors, this.onConnected = (p) => {
        this.privIsConnected = !0;
        try {
          this.privConversationTranslator?.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, p);
        } catch {
        }
      }, this.onDisconnected = (p) => {
        try {
          this.privConversationTranslator?.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, p);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (p, h) => {
        try {
          this.privConversationTranslator?.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, h);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.getParticipant(h.id);
          if (d !== void 0) {
            switch (h.key) {
              case e.ConversationTranslatorCommandTypes.changeNickname:
                d.displayName = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setUseTTS:
                d.isUsingTts = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setProfanityFiltering:
                d.profanity = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setMute:
                d.isMuted = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                d.translateToLanguages = h.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(d), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, [this.toParticipant(d)], h.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (p, h) => {
        try {
          this.privParticipants.participants.forEach((d) => d.isMuted = d.isHost ? !1 : h.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, this.toParticipants(!1), h.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.addOrUpdateParticipant(h.participant);
          d !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, [this.toParticipant(d)], h.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.getParticipant(h.participant.id);
          d !== void 0 && (this.privParticipants.deleteParticipant(h.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.LeftConversation, [this.toParticipant(d)], h.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (p, h) => {
        try {
          switch (h.command) {
            case e.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (p, h) => {
        try {
          if (h.sessionToken !== void 0 && h.sessionToken !== null && (this.privRoom.token = h.sessionToken), this.privParticipants.participants = [...h.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), h.sessionId)), this.me.isHost) {
            const d = this.privConversationTranslator?.properties.getProperty(o.PropertyId.ConversationTranslator_Name);
            d !== void 0 && d.length > 0 && d !== this.me.displayName && this.changeNicknameAsync(d);
          }
        } catch {
        }
      }, this.onConversationExpiration = (p, h) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, h);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new o.PropertyCollection(), this.privManager = new e.ConversationManager(), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]) || n.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage], e.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]), this.privConversationId = c, this.privConfig = n;
      const l = n;
      r.Contracts.throwIfNull(l, "speechConfig"), this.privProperties = l.properties.clone(), this.privIsConnected = !1, this.privParticipants = new e.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the meeting Id
    get meetingId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      return this.privParticipants.me?.isHost ? !1 : this.privParticipants.me?.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get meetingInfo() {
      const n = this.meetingId, c = this.participants.map((p) => ({
        id: p.id,
        preferredLanguage: p.preferredLanguage,
        voice: p.voice
      })), u = {};
      for (const p of e.ConversationConnectionConfig.transcriptionEventKeys) {
        const h = this.properties.getProperty(p, "");
        h !== "" && (u[p] = h);
      }
      return { id: n, participants: c, meetingProperties: u };
    }
    get canSend() {
      return this.privIsConnected && !this.privParticipants.me?.isMuted;
    }
    get canSendAsHost() {
      return this.privIsConnected && this.privParticipants.me?.isHost;
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "authorizationToken"), this.privToken = n;
    }
    /**
     * Create a new meeting as Host
     * @param cb
     * @param err
     */
    createMeetingAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new meeting as host.
     * @param cb
     * @param err
     */
    startMeetingAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a meeting as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(n, c, u) {
      r.Contracts.throwIfNullOrUndefined(n, "Participant"), (0, t.marshalPromiseToCallbacks)(this.addParticipantImplAsync(n), c, u);
    }
    /**
     * Join a meeting as a participant.
     * @param meeting
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinMeetingAsync(n, c, u, l, p) {
      try {
        r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), r.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, n, (h) => {
          r.Contracts.throwIfNullOrUndefined(h, this.privErrors.permissionDeniedConnect), this.privRoom = h, this.privConfig.authorizationToken = h.cognitiveSpeechAuthToken, l && l(h.cognitiveSpeechAuthToken);
        }, (h) => {
          this.handleError(h, p);
        });
      } catch (h) {
        this.handleError(h, p);
      }
    }
    /**
     * Deletes a meeting
     * @param cb
     * @param err
     */
    deleteMeetingAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.deleteMeetingImplAsync(), n, c);
    }
    async deleteMeetingImplAsync() {
      r.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), r.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endMeetingAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.endMeetingImplAsync(), n, c);
    }
    endMeetingImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockMeetingAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the meeting
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !0), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(n, c, u) {
      try {
        if (r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && n.hasOwnProperty("id"))
          (0, t.marshalPromiseToCallbacks)(this.removeParticipantImplAsync(n), c, u);
        else {
          r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let l = "";
          typeof n == "string" ? l = n : n.hasOwnProperty("id") ? l = n.id : n.hasOwnProperty("userId") && (l = n.userId), r.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((h) => h.id === l) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(l), () => {
            this.handleCallback(c, u);
          }, (h) => {
            this.handleError(h, u);
          });
        }
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to unlock the meeting
     * @param cb
     * @param err
     */
    unlockMeetingAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the meeting
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !1), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "message")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), n.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfArrayEmptyOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "languages")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(n) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await n.enforceAudioGating(), this.privTranscriberRecognizer = n, this.privTranscriberRecognizer.meeting = this;
    }
    getKeepAlive() {
      const n = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: n,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(n) {
      if (this.privParticipants.addOrUpdateParticipant(n) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.meetingInfo;
        return u.participants = [n], this.privTranscriberRecognizer.pushMeetingEvent(u, "join");
      }
    }
    removeParticipantImplAsync(n) {
      this.privParticipants.deleteParticipant(n.id);
      const c = this.meetingInfo;
      return c.participants = [n], this.privTranscriberRecognizer.pushMeetingEvent(c, "leave");
    }
    async close(n) {
      try {
        this.privIsConnected = !1, await this.privConversationRecognizer?.close(), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (c) {
        throw c;
      }
      n && this.dispose();
    }
    /** Helpers */
    handleCallback(n, c) {
      if (n) {
        try {
          n();
        } catch (u) {
          c && c(u);
        }
        n = void 0;
      }
    }
    handleError(n, c) {
      if (c)
        if (n instanceof Error) {
          const u = n;
          c(u.name + ": " + u.message);
        } else
          c(n);
    }
    /** Participant Helpers */
    toParticipants(n) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return n ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(n) {
      return new o.Participant(n.id, n.avatar, n.displayName, n.isHost, n.isMuted, n.isUsingTts, n.preferredLanguage, n.voice);
    }
    getMuteAllCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMuteCommand(n, c) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getEjectCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getChangeNicknameCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(n, "nickname"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.changeNickname,
        nickname: n,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMessageCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), r.Contracts.throwIfNullOrWhitespace(n, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: n,
        type: e.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return wt.MeetingImpl = a, wt;
}
var Wn = {}, Mp;
function IP() {
  if (Mp) return Wn;
  Mp = 1, Object.defineProperty(Wn, "__esModule", { value: !0 }), Wn.MeetingTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ ws();
  class t extends e.CancellationEventArgsBase {
  }
  return Wn.MeetingTranscriptionCanceledEventArgs = t, Wn;
}
var Hn = {}, Dp;
function AP() {
  if (Dp) return Hn;
  Dp = 1, Object.defineProperty(Hn, "__esModule", { value: !0 }), Hn.MeetingTranscriber = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ vc();
  let a = class {
    /**
     * MeetingTranscriber constructor.
     * @constructor
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n) {
      this.privAudioConfig = n, this.privProperties = new o.PropertyCollection(), this.privRecognizer = void 0, this.privDisposedRecognizer = !1;
    }
    /**
     * Gets the spoken language of recognition.
     * @member MeetingTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return r.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(o.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * The collection of properties and their values defined for this MeetingTranscriber.
     * @member MeetingTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privRecognizer.internalData;
    }
    /**
     * @Deprecated
     * @Obsolete
     * Please use the Connection.fromRecognizer pattern to obtain a connection object
     */
    get connection() {
      return o.Connection.fromRecognizer(this.privRecognizer);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * @param {Meeting} meeting - meeting to be recognized
     */
    joinMeetingAsync(n, c, u) {
      const l = n;
      r.Contracts.throwIfNullOrUndefined(i.MeetingImpl, "Meeting"), this.privRecognizer = new e.TranscriberRecognizer(n.config, this.privAudioConfig), r.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer"), this.privRecognizer.connectMeetingCallbacks(this), (0, t.marshalPromiseToCallbacks)(l.connectTranscriberRecognizer(this.privRecognizer), c, u);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(n, c) {
      this.privRecognizer.startContinuousRecognitionAsync(n, c);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(n, c) {
      this.privRecognizer.stopContinuousRecognitionAsync(n, c);
    }
    /**
     * Leave the current meeting. After this is called, you will no longer receive any events.
     */
    leaveMeetingAsync(n, c) {
      this.privRecognizer.disconnectCallbacks(), (0, t.marshalPromiseToCallbacks)((async () => {
      })(), n, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member MeetingTranscriber.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      r.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member MeetingTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (this.privRecognizer && (await this.privRecognizer.close(), this.privRecognizer = void 0), n && (this.privDisposedRecognizer = !0));
    }
  };
  return Hn.MeetingTranscriber = a, Hn;
}
var Kn = {}, xp;
function TP() {
  if (xp) return Kn;
  xp = 1, Object.defineProperty(Kn, "__esModule", { value: !0 }), Kn.ConversationTranscriptionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(o, i, a, s, n, c, u, p, h, d), this.privSpeakerId = l;
    }
    /**
     * speaker id
     * @member ConversationTranscriptionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return Kn.ConversationTranscriptionResult = t, Kn;
}
var Np;
function vc() {
  return Np || (Np = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConversationTranscriptionResult = e.MeetingTranscriber = e.MeetingTranscriptionCanceledEventArgs = e.MeetingImpl = e.Meeting = e.ParticipantChangedReason = e.User = e.Participant = e.ConversationTranscriber = e.ConversationTranslator = e.ConversationTranslationResult = e.ConversationTranslationEventArgs = e.ConversationTranslationCanceledEventArgs = e.ConversationParticipantsChangedEventArgs = e.ConversationExpirationEventArgs = e.ConversationCommon = e.ConversationImpl = e.Conversation = void 0;
    var t = /* @__PURE__ */ zv();
    Object.defineProperty(e, "Conversation", { enumerable: !0, get: function() {
      return t.Conversation;
    } }), Object.defineProperty(e, "ConversationImpl", { enumerable: !0, get: function() {
      return t.ConversationImpl;
    } });
    var r = /* @__PURE__ */ fP();
    Object.defineProperty(e, "ConversationCommon", { enumerable: !0, get: function() {
      return r.ConversationCommon;
    } });
    var o = /* @__PURE__ */ vP();
    Object.defineProperty(e, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return o.ConversationExpirationEventArgs;
    } });
    var i = /* @__PURE__ */ gP();
    Object.defineProperty(e, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return i.ConversationParticipantsChangedEventArgs;
    } });
    var a = /* @__PURE__ */ mP();
    Object.defineProperty(e, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return a.ConversationTranslationCanceledEventArgs;
    } });
    var s = /* @__PURE__ */ yP();
    Object.defineProperty(e, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return s.ConversationTranslationEventArgs;
    } });
    var n = /* @__PURE__ */ SP();
    Object.defineProperty(e, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return n.ConversationTranslationResult;
    } });
    var c = /* @__PURE__ */ RP();
    Object.defineProperty(e, "ConversationTranslator", { enumerable: !0, get: function() {
      return c.ConversationTranslator;
    } });
    var u = /* @__PURE__ */ PP();
    Object.defineProperty(e, "ConversationTranscriber", { enumerable: !0, get: function() {
      return u.ConversationTranscriber;
    } });
    var l = /* @__PURE__ */ wP();
    Object.defineProperty(e, "Participant", { enumerable: !0, get: function() {
      return l.Participant;
    } }), Object.defineProperty(e, "User", { enumerable: !0, get: function() {
      return l.User;
    } });
    var p = /* @__PURE__ */ bP();
    Object.defineProperty(e, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return p.ParticipantChangedReason;
    } });
    var h = /* @__PURE__ */ EP();
    Object.defineProperty(e, "Meeting", { enumerable: !0, get: function() {
      return h.Meeting;
    } }), Object.defineProperty(e, "MeetingImpl", { enumerable: !0, get: function() {
      return h.MeetingImpl;
    } });
    var d = /* @__PURE__ */ IP();
    Object.defineProperty(e, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return d.MeetingTranscriptionCanceledEventArgs;
    } });
    var f = /* @__PURE__ */ AP();
    Object.defineProperty(e, "MeetingTranscriber", { enumerable: !0, get: function() {
      return f.MeetingTranscriber;
    } });
    var g = /* @__PURE__ */ TP();
    Object.defineProperty(e, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return g.ConversationTranscriptionResult;
    } });
  }(ra)), ra;
}
var bt = {}, zp;
function gc() {
  if (zp) return bt;
  zp = 1, Object.defineProperty(bt, "__esModule", { value: !0 }), bt.SynthesisRequest = bt.Synthesizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class Fv {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config to initialize the synthesizer.
     */
    constructor(n) {
      const c = n;
      r.Contracts.throwIfNull(c, "speechConfig"), this.privProperties = c.properties.clone(), this.privDisposed = !1, this.privSynthesizing = !1, this.synthesisRequestQueue = new t.Queue(), this.tokenCredential = n.tokenCredential;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * The collection of properties and their values defined for this Synthesizer.
     * @member Synthesizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Indicates if auto detect source language is enabled
     * @member Synthesizer.prototype.autoDetectSourceLanguage
     * @function
     * @public
     * @returns {boolean} if auto detect source language is enabled
     */
    get autoDetectSourceLanguage() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === e.AutoDetectSourceLanguagesOpenRangeOptionName;
    }
    buildSsml(n) {
      const c = {
        "af-ZA": "af-ZA-AdriNeural",
        "am-ET": "am-ET-AmehaNeural",
        "ar-AE": "ar-AE-FatimaNeural",
        "ar-BH": "ar-BH-AliNeural",
        "ar-DZ": "ar-DZ-AminaNeural",
        "ar-EG": "ar-EG-SalmaNeural",
        "ar-IQ": "ar-IQ-BasselNeural",
        "ar-JO": "ar-JO-SanaNeural",
        "ar-KW": "ar-KW-FahedNeural",
        "ar-LY": "ar-LY-ImanNeural",
        "ar-MA": "ar-MA-JamalNeural",
        "ar-QA": "ar-QA-AmalNeural",
        "ar-SA": "ar-SA-HamedNeural",
        "ar-SY": "ar-SY-AmanyNeural",
        "ar-TN": "ar-TN-HediNeural",
        "ar-YE": "ar-YE-MaryamNeural",
        "bg-BG": "bg-BG-BorislavNeural",
        "bn-BD": "bn-BD-NabanitaNeural",
        "bn-IN": "bn-IN-BashkarNeural",
        "ca-ES": "ca-ES-JoanaNeural",
        "cs-CZ": "cs-CZ-AntoninNeural",
        "cy-GB": "cy-GB-AledNeural",
        "da-DK": "da-DK-ChristelNeural",
        "de-AT": "de-AT-IngridNeural",
        "de-CH": "de-CH-JanNeural",
        "de-DE": "de-DE-KatjaNeural",
        "el-GR": "el-GR-AthinaNeural",
        "en-AU": "en-AU-NatashaNeural",
        "en-CA": "en-CA-ClaraNeural",
        "en-GB": "en-GB-LibbyNeural",
        "en-HK": "en-HK-SamNeural",
        "en-IE": "en-IE-ConnorNeural",
        "en-IN": "en-IN-NeerjaNeural",
        "en-KE": "en-KE-AsiliaNeural",
        "en-NG": "en-NG-AbeoNeural",
        "en-NZ": "en-NZ-MitchellNeural",
        "en-PH": "en-PH-JamesNeural",
        "en-SG": "en-SG-LunaNeural",
        "en-TZ": "en-TZ-ElimuNeural",
        "en-US": "en-US-AvaMultilingualNeural",
        "en-ZA": "en-ZA-LeahNeural",
        "es-AR": "es-AR-ElenaNeural",
        "es-BO": "es-BO-MarceloNeural",
        "es-CL": "es-CL-CatalinaNeural",
        "es-CO": "es-CO-GonzaloNeural",
        "es-CR": "es-CR-JuanNeural",
        "es-CU": "es-CU-BelkysNeural",
        "es-DO": "es-DO-EmilioNeural",
        "es-EC": "es-EC-AndreaNeural",
        "es-ES": "es-ES-AlvaroNeural",
        "es-GQ": "es-GQ-JavierNeural",
        "es-GT": "es-GT-AndresNeural",
        "es-HN": "es-HN-CarlosNeural",
        "es-MX": "es-MX-DaliaNeural",
        "es-NI": "es-NI-FedericoNeural",
        "es-PA": "es-PA-MargaritaNeural",
        "es-PE": "es-PE-AlexNeural",
        "es-PR": "es-PR-KarinaNeural",
        "es-PY": "es-PY-MarioNeural",
        "es-SV": "es-SV-LorenaNeural",
        "es-US": "es-US-AlonsoNeural",
        "es-UY": "es-UY-MateoNeural",
        "es-VE": "es-VE-PaolaNeural",
        "et-EE": "et-EE-AnuNeural",
        "fa-IR": "fa-IR-DilaraNeural",
        "fi-FI": "fi-FI-SelmaNeural",
        "fil-PH": "fil-PH-AngeloNeural",
        "fr-BE": "fr-BE-CharlineNeural",
        "fr-CA": "fr-CA-SylvieNeural",
        "fr-CH": "fr-CH-ArianeNeural",
        "fr-FR": "fr-FR-DeniseNeural",
        "ga-IE": "ga-IE-ColmNeural",
        "gl-ES": "gl-ES-RoiNeural",
        "gu-IN": "gu-IN-DhwaniNeural",
        "he-IL": "he-IL-AvriNeural",
        "hi-IN": "hi-IN-MadhurNeural",
        "hr-HR": "hr-HR-GabrijelaNeural",
        "hu-HU": "hu-HU-NoemiNeural",
        "id-ID": "id-ID-ArdiNeural",
        "is-IS": "is-IS-GudrunNeural",
        "it-IT": "it-IT-IsabellaNeural",
        "ja-JP": "ja-JP-NanamiNeural",
        "jv-ID": "jv-ID-DimasNeural",
        "kk-KZ": "kk-KZ-AigulNeural",
        "km-KH": "km-KH-PisethNeural",
        "kn-IN": "kn-IN-GaganNeural",
        "ko-KR": "ko-KR-SunHiNeural",
        "lo-LA": "lo-LA-ChanthavongNeural",
        "lt-LT": "lt-LT-LeonasNeural",
        "lv-LV": "lv-LV-EveritaNeural",
        "mk-MK": "mk-MK-AleksandarNeural",
        "ml-IN": "ml-IN-MidhunNeural",
        "mr-IN": "mr-IN-AarohiNeural",
        "ms-MY": "ms-MY-OsmanNeural",
        "mt-MT": "mt-MT-GraceNeural",
        "my-MM": "my-MM-NilarNeural",
        "nb-NO": "nb-NO-PernilleNeural",
        "nl-BE": "nl-BE-ArnaudNeural",
        "nl-NL": "nl-NL-ColetteNeural",
        "pl-PL": "pl-PL-AgnieszkaNeural",
        "ps-AF": "ps-AF-GulNawazNeural",
        "pt-BR": "pt-BR-FranciscaNeural",
        "pt-PT": "pt-PT-DuarteNeural",
        "ro-RO": "ro-RO-AlinaNeural",
        "ru-RU": "ru-RU-SvetlanaNeural",
        "si-LK": "si-LK-SameeraNeural",
        "sk-SK": "sk-SK-LukasNeural",
        "sl-SI": "sl-SI-PetraNeural",
        "so-SO": "so-SO-MuuseNeural",
        "sr-RS": "sr-RS-NicholasNeural",
        "su-ID": "su-ID-JajangNeural",
        "sv-SE": "sv-SE-SofieNeural",
        "sw-KE": "sw-KE-RafikiNeural",
        "sw-TZ": "sw-TZ-DaudiNeural",
        "ta-IN": "ta-IN-PallaviNeural",
        "ta-LK": "ta-LK-KumarNeural",
        "ta-SG": "ta-SG-AnbuNeural",
        "te-IN": "te-IN-MohanNeural",
        "th-TH": "th-TH-PremwadeeNeural",
        "tr-TR": "tr-TR-AhmetNeural",
        "uk-UA": "uk-UA-OstapNeural",
        "ur-IN": "ur-IN-GulNeural",
        "ur-PK": "ur-PK-AsadNeural",
        "uz-UZ": "uz-UZ-MadinaNeural",
        "vi-VN": "vi-VN-HoaiMyNeural",
        "zh-CN": "zh-CN-XiaoxiaoNeural",
        "zh-HK": "zh-HK-HiuMaanNeural",
        "zh-TW": "zh-TW-HsiaoChenNeural",
        "zu-ZA": "zu-ZA-ThandoNeural"
      };
      let u = this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US"), l = this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthVoice, ""), p = Fv.XMLEncode(n);
      return this.autoDetectSourceLanguage ? u = "en-US" : l = l || c[u], l && (p = `<voice name='${l}'>${p}</voice>`), p = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${u}'>${p}</speak>`, p;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Synthesizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(n) {
      this.privDisposed || (n && this.privAdapter && await this.privAdapter.dispose(), this.privDisposed = !0);
    }
    async adapterSpeak() {
      if (!this.privDisposed && !this.privSynthesizing) {
        this.privSynthesizing = !0;
        const n = await this.synthesisRequestQueue.dequeue();
        return this.privAdapter.Speak(n.text, n.isSSML, n.requestId, n.cb, n.err, n.dataStream);
      }
    }
    createSynthesizerConfig(n) {
      return new e.SynthesizerConfig(n, this.privProperties);
    }
    // Does the generic synthesizer setup that is common across all synthesizer types.
    implCommonSynthesizeSetup() {
      let n = typeof window < "u" ? "Browser" : "Node", c = "unknown", u = "unknown";
      typeof navigator < "u" && (n = n + "/" + navigator.platform, c = navigator.userAgent, u = navigator.appVersion);
      const l = this.createSynthesizerConfig(new e.SpeechServiceConfig(new e.Context(new e.OS(n, c, u)))), p = this.privProperties.getProperty(o.PropertyId.SpeechServiceConnection_Key, void 0), h = p && p !== "" ? new e.CognitiveSubscriptionKeyAuthentication(p) : this.tokenCredential ? new e.CognitiveTokenAuthentication(async () => {
        try {
          return (await this.tokenCredential.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (d) {
          throw d;
        }
      }, async () => {
        try {
          return (await this.tokenCredential.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (d) {
          throw d;
        }
      }) : new e.CognitiveTokenAuthentication(() => {
        const d = this.privProperties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(d);
      }, () => {
        const d = this.privProperties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(d);
      });
      this.privAdapter = this.createSynthesisAdapter(h, this.privConnectionFactory, l), this.privRestAdapter = this.createRestSynthesisAdapter(h, l);
    }
    static XMLEncode(n) {
      return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
  };
  bt.Synthesizer = i;
  class a {
    constructor(n, c, u, l, p, h) {
      this.requestId = n, this.text = c, this.isSSML = u, this.cb = l, this.err = p, this.dataStream = h;
    }
  }
  return bt.SynthesisRequest = a, bt;
}
var Jn = {}, Lp;
function _P() {
  if (Lp) return Jn;
  Lp = 1, Object.defineProperty(Jn, "__esModule", { value: !0 }), Jn.SpeechSynthesizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ fv(), o = /* @__PURE__ */ Ps(), i = /* @__PURE__ */ Kt(), a = /* @__PURE__ */ z(), s = /* @__PURE__ */ I(), n = /* @__PURE__ */ gc();
  let c = class Bv extends s.Synthesizer {
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
     */
    constructor(l, p) {
      super(l), p !== null && (p === void 0 ? this.audioConfig = typeof window > "u" ? void 0 : s.AudioConfig.fromDefaultSpeakerOutput() : this.audioConfig = p), this.privConnectionFactory = new e.SpeechSynthesisConnectionFactory(), this.implCommonSynthesizeSetup();
    }
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
     */
    static FromConfig(l, p, h) {
      const d = l;
      return p.properties.mergeTo(d.properties), new Bv(l, h);
    }
    /**
     * Executes speech synthesis on plain text.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param text - Text to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakTextAsync(l, p, h, d) {
      this.speakImpl(l, !1, p, h, d);
    }
    /**
     * Executes speech synthesis on SSML.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param ssml - SSML to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakSsmlAsync(l, p, h, d) {
      this.speakImpl(l, !0, p, h, d);
    }
    /**
     * Get list of synthesis voices available.
     * The task returns the synthesis voice result.
     * @member SpeechSynthesizer.prototype.getVoicesAsync
     * @function
     * @async
     * @public
     * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
     * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
     */
    async getVoicesAsync(l = "") {
      return this.getVoices(l);
    }
    /**
     * Dispose of associated resources.
     * @member SpeechSynthesizer.prototype.close
     * @function
     * @public
     */
    close(l, p) {
      a.Contracts.throwIfDisposed(this.privDisposed), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), l, p);
    }
    /**
     * @Internal
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privAdapter;
    }
    //
    // ################################################################################################################
    // IMPLEMENTATION.
    // ################################################################################################################
    //
    // Creates the synthesis adapter
    createSynthesisAdapter(l, p, h) {
      return new e.SpeechSynthesisAdapter(l, p, h, this, this.audioConfig);
    }
    createRestSynthesisAdapter(l, p) {
      return new e.SynthesisRestAdapter(p, l);
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(s.SpeechSynthesisOutputFormat[this.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)]);
    }
    speakImpl(l, p, h, d, f) {
      try {
        a.Contracts.throwIfDisposed(this.privDisposed);
        const g = (0, t.createNoDashGuid)();
        let m;
        f instanceof s.PushAudioOutputStreamCallback ? m = new i.PushAudioOutputStreamImpl(f) : f instanceof s.PullAudioOutputStream ? m = f : f !== void 0 ? m = new r.AudioFileWriter(f) : m = void 0, this.synthesisRequestQueue.enqueue(new n.SynthesisRequest(g, l, p, (v) => {
          if (this.privSynthesizing = !1, h)
            try {
              h(v);
            } catch (y) {
              d && d(y);
            }
          h = void 0, this.adapterSpeak().catch(() => {
          });
        }, (v) => {
          d && d(v);
        }, m)), this.adapterSpeak().catch(() => {
        });
      } catch (g) {
        if (d)
          if (g instanceof Error) {
            const m = g;
            d(m.name + ": " + m.message);
          } else
            d(g);
        this.dispose(!0).catch(() => {
        });
      }
    }
    async getVoices(l) {
      const p = (0, t.createNoDashGuid)(), h = await this.privRestAdapter.getVoicesList(p);
      if (h.ok && Array.isArray(h.json)) {
        let d = h.json;
        return l && l.length > 0 && (d = d.filter((f) => !!f.Locale && f.Locale.toLowerCase() === l.toLowerCase())), new s.SynthesisVoicesResult(p, d, void 0);
      } else
        return new s.SynthesisVoicesResult(p, void 0, `Error: ${h.status}: ${h.statusText}`);
    }
  };
  return Jn.SpeechSynthesizer = c, Jn;
}
var Gn = {}, jp;
function kP() {
  if (jp) return Gn;
  jp = 1, Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.SynthesisResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, o, i, a) {
      this.privResultId = r, this.privReason = o, this.privErrorDetails = i, this.privProperties = a;
    }
    /**
     * Specifies the result identifier.
     * @member SynthesisResult.prototype.resultId
     * @function
     * @public
     * @returns {string} Specifies the result identifier.
     */
    get resultId() {
      return this.privResultId;
    }
    /**
     * Specifies status of the result.
     * @member SynthesisResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} Specifies status of the result.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * In case of an unsuccessful synthesis, provides details of the occurred error.
     * @member SynthesisResult.prototype.errorDetails
     * @function
     * @public
     * @returns {string} a brief description of an error.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * The set of properties exposed in the result.
     * @member SynthesisResult.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The set of properties exposed in the result.
     */
    get properties() {
      return this.privProperties;
    }
  };
  return Gn.SynthesisResult = e, Gn;
}
var Qn = {}, qp;
function OP() {
  if (qp) return Qn;
  qp = 1, Object.defineProperty(Qn, "__esModule", { value: !0 }), Qn.SpeechSynthesisResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {ArrayBuffer} audioData - The synthesized audio binary.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     * @param {number} audioDuration - The audio duration.
     */
    constructor(o, i, a, s, n, c) {
      super(o, i, s, n), this.privAudioData = a, this.privAudioDuration = c;
    }
    /**
     * The synthesized audio data
     * @member SpeechSynthesisResult.prototype.audioData
     * @function
     * @public
     * @returns {ArrayBuffer} The synthesized audio data.
     */
    get audioData() {
      return this.privAudioData;
    }
    /**
     * The time duration of synthesized audio, in ticks (100 nanoseconds).
     * @member SpeechSynthesisResult.prototype.audioDuration
     * @function
     * @public
     * @returns {number} The time duration of synthesized audio.
     */
    get audioDuration() {
      return this.privAudioDuration;
    }
  };
  return Qn.SpeechSynthesisResult = t, Qn;
}
var Yn = {}, Fp;
function MP() {
  if (Fp) return Yn;
  Fp = 1, Object.defineProperty(Yn, "__esModule", { value: !0 }), Yn.SpeechSynthesisEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechSynthesisResult} result - The speech synthesis result.
     */
    constructor(r) {
      this.privResult = r;
    }
    /**
     * Specifies the synthesis result.
     * @member SpeechSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechSynthesisResult} the synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Yn.SpeechSynthesisEventArgs = e, Yn;
}
var Zn = {}, Bp;
function DP() {
  if (Bp) return Zn;
  Bp = 1, Object.defineProperty(Zn, "__esModule", { value: !0 }), Zn.SpeechSynthesisWordBoundaryEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} duration - The audio duration.
     * @param {string} text - The text.
     * @param {number} wordLength - The length of the word.
     * @param {number} textOffset - The text offset.
     * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
     */
    constructor(r, o, i, a, s, n) {
      this.privAudioOffset = r, this.privDuration = o, this.privText = i, this.privWordLength = a, this.privTextOffset = s, this.privBoundaryType = n;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the duration, in ticks (100 nanoseconds).
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
     * @function
     * @public
     * @returns {number} Duration in 100 nanosecond increments.
     */
    get duration() {
      return this.privDuration;
    }
    /**
     * Specifies the text of the word boundary event.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
     * @function
     * @public
     * @returns {string} the text.
     */
    get text() {
      return this.privText;
    }
    /**
     * Specifies the word length
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
     * @function
     * @public
     * @returns {number} the word length
     */
    get wordLength() {
      return this.privWordLength;
    }
    /**
     * Specifies the text offset.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
     * @function
     * @public
     * @returns {number} the text offset.
     */
    get textOffset() {
      return this.privTextOffset;
    }
    /**
     * Specifies the boundary type.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
     * @function
     * @public
     * @returns {SpeechSynthesisBoundaryType} the boundary type.
     */
    get boundaryType() {
      return this.privBoundaryType;
    }
  };
  return Zn.SpeechSynthesisWordBoundaryEventArgs = e, Zn;
}
var Xn = {}, Up;
function xP() {
  if (Up) return Xn;
  Up = 1, Object.defineProperty(Xn, "__esModule", { value: !0 }), Xn.SpeechSynthesisBookmarkEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {string} text - The bookmark text.
     */
    constructor(r, o) {
      this.privAudioOffset = r, this.privText = o;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the bookmark.
     * @member SpeechSynthesisBookmarkEventArgs.prototype.text
     * @function
     * @public
     * @returns {string} the bookmark text.
     */
    get text() {
      return this.privText;
    }
  };
  return Xn.SpeechSynthesisBookmarkEventArgs = e, Xn;
}
var ei = {}, $p;
function NP() {
  if ($p) return ei;
  $p = 1, Object.defineProperty(ei, "__esModule", { value: !0 }), ei.SpeechSynthesisVisemeEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} visemeId - The viseme ID.
     * @param {string} animation - The animation, could be in svg or other format.
     */
    constructor(r, o, i) {
      this.privAudioOffset = r, this.privVisemeId = o, this.privAnimation = i;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the viseme ID.
     * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
     * @function
     * @public
     * @returns {number} the viseme ID.
     */
    get visemeId() {
      return this.privVisemeId;
    }
    /**
     * Specifies the animation.
     * @member SpeechSynthesisVisemeEventArgs.prototype.animation
     * @function
     * @public
     * @returns {string} the animation, could be in svg or other format.
     */
    get animation() {
      return this.privAnimation;
    }
  };
  return ei.SpeechSynthesisVisemeEventArgs = e, ei;
}
var sa = {}, Vp;
function zP() {
  return Vp || (Vp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeechSynthesisBoundaryType = void 0, function(t) {
      t.Word = "WordBoundary", t.Punctuation = "PunctuationBoundary", t.Sentence = "SentenceBoundary";
    }(e.SpeechSynthesisBoundaryType || (e.SpeechSynthesisBoundaryType = {}));
  }(sa)), sa;
}
var ti = {}, Wp;
function LP() {
  if (Wp) return ti;
  Wp = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.SynthesisVoicesResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param requestId - result id for request.
     * @param json - json payload from endpoint.
     */
    constructor(o, i, a) {
      if (Array.isArray(i)) {
        super(o, e.ResultReason.VoicesListRetrieved, void 0, new e.PropertyCollection()), this.privVoices = [];
        for (const s of i)
          this.privVoices.push(new e.VoiceInfo(s));
      } else
        super(o, e.ResultReason.Canceled, a || "Error information unavailable", new e.PropertyCollection());
    }
    /**
     * The list of voices
     * @member SynthesisVoicesResult.prototype.voices
     * @function
     * @public
     * @returns {VoiceInfo[]} List of synthesized voices.
     */
    get voices() {
      return this.privVoices;
    }
  };
  return ti.SynthesisVoicesResult = t, ti;
}
var oa = {}, Hp;
function jP() {
  return Hp || (Hp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.VoiceInfo = e.SynthesisVoiceType = e.SynthesisVoiceGender = void 0;
    var t;
    (function(s) {
      s[s.Unknown = 0] = "Unknown", s[s.Female = 1] = "Female", s[s.Male = 2] = "Male", s[s.Neutral = 3] = "Neutral";
    })(t = e.SynthesisVoiceGender || (e.SynthesisVoiceGender = {}));
    var r;
    (function(s) {
      s[s.Unknown = 0] = "Unknown", s[s.OnlineNeural = 1] = "OnlineNeural", s[s.OnlineStandard = 2] = "OnlineStandard", s[s.OfflineNeural = 3] = "OfflineNeural", s[s.OfflineStandard = 4] = "OfflineStandard", s[s.OnlineNeuralHD = 5] = "OnlineNeuralHD";
    })(r = e.SynthesisVoiceType || (e.SynthesisVoiceType = {}));
    const o = {
      [t[t.Neutral]]: t.Neutral,
      [t[t.Male]]: t.Male,
      [t[t.Female]]: t.Female
    }, i = {
      Neural: r.OnlineNeural,
      NeuralHD: r.OnlineNeuralHD
    };
    class a {
      constructor(n) {
        if (this.privStyleList = [], n) {
          if (this.privName = n.Name, this.privLocale = n.Locale, this.privShortName = n.ShortName, this.privLocaleName = n.LocaleName, this.privDisplayName = n.DisplayName, this.privLocalName = n.LocalName, this.privVoiceType = i[n.VoiceType] || r.Unknown, this.privGender = o[n.Gender] || t.Unknown, n.StyleList && Array.isArray(n.StyleList))
            for (const c of n.StyleList)
              this.privStyleList.push(c);
          this.privSampleRateHertz = n.SampleRateHertz, this.privStatus = n.Status, n.ExtendedPropertyMap && (this.privExtendedPropertyMap = n.ExtendedPropertyMap), this.privWordsPerMinute = n.WordsPerMinute, Array.isArray(n.SecondaryLocaleList) && (this.privSecondaryLocaleList = [...n.SecondaryLocaleList]), Array.isArray(n.RolePlayList) && (this.privRolePlayList = [...n.RolePlayList]), n.VoiceTag && (this.privVoiceTag = n.VoiceTag);
        }
      }
      get name() {
        return this.privName;
      }
      get locale() {
        return this.privLocale;
      }
      get shortName() {
        return this.privShortName;
      }
      get displayName() {
        return this.privDisplayName;
      }
      get localName() {
        return this.privLocalName;
      }
      get localeName() {
        return this.privLocaleName;
      }
      get gender() {
        return this.privGender;
      }
      get voiceType() {
        return this.privVoiceType;
      }
      get styleList() {
        return this.privStyleList;
      }
      get sampleRateHertz() {
        return this.privSampleRateHertz;
      }
      get status() {
        return this.privStatus;
      }
      get extendedPropertyMap() {
        return this.privExtendedPropertyMap;
      }
      get wordsPerMinute() {
        return this.privWordsPerMinute;
      }
      get secondaryLocaleList() {
        return this.privSecondaryLocaleList;
      }
      get rolePlayList() {
        return this.privRolePlayList;
      }
      get voiceTag() {
        return this.privVoiceTag;
      }
    }
    e.VoiceInfo = a;
  }(oa)), oa;
}
var ri = {}, Kp;
function qP() {
  if (Kp) return ri;
  Kp = 1, Object.defineProperty(ri, "__esModule", { value: !0 }), ri.SpeakerAudioDestination = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ Kt(), r = /* @__PURE__ */ zt(), o = 60 * 30, i = {
    [r.AudioFormatTag.PCM]: "audio/wav",
    [r.AudioFormatTag.MuLaw]: "audio/x-wav",
    [r.AudioFormatTag.MP3]: "audio/mpeg",
    [r.AudioFormatTag.OGG_OPUS]: "audio/ogg",
    [r.AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
    [r.AudioFormatTag.ALaw]: "audio/x-wav",
    [r.AudioFormatTag.FLAC]: "audio/flac",
    [r.AudioFormatTag.AMR_WB]: "audio/amr-wb",
    [r.AudioFormatTag.G722]: "audio/G722"
  };
  let a = class {
    constructor(n) {
      this.privPlaybackStarted = !1, this.privAppendingToBuffer = !1, this.privMediaSourceOpened = !1, this.privBytesReceived = 0, this.privId = n || (0, e.createNoDashGuid)(), this.privIsPaused = !1, this.privIsClosed = !1;
    }
    id() {
      return this.privId;
    }
    write(n, c, u) {
      this.privAudioBuffer !== void 0 ? (this.privAudioBuffer.push(n), this.updateSourceBuffer().then(() => {
        c && c();
      }, (l) => {
        u && u(l);
      })) : this.privAudioOutputStream !== void 0 && (this.privAudioOutputStream.write(n), this.privBytesReceived += n.byteLength);
    }
    close(n, c) {
      if (this.privIsClosed = !0, this.privSourceBuffer !== void 0)
        this.handleSourceBufferUpdateEnd().then(() => {
          n && n();
        }, (u) => {
          c && c(u);
        });
      else if (this.privAudioOutputStream !== void 0 && typeof window < "u")
        if ((this.privFormat.formatTag === r.AudioFormatTag.PCM || this.privFormat.formatTag === r.AudioFormatTag.MuLaw || this.privFormat.formatTag === r.AudioFormatTag.ALaw) && this.privFormat.hasHeader === !1)
          console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header."), this.onAudioEnd && this.onAudioEnd(this);
        else {
          let u = new ArrayBuffer(this.privBytesReceived);
          this.privAudioOutputStream.read(u).then(() => {
            u = this.privFormat.addHeader(u);
            const l = new Blob([u], { type: i[this.privFormat.formatTag] });
            this.privAudio.src = window.URL.createObjectURL(l), this.notifyPlayback().then(() => {
              n && n();
            }, (p) => {
              c && c(p);
            });
          }, (l) => {
            c && c(l);
          });
        }
      else
        this.onAudioEnd && this.onAudioEnd(this);
    }
    set format(n) {
      if (typeof AudioContext < "u" || typeof window < "u" && typeof window.webkitAudioContext < "u") {
        this.privFormat = n;
        const c = i[this.privFormat.formatTag];
        c === void 0 ? console.warn(`Unknown mimeType for format ${r.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`) : typeof MediaSource < "u" && MediaSource.isTypeSupported(c) ? (this.privAudio = new Audio(), this.privAudioBuffer = [], this.privMediaSource = new MediaSource(), this.privAudio.src = URL.createObjectURL(this.privMediaSource), this.privAudio.load(), this.privMediaSource.onsourceopen = () => {
          this.privMediaSourceOpened = !0, this.privMediaSource.duration = o, this.privSourceBuffer = this.privMediaSource.addSourceBuffer(c), this.privSourceBuffer.onupdate = () => {
            this.updateSourceBuffer().catch((u) => {
              e.Events.instance.onEvent(new e.BackgroundEvent(u));
            });
          }, this.privSourceBuffer.onupdateend = () => {
            this.handleSourceBufferUpdateEnd().catch((u) => {
              e.Events.instance.onEvent(new e.BackgroundEvent(u));
            });
          }, this.privSourceBuffer.onupdatestart = () => {
            this.privAppendingToBuffer = !1;
          };
        }, this.updateSourceBuffer().catch((u) => {
          e.Events.instance.onEvent(new e.BackgroundEvent(u));
        })) : (console.warn(`Format ${r.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`), this.privAudioOutputStream = new t.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privFormat, this.privAudio = new Audio());
      }
    }
    get volume() {
      return this.privAudio?.volume ?? -1;
    }
    set volume(n) {
      this.privAudio && (this.privAudio.volume = n);
    }
    mute() {
      this.privAudio && (this.privAudio.muted = !0);
    }
    unmute() {
      this.privAudio && (this.privAudio.muted = !1);
    }
    get isClosed() {
      return this.privIsClosed;
    }
    get currentTime() {
      return this.privAudio !== void 0 ? this.privAudio.currentTime : -1;
    }
    pause() {
      !this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.pause(), this.privIsPaused = !0);
    }
    resume(n, c) {
      this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.play().then(() => {
        n && n();
      }, (u) => {
        c && c(u);
      }), this.privIsPaused = !1);
    }
    get internalAudio() {
      return this.privAudio;
    }
    async updateSourceBuffer() {
      if (this.privAudioBuffer !== void 0 && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
        this.privAppendingToBuffer = !0;
        const n = this.privAudioBuffer.shift();
        try {
          this.privSourceBuffer.appendBuffer(n);
        } catch {
          this.privAudioBuffer.unshift(n), console.log("buffer filled, pausing addition of binaries until space is made");
          return;
        }
        await this.notifyPlayback();
      } else this.canEndStream() && await this.handleSourceBufferUpdateEnd();
    }
    async handleSourceBufferUpdateEnd() {
      this.canEndStream() && this.sourceBufferAvailable() && (this.privMediaSource.endOfStream(), await this.notifyPlayback());
    }
    async notifyPlayback() {
      !this.privPlaybackStarted && this.privAudio !== void 0 && (this.privPlaybackStarted = !0, this.onAudioStart && this.onAudioStart(this), this.privAudio.onended = () => {
        this.onAudioEnd && this.onAudioEnd(this);
      }, this.privIsPaused || await this.privAudio.play());
    }
    canEndStream() {
      return this.isClosed && this.privSourceBuffer !== void 0 && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
    }
    sourceBufferAvailable() {
      return this.privSourceBuffer !== void 0 && !this.privSourceBuffer.updating;
    }
  };
  return ri.SpeakerAudioDestination = a, ri;
}
var ni = {}, Jp;
function FP() {
  if (Jp) return ni;
  Jp = 1, Object.defineProperty(ni, "__esModule", { value: !0 }), ni.ConversationTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ ws();
  let t = class extends e.CancellationEventArgsBase {
  };
  return ni.ConversationTranscriptionCanceledEventArgs = t, ni;
}
var ii = {}, Gp;
function BP() {
  if (Gp) return ii;
  Gp = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.MeetingTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ ws();
  let t = class extends e.CancellationEventArgsBase {
  };
  return ii.MeetingTranscriptionCanceledEventArgs = t, ii;
}
var aa = {}, Qp;
function UP() {
  return Qp || (Qp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PronunciationAssessmentGradingSystem = void 0, function(t) {
      t[t.FivePoint = 1] = "FivePoint", t[t.HundredMark = 2] = "HundredMark";
    }(e.PronunciationAssessmentGradingSystem || (e.PronunciationAssessmentGradingSystem = {}));
  }(aa)), aa;
}
var ca = {}, Yp;
function $P() {
  return Yp || (Yp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PronunciationAssessmentGranularity = void 0, function(t) {
      t[t.Phoneme = 1] = "Phoneme", t[t.Word = 2] = "Word", t[t.FullText = 3] = "FullText";
    }(e.PronunciationAssessmentGranularity || (e.PronunciationAssessmentGranularity = {}));
  }(ca)), ca;
}
var si = {}, Zp;
function VP() {
  if (Zp) return si;
  Zp = 1, Object.defineProperty(si, "__esModule", { value: !0 }), si.PronunciationAssessmentConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class Uv {
    /**
     * PronunciationAssessmentConfig constructor.
     * @constructor
     * @param {string} referenceText
     * @param gradingSystem
     * @param granularity
     * @param enableMiscue
     */
    constructor(i, a = t.PronunciationAssessmentGradingSystem.FivePoint, s = t.PronunciationAssessmentGranularity.Phoneme, n = !1) {
      e.Contracts.throwIfNullOrUndefined(i, "referenceText"), this.privProperties = new t.PropertyCollection(), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_ReferenceText, i), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_GradingSystem, t.PronunciationAssessmentGradingSystem[a]), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_Granularity, t.PronunciationAssessmentGranularity[s]), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, String(n));
    }
    /**
     * @member PronunciationAssessmentConfig.fromJSON
     * @function
     * @public
     * @param {string} json The json string containing the pronunciation assessment parameters.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentConfig from json.
     * This method is designed to support the pronunciation assessment parameters still in preview.
     * Under normal circumstances, use the constructor instead.
     */
    static fromJSON(i) {
      e.Contracts.throwIfNullOrUndefined(i, "json");
      const a = new Uv("");
      return a.privProperties = new t.PropertyCollection(), a.properties.setProperty(t.PropertyId.PronunciationAssessment_Json, i), a;
    }
    toJSON() {
      return this.updateJson(), this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Params);
    }
    applyTo(i) {
      this.updateJson();
      const a = i.internalData;
      a.expectContentAssessmentResponse = !!this.privContentAssessmentTopic, a.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(t.PropertyId.PronunciationAssessment_Params), this.privContentAssessmentTopic, a.isSpeakerDiarizationEnabled);
    }
    /**
     * Gets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @returns {string} Reference text.
     */
    get referenceText() {
      return this.properties.getProperty(t.PropertyId.PronunciationAssessment_ReferenceText);
    }
    /**
     * Gets/Sets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @param {string} referenceText - Reference text.
     */
    set referenceText(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "referenceText"), this.properties.setProperty(t.PropertyId.PronunciationAssessment_ReferenceText, i);
    }
    /**
     * Sets the phoneme alphabet.
     * The valid values are "SAPI" (default) and "IPA".
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
     * @function
     * @public
     * @param {string} phonemeAlphabet - Phoneme alphabet.
     */
    set phonemeAlphabet(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "phonemeAlphabet"), this.privPhonemeAlphabet = i;
    }
    /**
     * Sets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @param {boolean} enableMiscue - enable miscue.
     */
    set enableMiscue(i) {
      const a = i ? "true" : "false";
      this.properties.setProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, a);
    }
    /**
     * Gets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @return {boolean} enableMiscue - enable miscue.
     */
    get enableMiscue() {
      return this.properties.getProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, "false").toLowerCase() === "true";
    }
    /**
     * Sets the nbest phoneme count
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
     * @function
     * @public
     * @param {number} nbestPhonemeCount - NBest phoneme count.
     */
    set nbestPhonemeCount(i) {
      this.privNBestPhonemeCount = i;
    }
    /**
     * Enables the prosody assessment.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableProsodyAssessment
     * @function
     * @public
     * @param {boolean} enableProsodyAssessment - enable prosody assessment.
     */
    set enableProsodyAssessment(i) {
      this.privEnableProsodyAssessment = i;
    }
    /**
     * Enables content assessment and sets the topic.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableContentAssessmentWithTopic
     * @function
     * @public
     * @param {string} topic - Topic for content assessment.
     */
    enableContentAssessmentWithTopic(i) {
      this.privContentAssessmentTopic = i;
    }
    /**
     * @member PronunciationAssessmentConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets a pronunciation assessment config properties
     */
    get properties() {
      return this.privProperties;
    }
    updateJson() {
      const i = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Json, "{}"), a = JSON.parse(i), s = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_ReferenceText);
      s && (a.referenceText = s);
      const n = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_GradingSystem);
      n && (a.gradingSystem = n);
      const c = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Granularity);
      c && (a.granularity = c), this.privPhonemeAlphabet && (a.phonemeAlphabet = this.privPhonemeAlphabet), this.privNBestPhonemeCount && (a.nbestPhonemeCount = this.privNBestPhonemeCount), a.enableProsodyAssessment = this.privEnableProsodyAssessment, a.dimension = "Comprehensive", this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_EnableMiscue) && (a.enableMiscue = this.enableMiscue), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_Params, JSON.stringify(a));
    }
  };
  return si.PronunciationAssessmentConfig = r, si;
}
var Et = {}, Xp;
function WP() {
  if (Xp) return Et;
  Xp = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.PronunciationAssessmentResult = Et.ContentAssessmentResult = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  class r {
    /**
     * @Internal
     * Do not use externally.
     */
    constructor(a) {
      this.privPronJson = a;
    }
    /**
     * Correctness in using grammar and variety of sentence patterns.
     * Grammatical errors are jointly evaluated by lexical accuracy,
     * grammatical accuracy and diversity of sentence structures.
     * @member ContentAssessmentResult.prototype.grammarScore
     * @function
     * @public
     * @returns {number} Grammar score.
     */
    get grammarScore() {
      return this.privPronJson.ContentAssessment.GrammarScore;
    }
    /**
     * Proficiency in lexical usage. It evaluates the speaker's effective usage
     * of words and their appropriateness within the given context to express
     * ideas accurately, as well as level of lexical complexity.
     * @member ContentAssessmentResult.prototype.vocabularyScore
     * @function
     * @public
     * @returns {number} Vocabulary score.
     */
    get vocabularyScore() {
      return this.privPronJson.ContentAssessment.VocabularyScore;
    }
    /**
     * Level of understanding and engagement with the topic, which provides
     * insights into the speaker’s ability to express their thoughts and ideas
     * effectively and the ability to engage with the topic.
     * @member ContentAssessmentResult.prototype.topicScore
     * @function
     * @public
     * @returns {number} Topic score.
     */
    get topicScore() {
      return this.privPronJson.ContentAssessment.TopicScore;
    }
  }
  Et.ContentAssessmentResult = r;
  let o = class $v {
    constructor(a) {
      const s = JSON.parse(a);
      e.Contracts.throwIfNullOrUndefined(s.NBest[0], "NBest"), this.privPronJson = s.NBest[0];
    }
    /**
     * @member PronunciationAssessmentResult.fromResult
     * @function
     * @public
     * @param {RecognitionResult} result The recognition result.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
     */
    static fromResult(a) {
      e.Contracts.throwIfNullOrUndefined(a, "result");
      const s = a.properties.getProperty(t.PropertyId.SpeechServiceResponse_JsonResult);
      return e.Contracts.throwIfNullOrUndefined(s, "json"), new $v(s);
    }
    /**
     * Gets the detail result of pronunciation assessment.
     * @member PronunciationAssessmentConfig.prototype.detailResult
     * @function
     * @public
     * @returns {DetailResult} detail result.
     */
    get detailResult() {
      return this.privPronJson;
    }
    /**
     * The score indicating the pronunciation accuracy of the given speech, which indicates
     * how closely the phonemes match a native speaker's pronunciation.
     * @member PronunciationAssessmentResult.prototype.accuracyScore
     * @function
     * @public
     * @returns {number} Accuracy score.
     */
    get accuracyScore() {
      return this.detailResult.PronunciationAssessment?.AccuracyScore;
    }
    /**
     * The overall score indicating the pronunciation quality of the given speech.
     * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
     * @member PronunciationAssessmentResult.prototype.pronunciationScore
     * @function
     * @public
     * @returns {number} Pronunciation score.
     */
    get pronunciationScore() {
      return this.detailResult.PronunciationAssessment?.PronScore;
    }
    /**
     * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
     * @member PronunciationAssessmentResult.prototype.completenessScore
     * @function
     * @public
     * @returns {number} Completeness score.
     */
    get completenessScore() {
      return this.detailResult.PronunciationAssessment?.CompletenessScore;
    }
    /**
     * The score indicating the fluency of the given speech.
     * @member PronunciationAssessmentResult.prototype.fluencyScore
     * @function
     * @public
     * @returns {number} Fluency score.
     */
    get fluencyScore() {
      return this.detailResult.PronunciationAssessment?.FluencyScore;
    }
    /**
     * The prosody score, which indicates how nature of the given speech, including stress, intonation, speaking speed and rhythm.
     * @member PronunciationAssessmentResult.prototype.prosodyScore
     * @function
     * @public
     * @returns {number} Prosody score.
     */
    get prosodyScore() {
      return this.detailResult.PronunciationAssessment?.ProsodyScore;
    }
    /**
     * The concent assessment result.
     * Only available when content assessment is enabled.
     * @member PronunciationAssessmentResult.prototype.contentAssessmentResult
     * @function
     * @public
     * @returns {ContentAssessmentResult} Content assessment result.
     */
    get contentAssessmentResult() {
      if (this.detailResult.ContentAssessment !== void 0)
        return new r(this.detailResult);
    }
  };
  return Et.PronunciationAssessmentResult = o, Et;
}
var oi = {}, ed;
function HP() {
  if (ed) return oi;
  ed = 1, Object.defineProperty(oi, "__esModule", { value: !0 }), oi.AvatarConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} character - The avatar character.
     * @param {string} style - The avatar style.
     * @param {AvatarVideoFormat} videoFormat - The talking avatar output video format.
     */
    constructor(i, a, s) {
      this.privCustomized = !1, this.privUseBuiltInVoice = !1, e.Contracts.throwIfNullOrWhitespace(i, "character"), this.character = i, this.style = a, s === void 0 && (s = new t.AvatarVideoFormat()), this.videoFormat = s;
    }
    /**
     * Indicates if the talking avatar is customized.
     */
    get customized() {
      return this.privCustomized;
    }
    /**
     * Sets if the talking avatar is customized.
     */
    set customized(i) {
      this.privCustomized = i;
    }
    /**
     * Indicates whether to use built-in voice for custom avatar.
     */
    get useBuiltInVoice() {
      return this.privUseBuiltInVoice;
    }
    /**
     * Sets whether to use built-in voice for custom avatar.
     */
    set useBuiltInVoice(i) {
      this.privUseBuiltInVoice = i;
    }
    /**
     * Gets the background color.
     */
    get backgroundColor() {
      return this.privBackgroundColor;
    }
    /**
     * Sets the background color.
     */
    set backgroundColor(i) {
      this.privBackgroundColor = i;
    }
    /**
     * Gets the background image.
     */
    get backgroundImage() {
      return this.privBackgroundImage;
    }
    /**
     * Sets the background image.
     * @param {URL} value - The background image.
     */
    set backgroundImage(i) {
      this.privBackgroundImage = i;
    }
    /**
     * Gets the remote ICE servers.
     * @remarks This method is designed to be used internally in the SDK.
     * @returns {RTCIceServer[]} The remote ICE servers.
     */
    get remoteIceServers() {
      return this.privRemoteIceServers;
    }
    /**
     * Sets the remote ICE servers.
     * @remarks Normally, the ICE servers are gathered from the PeerConnection,
     * set this property to override the ICE servers. E.g., the ICE servers are
     * different in client and server side.
     * @param {RTCIceServer[]} value - The remote ICE servers.
     */
    set remoteIceServers(i) {
      this.privRemoteIceServers = i;
    }
  };
  return oi.AvatarConfig = r, oi;
}
var ua = {}, td;
function KP() {
  return td || (td = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AvatarEventArgs = e.AvatarEventTypes = void 0, function(r) {
      r.SwitchedToSpeaking = "SwitchedToSpeaking", r.SwitchedToIdle = "SwitchedToIdle", r.SessionClosed = "SessionClosed";
    }(e.AvatarEventTypes || (e.AvatarEventTypes = {}));
    class t {
      /**
       * Creates and initializes an instance of this class.
       * @constructor
       * @param {number} audioOffset - The audio offset.
       * @param {string} description - The description of the event.
       */
      constructor(o, i) {
        this.privOffset = o, this.privDescription = i;
      }
      /**
       * The type of the event.
       * @public
       * @returns {AvatarEventTypes} The type of the event.
       */
      get type() {
        return this.privType;
      }
      /**
       * The time offset associated with this event.
       * @public
       * @returns {number} The time offset associated with this event.
       */
      get offset() {
        return this.privOffset;
      }
      /**
       * The description of the event.
       * @public
       * @returns {string} The description of the event.
       */
      get description() {
        return this.privDescription;
      }
    }
    e.AvatarEventArgs = t;
  }(ua)), ua;
}
var ai = {}, ci = {}, rd;
function Vv() {
  if (rd) return ci;
  rd = 1, Object.defineProperty(ci, "__esModule", { value: !0 }), ci.SpeechSynthesisConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ le(), a = /* @__PURE__ */ tt();
  let s = class {
    constructor() {
      this.synthesisUri = "/tts/cognitiveservices/websocket/v1";
    }
    async create(c, u, l) {
      let p = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, void 0), d = r.ConnectionFactoryBase.getHostSuffix(h), f = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), g = f === void 0 ? "tts" : "voice", m = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + h + "." + g + ".speech" + d), v = {}, y = {};
      if (u.token !== void 0 && u.token !== "" && (y[u.headerName] = u.token), y[i.HeaderNames.ConnectionId] = l, f !== void 0 && f !== "" && (!p || p.search(a.QueryParameterNames.CustomVoiceDeploymentId) === -1) && (v[a.QueryParameterNames.CustomVoiceDeploymentId] = f), c.avatarEnabled && (!p || p.search(a.QueryParameterNames.EnableAvatar) === -1) && (v[a.QueryParameterNames.EnableAvatar] = "true"), p) {
        const C = new URL(p), P = C.pathname;
        (P === "" || P === "/") && (C.pathname = this.synthesisUri, p = await r.ConnectionFactoryBase.getRedirectUrlFromEndpoint(C.toString()));
      }
      p || (p = m + this.synthesisUri), c.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, p);
      const S = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new e.WebsocketConnection(p, v, y, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromParameters(c.parameters), S, l);
    }
  };
  return ci.SpeechSynthesisConnectionFactory = s, ci;
}
var nd;
function JP() {
  if (nd) return ai;
  nd = 1, Object.defineProperty(ai, "__esModule", { value: !0 }), ai.AvatarSynthesizer = void 0;
  const e = /* @__PURE__ */ Vv(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ M(), o = /* @__PURE__ */ Ps(), i = /* @__PURE__ */ I(), a = /* @__PURE__ */ z(), s = /* @__PURE__ */ gc();
  let n = class extends i.Synthesizer {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config.
     * @param {AvatarConfig} avatarConfig - The talking avatar config.
     */
    constructor(u, l) {
      super(u), a.Contracts.throwIfNullOrUndefined(l, "avatarConfig"), this.privConnectionFactory = new e.SpeechSynthesisConnectionFactory(), this.privAvatarConfig = l, this.implCommonSynthesizeSetup();
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(i.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);
    }
    /**
     * Starts the talking avatar session and establishes the WebRTC connection.
     * @member AvatarSynthesizer.prototype.startAvatarAsync
     * @function
     * @public
     * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.
     * @returns {Promise<SynthesisResult>} The promise of the connection result.
     */
    async startAvatarAsync(u) {
      a.Contracts.throwIfNullOrUndefined(u, "peerConnection"), this.privIceServers = u.getConfiguration().iceServers, a.Contracts.throwIfNullOrUndefined(this.privIceServers, "Ice servers must be set.");
      const l = new r.Deferred();
      u.onicegatheringstatechange = () => {
        r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering state: " + u.iceGatheringState, r.EventType.Debug)), u.iceGatheringState === "complete" && (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering complete.", r.EventType.Info)), l.resolve());
      }, u.onicecandidate = (g) => {
        g.candidate ? r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice candidate: " + g.candidate.candidate, r.EventType.Debug)) : (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice candidate: complete", r.EventType.Debug)), l.resolve());
      }, setTimeout(() => {
        u.iceGatheringState !== "complete" && (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering timeout.", r.EventType.Warning)), l.resolve());
      }, 2e3);
      const p = await u.createOffer();
      await u.setLocalDescription(p), await l.promise, r.Events.instance.onEvent(new r.PlatformEvent("peer connection: got local SDP.", r.EventType.Info)), this.privProperties.setProperty(i.PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(u.localDescription));
      const h = await this.speak("", !1);
      if (h.reason !== i.ResultReason.SynthesizingAudioCompleted)
        return new i.SynthesisResult(h.resultId, h.reason, h.errorDetails, h.properties);
      const d = atob(h.properties.getProperty(i.PropertyId.TalkingAvatarService_WebRTC_SDP)), f = new RTCSessionDescription(JSON.parse(d));
      return await u.setRemoteDescription(f), new i.SynthesisResult(h.resultId, h.reason, void 0, h.properties);
    }
    /**
     * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param {string} text - The plain text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakTextAsync(u) {
      const l = await this.speak(u, !1);
      return new i.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
    }
    /**
     * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param {string} ssml - The SSML text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakSsmlAsync(u) {
      const l = await this.speak(u, !0);
      return new i.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
    }
    /**
     * Speaks text asynchronously. The avatar will switch to idle state.
     * @member AvatarSynthesizer.prototype.stopSpeakingAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopSpeakingAsync() {
      for (; this.synthesisRequestQueue.length() > 0; )
        (await this.synthesisRequestQueue.dequeue()).err("Synthesis is canceled by user.");
      return this.privAdapter.stopSpeaking();
    }
    /**
     * Stops the talking avatar session and closes the WebRTC connection.
     * For now, this is the same as close().
     * You need to create a new AvatarSynthesizer instance to start a new session.
     * @member AvatarSynthesizer.prototype.stopAvatarAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopAvatarAsync() {
      return a.Contracts.throwIfDisposed(this.privDisposed), this.dispose(!0);
    }
    /**
     * Dispose of associated resources.
     * @member AvatarSynthesizer.prototype.close
     * @function
     * @public
     */
    async close() {
      if (!this.privDisposed)
        return this.dispose(!0);
    }
    /**
     * Gets the ICE servers. Internal use only.
     */
    get iceServers() {
      return this.privIceServers;
    }
    // Creates the synthesis adapter
    createSynthesisAdapter(u, l, p) {
      return new t.AvatarSynthesisAdapter(u, l, p, this, this.privAvatarConfig);
    }
    createRestSynthesisAdapter(u, l) {
    }
    createSynthesizerConfig(u) {
      const l = super.createSynthesizerConfig(u);
      return l.avatarEnabled = !0, l;
    }
    async speak(u, l) {
      const p = (0, r.createNoDashGuid)(), h = new r.Deferred();
      return this.synthesisRequestQueue.enqueue(new s.SynthesisRequest(p, u, l, (d) => {
        h.resolve(d), this.privSynthesizing = !1, this.adapterSpeak();
      }, (d) => {
        h.reject(d), this.privSynthesizing = !1;
      })), this.adapterSpeak(), h.promise;
    }
  };
  return ai.AvatarSynthesizer = n, ai;
}
var It = {}, id;
function GP() {
  if (id) return It;
  id = 1, Object.defineProperty(It, "__esModule", { value: !0 }), It.AvatarVideoFormat = It.Coordinate = void 0;
  class e {
    constructor(o, i) {
      this.x = o, this.y = i;
    }
  }
  It.Coordinate = e;
  let t = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} codec - The video codec.
     * @param {number} bitrate - The video bitrate.
     * @param {number} width - The video width.
     * @param {number} height - The video height.
     */
    constructor(o = "H264", i = 2e6, a = 1920, s = 1080) {
      this.codec = o, this.bitrate = i, this.width = a, this.height = s;
    }
    /**
     * Sets the video crop range.
     */
    setCropRange(o, i) {
      this.cropRange = {
        bottomRight: i,
        topLeft: o
      };
    }
  };
  return It.AvatarVideoFormat = t, It;
}
var ui = {}, sd;
function QP() {
  if (sd) return ui;
  sd = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.AvatarWebRTCConnectionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {RTCSessionDescriptionInit} SDPAnswer - The SDP answer of WebRTC connection.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n) {
      super(i, a, s, n), this.privSDPAnswer = o;
    }
    /**
     * Specifies SDP (Session Description Protocol) answer of WebRTC connection.
     * @member AvatarWebRTCConnectionResult.prototype.SDPAnswer
     * @function
     * @public
     * @returns {RTCSessionDescriptionInit} Specifies the SDP answer of WebRTC connection.
     */
    get SDPAnswer() {
      return this.privSDPAnswer;
    }
  };
  return ui.AvatarWebRTCConnectionResult = t, ui;
}
var li = {}, od;
function YP() {
  if (od) return li;
  od = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.Diagnostics = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ M();
  let r = class {
    static SetLoggingLevel(i) {
      this.privListener = new e.ConsoleLoggingListener(i), t.Events.instance.attachConsoleListener(this.privListener);
    }
    static StartConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !0);
    }
    static StopConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !1);
    }
    static SetLogOutputPath(i) {
      if (typeof window > "u")
        this.privListener && (this.privListener.logPath = i);
      else
        throw new Error("File system logging not available in browser.");
    }
    static set onLogOutput(i) {
      this.privListener && (this.privListener.logCallback = i);
    }
  };
  return li.Diagnostics = r, r.privListener = void 0, li;
}
var ad;
function I() {
  return ad || (ad = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionEventArgs = e.CancellationErrorCode = e.CancellationDetails = e.CancellationDetailsBase = e.IntentRecognitionCanceledEventArgs = e.TranslationRecognitionCanceledEventArgs = e.NoMatchDetails = e.NoMatchReason = e.Translations = e.TranslationRecognizer = e.VoiceProfileType = e.IntentRecognizer = e.SpeechRecognizer = e.Recognizer = e.PropertyId = e.PropertyCollection = e.SpeechTranslationConfigImpl = e.SpeechTranslationConfig = e.SpeechConfigImpl = e.SpeechConfig = e.ResultReason = e.TranslationSynthesisResult = e.TranslationRecognitionResult = e.TranslationSynthesisEventArgs = e.TranslationRecognitionEventArgs = e.SpeechRecognitionCanceledEventArgs = e.MeetingTranscriptionEventArgs = e.ConversationTranscriptionEventArgs = e.SpeechRecognitionEventArgs = e.LanguageUnderstandingModel = e.IntentRecognitionResult = e.SpeechRecognitionResult = e.RecognitionResult = e.IntentRecognitionEventArgs = e.OutputFormat = e.RecognitionEventArgs = e.SessionEventArgs = e.KeywordRecognitionModel = e.PushAudioOutputStreamCallback = e.PullAudioInputStreamCallback = e.CancellationReason = e.PushAudioOutputStream = e.PullAudioOutputStream = e.AudioOutputStream = e.PushAudioInputStream = e.PullAudioInputStream = e.AudioInputStream = e.AudioFormatTag = e.AudioStreamFormat = e.AudioConfig = void 0, e.SpeechSynthesisEventArgs = e.SpeechSynthesisResult = e.SynthesisResult = e.SpeechSynthesizer = e.SpeechSynthesisOutputFormat = e.Synthesizer = e.User = e.ParticipantChangedReason = e.Participant = e.MeetingTranscriber = e.Meeting = e.ConversationTranscriptionResult = e.ConversationTranscriber = e.ConversationTranslator = e.ConversationTranslationResult = e.ConversationTranslationEventArgs = e.ConversationTranslationCanceledEventArgs = e.ConversationParticipantsChangedEventArgs = e.ConversationExpirationEventArgs = e.Conversation = e.SpeakerRecognitionCancellationDetails = e.SpeakerRecognitionResultType = e.SpeakerRecognitionResult = e.SourceLanguageConfig = e.AutoDetectSourceLanguageResult = e.AutoDetectSourceLanguageConfig = e.SpeakerVerificationModel = e.SpeakerIdentificationModel = e.SpeakerRecognizer = e.VoiceProfileClient = e.VoiceProfilePhraseResult = e.VoiceProfileCancellationDetails = e.VoiceProfileResult = e.VoiceProfileEnrollmentCancellationDetails = e.VoiceProfileEnrollmentResult = e.VoiceProfile = e.ConnectionMessage = e.ConnectionMessageEventArgs = e.BaseAudioPlayer = e.ProfanityOption = e.ServicePropertyChannel = e.TurnStatusReceivedEventArgs = e.ActivityReceivedEventArgs = e.DialogServiceConnector = e.CustomCommandsConfig = e.BotFrameworkConfig = e.DialogServiceConfig = e.PhraseListGrammar = e.Connection = e.ServiceEventArgs = void 0, e.LogLevel = e.Diagnostics = e.AvatarWebRTCConnectionResult = e.Coordinate = e.AvatarVideoFormat = e.AvatarSynthesizer = e.AvatarEventArgs = e.AvatarConfig = e.LanguageIdMode = e.PronunciationAssessmentResult = e.PronunciationAssessmentConfig = e.PronunciationAssessmentGranularity = e.PronunciationAssessmentGradingSystem = e.MeetingTranscriptionCanceledEventArgs = e.ConversationTranscriptionCanceledEventArgs = e.SpeakerAudioDestination = e.VoiceInfo = e.SynthesisVoiceType = e.SynthesisVoiceGender = e.SynthesisVoicesResult = e.SpeechSynthesisBoundaryType = e.SpeechSynthesisVisemeEventArgs = e.SpeechSynthesisBookmarkEventArgs = e.SpeechSynthesisWordBoundaryEventArgs = void 0;
    var t = /* @__PURE__ */ yv();
    Object.defineProperty(e, "AudioConfig", { enumerable: !0, get: function() {
      return t.AudioConfig;
    } });
    var r = /* @__PURE__ */ zt();
    Object.defineProperty(e, "AudioStreamFormat", { enumerable: !0, get: function() {
      return r.AudioStreamFormat;
    } }), Object.defineProperty(e, "AudioFormatTag", { enumerable: !0, get: function() {
      return r.AudioFormatTag;
    } });
    var o = /* @__PURE__ */ vv();
    Object.defineProperty(e, "AudioInputStream", { enumerable: !0, get: function() {
      return o.AudioInputStream;
    } }), Object.defineProperty(e, "PullAudioInputStream", { enumerable: !0, get: function() {
      return o.PullAudioInputStream;
    } }), Object.defineProperty(e, "PushAudioInputStream", { enumerable: !0, get: function() {
      return o.PushAudioInputStream;
    } });
    var i = /* @__PURE__ */ Kt();
    Object.defineProperty(e, "AudioOutputStream", { enumerable: !0, get: function() {
      return i.AudioOutputStream;
    } }), Object.defineProperty(e, "PullAudioOutputStream", { enumerable: !0, get: function() {
      return i.PullAudioOutputStream;
    } }), Object.defineProperty(e, "PushAudioOutputStream", { enumerable: !0, get: function() {
      return i.PushAudioOutputStream;
    } });
    var a = /* @__PURE__ */ lR();
    Object.defineProperty(e, "CancellationReason", { enumerable: !0, get: function() {
      return a.CancellationReason;
    } });
    var s = /* @__PURE__ */ pR();
    Object.defineProperty(e, "PullAudioInputStreamCallback", { enumerable: !0, get: function() {
      return s.PullAudioInputStreamCallback;
    } });
    var n = /* @__PURE__ */ dR();
    Object.defineProperty(e, "PushAudioOutputStreamCallback", { enumerable: !0, get: function() {
      return n.PushAudioOutputStreamCallback;
    } });
    var c = /* @__PURE__ */ hR();
    Object.defineProperty(e, "KeywordRecognitionModel", { enumerable: !0, get: function() {
      return c.KeywordRecognitionModel;
    } });
    var u = /* @__PURE__ */ fR();
    Object.defineProperty(e, "SessionEventArgs", { enumerable: !0, get: function() {
      return u.SessionEventArgs;
    } });
    var l = /* @__PURE__ */ vR();
    Object.defineProperty(e, "RecognitionEventArgs", { enumerable: !0, get: function() {
      return l.RecognitionEventArgs;
    } });
    var p = /* @__PURE__ */ gR();
    Object.defineProperty(e, "OutputFormat", { enumerable: !0, get: function() {
      return p.OutputFormat;
    } });
    var h = /* @__PURE__ */ mR();
    Object.defineProperty(e, "IntentRecognitionEventArgs", { enumerable: !0, get: function() {
      return h.IntentRecognitionEventArgs;
    } });
    var d = /* @__PURE__ */ yR();
    Object.defineProperty(e, "RecognitionResult", { enumerable: !0, get: function() {
      return d.RecognitionResult;
    } });
    var f = /* @__PURE__ */ SR();
    Object.defineProperty(e, "SpeechRecognitionResult", { enumerable: !0, get: function() {
      return f.SpeechRecognitionResult;
    } });
    var g = /* @__PURE__ */ CR();
    Object.defineProperty(e, "IntentRecognitionResult", { enumerable: !0, get: function() {
      return g.IntentRecognitionResult;
    } });
    var m = /* @__PURE__ */ RR();
    Object.defineProperty(e, "LanguageUnderstandingModel", { enumerable: !0, get: function() {
      return m.LanguageUnderstandingModel;
    } });
    var v = /* @__PURE__ */ PR();
    Object.defineProperty(e, "SpeechRecognitionEventArgs", { enumerable: !0, get: function() {
      return v.SpeechRecognitionEventArgs;
    } }), Object.defineProperty(e, "ConversationTranscriptionEventArgs", { enumerable: !0, get: function() {
      return v.ConversationTranscriptionEventArgs;
    } }), Object.defineProperty(e, "MeetingTranscriptionEventArgs", { enumerable: !0, get: function() {
      return v.MeetingTranscriptionEventArgs;
    } });
    var y = /* @__PURE__ */ wR();
    Object.defineProperty(e, "SpeechRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return y.SpeechRecognitionCanceledEventArgs;
    } });
    var S = /* @__PURE__ */ bR();
    Object.defineProperty(e, "TranslationRecognitionEventArgs", { enumerable: !0, get: function() {
      return S.TranslationRecognitionEventArgs;
    } });
    var C = /* @__PURE__ */ ER();
    Object.defineProperty(e, "TranslationSynthesisEventArgs", { enumerable: !0, get: function() {
      return C.TranslationSynthesisEventArgs;
    } });
    var P = /* @__PURE__ */ Cv();
    Object.defineProperty(e, "TranslationRecognitionResult", { enumerable: !0, get: function() {
      return P.TranslationRecognitionResult;
    } });
    var b = /* @__PURE__ */ IR();
    Object.defineProperty(e, "TranslationSynthesisResult", { enumerable: !0, get: function() {
      return b.TranslationSynthesisResult;
    } });
    var A = /* @__PURE__ */ AR();
    Object.defineProperty(e, "ResultReason", { enumerable: !0, get: function() {
      return A.ResultReason;
    } });
    var E = /* @__PURE__ */ TR();
    Object.defineProperty(e, "SpeechConfig", { enumerable: !0, get: function() {
      return E.SpeechConfig;
    } }), Object.defineProperty(e, "SpeechConfigImpl", { enumerable: !0, get: function() {
      return E.SpeechConfigImpl;
    } });
    var D = /* @__PURE__ */ _R();
    Object.defineProperty(e, "SpeechTranslationConfig", { enumerable: !0, get: function() {
      return D.SpeechTranslationConfig;
    } }), Object.defineProperty(e, "SpeechTranslationConfigImpl", { enumerable: !0, get: function() {
      return D.SpeechTranslationConfigImpl;
    } });
    var R = /* @__PURE__ */ Pv();
    Object.defineProperty(e, "PropertyCollection", { enumerable: !0, get: function() {
      return R.PropertyCollection;
    } });
    var j = /* @__PURE__ */ hc();
    Object.defineProperty(e, "PropertyId", { enumerable: !0, get: function() {
      return j.PropertyId;
    } });
    var T = /* @__PURE__ */ kR();
    Object.defineProperty(e, "Recognizer", { enumerable: !0, get: function() {
      return T.Recognizer;
    } });
    var x = /* @__PURE__ */ OR();
    Object.defineProperty(e, "SpeechRecognizer", { enumerable: !0, get: function() {
      return x.SpeechRecognizer;
    } });
    var q = /* @__PURE__ */ MR();
    Object.defineProperty(e, "IntentRecognizer", { enumerable: !0, get: function() {
      return q.IntentRecognizer;
    } });
    var pe = /* @__PURE__ */ DR();
    Object.defineProperty(e, "VoiceProfileType", { enumerable: !0, get: function() {
      return pe.VoiceProfileType;
    } });
    var W = /* @__PURE__ */ xR();
    Object.defineProperty(e, "TranslationRecognizer", { enumerable: !0, get: function() {
      return W.TranslationRecognizer;
    } });
    var G = /* @__PURE__ */ NR();
    Object.defineProperty(e, "Translations", { enumerable: !0, get: function() {
      return G.Translations;
    } });
    var ne = /* @__PURE__ */ zR();
    Object.defineProperty(e, "NoMatchReason", { enumerable: !0, get: function() {
      return ne.NoMatchReason;
    } });
    var oe = /* @__PURE__ */ LR();
    Object.defineProperty(e, "NoMatchDetails", { enumerable: !0, get: function() {
      return oe.NoMatchDetails;
    } });
    var ye = /* @__PURE__ */ jR();
    Object.defineProperty(e, "TranslationRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return ye.TranslationRecognitionCanceledEventArgs;
    } });
    var V = /* @__PURE__ */ qR();
    Object.defineProperty(e, "IntentRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return V.IntentRecognitionCanceledEventArgs;
    } });
    var te = /* @__PURE__ */ _v();
    Object.defineProperty(e, "CancellationDetailsBase", { enumerable: !0, get: function() {
      return te.CancellationDetailsBase;
    } });
    var Se = /* @__PURE__ */ FR();
    Object.defineProperty(e, "CancellationDetails", { enumerable: !0, get: function() {
      return Se.CancellationDetails;
    } });
    var Ce = /* @__PURE__ */ BR();
    Object.defineProperty(e, "CancellationErrorCode", { enumerable: !0, get: function() {
      return Ce.CancellationErrorCode;
    } });
    var Gt = /* @__PURE__ */ UR();
    Object.defineProperty(e, "ConnectionEventArgs", { enumerable: !0, get: function() {
      return Gt.ConnectionEventArgs;
    } });
    var Ne = /* @__PURE__ */ $R();
    Object.defineProperty(e, "ServiceEventArgs", { enumerable: !0, get: function() {
      return Ne.ServiceEventArgs;
    } });
    var ze = /* @__PURE__ */ Iv();
    Object.defineProperty(e, "Connection", { enumerable: !0, get: function() {
      return ze.Connection;
    } });
    var Lt = /* @__PURE__ */ VR();
    Object.defineProperty(e, "PhraseListGrammar", { enumerable: !0, get: function() {
      return Lt.PhraseListGrammar;
    } });
    var be = /* @__PURE__ */ fc();
    Object.defineProperty(e, "DialogServiceConfig", { enumerable: !0, get: function() {
      return be.DialogServiceConfig;
    } });
    var Qt = /* @__PURE__ */ WR();
    Object.defineProperty(e, "BotFrameworkConfig", { enumerable: !0, get: function() {
      return Qt.BotFrameworkConfig;
    } });
    var rt = /* @__PURE__ */ HR();
    Object.defineProperty(e, "CustomCommandsConfig", { enumerable: !0, get: function() {
      return rt.CustomCommandsConfig;
    } });
    var nt = /* @__PURE__ */ JR();
    Object.defineProperty(e, "DialogServiceConnector", { enumerable: !0, get: function() {
      return nt.DialogServiceConnector;
    } });
    var Ke = /* @__PURE__ */ GR();
    Object.defineProperty(e, "ActivityReceivedEventArgs", { enumerable: !0, get: function() {
      return Ke.ActivityReceivedEventArgs;
    } });
    var it = /* @__PURE__ */ YR();
    Object.defineProperty(e, "TurnStatusReceivedEventArgs", { enumerable: !0, get: function() {
      return it.TurnStatusReceivedEventArgs;
    } });
    var de = /* @__PURE__ */ ZR();
    Object.defineProperty(e, "ServicePropertyChannel", { enumerable: !0, get: function() {
      return de.ServicePropertyChannel;
    } });
    var bs = /* @__PURE__ */ XR();
    Object.defineProperty(e, "ProfanityOption", { enumerable: !0, get: function() {
      return bs.ProfanityOption;
    } });
    var Es = /* @__PURE__ */ eP();
    Object.defineProperty(e, "BaseAudioPlayer", { enumerable: !0, get: function() {
      return Es.BaseAudioPlayer;
    } });
    var Is = /* @__PURE__ */ tP();
    Object.defineProperty(e, "ConnectionMessageEventArgs", { enumerable: !0, get: function() {
      return Is.ConnectionMessageEventArgs;
    } });
    var jt = /* @__PURE__ */ Ev();
    Object.defineProperty(e, "ConnectionMessage", { enumerable: !0, get: function() {
      return jt.ConnectionMessage;
    } });
    var Oe = /* @__PURE__ */ rP();
    Object.defineProperty(e, "VoiceProfile", { enumerable: !0, get: function() {
      return Oe.VoiceProfile;
    } });
    var Je = /* @__PURE__ */ nP();
    Object.defineProperty(e, "VoiceProfileEnrollmentResult", { enumerable: !0, get: function() {
      return Je.VoiceProfileEnrollmentResult;
    } }), Object.defineProperty(e, "VoiceProfileEnrollmentCancellationDetails", { enumerable: !0, get: function() {
      return Je.VoiceProfileEnrollmentCancellationDetails;
    } });
    var ae = /* @__PURE__ */ iP();
    Object.defineProperty(e, "VoiceProfileResult", { enumerable: !0, get: function() {
      return ae.VoiceProfileResult;
    } }), Object.defineProperty(e, "VoiceProfileCancellationDetails", { enumerable: !0, get: function() {
      return ae.VoiceProfileCancellationDetails;
    } });
    var Yt = /* @__PURE__ */ sP();
    Object.defineProperty(e, "VoiceProfilePhraseResult", { enumerable: !0, get: function() {
      return Yt.VoiceProfilePhraseResult;
    } });
    var F = /* @__PURE__ */ oP();
    Object.defineProperty(e, "VoiceProfileClient", { enumerable: !0, get: function() {
      return F.VoiceProfileClient;
    } });
    var X = /* @__PURE__ */ aP();
    Object.defineProperty(e, "SpeakerRecognizer", { enumerable: !0, get: function() {
      return X.SpeakerRecognizer;
    } });
    var qt = /* @__PURE__ */ cP();
    Object.defineProperty(e, "SpeakerIdentificationModel", { enumerable: !0, get: function() {
      return qt.SpeakerIdentificationModel;
    } });
    var As = /* @__PURE__ */ uP();
    Object.defineProperty(e, "SpeakerVerificationModel", { enumerable: !0, get: function() {
      return As.SpeakerVerificationModel;
    } });
    var ro = /* @__PURE__ */ lP();
    Object.defineProperty(e, "AutoDetectSourceLanguageConfig", { enumerable: !0, get: function() {
      return ro.AutoDetectSourceLanguageConfig;
    } });
    var st = /* @__PURE__ */ pP();
    Object.defineProperty(e, "AutoDetectSourceLanguageResult", { enumerable: !0, get: function() {
      return st.AutoDetectSourceLanguageResult;
    } });
    var no = /* @__PURE__ */ dP();
    Object.defineProperty(e, "SourceLanguageConfig", { enumerable: !0, get: function() {
      return no.SourceLanguageConfig;
    } });
    var Zt = /* @__PURE__ */ hP();
    Object.defineProperty(e, "SpeakerRecognitionResult", { enumerable: !0, get: function() {
      return Zt.SpeakerRecognitionResult;
    } }), Object.defineProperty(e, "SpeakerRecognitionResultType", { enumerable: !0, get: function() {
      return Zt.SpeakerRecognitionResultType;
    } }), Object.defineProperty(e, "SpeakerRecognitionCancellationDetails", { enumerable: !0, get: function() {
      return Zt.SpeakerRecognitionCancellationDetails;
    } });
    var ie = /* @__PURE__ */ vc();
    Object.defineProperty(e, "Conversation", { enumerable: !0, get: function() {
      return ie.Conversation;
    } }), Object.defineProperty(e, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return ie.ConversationExpirationEventArgs;
    } }), Object.defineProperty(e, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return ie.ConversationParticipantsChangedEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return ie.ConversationTranslationCanceledEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return ie.ConversationTranslationEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return ie.ConversationTranslationResult;
    } }), Object.defineProperty(e, "ConversationTranslator", { enumerable: !0, get: function() {
      return ie.ConversationTranslator;
    } }), Object.defineProperty(e, "ConversationTranscriber", { enumerable: !0, get: function() {
      return ie.ConversationTranscriber;
    } }), Object.defineProperty(e, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return ie.ConversationTranscriptionResult;
    } }), Object.defineProperty(e, "Meeting", { enumerable: !0, get: function() {
      return ie.Meeting;
    } }), Object.defineProperty(e, "MeetingTranscriber", { enumerable: !0, get: function() {
      return ie.MeetingTranscriber;
    } }), Object.defineProperty(e, "Participant", { enumerable: !0, get: function() {
      return ie.Participant;
    } }), Object.defineProperty(e, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return ie.ParticipantChangedReason;
    } }), Object.defineProperty(e, "User", { enumerable: !0, get: function() {
      return ie.User;
    } });
    var Xt = /* @__PURE__ */ gc();
    Object.defineProperty(e, "Synthesizer", { enumerable: !0, get: function() {
      return Xt.Synthesizer;
    } });
    var Ts = /* @__PURE__ */ gv();
    Object.defineProperty(e, "SpeechSynthesisOutputFormat", { enumerable: !0, get: function() {
      return Ts.SpeechSynthesisOutputFormat;
    } });
    var ot = /* @__PURE__ */ _P();
    Object.defineProperty(e, "SpeechSynthesizer", { enumerable: !0, get: function() {
      return ot.SpeechSynthesizer;
    } });
    var io = /* @__PURE__ */ kP();
    Object.defineProperty(e, "SynthesisResult", { enumerable: !0, get: function() {
      return io.SynthesisResult;
    } });
    var so = /* @__PURE__ */ OP();
    Object.defineProperty(e, "SpeechSynthesisResult", { enumerable: !0, get: function() {
      return so.SpeechSynthesisResult;
    } });
    var _s = /* @__PURE__ */ MP();
    Object.defineProperty(e, "SpeechSynthesisEventArgs", { enumerable: !0, get: function() {
      return _s.SpeechSynthesisEventArgs;
    } });
    var oo = /* @__PURE__ */ DP();
    Object.defineProperty(e, "SpeechSynthesisWordBoundaryEventArgs", { enumerable: !0, get: function() {
      return oo.SpeechSynthesisWordBoundaryEventArgs;
    } });
    var $ = /* @__PURE__ */ xP();
    Object.defineProperty(e, "SpeechSynthesisBookmarkEventArgs", { enumerable: !0, get: function() {
      return $.SpeechSynthesisBookmarkEventArgs;
    } });
    var ee = /* @__PURE__ */ NP();
    Object.defineProperty(e, "SpeechSynthesisVisemeEventArgs", { enumerable: !0, get: function() {
      return ee.SpeechSynthesisVisemeEventArgs;
    } });
    var H = /* @__PURE__ */ zP();
    Object.defineProperty(e, "SpeechSynthesisBoundaryType", { enumerable: !0, get: function() {
      return H.SpeechSynthesisBoundaryType;
    } });
    var he = /* @__PURE__ */ LP();
    Object.defineProperty(e, "SynthesisVoicesResult", { enumerable: !0, get: function() {
      return he.SynthesisVoicesResult;
    } });
    var Le = /* @__PURE__ */ jP();
    Object.defineProperty(e, "SynthesisVoiceGender", { enumerable: !0, get: function() {
      return Le.SynthesisVoiceGender;
    } }), Object.defineProperty(e, "SynthesisVoiceType", { enumerable: !0, get: function() {
      return Le.SynthesisVoiceType;
    } }), Object.defineProperty(e, "VoiceInfo", { enumerable: !0, get: function() {
      return Le.VoiceInfo;
    } });
    var J = /* @__PURE__ */ qP();
    Object.defineProperty(e, "SpeakerAudioDestination", { enumerable: !0, get: function() {
      return J.SpeakerAudioDestination;
    } });
    var Ee = /* @__PURE__ */ FP();
    Object.defineProperty(e, "ConversationTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return Ee.ConversationTranscriptionCanceledEventArgs;
    } });
    var Re = /* @__PURE__ */ BP();
    Object.defineProperty(e, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return Re.MeetingTranscriptionCanceledEventArgs;
    } });
    var er = /* @__PURE__ */ UP();
    Object.defineProperty(e, "PronunciationAssessmentGradingSystem", { enumerable: !0, get: function() {
      return er.PronunciationAssessmentGradingSystem;
    } });
    var ao = /* @__PURE__ */ $P();
    Object.defineProperty(e, "PronunciationAssessmentGranularity", { enumerable: !0, get: function() {
      return ao.PronunciationAssessmentGranularity;
    } });
    var co = /* @__PURE__ */ VP();
    Object.defineProperty(e, "PronunciationAssessmentConfig", { enumerable: !0, get: function() {
      return co.PronunciationAssessmentConfig;
    } });
    var uo = /* @__PURE__ */ WP();
    Object.defineProperty(e, "PronunciationAssessmentResult", { enumerable: !0, get: function() {
      return uo.PronunciationAssessmentResult;
    } });
    var lo = /* @__PURE__ */ xv();
    Object.defineProperty(e, "LanguageIdMode", { enumerable: !0, get: function() {
      return lo.LanguageIdMode;
    } });
    var po = /* @__PURE__ */ HP();
    Object.defineProperty(e, "AvatarConfig", { enumerable: !0, get: function() {
      return po.AvatarConfig;
    } });
    var ho = /* @__PURE__ */ KP();
    Object.defineProperty(e, "AvatarEventArgs", { enumerable: !0, get: function() {
      return ho.AvatarEventArgs;
    } });
    var fo = /* @__PURE__ */ JP();
    Object.defineProperty(e, "AvatarSynthesizer", { enumerable: !0, get: function() {
      return fo.AvatarSynthesizer;
    } });
    var ks = /* @__PURE__ */ GP();
    Object.defineProperty(e, "AvatarVideoFormat", { enumerable: !0, get: function() {
      return ks.AvatarVideoFormat;
    } }), Object.defineProperty(e, "Coordinate", { enumerable: !0, get: function() {
      return ks.Coordinate;
    } });
    var Pg = /* @__PURE__ */ QP();
    Object.defineProperty(e, "AvatarWebRTCConnectionResult", { enumerable: !0, get: function() {
      return Pg.AvatarWebRTCConnectionResult;
    } });
    var wg = /* @__PURE__ */ YP();
    Object.defineProperty(e, "Diagnostics", { enumerable: !0, get: function() {
      return wg.Diagnostics;
    } });
    var bg = /* @__PURE__ */ dv();
    Object.defineProperty(e, "LogLevel", { enumerable: !0, get: function() {
      return bg.LogLevel;
    } });
  }(Uo)), Uo;
}
var cd;
function ZP() {
  if (cd) return Lr;
  cd = 1, Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.ProxyInfo = void 0;
  const e = /* @__PURE__ */ I();
  let t = class Wv {
    constructor(o, i, a, s) {
      this.privProxyHostName = o, this.privProxyPort = i, this.privProxyUserName = a, this.privProxyPassword = s;
    }
    static fromParameters(o) {
      return new Wv(o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyPort), 10), o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyUserName), o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyPassword));
    }
    static fromRecognizerConfig(o) {
      return this.fromParameters(o.parameters);
    }
    get HostName() {
      return this.privProxyHostName;
    }
    get Port() {
      return this.privProxyPort;
    }
    get UserName() {
      return this.privProxyUserName;
    }
    get Password() {
      return this.privProxyPassword;
    }
  };
  return Lr.ProxyInfo = t, Lr;
}
var pi = {}, la, ud;
function XP() {
  if (ud) return la;
  ud = 1;
  const e = /* @__PURE__ */ new Set(["json", "buffer", "string"]);
  return la = (t) => (...r) => {
    const o = /* @__PURE__ */ new Set();
    let i, a, s, n = "";
    return r.forEach((c) => {
      if (typeof c == "string")
        if (c.toUpperCase() === c)
          if (i) {
            const u = `Can't set method to ${c}, already set to ${i}.`;
            throw new Error(u);
          } else
            i = c;
        else if (c.startsWith("http:") || c.startsWith("https:"))
          n = c;
        else if (e.has(c))
          a = c;
        else
          throw new Error(`Unknown encoding, ${c}`);
      else if (typeof c == "number")
        o.add(c);
      else if (typeof c == "object")
        if (Array.isArray(c) || c instanceof Set)
          c.forEach((u) => o.add(u));
        else {
          if (s)
            throw new Error("Cannot set headers twice.");
          s = c;
        }
      else
        throw new Error(`Unknown type: ${typeof c}`);
    }), i || (i = "GET"), o.size === 0 && o.add(200), t(o, i, a, s, n);
  }, la;
}
var pa, ld;
function ew() {
  if (ld) return pa;
  ld = 1;
  const e = XP();
  class t extends Error {
    constructor(i, ...a) {
      super(...a), Error.captureStackTrace && Error.captureStackTrace(this, t), this.name = "StatusError", this.message = i.statusMessage, this.statusCode = i.status, this.res = i, this.json = i.json.bind(i), this.text = i.text.bind(i), this.arrayBuffer = i.arrayBuffer.bind(i);
      let s;
      Object.defineProperty(this, "responseBody", { get: () => (s || (s = this.arrayBuffer()), s) }), this.headers = {};
      for (const [c, u] of i.headers.entries())
        this.headers[c.toLowerCase()] = u;
    }
  }
  return pa = e((o, i, a, s, n) => async (c, u, l = {}) => {
    c = n + (c || "");
    let p = new URL(c);
    if (s || (s = {}), p.username && (s.Authorization = "Basic " + btoa(p.username + ":" + p.password), p = new URL(p.protocol + "//" + p.host + p.pathname + p.search)), p.protocol !== "https:" && p.protocol !== "http:")
      throw new Error(`Unknown protocol, ${p.protocol}`);
    if (u && !(u instanceof ArrayBuffer || ArrayBuffer.isView(u) || typeof u == "string"))
      if (typeof u == "object")
        u = JSON.stringify(u), s["Content-Type"] = "application/json";
      else
        throw new Error("Unknown body type.");
    l = new Headers({ ...s || {}, ...l });
    const h = await fetch(p, { method: i, headers: l, body: u });
    if (h.statusCode = h.status, !o.has(h.status))
      throw new t(h);
    return a === "json" ? h.json() : a === "buffer" ? h.arrayBuffer() : a === "string" ? h.text() : h;
  }), pa;
}
var pd;
function tw() {
  return pd || (pd = 1, function(e) {
    var t = pi && pi.__importDefault || function(s) {
      return s && s.__esModule ? s : { default: s };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RestMessageAdapter = e.RestRequestType = void 0;
    const r = t(ew()), o = /* @__PURE__ */ M();
    var i;
    (function(s) {
      s.Get = "GET", s.Post = "POST", s.Delete = "DELETE", s.File = "file";
    })(i = e.RestRequestType || (e.RestRequestType = {}));
    let a = class {
      constructor(n) {
        if (!n)
          throw new o.ArgumentNullError("configParams");
        this.privHeaders = n.headers, this.privIgnoreCache = n.ignoreCache;
      }
      static extractHeaderValue(n, c) {
        let u = "";
        try {
          const l = c.trim().split(/[\r\n]+/), p = {};
          l.forEach((h) => {
            const d = h.split(": "), f = d.shift().toLowerCase(), g = d.join(": ");
            p[f] = g;
          }), u = p[n.toLowerCase()];
        } catch {
        }
        return u;
      }
      set options(n) {
        this.privHeaders = n.headers, this.privIgnoreCache = n.ignoreCache;
      }
      setHeaders(n, c) {
        this.privHeaders[n] = c;
      }
      request(n, c, u = {}, l = null) {
        const p = new o.Deferred(), h = n === i.File ? "POST" : n, d = (g, m = {}) => {
          const v = g;
          return {
            data: JSON.stringify(m),
            headers: JSON.stringify(g.headers),
            json: m,
            ok: g.statusCode >= 200 && g.statusCode < 300,
            status: g.statusCode,
            statusText: m.error ? m.error.message : v.statusText ? v.statusText : v.statusMessage
          };
        }, f = (g) => {
          const m = (0, r.default)(c, h, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404), v = this.queryParams(u) === "" ? "" : `?${this.queryParams(u)}`;
          m(v, g).then(async (y) => {
            if (n === i.Delete || y.statusCode === 204)
              p.resolve(d(y));
            else
              try {
                const S = await y.json();
                p.resolve(d(y, S));
              } catch {
                p.resolve(d(y));
              }
          }).catch((y) => {
            p.reject(y);
          });
        };
        return this.privIgnoreCache && (this.privHeaders["Cache-Control"] = "no-cache"), n === i.Post && l && (this.privHeaders["content-type"] = "application/json", this.privHeaders["Content-Type"] = "application/json"), f(l), p.promise;
      }
      queryParams(n = {}) {
        return Object.keys(n).map((c) => encodeURIComponent(c) + "=" + encodeURIComponent(n[c])).join("&");
      }
    };
    e.RestMessageAdapter = a;
  }(pi)), pi;
}
var di = {}, dd;
function Hv() {
  if (dd) return di;
  dd = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.RestConfigBase = void 0;
  let e = class Ls {
    static get requestOptions() {
      return Ls.privDefaultRequestOptions;
    }
    static get configParams() {
      return Ls.privDefaultParams;
    }
    static get restErrors() {
      return Ls.privRestErrors;
    }
  };
  return di.RestConfigBase = e, e.privDefaultRequestOptions = {
    headers: {
      Accept: "application/json"
    },
    ignoreCache: !1,
    timeout: 1e4
  }, e.privRestErrors = {
    authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
    authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
    invalidArgs: "Required input not found: {arg}.",
    invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
    invalidParticipantRequest: "The requested participant was not found.",
    permissionDeniedConnect: "Required credentials not found.",
    permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
    permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
    permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
    permissionDeniedStart: "Invalid operation: there is already an active conversation."
  }, e.privDefaultParams = {
    apiVersion: "api-version",
    authorization: "Authorization",
    clientAppId: "X-ClientAppId",
    contentTypeKey: "Content-Type",
    correlationId: "X-CorrelationId",
    languageCode: "language",
    nickname: "nickname",
    profanity: "profanity",
    requestId: "X-RequestId",
    roomId: "roomid",
    sessionToken: "token",
    subscriptionKey: "Ocp-Apim-Subscription-Key",
    subscriptionRegion: "Ocp-Apim-Subscription-Region",
    token: "X-CapitoToken"
  }, di;
}
var hd;
function re() {
  return hd || (hd = 1, function(e) {
    var t = ht && ht.__createBinding || (Object.create ? function(o, i, a, s) {
      s === void 0 && (s = a), Object.defineProperty(o, s, { enumerable: !0, get: function() {
        return i[a];
      } });
    } : function(o, i, a, s) {
      s === void 0 && (s = a), o[s] = i[a];
    }), r = ht && ht.__exportStar || function(o, i) {
      for (var a in o) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, o, a);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), r(/* @__PURE__ */ nR(), e), r(/* @__PURE__ */ iR(), e), r(/* @__PURE__ */ sR(), e), r(/* @__PURE__ */ oR(), e), r(/* @__PURE__ */ aR(), e), r(/* @__PURE__ */ cR(), e), r(/* @__PURE__ */ hv(), e), r(/* @__PURE__ */ uR(), e), r(/* @__PURE__ */ ZP(), e), r(/* @__PURE__ */ tw(), e), r(/* @__PURE__ */ Hv(), e);
  }(ht)), ht;
}
var fd;
function rw() {
  if (fd) return Or;
  fd = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.IntentConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ le();
  let a = class extends r.ConnectionFactoryBase {
    create(n, c, u) {
      let l = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint);
      if (!l) {
        const f = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_IntentRegion), g = r.ConnectionFactoryBase.getHostSuffix(f);
        l = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + f + ".sr.speech" + g) + "/speech/recognition/interactive/cognitiveservices/v1";
      }
      const p = {
        format: "simple",
        language: n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(n, p, l);
      const h = {};
      c.token !== void 0 && c.token !== "" && (h[c.headerName] = c.token), h[i.HeaderNames.ConnectionId] = u, n.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, l);
      const d = n.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(l, p, h, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(n), d, u));
    }
    getSpeechRegionFromIntentRegion(n) {
      switch (n) {
        case "West US":
        case "US West":
        case "westus":
          return "uswest";
        case "West US 2":
        case "US West 2":
        case "westus2":
          return "uswest2";
        case "South Central US":
        case "US South Central":
        case "southcentralus":
          return "ussouthcentral";
        case "West Central US":
        case "US West Central":
        case "westcentralus":
          return "uswestcentral";
        case "East US":
        case "US East":
        case "eastus":
          return "useast";
        case "East US 2":
        case "US East 2":
        case "eastus2":
          return "useast2";
        case "West Europe":
        case "Europe West":
        case "westeurope":
          return "europewest";
        case "North Europe":
        case "Europe North":
        case "northeurope":
          return "europenorth";
        case "Brazil South":
        case "South Brazil":
        case "southbrazil":
          return "brazilsouth";
        case "Australia East":
        case "East Australia":
        case "eastaustralia":
          return "australiaeast";
        case "Southeast Asia":
        case "Asia Southeast":
        case "southeastasia":
          return "asiasoutheast";
        case "East Asia":
        case "Asia East":
        case "eastasia":
          return "asiaeast";
        default:
          return n;
      }
    }
  };
  return Or.IntentConnectionFactory = a, Or;
}
var At = {}, vd;
function nw() {
  if (vd) return At;
  vd = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.VoiceProfileConnectionFactory = At.SpeakerRecognitionConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ le();
  class a extends r.ConnectionFactoryBase {
    create(u, l, p, h) {
      let d = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint);
      if (!d) {
        const v = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region), y = r.ConnectionFactoryBase.getHostSuffix(v), S = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, `wss://${v}.spr-frontend.speech${y}`), C = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
        d = `${S}/speaker/ws/${this.scenarioToPath(C)}/${p}`;
      }
      const f = {
        format: "simple",
        language: u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(u, f, d);
      const g = {};
      l.token !== void 0 && l.token !== "" && (g[l.headerName] = l.token), g[i.HeaderNames.ConnectionId] = h, g[i.HeaderNames.SpIDAuthKey] = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Key), u.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, d);
      const m = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(d, f, g, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), m, h));
    }
    scenarioToPath(u) {
      switch (u) {
        case "TextIndependentVerification":
        case "2":
          return "verification/text-independent";
        case "TextDependentVerification":
        case "1":
          return "verification/text-dependent";
        default:
          return "identification/text-independent";
      }
    }
  }
  let s = class extends a {
    create(u, l, p) {
      return super.create(u, l, "recognition", p);
    }
  };
  At.SpeakerRecognitionConnectionFactory = s;
  class n extends a {
    create(u, l, p) {
      return super.create(u, l, "profile", p);
    }
  }
  return At.VoiceProfileConnectionFactory = n, At;
}
var da = {}, gd;
function mc() {
  return gd || (gd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionEndedEvent = e.RecognitionCompletionStatus = e.RecognitionStartedEvent = e.ConnectingToServiceEvent = e.ListeningStartedEvent = e.RecognitionTriggeredEvent = e.SpeechRecognitionEvent = void 0;
    const t = /* @__PURE__ */ M();
    class r extends t.PlatformEvent {
      constructor(l, p, h, d = t.EventType.Info) {
        super(l, d), this.privRequestId = p, this.privSessionId = h;
      }
      get requestId() {
        return this.privRequestId;
      }
      get sessionId() {
        return this.privSessionId;
      }
    }
    e.SpeechRecognitionEvent = r;
    class o extends r {
      constructor(l, p, h, d) {
        super("RecognitionTriggeredEvent", l, p), this.privAudioSourceId = h, this.privAudioNodeId = d;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
    }
    e.RecognitionTriggeredEvent = o;
    class i extends r {
      constructor(l, p, h, d) {
        super("ListeningStartedEvent", l, p), this.privAudioSourceId = h, this.privAudioNodeId = d;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
    }
    e.ListeningStartedEvent = i;
    class a extends r {
      constructor(l, p, h) {
        super("ConnectingToServiceEvent", l, h), this.privAuthFetchEventid = p;
      }
      get authFetchEventid() {
        return this.privAuthFetchEventid;
      }
    }
    e.ConnectingToServiceEvent = a;
    class s extends r {
      constructor(l, p, h, d, f) {
        super("RecognitionStartedEvent", l, f), this.privAudioSourceId = p, this.privAudioNodeId = h, this.privAuthFetchEventId = d;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
      get authFetchEventId() {
        return this.privAuthFetchEventId;
      }
    }
    e.RecognitionStartedEvent = s;
    var n;
    (function(u) {
      u[u.Success = 0] = "Success", u[u.AudioSourceError = 1] = "AudioSourceError", u[u.AudioSourceTimeout = 2] = "AudioSourceTimeout", u[u.AuthTokenFetchError = 3] = "AuthTokenFetchError", u[u.AuthTokenFetchTimeout = 4] = "AuthTokenFetchTimeout", u[u.UnAuthorized = 5] = "UnAuthorized", u[u.ConnectTimeout = 6] = "ConnectTimeout", u[u.ConnectError = 7] = "ConnectError", u[u.ClientRecognitionActivityTimeout = 8] = "ClientRecognitionActivityTimeout", u[u.UnknownError = 9] = "UnknownError";
    })(n = e.RecognitionCompletionStatus || (e.RecognitionCompletionStatus = {}));
    class c extends r {
      constructor(l, p, h, d, f, g, m, v) {
        super("RecognitionEndedEvent", l, f, m === n.Success ? t.EventType.Info : t.EventType.Error), this.privAudioSourceId = p, this.privAudioNodeId = h, this.privAuthFetchEventId = d, this.privStatus = m, this.privError = v, this.privServiceTag = g;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
      get authFetchEventId() {
        return this.privAuthFetchEventId;
      }
      get serviceTag() {
        return this.privServiceTag;
      }
      get status() {
        return this.privStatus;
      }
      get error() {
        return this.privError;
      }
    }
    e.RecognitionEndedEvent = c;
  }(da)), da;
}
var hi = {}, fi = {}, md;
function Jt() {
  if (md) return fi;
  md = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.SpeechConnectionMessage = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ le();
  class r extends e.ConnectionMessage {
    constructor(i, a, s, n, c, u, l, p) {
      if (!a)
        throw new e.ArgumentNullError("path");
      if (!s)
        throw new e.ArgumentNullError("requestId");
      const h = {};
      if (h[t.HeaderNames.Path] = a, h[t.HeaderNames.RequestId] = s, h[t.HeaderNames.RequestTimestamp] = (/* @__PURE__ */ new Date()).toISOString(), n && (h[t.HeaderNames.ContentType] = n), u && (h[t.HeaderNames.RequestStreamId] = u), l)
        for (const d in l)
          d && (h[d] = l[d]);
      p ? super(i, c, h, p) : super(i, c, h), this.privPath = a, this.privRequestId = s, this.privContentType = n, this.privStreamId = u, this.privAdditionalHeaders = l;
    }
    get path() {
      return this.privPath;
    }
    get requestId() {
      return this.privRequestId;
    }
    get contentType() {
      return this.privContentType;
    }
    get streamId() {
      return this.privStreamId;
    }
    get additionalHeaders() {
      return this.privAdditionalHeaders;
    }
    static fromConnectionMessage(i) {
      let a = null, s = null, n = null, c = null;
      const u = {};
      if (i.headers)
        for (const l in i.headers)
          l && (l.toLowerCase() === t.HeaderNames.Path.toLowerCase() ? a = i.headers[l] : l.toLowerCase() === t.HeaderNames.RequestId.toLowerCase() ? s = i.headers[l] : l.toLowerCase() === t.HeaderNames.ContentType.toLowerCase() ? n = i.headers[l] : l.toLowerCase() === t.HeaderNames.RequestStreamId.toLowerCase() ? c = i.headers[l] : u[l] = i.headers[l]);
      return new r(i.messageType, a, s, n, i.body, c, u, i.id);
    }
  }
  return fi.SpeechConnectionMessage = r, fi;
}
var ha = {}, yd;
function iw() {
  return yd || (yd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SegmentationMode = void 0, function(t) {
      t.Normal = "Normal", t.Disabled = "Disabled", t.Custom = "Custom", t.Semantic = "Semantic";
    }(e.SegmentationMode || (e.SegmentationMode = {}));
  }(ha)), ha;
}
var fa = {}, Sd;
function sw() {
  return Sd || (Sd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.None = "None", t.Synthesize = "Synthesize";
    }(e.NextAction || (e.NextAction = {}));
  }(fa)), fa;
}
var va = {}, Cd;
function ow() {
  return Cd || (Cd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Mode = void 0, function(t) {
      t.None = "None", t.Always = "Always";
    }(e.Mode || (e.Mode = {}));
  }(va)), va;
}
var ga = {}, Rd;
function aw() {
  return Rd || (Rd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LanguageIdDetectionPriority = e.LanguageIdDetectionMode = void 0, function(t) {
      t.DetectAtAudioStart = "DetectAtAudioStart", t.DetectContinuous = "DetectContinuous", t.DetectSegments = "DetectSegments";
    }(e.LanguageIdDetectionMode || (e.LanguageIdDetectionMode = {})), function(t) {
      t.Auto = "Auto", t.PrioritizeLatency = "PrioritizeLatency", t.PrioritizeAccuracy = "PrioritizeAccuracy";
    }(e.LanguageIdDetectionPriority || (e.LanguageIdDetectionPriority = {}));
  }(ga)), ga;
}
var ma = {}, Pd;
function cw() {
  return Pd || (Pd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.Recognize = "Recognize", t.None = "None";
    }(e.NextAction || (e.NextAction = {}));
  }(ma)), ma;
}
var ya = {}, wd;
function uw() {
  return wd || (wd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OnUnknownAction = void 0, function(t) {
      t.RecognizeWithDefaultLanguage = "RecognizeWithDefaultLanguage", t.None = "None";
    }(e.OnUnknownAction || (e.OnUnknownAction = {}));
  }(ya)), ya;
}
var Sa = {}, bd;
function lw() {
  return bd || (bd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ResultType = void 0, function(t) {
      t.Auto = "Auto", t.StableFragment = "StableFragment", t.Hypothesis = "Hypothesis", t.None = "None";
    }(e.ResultType || (e.ResultType = {}));
  }(Sa)), Sa;
}
var Ca = {}, Ed;
function pw() {
  return Ed || (Ed = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PhraseResultOutputType = void 0, function(t) {
      t.Always = "Always", t.None = "None";
    }(e.PhraseResultOutputType || (e.PhraseResultOutputType = {}));
  }(Ca)), Ca;
}
var Ra = {}, Id;
function dw() {
  return Id || (Id = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.None = "None", t.Translate = "Translate";
    }(e.NextAction || (e.NextAction = {}));
  }(Ra)), Ra;
}
var Ad;
function hw() {
  if (Ad) return hi;
  Ad = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.ServiceRecognizerBase = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Jt(), a = /* @__PURE__ */ iw(), s = /* @__PURE__ */ we(), n = /* @__PURE__ */ sw(), c = /* @__PURE__ */ ow(), u = /* @__PURE__ */ aw(), l = /* @__PURE__ */ cw(), p = /* @__PURE__ */ uw(), h = /* @__PURE__ */ lw(), d = /* @__PURE__ */ pw(), f = /* @__PURE__ */ dw();
  let g = class ps {
    constructor(v, y, S, C, P) {
      if (this.privConnectionConfigurationPromise = void 0, this.privConnectionPromise = void 0, this.privSetTimeout = setTimeout, this.privIsLiveAudio = !1, this.privAverageBytesPerMs = 0, this.privEnableSpeakerId = !1, this.privExpectContentAssessmentResponse = !1, this.recognizeOverride = void 0, this.recognizeSpeaker = void 0, this.disconnectOverride = void 0, this.receiveMessageOverride = void 0, this.sendPrePayloadJSONOverride = void 0, this.postConnectImplOverride = void 0, this.configConnectionOverride = void 0, this.handleSpeechPhraseMessage = void 0, this.handleSpeechHypothesisMessage = void 0, !v)
        throw new t.ArgumentNullError("authentication");
      if (!y)
        throw new t.ArgumentNullError("connectionFactory");
      if (!S)
        throw new t.ArgumentNullError("audioSource");
      if (!C)
        throw new t.ArgumentNullError("recognizerConfig");
      this.privEnableSpeakerId = C.isSpeakerDiarizationEnabled, this.privMustReportEndOfStream = !1, this.privAuthentication = v, this.privConnectionFactory = y, this.privAudioSource = S, this.privRecognizerConfig = C, this.privIsDisposed = !1, this.privRecognizer = P, this.privRequestSession = new o.RequestSession(this.privAudioSource.id()), this.privConnectionEvents = new t.EventSource(), this.privServiceEvents = new t.EventSource(), this.privDynamicGrammar = new o.DynamicGrammarBuilder(), this.privSpeechContext = new o.SpeechContext(this.privDynamicGrammar), this.privAgentConfig = new o.AgentConfig(), this.privRecognizerConfig.parameters.getProperty(r.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? this.privSetTimeout = t.Timeout.setTimeout : (typeof window < "u" && (this.privSetTimeout = window.setTimeout.bind(window)), typeof globalThis < "u" && (this.privSetTimeout = globalThis.setTimeout.bind(globalThis))), this.connectionEvents.attach((A) => {
        if (A.name === "ConnectionClosedEvent") {
          const E = A;
          (E.statusCode === 1003 || E.statusCode === 1007 || E.statusCode === 1002 || E.statusCode === 4e3 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) && this.cancelRecognitionLocal(r.CancellationReason.Error, E.statusCode === 1007 ? r.CancellationErrorCode.BadRequestParameters : r.CancellationErrorCode.ConnectionFailure, `${E.reason} websocket error code: ${E.statusCode}`);
        }
      }), this.privEnableSpeakerId && (this.privDiarizationSessionId = (0, t.createNoDashGuid)());
    }
    setTranslationJson() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0);
      if (v !== void 0) {
        const y = v.split(","), S = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0), C = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationCategoryId, void 0), P = S !== void 0 ? n.NextAction.Synthesize : n.NextAction.None;
        if (this.privSpeechContext.getContext().translation = {
          onPassthrough: { action: P },
          onSuccess: { action: P },
          output: {
            includePassThroughResults: !0,
            interimResults: { mode: c.Mode.Always }
          },
          targetLanguages: y
        }, C !== void 0 && (this.privSpeechContext.getContext().translation.category = C), S !== void 0) {
          const A = {};
          for (const E of y)
            A[E] = S;
          this.privSpeechContext.getContext().synthesis = {
            defaultVoices: A
          };
        }
        const b = this.privSpeechContext.getContext().phraseDetection || {};
        b.onSuccess = { action: f.NextAction.Translate }, b.onInterim = { action: f.NextAction.Translate }, this.privSpeechContext.getContext().phraseDetection = b;
      }
    }
    setSpeechSegmentationTimeoutJson() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationSilenceTimeoutMs, void 0), y = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationMaximumTimeMs, void 0), S = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationStrategy, void 0), C = {
        mode: a.SegmentationMode.Normal
      };
      let P = !1;
      if (S !== void 0) {
        P = !0;
        let b = a.SegmentationMode.Normal;
        switch (S.toLowerCase()) {
          case "default":
            break;
          case "time":
            b = a.SegmentationMode.Custom;
            break;
          case "semantic":
            b = a.SegmentationMode.Semantic;
            break;
        }
        C.mode = b;
      }
      if (v !== void 0) {
        P = !0;
        const b = parseInt(v, 10);
        C.mode = a.SegmentationMode.Custom, C.segmentationSilenceTimeoutMs = b;
      }
      if (y !== void 0) {
        P = !0;
        const b = parseInt(y, 10);
        C.mode = a.SegmentationMode.Custom, C.segmentationForcedTimeoutMs = b;
      }
      if (P) {
        const b = this.privSpeechContext.getContext().phraseDetection || {};
        switch (b.mode = this.recognitionMode, this.recognitionMode) {
          case s.RecognitionMode.Conversation:
            b.conversation = b.conversation ?? { segmentation: {} }, b.conversation.segmentation = C;
            break;
          case s.RecognitionMode.Interactive:
            b.interactive = b.interactive ?? { segmentation: {} }, b.interactive.segmentation = C;
            break;
          case s.RecognitionMode.Dictation:
            b.dictation = b.dictation ?? {}, b.dictation.segmentation = C;
            break;
        }
        this.privSpeechContext.getContext().phraseDetection = b;
      }
    }
    setLanguageIdJson() {
      const v = this.privSpeechContext.getContext().phraseDetection || {};
      if (this.privRecognizerConfig.autoDetectSourceLanguages !== void 0) {
        const y = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
        y.length === 1 && y[0] === o.AutoDetectSourceLanguagesOpenRangeOptionName && (y[0] = "UND");
        let S;
        this.privRecognizerConfig.languageIdMode === "Continuous" ? S = u.LanguageIdDetectionMode.DetectContinuous : S = u.LanguageIdDetectionMode.DetectAtAudioStart, this.privSpeechContext.getContext().languageId = {
          languages: y,
          mode: S,
          onSuccess: { action: l.NextAction.Recognize },
          onUnknown: { action: p.OnUnknownAction.None },
          priority: u.LanguageIdDetectionPriority.PrioritizeLatency
        }, this.privSpeechContext.getContext().phraseOutput = {
          interimResults: {
            resultType: h.ResultType.Auto
          },
          phraseResults: {
            resultType: d.PhraseResultOutputType.Always
          }
        };
        const C = this.privRecognizerConfig.sourceLanguageModels;
        C !== void 0 && (v.customModels = C, v.onInterim = { action: f.NextAction.None }, v.onSuccess = { action: f.NextAction.None });
      }
      this.privSpeechContext.getContext().phraseDetection = v;
    }
    setOutputDetailLevelJson() {
      this.privEnableSpeakerId && (this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true" ? this.privSpeechContext.setWordLevelTimings() : this.privRecognizerConfig.parameters.getProperty(o.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase() === r.OutputFormat[r.OutputFormat.Detailed].toLocaleLowerCase() && this.privSpeechContext.setDetailedOutputFormat());
    }
    get isSpeakerDiarizationEnabled() {
      return this.privEnableSpeakerId;
    }
    get audioSource() {
      return this.privAudioSource;
    }
    get speechContext() {
      return this.privSpeechContext;
    }
    get dynamicGrammar() {
      return this.privDynamicGrammar;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    set conversationTranslatorToken(v) {
      this.privRecognizerConfig.parameters.setProperty(r.PropertyId.ConversationTranslator_Token, v);
    }
    set voiceProfileType(v) {
      this.privRecognizerConfig.parameters.setProperty(r.PropertyId.SpeechServiceConnection_SpeakerIdMode, v);
    }
    set authentication(v) {
      this.privAuthentication = v;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(v) {
      if (this.privIsDisposed = !0, this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose(v);
        } catch {
          return;
        }
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    get recognitionMode() {
      return this.privRecognizerConfig.recognitionMode;
    }
    async recognize(v, y, S) {
      if (this.recognizeOverride !== void 0) {
        await this.recognizeOverride(v, y, S);
        return;
      }
      if (this.privConnectionConfigurationPromise = void 0, this.privRecognizerConfig.recognitionMode = v, this.privRecognizerConfig.recognitionEndpointVersion === "2") {
        const E = this.privSpeechContext.getContext().phraseDetection || {};
        E.mode = v, this.privSpeechContext.getContext().phraseDetection = E;
      }
      this.setLanguageIdJson(), this.setTranslationJson(), this.privRecognizerConfig.autoDetectSourceLanguages !== void 0 && this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 && this.setupTranslationWithLanguageId(), this.setSpeechSegmentationTimeoutJson(), this.setOutputDetailLevelJson(), this.privSuccessCallback = y, this.privErrorCallback = S, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
      const C = this.connectImpl();
      let P;
      try {
        const E = await this.audioSource.attach(this.privRequestSession.audioNodeId), D = await this.audioSource.format, R = await this.audioSource.deviceInfo;
        this.privIsLiveAudio = R.type && R.type === o.type.Microphones, P = new e.ReplayableAudioNode(E, D.avgBytesPerSec), await this.privRequestSession.onAudioSourceAttachCompleted(P, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: R };
      } catch (E) {
        throw await this.privRequestSession.onStopRecognizing(), E;
      }
      try {
        await C;
      } catch (E) {
        await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, E);
        return;
      }
      const b = new r.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, b), this.receiveMessage(), this.sendAudio(P).catch(async (E) => {
        await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, E);
      });
    }
    async stopRecognizing() {
      if (this.privRequestSession.isRecognizing)
        try {
          await this.audioSource.turnOff(), await this.sendFinalAudio(), await this.privRequestSession.onStopRecognizing(), await this.privRequestSession.turnCompletionPromise;
        } finally {
          await this.privRequestSession.dispose();
        }
    }
    async connect() {
      return await this.connectImpl(), Promise.resolve();
    }
    connectAsync(v, y) {
      this.connectImpl().then(() => {
        try {
          v && v();
        } catch (S) {
          y && y(S);
        }
      }, (S) => {
        try {
          y && y(S);
        } catch {
        }
      });
    }
    async disconnect() {
      if (await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.NoError, "Disconnecting"), this.disconnectOverride !== void 0 && await this.disconnectOverride(), this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose();
        } catch {
        }
      this.privConnectionPromise = void 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendMessage(v) {
    }
    async sendNetworkMessage(v, y) {
      const S = typeof y == "string" ? t.MessageType.Text : t.MessageType.Binary, C = typeof y == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new i.SpeechConnectionMessage(S, v, this.privRequestSession.requestId, C, y));
    }
    set activityTemplate(v) {
      this.privActivityTemplate = v;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set expectContentAssessmentResponse(v) {
      this.privExpectContentAssessmentResponse = v;
    }
    async sendTelemetryData() {
      const v = this.privRequestSession.getTelemetry();
      if (ps.telemetryDataEnabled !== !0 || this.privIsDisposed || v === null)
        return;
      if (ps.telemetryData)
        try {
          ps.telemetryData(v);
        } catch {
        }
      await (await this.fetchConnection()).send(new i.SpeechConnectionMessage(t.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", v));
    }
    // Cancels recognition.
    async cancelRecognitionLocal(v, y, S) {
      this.privRequestSession.isRecognizing && (await this.privRequestSession.onStopRecognizing(), this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, v, y, S));
    }
    async receiveMessage() {
      try {
        if (this.privIsDisposed)
          return;
        let v = await this.fetchConnection();
        const y = await v.read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (!y)
          return this.receiveMessage();
        this.privServiceHasSentMessage = !0;
        const S = i.SpeechConnectionMessage.fromConnectionMessage(y);
        if (S.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase())
          switch (S.path.toLowerCase()) {
            case "turn.start":
              this.privMustReportEndOfStream = !0, this.privRequestSession.onServiceTurnStartResponse();
              break;
            case "speech.startdetected":
              const C = o.SpeechDetected.fromJSON(S.textBody, this.privRequestSession.currentTurnAudioOffset), P = new r.RecognitionEventArgs(C.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, P);
              break;
            case "speech.enddetected":
              let b;
              S.textBody.length > 0 ? b = S.textBody : b = "{ Offset: 0 }";
              const A = o.SpeechDetected.fromJSON(b, this.privRequestSession.currentTurnAudioOffset), E = new r.RecognitionEventArgs(A.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, E);
              break;
            case "turn.end":
              await this.sendTelemetryData(), this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream && (this.privMustReportEndOfStream = !1, await this.cancelRecognitionLocal(r.CancellationReason.EndOfStream, r.CancellationErrorCode.NoError, void 0));
              const D = new r.SessionEventArgs(this.privRequestSession.sessionId);
              if (await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition), !this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, D);
                return;
              } else
                v = await this.fetchConnection(), await this.sendPrePayloadJSON(v);
              break;
            default:
              await this.processTypeSpecificMessages(S) || this.privServiceEvents && this.serviceEvents.onEvent(new t.ServiceEvent(S.path.toLowerCase(), S.textBody));
          }
        return this.receiveMessage();
      } catch {
        return null;
      }
    }
    updateSpeakerDiarizationAudioOffset() {
      const v = this.privRequestSession.recognitionBytesSent, y = this.privAverageBytesPerMs !== 0 ? v / this.privAverageBytesPerMs : 0;
      this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(y);
    }
    sendSpeechContext(v, y) {
      this.privEnableSpeakerId && this.updateSpeakerDiarizationAudioOffset();
      const S = this.speechContext.toJSON();
      if (y && this.privRequestSession.onSpeechContext(), S)
        return v.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", S));
    }
    setupTranslationWithLanguageId() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0), y = this.privRecognizerConfig.autoDetectSourceLanguages !== void 0;
      if (v !== void 0 && y) {
        this.privSpeechContext.getContext().phraseOutput = {
          interimResults: {
            resultType: h.ResultType.None
          },
          phraseResults: {
            resultType: d.PhraseResultOutputType.None
          }
        };
        const S = this.privSpeechContext.getContext().translation;
        if (S) {
          const C = this.privRecognizerConfig.sourceLanguageModels;
          if (C !== void 0 && C.length > 0) {
            const b = this.privSpeechContext.getContext().phraseDetection || {};
            b.customModels = C, this.privSpeechContext.getContext().phraseDetection = b;
          }
          this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && (S.onSuccess = { action: n.NextAction.Synthesize }, S.onPassthrough = { action: n.NextAction.Synthesize });
        }
      }
    }
    noOp() {
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendPrePayloadJSON(v, y = !0) {
      if (this.sendPrePayloadJSONOverride !== void 0)
        return this.sendPrePayloadJSONOverride(v);
      await this.sendSpeechContext(v, y), await this.sendWaveHeader(v);
    }
    async sendWaveHeader(v) {
      const y = await this.audioSource.format;
      return v.send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", y.header));
    }
    // Establishes a websocket connection to the end point.
    connectImpl() {
      return this.privConnectionPromise !== void 0 ? this.privConnectionPromise.then((v) => v.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl())) : (this.privConnectionPromise = this.retryableConnect(), this.privConnectionPromise.catch(() => {
      }), this.postConnectImplOverride !== void 0 ? this.postConnectImplOverride(this.privConnectionPromise) : this.privConnectionPromise);
    }
    sendSpeechServiceConfig(v, y, S) {
      if (y.onSpeechContext(), ps.telemetryDataEnabled !== !0) {
        const P = {
          context: {
            system: JSON.parse(S).context.system
          }
        };
        S = JSON.stringify(P);
      }
      if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
        const C = JSON.parse(S);
        C.context.DisableReferenceChannel = "True", C.context.MicSpec = "1_0_0", S = JSON.stringify(C);
      }
      if (S)
        return v.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speech.config", y.requestId, "application/json", S));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((v) => v.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    async sendAudio(v) {
      const y = await this.audioSource.format;
      this.privAverageBytesPerMs = y.avgBytesPerSec / 1e3;
      let S = Date.now();
      const C = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000"), P = y.avgBytesPerSec / 1e3 * parseInt(C, 10), b = this.privRequestSession.recogNumber, A = async () => {
        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === b) {
          const E = await this.fetchConnection(), D = await v.read();
          if (this.privRequestSession.isSpeechEnded)
            return;
          let R, j;
          if (!D || D.isEnd ? (R = null, j = 0) : (R = D.buffer, this.privRequestSession.onAudioSent(R.byteLength), P >= this.privRequestSession.bytesSent ? j = 0 : j = Math.max(0, S - Date.now())), j !== 0 && await this.delay(j), R !== null && (S = Date.now() + R.byteLength * 1e3 / (y.avgBytesPerSec * 2)), !this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === b)
            if (E.send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, null, R)).catch(() => {
              this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {
              });
            }), D?.isEnd)
              this.privIsLiveAudio || this.privRequestSession.onSpeechEnded();
            else
              return A();
        }
      };
      return A();
    }
    async retryableConnect() {
      let v = !1;
      this.privAuthFetchEventId = (0, t.createNoDashGuid)();
      const y = this.privRequestSession.sessionId;
      this.privConnectionId = y !== void 0 ? y : (0, t.createNoDashGuid)(), this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
      let S = 0, C = "";
      for (; this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount; ) {
        this.privRequestSession.onRetryConnection();
        const b = await (v ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId));
        await this.privRequestSession.onAuthCompleted(!1);
        const A = await this.privConnectionFactory.create(this.privRecognizerConfig, b, this.privConnectionId);
        this.privRequestSession.listenForServiceTelemetry(A.events), A.events.attach((D) => {
          this.connectionEvents.onEvent(D);
        });
        const E = await A.open();
        if (E.statusCode === 200)
          return await this.privRequestSession.onConnectionEstablishCompleted(E.statusCode), Promise.resolve(A);
        E.statusCode === 1006 && (v = !0), S = E.statusCode, C = E.reason;
      }
      return await this.privRequestSession.onConnectionEstablishCompleted(S, C), Promise.reject(`Unable to contact server. StatusCode: ${S}, ${this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${C}`);
    }
    delay(v) {
      return new Promise((y) => this.privSetTimeout(y, v));
    }
    writeBufferToConsole(v) {
      let y = "Buffer Size: ";
      if (v === null)
        y += "null";
      else {
        const S = new Uint8Array(v);
        y += `${v.byteLength}\r
`;
        for (let C = 0; C < v.byteLength; C++)
          y += S[C].toString(16).padStart(2, "0") + " ", (C + 1) % 16 === 0 && (console.info(y), y = "");
      }
      console.info(y);
    }
    async sendFinalAudio() {
      await (await this.fetchConnection()).send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const v = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(v) : (await this.sendSpeechServiceConfig(v, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendPrePayloadJSON(v, !1), v);
    }
  };
  return hi.ServiceRecognizerBase = g, g.telemetryDataEnabled = !0, hi;
}
var vi = {}, Td;
function fw() {
  if (Td) return vi;
  Td = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.ConversationServiceRecognizer = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class extends t.ServiceRecognizerBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, n, c), this.handleSpeechPhraseMessage = async (u) => this.handleSpeechPhrase(u), this.handleSpeechHypothesisMessage = (u) => this.handleSpeechHypothesis(u);
    }
    processTypeSpecificMessages(i) {
    }
    handleRecognizedCallback(i, a, s) {
    }
    handleRecognizingCallback(i, a, s) {
    }
    async processSpeechMessages(i) {
      let a = !1;
      switch (i.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          this.handleSpeechHypothesisMessage && this.handleSpeechHypothesisMessage(i.textBody), a = !0;
          break;
        case "speech.phrase":
          this.handleSpeechPhraseMessage && await this.handleSpeechPhraseMessage(i.textBody), a = !0;
          break;
      }
      return a;
    }
    cancelRecognition(i, a, s, n, c) {
    }
    async handleSpeechPhrase(i) {
      const a = t.SimpleSpeechPhrase.fromJSON(i, this.privRequestSession.currentTurnAudioOffset), s = t.EnumTranslation.implTranslateRecognitionResult(a.RecognitionStatus);
      let n;
      const c = new e.PropertyCollection();
      if (c.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, i), this.privRequestSession.onPhraseRecognized(a.Offset + a.Duration), e.ResultReason.Canceled === s) {
        const u = t.EnumTranslation.implTranslateCancelResult(a.RecognitionStatus), l = t.EnumTranslation.implTranslateCancelErrorCode(a.RecognitionStatus);
        await this.cancelRecognitionLocal(u, l, t.EnumTranslation.implTranslateErrorDetails(l));
      } else if (a.RecognitionStatus !== t.RecognitionStatus.EndOfDictation) {
        if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
          n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, s, a.DisplayText, a.Duration, a.Offset, a.Language, a.LanguageDetectionConfidence, a.SpeakerId, void 0, a.asJson(), c);
        else {
          const u = t.DetailedSpeechPhrase.fromJSON(i, this.privRequestSession.currentTurnAudioOffset);
          n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, s, u.Text, u.Duration, u.Offset, u.Language, u.LanguageDetectionConfidence, u.SpeakerId, void 0, u.asJson(), c);
        }
        this.handleRecognizedCallback(n, n.offset, this.privRequestSession.sessionId);
      }
    }
    handleSpeechHypothesis(i) {
      const a = t.SpeechHypothesis.fromJSON(i, this.privRequestSession.currentTurnAudioOffset), s = new e.PropertyCollection();
      s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, i);
      const n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, e.ResultReason.RecognizingSpeech, a.Text, a.Duration, a.Offset, a.Language, a.LanguageDetectionConfidence, a.SpeakerId, void 0, a.asJson(), s);
      this.privRequestSession.onHypothesis(a.Offset), this.handleRecognizingCallback(n, a.Duration, this.privRequestSession.sessionId);
    }
  };
  return vi.ConversationServiceRecognizer = r, vi;
}
var Pa = {}, _d;
function vw() {
  return _d || (_d = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognizerConfig = e.SpeechResultFormat = void 0;
    const t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ we();
    (function(a) {
      a[a.Simple = 0] = "Simple", a[a.Detailed = 1] = "Detailed";
    })(e.SpeechResultFormat || (e.SpeechResultFormat = {}));
    class i {
      constructor(s, n) {
        this.privSpeechServiceConfig = s || new r.SpeechServiceConfig(new r.Context(null)), this.privParameters = n, this.privMaxRetryCount = parseInt(n.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10), this.privLanguageIdMode = n.getProperty(t.PropertyId.SpeechServiceConnection_LanguageIdMode, void 0), this.privEnableSpeakerId = !1;
      }
      get parameters() {
        return this.privParameters;
      }
      get recognitionMode() {
        return this.privRecognitionMode;
      }
      set recognitionMode(s) {
        this.privRecognitionMode = s, this.privRecognitionActivityTimeout = s === o.RecognitionMode.Interactive ? 8e3 : 25e3, this.privSpeechServiceConfig.Recognition = o.RecognitionMode[s];
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
      get recognitionActivityTimeout() {
        return this.privRecognitionActivityTimeout;
      }
      get isContinuousRecognition() {
        return this.privRecognitionMode !== o.RecognitionMode.Interactive;
      }
      get languageIdMode() {
        return this.privLanguageIdMode;
      }
      get autoDetectSourceLanguages() {
        return this.parameters.getProperty(t.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0);
      }
      get recognitionEndpointVersion() {
        return this.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
      }
      set recognitionEndpointVersion(s) {
        this.parameters.setProperty(t.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, s);
      }
      get sourceLanguageModels() {
        const s = [];
        let n = !1;
        if (this.autoDetectSourceLanguages !== void 0)
          for (const c of this.autoDetectSourceLanguages.split(",")) {
            const u = c + t.PropertyId.SpeechServiceConnection_EndpointId.toString(), l = this.parameters.getProperty(u, void 0);
            l !== void 0 ? (s.push({ language: c, endpoint: l }), n = !0) : s.push({ language: c, endpoint: "" });
          }
        return n ? s : void 0;
      }
      get maxRetryCount() {
        return this.privMaxRetryCount;
      }
      get isSpeakerDiarizationEnabled() {
        return this.privEnableSpeakerId;
      }
      set isSpeakerDiarizationEnabled(s) {
        this.privEnableSpeakerId = s;
      }
    }
    e.RecognizerConfig = i;
  }(Pa)), Pa;
}
var wa = {}, kd;
function gw() {
  return kd || (kd = 1, Object.defineProperty(wa, "__esModule", { value: !0 })), wa;
}
var gi = {}, Od;
function mw() {
  if (Od) return gi;
  Od = 1, Object.defineProperty(gi, "__esModule", { value: !0 }), gi.WebsocketMessageFormatter = void 0;
  const e = /* @__PURE__ */ M(), t = `\r
`;
  let r = class {
    toConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = i.textContent;
          let n = {}, c = null;
          if (s) {
            const u = s.split(`\r
\r
`);
            u && u.length > 0 && (n = this.parseHeaders(u[0]), u.length > 1 && (c = u[1]));
          }
          a.resolve(new e.ConnectionMessage(i.messageType, c, n, i.id));
        } else if (i.messageType === e.MessageType.Binary) {
          const s = i.binaryContent;
          let n = {}, c = null;
          if (!s || s.byteLength < 2)
            throw new Error("Invalid binary message format. Header length missing.");
          const u = new DataView(s), l = u.getInt16(0);
          if (s.byteLength < l + 2)
            throw new Error("Invalid binary message format. Header content missing.");
          let p = "";
          for (let h = 0; h < l; h++)
            p += String.fromCharCode(u.getInt8(h + 2));
          n = this.parseHeaders(p), s.byteLength > l + 2 && (c = s.slice(2 + l)), a.resolve(new e.ConnectionMessage(i.messageType, c, n, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. Error: ${s}`);
      }
      return a.promise;
    }
    fromConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = `${this.makeHeaders(i)}${t}${i.textBody ? i.textBody : ""}`;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Text, s, i.id));
        } else if (i.messageType === e.MessageType.Binary) {
          const s = this.makeHeaders(i), n = i.binaryBody, c = this.stringToArrayBuffer(s), u = new Int8Array(c), l = u.byteLength, p = new Int8Array(2 + l + (n ? n.byteLength : 0));
          if (p[0] = l >> 8 & 255, p[1] = l & 255, p.set(u, 2), n) {
            const d = new Int8Array(n);
            p.set(d, 2 + l);
          }
          const h = p.buffer;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Binary, h, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. ${s}`);
      }
      return a.promise;
    }
    makeHeaders(i) {
      let a = "";
      if (i.headers)
        for (const s in i.headers)
          s && (a += `${s}: ${i.headers[s]}${t}`);
      return a;
    }
    parseHeaders(i) {
      const a = {};
      if (i) {
        const s = i.match(/[^\r\n]+/g);
        if (a) {
          for (const n of s)
            if (n) {
              const c = n.indexOf(":"), u = c > 0 ? n.substr(0, c).trim().toLowerCase() : n, l = c > 0 && n.length > c + 1 ? n.substr(c + 1).trim() : "";
              a[u] = l;
            }
        }
      }
      return a;
    }
    stringToArrayBuffer(i) {
      const a = new ArrayBuffer(i.length), s = new DataView(a);
      for (let n = 0; n < i.length; n++)
        s.setUint8(n, i.charCodeAt(n));
      return a;
    }
  };
  return gi.WebsocketMessageFormatter = r, gi;
}
var mi = {}, Md;
function yw() {
  if (Md) return mi;
  Md = 1, Object.defineProperty(mi, "__esModule", { value: !0 }), mi.SpeechConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ ke(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ le(), s = /* @__PURE__ */ tt(), n = /* @__PURE__ */ we();
  let c = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1", this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1", this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1", this.universalUri = "/stt/speech/universal/v";
    }
    async create(l, p, h) {
      let d = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region, void 0), g = o.ConnectionFactoryBase.getHostSuffix(f), m = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://" + f + ".stt.speech" + g), v = {}, y = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId, void 0), S = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (y ? (!d || d.search(s.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (v[s.QueryParameterNames.CustomSpeechDeploymentId] = y) : S && (!d || d.search(s.QueryParameterNames.Language) === -1) && (v[s.QueryParameterNames.Language] = S), (!d || d.search(s.QueryParameterNames.Format) === -1) && (v[s.QueryParameterNames.Format] = l.parameters.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase()), l.autoDetectSourceLanguages !== void 0 && (v[s.QueryParameterNames.EnableLanguageId] = "true"), this.setCommonUrlParams(l, v, d), d) {
        const E = new URL(d), D = E.pathname;
        (D === "" || D === "/") && (E.pathname = this.universalUri + l.recognitionEndpointVersion, d = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(E.toString()));
      }
      if (!d)
        switch (l.recognitionMode) {
          case n.RecognitionMode.Conversation:
            l.parameters.getProperty(t.ForceDictationPropertyName, "false") === "true" ? d = m + this.dictationRelativeUri : l.recognitionEndpointVersion !== void 0 && parseInt(l.recognitionEndpointVersion, 10) > 1 ? d = `${m}${this.universalUri}${l.recognitionEndpointVersion}` : d = m + this.conversationRelativeUri;
            break;
          case n.RecognitionMode.Dictation:
            d = m + this.dictationRelativeUri;
            break;
          default:
            l.recognitionEndpointVersion !== void 0 && parseInt(l.recognitionEndpointVersion, 10) > 1 ? d = `${m}${this.universalUri}${l.recognitionEndpointVersion}` : d = m + this.interactiveRelativeUri;
            break;
        }
      const C = {};
      p.token !== void 0 && p.token !== "" && (C[p.headerName] = p.token), C[a.HeaderNames.ConnectionId] = h, C.connectionId = h;
      const P = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", b = new e.WebsocketConnection(d, v, C, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), P, h), A = b.uri;
      return l.parameters.setProperty(r.PropertyId.SpeechServiceConnection_Url, A), b;
    }
  };
  return mi.SpeechConnectionFactory = c, mi;
}
var yi = {}, Dd;
function Sw() {
  if (Dd) return yi;
  Dd = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.ConversationTranscriberConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ ke(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ le(), s = /* @__PURE__ */ tt();
  let n = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/stt/speech/universal/v2";
    }
    async create(u, l, p) {
      let h = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const d = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, void 0), f = o.ConnectionFactoryBase.getHostSuffix(d), g = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + d + ".stt.speech" + f), m = {}, v = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), y = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (v ? (!h || h.search(s.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (m[s.QueryParameterNames.CustomSpeechDeploymentId] = v) : y && (!h || h.search(s.QueryParameterNames.Language) === -1) && (m[s.QueryParameterNames.Language] = y), u.autoDetectSourceLanguages !== void 0 && (m[s.QueryParameterNames.EnableLanguageId] = "true"), this.setV2UrlParams(u, m, h), h) {
        const A = new URL(h), E = A.pathname;
        (E === "" || E === "/") && (A.pathname = this.universalUri, h = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(A.toString()));
      }
      h || (h = `${g}${this.universalUri}`);
      const S = {};
      l.token !== void 0 && l.token !== "" && (S[l.headerName] = l.token), S[a.HeaderNames.ConnectionId] = p;
      const C = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", P = new e.WebsocketConnection(h, m, S, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), C, p), b = P.uri;
      return u.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, b), P;
    }
    setV2UrlParams(u, l, p) {
      (/* @__PURE__ */ new Map([
        [t.PropertyId.Speech_SegmentationSilenceTimeoutMs, s.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceConnection_EnableAudioLogging, s.QueryParameterNames.EnableAudioLogging],
        [t.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, s.QueryParameterNames.EndSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, s.QueryParameterNames.InitialSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceResponse_PostProcessingOption, s.QueryParameterNames.Postprocessing],
        [t.PropertyId.SpeechServiceResponse_ProfanityOption, s.QueryParameterNames.Profanity],
        [t.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, s.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((f, g) => {
        this.setUrlParameter(g, f, u, l, p);
      });
      const d = JSON.parse(u.parameters.getProperty(r.ServicePropertiesPropertyName, "{}"));
      Object.keys(d).forEach((f) => {
        l[f] = d[f];
      });
    }
  };
  return yi.ConversationTranscriberConnectionFactory = n, yi;
}
var Si = {}, xd;
function Cw() {
  if (xd) return Si;
  xd = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.TranscriberConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ le(), a = /* @__PURE__ */ tt();
  let s = class extends r.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
    }
    create(c, u, l) {
      let p = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, "centralus"), d = r.ConnectionFactoryBase.getHostSuffix(h), f = "wss://transcribe." + h + ".cts.speech" + d + this.multiaudioRelativeUri, g = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, f), m = {};
      this.setQueryParams(m, c, p), p || (p = g);
      const v = {};
      u.token !== void 0 && u.token !== "" && (v[u.headerName] = u.token), v[i.HeaderNames.ConnectionId] = l, c.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, p);
      const y = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(p, m, v, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(c), y, l));
    }
    setQueryParams(c, u, l) {
      const p = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), h = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      p && !(a.QueryParameterNames.CustomSpeechDeploymentId in c) && (c[a.QueryParameterNames.CustomSpeechDeploymentId] = p), h && !(a.QueryParameterNames.Language in c) && (c[a.QueryParameterNames.Language] = h);
      const d = u.parameters.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true", f = u.parameters.getProperty(o.OutputFormatPropertyName, t.OutputFormat[t.OutputFormat.Simple]) !== t.OutputFormat[t.OutputFormat.Simple];
      (d || f) && (c[a.QueryParameterNames.Format] = t.OutputFormat[t.OutputFormat.Detailed].toLowerCase()), this.setCommonUrlParams(u, c, l);
    }
  };
  return Si.TranscriberConnectionFactory = s, Si;
}
var Ci = {}, Nd;
function Rw() {
  if (Nd) return Ci;
  Nd = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.TranslationConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ Lv(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ ke(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ le(), s = /* @__PURE__ */ tt(), n = /* @__PURE__ */ we();
  let c = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/stt/speech/universal/v2", this.translationV1Uri = "/speech/translation/cognitiveservices/v1";
    }
    async create(l, p, h) {
      let d = this.getEndpointUrl(l);
      const f = {};
      if (this.setQueryParams(f, l, d), d) {
        const y = new URL(d), S = y.pathname;
        (S === "" || S === "/") && (y.pathname = this.universalUri, d = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(y.toString()));
      }
      const g = {};
      p.token !== void 0 && p.token !== "" && (g[p.headerName] = p.token), g[a.HeaderNames.ConnectionId] = h, l.parameters.setProperty(r.PropertyId.SpeechServiceConnection_Url, d);
      const m = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new e.WebsocketConnection(d, f, g, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), m, h);
    }
    getEndpointUrl(l, p) {
      const h = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region), d = o.ConnectionFactoryBase.getHostSuffix(h);
      let f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      return f ? p === !0 ? f : t.StringUtils.formatString(f, { region: h }) : (l.parameters.getProperty("SPEECH-ForceV1Endpoint", "false") === "true" ? f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + d) + this.translationV1Uri : f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + d) + this.universalUri, p === !0 ? f : t.StringUtils.formatString(f, { region: h }));
    }
    setQueryParams(l, p, h) {
      l.from = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), l.to = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages), l.scenario = p.recognitionMode === n.RecognitionMode.Interactive ? "interactive" : p.recognitionMode === n.RecognitionMode.Conversation ? "conversation" : "", this.setCommonUrlParams(p, l, h), this.setUrlParameter(r.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, s.QueryParameterNames.StableTranslation, p, l, h);
      const d = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
      d !== void 0 && (l.voice = d, l.features = "requireVoice");
    }
  };
  return Ci.TranslationConnectionFactory = c, Ci;
}
var Ri = {}, zd;
function Pw() {
  if (zd) return Ri;
  zd = 1, Object.defineProperty(Ri, "__esModule", { value: !0 }), Ri.EnumTranslation = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class {
    static implTranslateRecognitionResult(i, a = !1) {
      let s = e.ResultReason.Canceled;
      switch (i) {
        case t.RecognitionStatus.Success:
          s = e.ResultReason.RecognizedSpeech;
          break;
        case t.RecognitionStatus.EndOfDictation:
          s = a ? e.ResultReason.RecognizedSpeech : e.ResultReason.NoMatch;
          break;
        case t.RecognitionStatus.NoMatch:
        case t.RecognitionStatus.InitialSilenceTimeout:
        case t.RecognitionStatus.BabbleTimeout:
          s = e.ResultReason.NoMatch;
          break;
        case t.RecognitionStatus.Error:
        case t.RecognitionStatus.BadRequest:
        case t.RecognitionStatus.Forbidden:
        default:
          s = e.ResultReason.Canceled;
          break;
      }
      return s;
    }
    static implTranslateCancelResult(i) {
      let a = e.CancellationReason.EndOfStream;
      switch (i) {
        case t.RecognitionStatus.Success:
        case t.RecognitionStatus.EndOfDictation:
        case t.RecognitionStatus.NoMatch:
          a = e.CancellationReason.EndOfStream;
          break;
        case t.RecognitionStatus.InitialSilenceTimeout:
        case t.RecognitionStatus.BabbleTimeout:
        case t.RecognitionStatus.Error:
        case t.RecognitionStatus.BadRequest:
        case t.RecognitionStatus.Forbidden:
        default:
          a = e.CancellationReason.Error;
          break;
      }
      return a;
    }
    static implTranslateCancelErrorCode(i) {
      let a = e.CancellationErrorCode.NoError;
      switch (i) {
        case t.RecognitionStatus.Error:
          a = e.CancellationErrorCode.ServiceError;
          break;
        case t.RecognitionStatus.TooManyRequests:
          a = e.CancellationErrorCode.TooManyRequests;
          break;
        case t.RecognitionStatus.BadRequest:
          a = e.CancellationErrorCode.BadRequestParameters;
          break;
        case t.RecognitionStatus.Forbidden:
          a = e.CancellationErrorCode.Forbidden;
          break;
        default:
          a = e.CancellationErrorCode.NoError;
          break;
      }
      return a;
    }
    static implTranslateErrorDetails(i) {
      let a = "The speech service encountered an internal error and could not continue.";
      switch (i) {
        case e.CancellationErrorCode.Forbidden:
          a = "The recognizer is using a free subscription that ran out of quota.";
          break;
        case e.CancellationErrorCode.BadRequestParameters:
          a = "Invalid parameter or unsupported audio format in the request.";
          break;
        case e.CancellationErrorCode.TooManyRequests:
          a = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
          break;
      }
      return a;
    }
  };
  return Ri.EnumTranslation = r, Ri;
}
var ba = {}, Ld;
function ww() {
  return Ld || (Ld = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionStatus = e.SynthesisStatus = void 0, function(t) {
      t[t.Success = 0] = "Success", t[t.SynthesisEnd = 1] = "SynthesisEnd", t[t.Error = 2] = "Error";
    }(e.SynthesisStatus || (e.SynthesisStatus = {})), function(t) {
      t[t.Success = 0] = "Success", t[t.NoMatch = 1] = "NoMatch", t[t.InitialSilenceTimeout = 2] = "InitialSilenceTimeout", t[t.BabbleTimeout = 3] = "BabbleTimeout", t[t.Error = 4] = "Error", t[t.EndOfDictation = 5] = "EndOfDictation", t[t.TooManyRequests = 6] = "TooManyRequests", t[t.BadRequest = 7] = "BadRequest", t[t.Forbidden = 8] = "Forbidden";
    }(e.RecognitionStatus || (e.RecognitionStatus = {}));
  }(ba)), ba;
}
var Pi = {}, jd;
function bw() {
  if (jd) return Pi;
  jd = 1, Object.defineProperty(Pi, "__esModule", { value: !0 }), Pi.TranslationSynthesisEnd = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Kv {
    constructor(o) {
      this.privSynthesisEnd = JSON.parse(o), this.privSynthesisEnd.SynthesisStatus && (this.privSynthesisEnd.SynthesisStatus = e.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus]), this.privSynthesisEnd.Status && (this.privSynthesisEnd.SynthesisStatus = e.SynthesisStatus[this.privSynthesisEnd.Status]);
    }
    static fromJSON(o) {
      return new Kv(o);
    }
    get SynthesisStatus() {
      return this.privSynthesisEnd.SynthesisStatus;
    }
    get FailureReason() {
      return this.privSynthesisEnd.FailureReason;
    }
  };
  return Pi.TranslationSynthesisEnd = t, Pi;
}
var wi = {}, qd;
function Ew() {
  if (qd) return wi;
  qd = 1, Object.defineProperty(wi, "__esModule", { value: !0 }), wi.TranslationHypothesis = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ pc();
  let r = class Ya {
    constructor(i, a) {
      this.privTranslationHypothesis = i, this.privTranslationHypothesis.Offset += a, this.privTranslationHypothesis.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationHypothesis.Translation.TranslationStatus);
    }
    static fromJSON(i, a) {
      return new Ya(JSON.parse(i), a);
    }
    static fromTranslationResponse(i, a) {
      e.Contracts.throwIfNullOrUndefined(i, "translationHypothesis");
      const s = i.SpeechHypothesis;
      return i.SpeechHypothesis = void 0, s.Translation = i, new Ya(s, a);
    }
    get Duration() {
      return this.privTranslationHypothesis.Duration;
    }
    get Offset() {
      return this.privTranslationHypothesis.Offset;
    }
    get Text() {
      return this.privTranslationHypothesis.Text;
    }
    get Translation() {
      return this.privTranslationHypothesis.Translation;
    }
    get Language() {
      return this.privTranslationHypothesis.PrimaryLanguage?.Language;
    }
    asJson() {
      const i = { ...this.privTranslationHypothesis };
      return i.Translation !== void 0 ? JSON.stringify({
        ...i,
        TranslationStatus: t.TranslationStatus[i.Translation.TranslationStatus]
      }) : JSON.stringify(i);
    }
    mapTranslationStatus(i) {
      if (typeof i == "string")
        return t.TranslationStatus[i];
      if (typeof i == "number")
        return i;
    }
  };
  return wi.TranslationHypothesis = r, wi;
}
var bi = {}, Fd;
function Iw() {
  if (Fd) return bi;
  Fd = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.TranslationPhrase = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ pc();
  let o = class Za {
    constructor(a, s) {
      this.privTranslationPhrase = a, this.privTranslationPhrase.Offset += s, this.privTranslationPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privTranslationPhrase.RecognitionStatus), this.privTranslationPhrase.Translation !== void 0 && (this.privTranslationPhrase.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationPhrase.Translation.TranslationStatus));
    }
    static fromJSON(a, s) {
      return new Za(JSON.parse(a), s);
    }
    static fromTranslationResponse(a, s) {
      e.Contracts.throwIfNullOrUndefined(a, "translationResponse");
      const n = a.SpeechPhrase;
      return a.SpeechPhrase = void 0, n.Translation = a, n.Text = n.DisplayText, new Za(n, s);
    }
    get RecognitionStatus() {
      return this.privTranslationPhrase.RecognitionStatus;
    }
    get Offset() {
      return this.privTranslationPhrase.Offset;
    }
    get Duration() {
      return this.privTranslationPhrase.Duration;
    }
    get Text() {
      return this.privTranslationPhrase.Text;
    }
    get Language() {
      return this.privTranslationPhrase.PrimaryLanguage?.Language;
    }
    get Confidence() {
      return this.privTranslationPhrase.PrimaryLanguage?.Confidence;
    }
    get Translation() {
      return this.privTranslationPhrase.Translation;
    }
    asJson() {
      const a = { ...this.privTranslationPhrase }, s = {
        ...a,
        RecognitionStatus: t.RecognitionStatus[a.RecognitionStatus]
      };
      return a.Translation && (s.Translation = {
        ...a.Translation,
        TranslationStatus: r.TranslationStatus[a.Translation.TranslationStatus]
      }), JSON.stringify(s);
    }
    mapRecognitionStatus(a) {
      if (typeof a == "string")
        return t.RecognitionStatus[a];
      if (typeof a == "number")
        return a;
    }
    mapTranslationStatus(a) {
      if (typeof a == "string")
        return r.TranslationStatus[a];
      if (typeof a == "number")
        return a;
    }
  };
  return bi.TranslationPhrase = o, bi;
}
var Ei = {}, Bd;
function Aw() {
  if (Bd) return Ei;
  Bd = 1, Object.defineProperty(Ei, "__esModule", { value: !0 }), Ei.TranslationServiceRecognizer = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _();
  let o = class extends r.ConversationServiceRecognizer {
    constructor(a, s, n, c, u) {
      super(a, s, n, c, u), this.privTranslationRecognizer = u, this.connectionEvents.attach((l) => {
        l.name === "ConnectionEstablishedEvent" && this.privTranslationRecognizer.onConnection();
      });
    }
    async processTypeSpecificMessages(a) {
      const s = new t.PropertyCollection();
      let n = await this.processSpeechMessages(a);
      if (n)
        return !0;
      const c = async (l) => {
        if (s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, l.asJson()), this.privRequestSession.onPhraseRecognized(l.Offset + l.Duration), l.RecognitionStatus === r.RecognitionStatus.Success) {
          const p = this.fireEventForResult(l, s);
          if (this.privTranslationRecognizer.recognized)
            try {
              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, p);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(p.result);
            } catch (h) {
              this.privErrorCallback && this.privErrorCallback(h);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
        } else {
          const p = r.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus), h = new t.TranslationRecognitionResult(void 0, this.privRequestSession.requestId, p, l.Text, l.Duration, l.Offset, l.Language, l.Confidence, void 0, l.asJson(), s);
          if (p === t.ResultReason.Canceled) {
            const d = r.EnumTranslation.implTranslateCancelResult(l.RecognitionStatus), f = r.EnumTranslation.implTranslateCancelErrorCode(l.RecognitionStatus);
            await this.cancelRecognitionLocal(d, f, r.EnumTranslation.implTranslateErrorDetails(f));
          } else if (l.RecognitionStatus !== r.RecognitionStatus.EndOfDictation) {
            const d = new t.TranslationRecognitionEventArgs(h, h.offset, this.privRequestSession.sessionId);
            if (this.privTranslationRecognizer.recognized)
              try {
                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, d);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(h);
              } catch (f) {
                this.privErrorCallback && this.privErrorCallback(f);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          n = !0;
        }
      }, u = (l) => {
        s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, l.asJson());
        const p = this.fireEventForResult(l, s);
        if (this.privRequestSession.onHypothesis(p.offset), this.privTranslationRecognizer.recognizing)
          try {
            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, p);
          } catch {
          }
        n = !0;
      };
      switch (a.messageType === e.MessageType.Text && s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, a.textBody), a.path.toLowerCase()) {
        case "translation.hypothesis":
          u(r.TranslationHypothesis.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.response":
          const l = JSON.parse(a.textBody);
          if (l.SpeechPhrase)
            await c(r.TranslationPhrase.fromTranslationResponse(l, this.privRequestSession.currentTurnAudioOffset));
          else {
            const h = JSON.parse(a.textBody);
            h.SpeechHypothesis && u(r.TranslationHypothesis.fromTranslationResponse(h, this.privRequestSession.currentTurnAudioOffset));
          }
          break;
        case "translation.phrase":
          await c(r.TranslationPhrase.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.synthesis":
        case "audio":
          this.sendSynthesisAudio(a.binaryBody, this.privRequestSession.sessionId), n = !0;
          break;
        case "audio.end":
        case "translation.synthesis.end":
          const p = r.TranslationSynthesisEnd.fromJSON(a.textBody);
          switch (p.SynthesisStatus) {
            case r.SynthesisStatus.Error:
              if (this.privTranslationRecognizer.synthesizing) {
                const h = new t.TranslationSynthesisResult(t.ResultReason.Canceled, void 0), d = new t.TranslationSynthesisEventArgs(h, this.privRequestSession.sessionId);
                try {
                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, d);
                } catch {
                }
              }
              if (this.privTranslationRecognizer.canceled) {
                const h = new t.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, t.CancellationReason.Error, p.FailureReason, t.CancellationErrorCode.ServiceError, null);
                try {
                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, h);
                } catch {
                }
              }
              break;
            case r.SynthesisStatus.Success:
              this.sendSynthesisAudio(void 0, this.privRequestSession.sessionId);
              break;
          }
          n = !0;
          break;
      }
      return n;
    }
    // Cancels recognition.
    cancelRecognition(a, s, n, c, u) {
      const l = new t.PropertyCollection();
      if (l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]), this.privTranslationRecognizer.canceled) {
        const p = new t.TranslationRecognitionCanceledEventArgs(a, n, u, c, void 0);
        try {
          this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.TranslationRecognitionResult(
          void 0,
          // Translations
          s,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Druation
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          l
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    handleRecognizingCallback(a, s, n) {
      try {
        const c = new t.TranslationRecognitionEventArgs(t.TranslationRecognitionResult.fromSpeechRecognitionResult(a), s, n);
        this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    handleRecognizedCallback(a, s, n) {
      try {
        const c = new t.TranslationRecognitionEventArgs(t.TranslationRecognitionResult.fromSpeechRecognitionResult(a), s, n);
        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    fireEventForResult(a, s) {
      let n;
      if (a.Translation.Translations !== void 0) {
        n = new t.Translations();
        for (const d of a.Translation.Translations)
          n.set(d.Language, d.Text || d.DisplayText);
      }
      let c, u;
      a instanceof r.TranslationPhrase ? (a.Translation && a.Translation.TranslationStatus === e.TranslationStatus.Success ? c = t.ResultReason.TranslatedSpeech : c = t.ResultReason.RecognizedSpeech, u = a.Confidence) : c = t.ResultReason.TranslatingSpeech;
      const l = a.Language, p = new t.TranslationRecognitionResult(n, this.privRequestSession.requestId, c, a.Text, a.Duration, a.Offset, l, u, a.Translation.FailureReason, a.asJson(), s);
      return new t.TranslationRecognitionEventArgs(p, a.Offset, this.privRequestSession.sessionId);
    }
    sendSynthesisAudio(a, s) {
      const n = a === void 0 ? t.ResultReason.SynthesizingAudioCompleted : t.ResultReason.SynthesizingAudio, c = new t.TranslationSynthesisResult(n, a), u = new t.TranslationSynthesisEventArgs(c, s);
      if (this.privTranslationRecognizer.synthesizing)
        try {
          this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, u);
        } catch {
        }
    }
  };
  return Ei.TranslationServiceRecognizer = o, Ei;
}
var Ii = {}, Ud;
function Tw() {
  if (Ud) return Ii;
  Ud = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.SpeechDetected = void 0;
  let e = class Jv {
    constructor(r, o) {
      this.privSpeechStartDetected = JSON.parse(r), this.privSpeechStartDetected.Offset += o;
    }
    static fromJSON(r, o) {
      return new Jv(r, o);
    }
    get Offset() {
      return this.privSpeechStartDetected.Offset;
    }
  };
  return Ii.SpeechDetected = e, Ii;
}
var Ai = {}, $d;
function _w() {
  if ($d) return Ai;
  $d = 1, Object.defineProperty(Ai, "__esModule", { value: !0 }), Ai.SpeechHypothesis = void 0;
  let e = class Gv {
    constructor(r, o) {
      this.privSpeechHypothesis = JSON.parse(r), this.updateOffset(o);
    }
    static fromJSON(r, o) {
      return new Gv(r, o);
    }
    updateOffset(r) {
      this.privSpeechHypothesis.Offset += r;
    }
    asJson() {
      return JSON.stringify(this.privSpeechHypothesis);
    }
    get Text() {
      return this.privSpeechHypothesis.Text;
    }
    get Offset() {
      return this.privSpeechHypothesis.Offset;
    }
    get Duration() {
      return this.privSpeechHypothesis.Duration;
    }
    get Language() {
      return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSpeechHypothesis.SpeakerId;
    }
  };
  return Ai.SpeechHypothesis = e, Ai;
}
var Ti = {}, Vd;
function kw() {
  if (Vd) return Ti;
  Vd = 1, Object.defineProperty(Ti, "__esModule", { value: !0 }), Ti.SpeechKeyword = void 0;
  let e = class Qv {
    constructor(r, o) {
      this.privSpeechKeyword = JSON.parse(r), this.privSpeechKeyword.Offset += o;
    }
    static fromJSON(r, o) {
      return new Qv(r, o);
    }
    get Status() {
      return this.privSpeechKeyword.Status;
    }
    get Text() {
      return this.privSpeechKeyword.Text;
    }
    get Offset() {
      return this.privSpeechKeyword.Offset;
    }
    get Duration() {
      return this.privSpeechKeyword.Duration;
    }
    asJson() {
      return JSON.stringify(this.privSpeechKeyword);
    }
  };
  return Ti.SpeechKeyword = e, Ti;
}
var _i = {}, Wd;
function Ow() {
  if (Wd) return _i;
  Wd = 1, Object.defineProperty(_i, "__esModule", { value: !0 }), _i.SpeechServiceRecognizer = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class extends t.ServiceRecognizerBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, n, c), this.privSpeechRecognizer = c;
    }
    async processTypeSpecificMessages(i) {
      let a;
      const s = new e.PropertyCollection();
      let n = !1;
      switch (i.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const c = t.SpeechHypothesis.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
          s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, c.asJson()), a = new e.SpeechRecognitionResult(
            this.privRequestSession.requestId,
            e.ResultReason.RecognizingSpeech,
            c.Text,
            c.Duration,
            c.Offset,
            c.Language,
            c.LanguageDetectionConfidence,
            void 0,
            // Speaker Id
            void 0,
            c.asJson(),
            s
          ), this.privRequestSession.onHypothesis(c.Offset);
          const u = new e.SpeechRecognitionEventArgs(a, c.Offset, this.privRequestSession.sessionId);
          if (this.privSpeechRecognizer.recognizing)
            try {
              this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, u);
            } catch {
            }
          n = !0;
          break;
        case "speech.phrase":
          const l = t.SimpleSpeechPhrase.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
          s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, l.asJson());
          const p = t.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus, this.privExpectContentAssessmentResponse);
          if (this.privRequestSession.onPhraseRecognized(l.Offset + l.Duration), e.ResultReason.Canceled === p) {
            const h = t.EnumTranslation.implTranslateCancelResult(l.RecognitionStatus), d = t.EnumTranslation.implTranslateCancelErrorCode(l.RecognitionStatus);
            await this.cancelRecognitionLocal(h, d, t.EnumTranslation.implTranslateErrorDetails(d));
          } else {
            if (l.RecognitionStatus === t.RecognitionStatus.EndOfDictation)
              break;
            if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
              a = new e.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                p,
                l.DisplayText,
                l.Duration,
                l.Offset,
                l.Language,
                l.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                l.asJson(),
                s
              );
            else {
              const d = t.DetailedSpeechPhrase.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
              s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, d.asJson()), a = new e.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                p,
                d.RecognitionStatus === t.RecognitionStatus.Success ? d.NBest[0].Display : "",
                d.Duration,
                d.Offset,
                d.Language,
                d.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                d.asJson(),
                s
              );
            }
            const h = new e.SpeechRecognitionEventArgs(a, a.offset, this.privRequestSession.sessionId);
            if (this.privSpeechRecognizer.recognized)
              try {
                this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, h);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(a);
              } catch (d) {
                this.privErrorCallback && this.privErrorCallback(d);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          n = !0;
          break;
      }
      return n;
    }
    // Cancels recognition.
    cancelRecognition(i, a, s, n, c) {
      const u = new e.PropertyCollection();
      if (u.setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[n]), this.privSpeechRecognizer.canceled) {
        const l = new e.SpeechRecognitionCanceledEventArgs(s, c, n, void 0, i);
        try {
          this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, l);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const l = new e.SpeechRecognitionResult(
          a,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          c,
          void 0,
          // Json
          u
        );
        try {
          this.privSuccessCallback(l), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return _i.SpeechServiceRecognizer = r, _i;
}
var ki = {}, Ea = {}, Hd;
function Mw() {
  return Hd || (Hd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.IdentityProvider = e.SpeakerDiarizationMode = void 0, function(t) {
      t.None = "None", t.Identity = "Identity", t.Anonymous = "Anonymous";
    }(e.SpeakerDiarizationMode || (e.SpeakerDiarizationMode = {})), function(t) {
      t.CallCenter = "CallCenter";
    }(e.IdentityProvider || (e.IdentityProvider = {}));
  }(Ea)), Ea;
}
var Kd;
function Dw() {
  if (Kd) return ki;
  Kd = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.ConversationTranscriptionServiceRecognizer = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ Mw(), o = /* @__PURE__ */ we();
  let i = class extends t.ServiceRecognizerBase {
    constructor(s, n, c, u, l) {
      super(s, n, c, u, l), this.privConversationTranscriber = l, this.setSpeakerDiarizationJson();
    }
    setSpeakerDiarizationJson() {
      if (this.privEnableSpeakerId) {
        const s = this.privSpeechContext.getContext().phraseDetection || {};
        s.mode = o.RecognitionMode.Conversation;
        const n = {};
        n.mode = r.SpeakerDiarizationMode.Anonymous, n.audioSessionId = this.privDiarizationSessionId, n.audioOffsetMs = 0, n.diarizeIntermediates = this.privRecognizerConfig.parameters.getProperty(e.PropertyId.SpeechServiceResponse_DiarizeIntermediateResults, "false") === "true", s.speakerDiarization = n, this.privSpeechContext.getContext().phraseDetection = s;
      }
    }
    async processTypeSpecificMessages(s) {
      let n;
      const c = new e.PropertyCollection();
      c.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, s.textBody);
      let u = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const l = t.SpeechHypothesis.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, e.ResultReason.RecognizingSpeech, l.Text, l.Duration, l.Offset, l.Language, l.LanguageDetectionConfidence, l.SpeakerId, void 0, l.asJson(), c), this.privRequestSession.onHypothesis(l.Offset);
          const p = new e.ConversationTranscriptionEventArgs(n, l.Duration, this.privRequestSession.sessionId);
          if (this.privConversationTranscriber.transcribing)
            try {
              this.privConversationTranscriber.transcribing(this.privConversationTranscriber, p);
            } catch {
            }
          u = !0;
          break;
        case "speech.phrase":
          const h = t.SimpleSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset), d = t.EnumTranslation.implTranslateRecognitionResult(h.RecognitionStatus);
          if (this.privRequestSession.onPhraseRecognized(h.Offset + h.Duration), e.ResultReason.Canceled === d) {
            const f = t.EnumTranslation.implTranslateCancelResult(h.RecognitionStatus), g = t.EnumTranslation.implTranslateCancelErrorCode(h.RecognitionStatus);
            await this.cancelRecognitionLocal(f, g, t.EnumTranslation.implTranslateErrorDetails(g));
          } else if (!(this.privRequestSession.isSpeechEnded && d === e.ResultReason.NoMatch && h.RecognitionStatus !== t.RecognitionStatus.InitialSilenceTimeout)) {
            if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
              n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, d, h.DisplayText, h.Duration, h.Offset, h.Language, h.LanguageDetectionConfidence, h.SpeakerId, void 0, h.asJson(), c);
            else {
              const g = t.DetailedSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
              n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, d, g.RecognitionStatus === t.RecognitionStatus.Success ? g.NBest[0].Display : void 0, g.Duration, g.Offset, g.Language, g.LanguageDetectionConfidence, h.SpeakerId, void 0, g.asJson(), c);
            }
            const f = new e.ConversationTranscriptionEventArgs(n, n.offset, this.privRequestSession.sessionId);
            if (this.privConversationTranscriber.transcribed)
              try {
                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, f);
              } catch {
              }
          }
          u = !0;
          break;
      }
      return u;
    }
    // Cancels recognition.
    cancelRecognition(s, n, c, u, l) {
      if (new e.PropertyCollection().setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[u]), this.privConversationTranscriber.canceled) {
        const h = new e.ConversationTranscriptionCanceledEventArgs(c, l, u, void 0, s);
        try {
          this.privConversationTranscriber.canceled(this.privConversationTranscriber, h);
        } catch {
        }
      }
    }
  };
  return ki.ConversationTranscriptionServiceRecognizer = i, ki;
}
var Oi = {}, Jd;
function xw() {
  if (Jd) return Oi;
  Jd = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.TranscriptionServiceRecognizer = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Jt();
  let i = class extends r.ConversationServiceRecognizer {
    constructor(s, n, c, u, l) {
      super(s, n, c, u, l), this.privTranscriberRecognizer = l, this.sendPrePayloadJSONOverride = (p) => this.sendTranscriptionStartJSON(p), this.privRecognizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true" && this.privSpeechContext.setWordLevelTimings();
    }
    async sendSpeechEventAsync(s, n) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createSpeechEventPayload(s, n));
      }
    }
    async sendMeetingSpeechEventAsync(s, n) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createMeetingSpeechEventPayload(s, n));
      }
    }
    processTypeSpecificMessages(s) {
      return this.processSpeechMessages(s);
    }
    handleRecognizedCallback(s, n, c) {
      try {
        const u = new t.SpeechRecognitionEventArgs(s, n, c);
        if (this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, u), this.privSuccessCallback) {
          try {
            this.privSuccessCallback(s);
          } catch (l) {
            this.privErrorCallback && this.privErrorCallback(l);
          }
          this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
        }
      } catch {
      }
    }
    handleRecognizingCallback(s, n, c) {
      try {
        const u = new t.SpeechRecognitionEventArgs(s, n, c);
        this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, u);
      } catch {
      }
    }
    // Cancels recognition.
    cancelRecognition(s, n, c, u, l) {
      const p = new t.PropertyCollection();
      if (p.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[u]), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        if (this.privTranscriberRecognizer.canceled) {
          const h = new t.MeetingTranscriptionCanceledEventArgs(c, l, u, void 0, s);
          try {
            this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, h);
          } catch {
          }
        }
      } else if (this.privTranscriberRecognizer.canceled) {
        const h = new t.ConversationTranscriptionCanceledEventArgs(c, l, u, void 0, s);
        try {
          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, h);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const h = new t.SpeechRecognitionResult(
          n,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          l,
          void 0,
          // Json
          p
        );
        try {
          this.privSuccessCallback(h), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendTranscriptionStartJSON(s) {
      if (await this.sendSpeechContext(s, !0), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        const n = this.privTranscriberRecognizer.getMeetingInfo(), c = this.createMeetingSpeechEventPayload(n, "start");
        await this.sendSpeechEvent(s, c);
      } else {
        const n = this.privTranscriberRecognizer.getConversationInfo(), c = this.createSpeechEventPayload(n, "start");
        await this.sendSpeechEvent(s, c);
      }
      await this.sendWaveHeader(s);
    }
    sendSpeechEvent(s, n) {
      const c = JSON.stringify(n);
      if (c)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", c));
    }
    createSpeechEventPayload(s, n) {
      const c = { id: "meeting", name: n, meeting: s.conversationProperties };
      return c.meeting.id = s.id, c.meeting.attendees = s.participants, c;
    }
    createMeetingSpeechEventPayload(s, n) {
      const c = { id: "meeting", name: n, meeting: s.meetingProperties };
      return c.meeting.id = s.id, c.meeting.attendees = s.participants, c;
    }
  };
  return Oi.TranscriptionServiceRecognizer = i, Oi;
}
var Mi = {}, Gd;
function Nw() {
  if (Gd) return Mi;
  Gd = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.DetailedSpeechPhrase = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Yv {
    constructor(o, i) {
      this.privDetailedSpeechPhrase = JSON.parse(o), this.privDetailedSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privDetailedSpeechPhrase.RecognitionStatus), this.updateOffsets(i);
    }
    static fromJSON(o, i) {
      return new Yv(o, i);
    }
    updateOffsets(o) {
      if (this.privDetailedSpeechPhrase.Offset += o, this.privDetailedSpeechPhrase.NBest)
        for (const i of this.privDetailedSpeechPhrase.NBest) {
          if (i.Words)
            for (const a of i.Words)
              a.Offset += o;
          if (i.DisplayWords)
            for (const a of i.DisplayWords)
              a.Offset += o;
        }
    }
    asJson() {
      const o = { ...this.privDetailedSpeechPhrase };
      return JSON.stringify({
        ...o,
        RecognitionStatus: e.RecognitionStatus[o.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privDetailedSpeechPhrase.RecognitionStatus;
    }
    get NBest() {
      return this.privDetailedSpeechPhrase.NBest;
    }
    get Duration() {
      return this.privDetailedSpeechPhrase.Duration;
    }
    get Offset() {
      return this.privDetailedSpeechPhrase.Offset;
    }
    get Language() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get Text() {
      return this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0] ? this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText : this.privDetailedSpeechPhrase.DisplayText;
    }
    get SpeakerId() {
      return this.privDetailedSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(o) {
      if (typeof o == "string")
        return e.RecognitionStatus[o];
      if (typeof o == "number")
        return o;
    }
  };
  return Mi.DetailedSpeechPhrase = t, Mi;
}
var Di = {}, Qd;
function zw() {
  if (Qd) return Di;
  Qd = 1, Object.defineProperty(Di, "__esModule", { value: !0 }), Di.SimpleSpeechPhrase = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Zv {
    constructor(o, i = 0) {
      this.privSimpleSpeechPhrase = JSON.parse(o), this.privSimpleSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privSimpleSpeechPhrase.RecognitionStatus), this.updateOffset(i);
    }
    static fromJSON(o, i) {
      return new Zv(o, i);
    }
    updateOffset(o) {
      this.privSimpleSpeechPhrase.Offset += o;
    }
    asJson() {
      const o = { ...this.privSimpleSpeechPhrase };
      return JSON.stringify({
        ...o,
        RecognitionStatus: e.RecognitionStatus[o.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privSimpleSpeechPhrase.RecognitionStatus;
    }
    get DisplayText() {
      return this.privSimpleSpeechPhrase.DisplayText;
    }
    get Offset() {
      return this.privSimpleSpeechPhrase.Offset;
    }
    get Duration() {
      return this.privSimpleSpeechPhrase.Duration;
    }
    get Language() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSimpleSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(o) {
      if (typeof o == "string")
        return e.RecognitionStatus[o];
      if (typeof o == "number")
        return o;
    }
  };
  return Di.SimpleSpeechPhrase = t, Di;
}
var xi = {}, Yd;
function Lw() {
  if (Yd) return xi;
  Yd = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.AddedLmIntent = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param modelImpl - The model.
     * @param intentName - The intent name.
     */
    constructor(r, o) {
      this.modelImpl = r, this.intentName = o;
    }
  };
  return xi.AddedLmIntent = e, xi;
}
var Ni = {}, Zd;
function jw() {
  if (Zd) return Ni;
  Zd = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.IntentServiceRecognizer = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _();
  let o = class extends r.ServiceRecognizerBase {
    constructor(a, s, n, c, u) {
      super(a, s, n, c, u), this.privIntentRecognizer = u, this.privIntentDataSent = !1, c.recognitionEndpointVersion = "1";
    }
    setIntents(a, s) {
      this.privAddedLmIntents = a, this.privUmbrellaIntent = s, this.privIntentDataSent = !0;
    }
    processTypeSpecificMessages(a) {
      let s, n, c = !1;
      const u = new t.PropertyCollection();
      switch (a.messageType === e.MessageType.Text && u.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, a.textBody), a.path.toLowerCase()) {
        case "speech.hypothesis":
          const p = r.SpeechHypothesis.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (s = new t.IntentRecognitionResult(void 0, this.privRequestSession.requestId, t.ResultReason.RecognizingIntent, p.Text, p.Duration, p.Offset, p.Language, p.LanguageDetectionConfidence, void 0, p.asJson(), u), this.privRequestSession.onHypothesis(s.offset), n = new t.IntentRecognitionEventArgs(s, p.Offset, this.privRequestSession.sessionId), this.privIntentRecognizer.recognizing)
            try {
              this.privIntentRecognizer.recognizing(this.privIntentRecognizer, n);
            } catch {
            }
          c = !0;
          break;
        case "speech.phrase":
          const h = r.SimpleSpeechPhrase.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset);
          s = new t.IntentRecognitionResult(void 0, this.privRequestSession.requestId, r.EnumTranslation.implTranslateRecognitionResult(h.RecognitionStatus), h.DisplayText, h.Duration, h.Offset, h.Language, h.LanguageDetectionConfidence, void 0, h.asJson(), u), n = new t.IntentRecognitionEventArgs(s, s.offset, this.privRequestSession.sessionId);
          const d = () => {
            if (this.privIntentRecognizer.recognized)
              try {
                this.privIntentRecognizer.recognized(this.privIntentRecognizer, n);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(s);
              } catch (g) {
                this.privErrorCallback && this.privErrorCallback(g);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          };
          this.privIntentDataSent === !1 || t.ResultReason.NoMatch === n.result.reason ? (this.privRequestSession.onPhraseRecognized(n.offset + n.result.duration), d()) : this.privPendingIntentArgs = n, c = !0;
          break;
        case "response":
          if (n = this.privPendingIntentArgs, this.privPendingIntentArgs = void 0, n === void 0) {
            if (a.textBody === "")
              return;
            n = new t.IntentRecognitionEventArgs(new t.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
          }
          const f = r.IntentResponse.fromJSON(a.textBody);
          if (f !== null && f.topScoringIntent && f.topScoringIntent.intent) {
            let g = this.privAddedLmIntents[f.topScoringIntent.intent];
            if (this.privUmbrellaIntent !== void 0 && (g = this.privUmbrellaIntent), g) {
              const m = g === void 0 || g.intentName === void 0 ? f.topScoringIntent.intent : g.intentName;
              let v = n.result.reason;
              m !== void 0 && (v = t.ResultReason.RecognizedIntent);
              const y = n.result.properties !== void 0 ? n.result.properties : new t.PropertyCollection();
              y.setProperty(t.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, a.textBody), n = new t.IntentRecognitionEventArgs(new t.IntentRecognitionResult(m, n.result.resultId, v, n.result.text, n.result.duration, n.result.offset, void 0, void 0, n.result.errorDetails, n.result.json, y), n.offset, n.sessionId);
            }
          }
          if (this.privRequestSession.onPhraseRecognized(n.offset + n.result.duration), this.privIntentRecognizer.recognized)
            try {
              this.privIntentRecognizer.recognized(this.privIntentRecognizer, n);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(n.result);
            } catch (g) {
              this.privErrorCallback && this.privErrorCallback(g);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
          c = !0;
          break;
      }
      const l = new e.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(a, s, n, c, u) {
      const l = new t.PropertyCollection();
      if (l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]), this.privIntentRecognizer.canceled) {
        const p = new t.IntentRecognitionCanceledEventArgs(n, u, c, void 0, void 0, a);
        try {
          this.privIntentRecognizer.canceled(this.privIntentRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.IntentRecognitionResult(
          void 0,
          // Intent Id
          s,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          l
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Ni.IntentServiceRecognizer = o, Ni;
}
var zi = {}, Xd;
function qw() {
  if (Xd) return zi;
  Xd = 1, Object.defineProperty(zi, "__esModule", { value: !0 }), zi.IntentResponse = void 0;
  let e = class Xv {
    constructor(r) {
      r === "" ? this.privIntentResponse = {} : this.privIntentResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new Xv(r);
    }
    get query() {
      return this.privIntentResponse.query;
    }
    get topScoringIntent() {
      return this.privIntentResponse.topScoringIntent;
    }
    get entities() {
      return this.privIntentResponse.entities;
    }
  };
  return zi.IntentResponse = e, zi;
}
var Ia = {}, eh;
function Fw() {
  return eh || (eh = 1, Object.defineProperty(Ia, "__esModule", { value: !0 })), Ia;
}
var Li = {}, ji = {}, th;
function Bw() {
  if (th) return ji;
  th = 1, Object.defineProperty(ji, "__esModule", { value: !0 }), ji.ServiceTelemetryListener = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ mc();
  class r {
    constructor(i, a, s) {
      this.privIsDisposed = !1, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privRequestId = i, this.privAudioSourceId = a, this.privAudioNodeId = s, this.privReceivedMessages = {}, this.privPhraseLatencies = [], this.privHypothesisLatencies = [];
    }
    phraseReceived(i) {
      i > 0 && this.privPhraseLatencies.push(Date.now() - i);
    }
    hypothesisReceived(i) {
      i > 0 && this.privHypothesisLatencies.push(Date.now() - i);
    }
    onEvent(i) {
      this.privIsDisposed || (i instanceof t.RecognitionTriggeredEvent && i.requestId === this.privRequestId && (this.privListeningTriggerMetric = {
        End: i.eventTime,
        Name: "ListeningTrigger",
        Start: i.eventTime
      }), i instanceof e.AudioStreamNodeAttachingEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = i.eventTime), i instanceof e.AudioStreamNodeAttachedEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = i.eventTime), i instanceof e.AudioSourceErrorEvent && i.audioSourceId === this.privAudioSourceId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Error: i.error,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof e.AudioStreamNodeErrorEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Error: i.error,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof e.AudioStreamNodeDetachedEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof t.ConnectingToServiceEvent && i.requestId === this.privRequestId && (this.privConnectionId = i.sessionId), i instanceof e.ConnectionStartEvent && i.connectionId === this.privConnectionId && (this.privConnectionStartTime = i.eventTime), i instanceof e.ConnectionEstablishedEvent && i.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
        End: i.eventTime,
        Id: this.privConnectionId,
        Name: "Connection",
        Start: this.privConnectionStartTime
      })), i instanceof e.ConnectionEstablishErrorEvent && i.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
        End: i.eventTime,
        Error: this.getConnectionError(i.statusCode),
        Id: this.privConnectionId,
        Name: "Connection",
        Start: this.privConnectionStartTime
      })), i instanceof e.ConnectionMessageReceivedEvent && i.connectionId === this.privConnectionId && i.message && i.message.headers && i.message.headers.path && (this.privReceivedMessages[i.message.headers.path] || (this.privReceivedMessages[i.message.headers.path] = new Array()), this.privReceivedMessages[i.message.headers.path].length < 50 && this.privReceivedMessages[i.message.headers.path].push(i.networkReceivedTime)));
    }
    getTelemetry() {
      const i = new Array();
      this.privListeningTriggerMetric && i.push(this.privListeningTriggerMetric), this.privMicMetric && i.push(this.privMicMetric), this.privConnectionEstablishMetric && i.push(this.privConnectionEstablishMetric), this.privPhraseLatencies.length > 0 && i.push({
        PhraseLatencyMs: this.privPhraseLatencies
      }), this.privHypothesisLatencies.length > 0 && i.push({
        FirstHypothesisLatencyMs: this.privHypothesisLatencies
      });
      const a = {
        Metrics: i,
        ReceivedMessages: this.privReceivedMessages
      }, s = JSON.stringify(a);
      return this.privReceivedMessages = {}, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privPhraseLatencies = [], this.privHypothesisLatencies = [], s;
    }
    // Determines if there are any telemetry events to send to the service.
    get hasTelemetry() {
      return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
    }
    dispose() {
      this.privIsDisposed = !0;
    }
    getConnectionError(i) {
      switch (i) {
        case 400:
        case 1002:
        case 1003:
        case 1005:
        case 1007:
        case 1008:
        case 1009:
          return "BadRequest";
        case 401:
          return "Unauthorized";
        case 403:
          return "Forbidden";
        case 503:
        case 1001:
          return "ServerUnavailable";
        case 500:
        case 1011:
          return "ServerError";
        case 408:
        case 504:
          return "Timeout";
        default:
          return "statuscode:" + i.toString();
      }
    }
  }
  return ji.ServiceTelemetryListener = r, ji;
}
var rh;
function Uw() {
  if (rh) return Li;
  rh = 1, Object.defineProperty(Li, "__esModule", { value: !0 }), Li.RequestSession = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ mc(), r = /* @__PURE__ */ Bw();
  let o = class {
    constructor(a) {
      this.privIsDisposed = !1, this.privDetachables = new Array(), this.privIsAudioNodeDetached = !1, this.privIsRecognizing = !1, this.privIsSpeechEnded = !1, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privHypothesisReceived = !1, this.privBytesSent = 0, this.privRecognitionBytesSent = 0, this.privRecogNumber = 0, this.privInTurn = !1, this.privConnectionAttempts = 0, this.privAudioSourceId = a, this.privRequestId = (0, e.createNoDashGuid)(), this.privAudioNodeId = (0, e.createNoDashGuid)(), this.privTurnDeferral = new e.Deferred(), this.privTurnDeferral.resolve();
    }
    get sessionId() {
      return this.privSessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSpeechEnded() {
      return this.privIsSpeechEnded;
    }
    get isRecognizing() {
      return this.privIsRecognizing;
    }
    get currentTurnAudioOffset() {
      return this.privTurnStartAudioOffset;
    }
    get recogNumber() {
      return this.privRecogNumber;
    }
    get numConnectionAttempts() {
      return this.privConnectionAttempts;
    }
    // The number of bytes sent for the current connection.
    // Counter is reset to 0 each time a connection is established.
    get bytesSent() {
      return this.privBytesSent;
    }
    // The number of bytes sent for the current recognition.
    // Counter is reset to 0 each time recognition is started.
    get recognitionBytesSent() {
      return this.privRecognitionBytesSent;
    }
    listenForServiceTelemetry(a) {
      this.privServiceTelemetryListener && this.privDetachables.push(a.attachListener(this.privServiceTelemetryListener));
    }
    startNewRecognition() {
      this.privRecognitionBytesSent = 0, this.privIsSpeechEnded = !1, this.privIsRecognizing = !0, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privRecogNumber++, this.privServiceTelemetryListener = new r.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId), this.onEvent(new t.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
    async onAudioSourceAttachCompleted(a, s) {
      this.privAudioNode = a, this.privIsAudioNodeDetached = !1, s ? await this.onComplete() : this.onEvent(new t.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
    onPreConnectionStart(a, s) {
      this.privAuthFetchEventId = a, this.privSessionId = s, this.onEvent(new t.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
    }
    async onAuthCompleted(a) {
      a && await this.onComplete();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onConnectionEstablishCompleted(a, s) {
      if (a === 200) {
        this.onEvent(new t.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId)), this.privAudioNode && this.privAudioNode.replay(), this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privBytesSent = 0;
        return;
      } else a === 403 && await this.onComplete();
    }
    async onServiceTurnEndResponse(a) {
      this.privTurnDeferral.resolve(), !a || this.isSpeechEnded ? (await this.onComplete(), this.privInTurn = !1) : (this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privAudioNode.replay());
    }
    onSpeechContext() {
      this.privRequestId = (0, e.createNoDashGuid)();
    }
    onServiceTurnStartResponse() {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new e.Deferred();
    }
    onHypothesis(a) {
      this.privHypothesisReceived || (this.privHypothesisReceived = !0, this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(a)));
    }
    onPhraseRecognized(a) {
      this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(a)), this.onServiceRecognized(a);
    }
    onServiceRecognized(a) {
      this.privLastRecoOffset = a, this.privHypothesisReceived = !1, this.privAudioNode.shrinkBuffers(a), this.privConnectionAttempts = 0;
    }
    onAudioSent(a) {
      this.privBytesSent += a, this.privRecognitionBytesSent += a;
    }
    onRetryConnection() {
      this.privConnectionAttempts++;
    }
    async dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = !0;
        for (const a of this.privDetachables)
          await a.detach();
        this.privServiceTelemetryListener && this.privServiceTelemetryListener.dispose(), this.privIsRecognizing = !1;
      }
    }
    getTelemetry() {
      return this.privServiceTelemetryListener.hasTelemetry ? this.privServiceTelemetryListener.getTelemetry() : null;
    }
    async onStopRecognizing() {
      await this.onComplete();
    }
    // Should be called with the audioNode for this session has indicated that it is out of speech.
    onSpeechEnded() {
      this.privIsSpeechEnded = !0;
    }
    onEvent(a) {
      this.privServiceTelemetryListener && this.privServiceTelemetryListener.onEvent(a), e.Events.instance.onEvent(a);
    }
    async onComplete() {
      this.privIsRecognizing && (this.privIsRecognizing = !1, await this.detachAudioNode());
    }
    async detachAudioNode() {
      this.privIsAudioNodeDetached || (this.privIsAudioNodeDetached = !0, this.privAudioNode && await this.privAudioNode.detach());
    }
  };
  return Li.RequestSession = o, Li;
}
var qi = {}, Aa = {}, nh;
function $w() {
  return nh || (nh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TentativePhraseResultsOption = e.OutputFormat = e.PhraseExtension = e.PhraseOption = void 0, function(t) {
      t.WordTimings = "WordTimings", t.SNR = "SNR", t.Pronunciation = "Pronunciation", t.WordPronunciation = "WordPronunciation", t.WordConfidence = "WordConfidence", t.Words = "Words", t.Sentiment = "Sentiment", t.PronunciationAssessment = "PronunciationAssessment", t.ContentAssessment = "ContentAssessment", t.PhraseAMScore = "PhraseAMScore", t.PhraseLMScore = "PhraseLMScore", t.WordAMScore = "WordAMScore", t.WordLMScore = "WordLMScore", t.RuleTree = "RuleTree", t.NBestTimings = "NBestTimings", t.DecoderDiagnostics = "DecoderDiagnostics", t.DisplayWordTimings = "DisplayWordTimings", t.DisplayWords = "DisplayWords";
    }(e.PhraseOption || (e.PhraseOption = {})), function(t) {
      t.Graph = "Graph", t.Corrections = "Corrections", t.Sentiment = "Sentiment";
    }(e.PhraseExtension || (e.PhraseExtension = {})), function(t) {
      t.Simple = "Simple", t.Detailed = "Detailed";
    }(e.OutputFormat || (e.OutputFormat = {})), function(t) {
      t.None = "None", t.Always = "Always";
    }(e.TentativePhraseResultsOption || (e.TentativePhraseResultsOption = {}));
  }(Aa)), Aa;
}
var ih;
function Vw() {
  if (ih) return qi;
  ih = 1, Object.defineProperty(qi, "__esModule", { value: !0 }), qi.SpeechContext = void 0;
  const e = /* @__PURE__ */ we(), t = /* @__PURE__ */ $w();
  let r = class {
    constructor(i) {
      this.privContext = {}, this.privDynamicGrammar = i;
    }
    getContext() {
      return this.privContext;
    }
    /**
     * @Internal
     * This is only used by pronunciation assessment config.
     * Do not use externally, object returned will change without warning or notice.
     */
    setPronunciationAssessmentParams(i, a, s = !1) {
      this.privContext.phraseDetection === void 0 && (this.privContext.phraseDetection = {
        enrichment: {
          pronunciationAssessment: {}
        }
      }), this.privContext.phraseDetection.enrichment === void 0 && (this.privContext.phraseDetection.enrichment = {
        pronunciationAssessment: {}
      }), this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(i) || {}, s && (this.privContext.phraseDetection.mode = e.RecognitionMode.Conversation), this.setWordLevelTimings(), this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.PronunciationAssessment), this.privContext.phraseOutput.detailed.options.indexOf(t.PhraseOption.SNR) === -1 && this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.SNR), a && (this.privContext.phraseDetection.enrichment.contentAssessment = {
        topic: a
      }, this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.ContentAssessment));
    }
    setDetailedOutputFormat() {
      this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
        detailed: {
          options: []
        }
      }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
        options: []
      }), this.privContext.phraseOutput.format = t.OutputFormat.Detailed;
    }
    setWordLevelTimings() {
      this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
        detailed: {
          options: []
        }
      }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
        options: []
      }), this.privContext.phraseOutput.format = t.OutputFormat.Detailed, this.privContext.phraseOutput.detailed.options.indexOf(t.PhraseOption.WordTimings) === -1 && this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.WordTimings);
    }
    setSpeakerDiarizationAudioOffsetMs(i) {
      this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = i;
    }
    toJSON() {
      const i = this.privDynamicGrammar.generateGrammarObject();
      return this.privContext.dgi = i, JSON.stringify(this.privContext);
    }
  };
  return qi.SpeechContext = r, qi;
}
var Fi = {}, Ta = {}, sh;
function Ww() {
  return sh || (sh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SubstringMatchType = e.GroupType = void 0, function(t) {
      t.IntentText = "IntentText", t.IntentEntity = "IntentEntity", t.Generic = "Generic", t.People = "People", t.Place = "Place", t.DynamicEntity = "DynamicEntity";
    }(e.GroupType || (e.GroupType = {})), function(t) {
      t.None = "None", t.LeftRooted = "LeftRooted", t.PartialName = "PartialName", t.MiddleOfSentence = "MiddleOfSentence";
    }(e.SubstringMatchType || (e.SubstringMatchType = {}));
  }(Ta)), Ta;
}
var oh;
function Hw() {
  if (oh) return Fi;
  oh = 1, Object.defineProperty(Fi, "__esModule", { value: !0 }), Fi.DynamicGrammarBuilder = void 0;
  const e = /* @__PURE__ */ Ww();
  let t = class {
    // Adds one more reference phrases to the dynamic grammar to send.
    // All added phrases are generic phrases.
    addPhrase(o) {
      this.privPhrases || (this.privPhrases = []), o instanceof Array ? this.privPhrases = this.privPhrases.concat(o) : this.privPhrases.push(o);
    }
    // Clears all phrases stored in the current object.
    clearPhrases() {
      this.privPhrases = void 0;
    }
    // Adds one or more reference grammars to the current grammar.
    addReferenceGrammar(o) {
      this.privGrammars || (this.privGrammars = []), o instanceof Array ? this.privGrammars = this.privGrammars.concat(o) : this.privGrammars.push(o);
    }
    // clears all grammars stored on the recognizer.
    clearGrammars() {
      this.privGrammars = void 0;
    }
    // Generates an object that represents the dynamic grammar used by the Speech Service.
    // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
    // of a DynamicGrammarBuilder
    generateGrammarObject() {
      if (this.privGrammars === void 0 && this.privPhrases === void 0)
        return;
      const o = {};
      if (o.referenceGrammars = this.privGrammars, this.privPhrases !== void 0 && this.privPhrases.length !== 0) {
        const i = [];
        this.privPhrases.forEach((a) => {
          i.push({
            text: a
          });
        }), o.groups = [{ type: e.GroupType.Generic, items: i }];
      }
      return o;
    }
  };
  return Fi.DynamicGrammarBuilder = t, Fi;
}
var Bi = {}, Ui = {}, $i = {}, _a = {}, ah;
function eg() {
  return ah || (ah = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MessageDataStreamType = e.ActivityPayloadResponse = void 0;
    class t {
      constructor(o) {
        this.privActivityResponse = JSON.parse(o);
      }
      static fromJSON(o) {
        return new t(o);
      }
      get conversationId() {
        return this.privActivityResponse.conversationId;
      }
      get messageDataStreamType() {
        return this.privActivityResponse.messageDataStreamType;
      }
      get messagePayload() {
        return this.privActivityResponse.messagePayload;
      }
      get version() {
        return this.privActivityResponse.version;
      }
    }
    e.ActivityPayloadResponse = t, function(r) {
      r[r.None = 0] = "None", r[r.TextToSpeechAudio = 1] = "TextToSpeechAudio";
    }(e.MessageDataStreamType || (e.MessageDataStreamType = {}));
  }(_a)), _a;
}
var ch;
function Kw() {
  if (ch) return $i;
  ch = 1, Object.defineProperty($i, "__esModule", { value: !0 }), $i.DialogServiceTurnState = void 0;
  const e = /* @__PURE__ */ Ps(), t = /* @__PURE__ */ Kt(), r = /* @__PURE__ */ eg();
  let o = class {
    constructor(a, s) {
      this.privRequestId = s, this.privIsCompleted = !1, this.privAudioStream = null, this.privTurnManager = a, this.resetTurnEndTimeout();
    }
    get audioStream() {
      return this.resetTurnEndTimeout(), this.privAudioStream;
    }
    processActivityPayload(a, s) {
      return a.messageDataStreamType === r.MessageDataStreamType.TextToSpeechAudio && (this.privAudioStream = t.AudioOutputStream.createPullStream(), this.privAudioStream.format = s !== void 0 ? s : e.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privAudioStream;
    }
    endAudioStream() {
      this.privAudioStream !== null && !this.privAudioStream.isClosed && this.privAudioStream.close();
    }
    complete() {
      this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.endAudioStream();
    }
    resetTurnEndTimeout() {
      this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.privTimeoutToken = setTimeout(() => {
        this.privTurnManager.CompleteTurn(this.privRequestId);
      }, 2e3);
    }
  };
  return $i.DialogServiceTurnState = o, $i;
}
var uh;
function Jw() {
  if (uh) return Ui;
  uh = 1, Object.defineProperty(Ui, "__esModule", { value: !0 }), Ui.DialogServiceTurnStateManager = void 0;
  const e = /* @__PURE__ */ xe(), t = /* @__PURE__ */ Kw();
  let r = class {
    constructor() {
      this.privTurnMap = /* @__PURE__ */ new Map();
    }
    StartTurn(i) {
      if (this.privTurnMap.has(i))
        throw new e.InvalidOperationError("Service error: There is already a turn with id:" + i);
      const a = new t.DialogServiceTurnState(this, i);
      return this.privTurnMap.set(i, a), this.privTurnMap.get(i);
    }
    GetTurn(i) {
      return this.privTurnMap.get(i);
    }
    CompleteTurn(i) {
      if (!this.privTurnMap.has(i))
        throw new e.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + i);
      const a = this.privTurnMap.get(i);
      return a.complete(), this.privTurnMap.delete(i), a;
    }
  };
  return Ui.DialogServiceTurnStateManager = r, Ui;
}
var ka = {}, lh;
function Gw() {
  return lh || (lh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.InvocationSource = void 0, function(t) {
      t.None = "None", t.VoiceActivationWithKeyword = "VoiceActivationWithKeyword";
    }(e.InvocationSource || (e.InvocationSource = {}));
  }(ka)), ka;
}
var Oa = {}, ph;
function Qw() {
  return ph || (ph = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OnRejectAction = e.KeywordDetectionType = void 0, function(t) {
      t.StartTrigger = "StartTrigger";
    }(e.KeywordDetectionType || (e.KeywordDetectionType = {})), function(t) {
      t.EndOfTurn = "EndOfTurn", t.Continue = "Continue";
    }(e.OnRejectAction || (e.OnRejectAction = {}));
  }(Oa)), Oa;
}
var dh;
function Yw() {
  if (dh) return Bi;
  dh = 1, Object.defineProperty(Bi, "__esModule", { value: !0 }), Bi.DialogServiceAdapter = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ av(), r = /* @__PURE__ */ M(), o = /* @__PURE__ */ Ps(), i = /* @__PURE__ */ I(), a = /* @__PURE__ */ Jw(), s = /* @__PURE__ */ _(), n = /* @__PURE__ */ eg(), c = /* @__PURE__ */ Gw(), u = /* @__PURE__ */ Qw(), l = /* @__PURE__ */ Jt();
  let p = class extends s.ServiceRecognizerBase {
    constructor(d, f, g, m, v) {
      super(d, f, g, m, v), this.privEvents = new r.EventSource(), this.privDialogServiceConnector = v, this.receiveMessageOverride = () => this.receiveDialogMessageOverride(), this.privTurnStateManager = new a.DialogServiceTurnStateManager(), this.recognizeOverride = (y, S, C) => this.listenOnce(y, S, C), this.postConnectImplOverride = (y) => this.dialogConnectImpl(y), this.configConnectionOverride = (y) => this.configConnection(y), this.disconnectOverride = () => this.privDisconnect(), this.privDialogAudioSource = g, this.agentConfigSent = !1, this.privLastResult = null, this.connectionEvents.attach((y) => {
        y.name === "ConnectionClosedEvent" && (this.terminateMessageLoop = !0);
      });
    }
    async sendMessage(d) {
      const f = (0, r.createGuid)(), g = (0, r.createNoDashGuid)(), m = {
        context: {
          interactionId: f
        },
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        messagePayload: JSON.parse(d),
        version: 0.5
      }, v = JSON.stringify(m);
      await (await this.fetchConnection()).send(new l.SpeechConnectionMessage(r.MessageType.Text, "agent", g, "application/json", v));
    }
    async privDisconnect() {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, this.agentConfigSent = !1;
    }
    processTypeSpecificMessages(d) {
      const f = new i.PropertyCollection();
      d.messageType === r.MessageType.Text && f.setProperty(i.PropertyId.SpeechServiceResponse_JsonResult, d.textBody);
      let g, m;
      switch (d.path.toLowerCase()) {
        case "speech.phrase":
          const y = s.SimpleSpeechPhrase.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (this.privRequestSession.onPhraseRecognized(y.Offset + y.Duration), y.RecognitionStatus !== s.RecognitionStatus.TooManyRequests && y.RecognitionStatus !== s.RecognitionStatus.Error) {
            const A = this.fireEventForResult(y, f);
            if (this.privLastResult = A.result, this.privDialogServiceConnector.recognized)
              try {
                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, A);
              } catch {
              }
          }
          m = !0;
          break;
        case "speech.hypothesis":
          const S = s.SpeechHypothesis.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          g = new i.SpeechRecognitionResult(this.privRequestSession.requestId, i.ResultReason.RecognizingSpeech, S.Text, S.Duration, S.Offset, S.Language, S.LanguageDetectionConfidence, void 0, void 0, S.asJson(), f), this.privRequestSession.onHypothesis(S.Offset);
          const C = new i.SpeechRecognitionEventArgs(g, S.Offset, this.privRequestSession.sessionId);
          if (this.privDialogServiceConnector.recognizing)
            try {
              this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, C);
            } catch {
            }
          m = !0;
          break;
        case "speech.keyword":
          const P = s.SpeechKeyword.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          g = new i.SpeechRecognitionResult(this.privRequestSession.requestId, P.Status === "Accepted" ? i.ResultReason.RecognizedKeyword : i.ResultReason.NoMatch, P.Text, P.Duration, P.Offset, void 0, void 0, void 0, void 0, P.asJson(), f), P.Status !== "Accepted" && (this.privLastResult = g);
          const b = new i.SpeechRecognitionEventArgs(g, g.duration, g.resultId);
          if (this.privDialogServiceConnector.recognized)
            try {
              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, b);
            } catch {
            }
          m = !0;
          break;
        case "audio":
          {
            const A = d.requestId.toUpperCase(), E = this.privTurnStateManager.GetTurn(A);
            try {
              d.binaryBody ? E.audioStream.write(d.binaryBody) : E.endAudioStream();
            } catch {
            }
          }
          m = !0;
          break;
        case "response":
          this.handleResponseMessage(d), m = !0;
          break;
      }
      const v = new r.Deferred();
      return v.resolve(m), v.promise;
    }
    // Cancels recognition.
    async cancelRecognition(d, f, g, m, v) {
      if (this.terminateMessageLoop = !0, this.privRequestSession.isRecognizing && await this.privRequestSession.onStopRecognizing(), this.privDialogServiceConnector.canceled) {
        const y = new i.PropertyCollection();
        y.setProperty(s.CancellationErrorCodePropertyName, i.CancellationErrorCode[m]);
        const S = new i.SpeechRecognitionCanceledEventArgs(g, v, m, void 0, d);
        try {
          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, S);
        } catch {
        }
        if (this.privSuccessCallback) {
          const C = new i.SpeechRecognitionResult(
            void 0,
            // ResultId
            i.ResultReason.Canceled,
            void 0,
            // Text
            void 0,
            // Duration
            void 0,
            // Offset
            void 0,
            // Language
            void 0,
            // Language Detection Confidence
            void 0,
            // Speaker Id
            v,
            void 0,
            // Json
            y
          );
          try {
            this.privSuccessCallback(C), this.privSuccessCallback = void 0;
          } catch {
          }
        }
      }
    }
    async listenOnce(d, f, g) {
      this.privRecognizerConfig.recognitionMode = d, this.privSuccessCallback = f, this.privErrorCallback = g, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events), this.privRecognizerConfig.parameters.setProperty(i.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const m = this.connectImpl(), v = this.sendPreAudioMessages(), y = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId), S = await this.privDialogAudioSource.format, C = await this.privDialogAudioSource.deviceInfo, P = new e.ReplayableAudioNode(y, S.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(P, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: C };
      try {
        await m, await v;
      } catch (E) {
        return await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.ConnectionFailure, E), Promise.resolve();
      }
      const b = new i.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, b), this.sendAudio(P).then(() => {
      }, async (E) => {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.RuntimeError, E);
      });
    }
    // Establishes a websocket connection to the end point.
    dialogConnectImpl(d) {
      return this.privConnectionLoop = this.startMessageLoop(), d;
    }
    receiveDialogMessageOverride() {
      const d = new r.Deferred(), f = async () => {
        try {
          const g = this.isDisposed(), m = !this.isDisposed() && this.terminateMessageLoop;
          if (g || m) {
            d.resolve(void 0);
            return;
          }
          const y = await (await this.fetchConnection()).read();
          if (!y)
            return f();
          const S = l.SpeechConnectionMessage.fromConnectionMessage(y);
          switch (S.path.toLowerCase()) {
            case "turn.start":
              {
                const R = S.requestId.toUpperCase(), j = this.privRequestSession.requestId.toUpperCase();
                R !== j ? this.privTurnStateManager.StartTurn(R) : this.privRequestSession.onServiceTurnStartResponse();
              }
              break;
            case "speech.startdetected":
              const P = s.SpeechDetected.fromJSON(S.textBody, this.privRequestSession.currentTurnAudioOffset), b = new i.RecognitionEventArgs(P.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, b);
              break;
            case "speech.enddetected":
              let A;
              S.textBody.length > 0 ? A = S.textBody : A = "{ Offset: 0 }";
              const E = s.SpeechDetected.fromJSON(A, this.privRequestSession.currentTurnAudioOffset);
              this.privRequestSession.onServiceRecognized(E.Offset);
              const D = new i.RecognitionEventArgs(E.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, D);
              break;
            case "turn.end":
              {
                const R = S.requestId.toUpperCase(), j = this.privRequestSession.requestId.toUpperCase();
                if (R !== j)
                  this.privTurnStateManager.CompleteTurn(R);
                else {
                  const T = new i.SessionEventArgs(this.privRequestSession.sessionId);
                  if (await this.privRequestSession.onServiceTurnEndResponse(!1), (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) && this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, T), this.privSuccessCallback && this.privLastResult) {
                    try {
                      this.privSuccessCallback(this.privLastResult), this.privLastResult = null;
                    } catch (x) {
                      this.privErrorCallback && this.privErrorCallback(x);
                    }
                    this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
                  }
                }
              }
              break;
            default:
              try {
                await this.processTypeSpecificMessages(S) || this.serviceEvents && this.serviceEvents.onEvent(new r.ServiceEvent(S.path.toLowerCase(), S.textBody));
              } catch {
              }
          }
          return f();
        } catch {
          this.terminateMessageLoop = !0, d.resolve();
        }
      };
      return f().catch((g) => {
        r.Events.instance.onEvent(new r.BackgroundEvent(g));
      }), d.promise;
    }
    async startMessageLoop() {
      this.terminateMessageLoop = !1;
      try {
        await this.receiveDialogMessageOverride();
      } catch (d) {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.RuntimeError, d);
      }
      return Promise.resolve();
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configConnection(d) {
      return this.terminateMessageLoop ? (this.terminateMessageLoop = !1, Promise.reject("Connection to service terminated.")) : (await this.sendSpeechServiceConfig(d, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendAgentConfig(d), d);
    }
    async sendPreAudioMessages() {
      const d = await this.fetchConnection();
      this.addKeywordContextData(), await this.sendSpeechContext(d, !0), await this.sendAgentContext(d), await this.sendWaveHeader(d);
    }
    sendAgentConfig(d) {
      if (this.agentConfig && !this.agentConfigSent) {
        if (this.privRecognizerConfig.parameters.getProperty(i.PropertyId.Conversation_DialogType) === i.DialogServiceConfig.DialogTypes.CustomCommands) {
          const g = this.agentConfig.get();
          g.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us"), this.agentConfig.set(g);
        }
        this.onEvent(new t.SendingAgentContextMessageEvent(this.agentConfig));
        const f = this.agentConfig.toJsonString();
        return this.agentConfigSent = !0, d.send(new l.SpeechConnectionMessage(r.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", f));
      }
    }
    sendAgentContext(d) {
      const f = (0, r.createGuid)(), g = this.privDialogServiceConnector.properties.getProperty(i.PropertyId.Conversation_Speech_Activity_Template), v = JSON.stringify({
        channelData: "",
        context: {
          interactionId: f
        },
        messagePayload: typeof g === void 0 ? void 0 : g,
        version: 0.5
      });
      return d.send(new l.SpeechConnectionMessage(r.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", v));
    }
    fireEventForResult(d, f) {
      const g = s.EnumTranslation.implTranslateRecognitionResult(d.RecognitionStatus), m = new i.SpeechRecognitionResult(this.privRequestSession.requestId, g, d.DisplayText, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, void 0, void 0, d.asJson(), f);
      return new i.SpeechRecognitionEventArgs(m, d.Offset, this.privRequestSession.sessionId);
    }
    handleResponseMessage(d) {
      const f = JSON.parse(d.textBody);
      switch (f.messageType.toLowerCase()) {
        case "message":
          const g = d.requestId.toUpperCase(), m = n.ActivityPayloadResponse.fromJSON(d.textBody), v = this.privTurnStateManager.GetTurn(g);
          if (m.conversationId) {
            const C = this.agentConfig.get();
            C.botInfo.conversationId = m.conversationId, this.agentConfig.set(C);
          }
          const y = v.processActivityPayload(m, o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(i.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0))), S = new i.ActivityReceivedEventArgs(m.messagePayload, y);
          if (this.privDialogServiceConnector.activityReceived)
            try {
              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, S);
            } catch {
            }
          break;
        case "messagestatus":
          if (this.privDialogServiceConnector.turnStatusReceived)
            try {
              this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new i.TurnStatusReceivedEventArgs(d.textBody));
            } catch {
            }
          break;
        default:
          r.Events.instance.onEvent(new r.BackgroundEvent(`Unexpected response of type ${f.messageType}. Ignoring.`));
          break;
      }
    }
    onEvent(d) {
      this.privEvents.onEvent(d), r.Events.instance.onEvent(d);
    }
    addKeywordContextData() {
      const d = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
      if (d === void 0)
        return;
      const f = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets"), g = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations"), m = d.split(";"), v = f === void 0 ? [] : f.split(";"), y = g === void 0 ? [] : g.split(";"), S = [];
      for (let C = 0; C < m.length; C++) {
        const P = {
          text: m[C]
        };
        C < v.length && (P.startOffset = Number(v[C])), C < y.length && (P.duration = Number(y[C])), S.push(P);
      }
      this.speechContext.getContext().invocationSource = c.InvocationSource.VoiceActivationWithKeyword, this.speechContext.getContext().keywordDetection = [{
        clientDetectedKeywords: S,
        onReject: { action: u.OnRejectAction.EndOfTurn },
        type: u.KeywordDetectionType.StartTrigger
      }];
    }
  };
  return Bi.DialogServiceAdapter = p, Bi;
}
var Vi = {}, hh;
function Zw() {
  if (hh) return Vi;
  hh = 1, Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.AgentConfig = void 0;
  let e = class {
    toJsonString() {
      return JSON.stringify(this.iPrivConfig);
    }
    get() {
      return this.iPrivConfig;
    }
    /**
     * Setter for the agent.config object.
     * @param value a JSON serializable object.
     */
    set(r) {
      this.iPrivConfig = r;
    }
  };
  return Vi.AgentConfig = e, Vi;
}
var Ma = {}, Wi = {}, Hi = {}, fh;
function yc() {
  if (fh) return Hi;
  fh = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.ConversationConnectionConfig = void 0;
  const e = /* @__PURE__ */ Hv();
  let t = class Xe extends e.RestConfigBase {
    static get host() {
      return Xe.privHost;
    }
    static get apiVersion() {
      return Xe.privApiVersion;
    }
    static get clientAppId() {
      return Xe.privClientAppId;
    }
    static get defaultLanguageCode() {
      return Xe.privDefaultLanguageCode;
    }
    static get restPath() {
      return Xe.privRestPath;
    }
    static get webSocketPath() {
      return Xe.privWebSocketPath;
    }
    static get transcriptionEventKeys() {
      return Xe.privTranscriptionEventKeys;
    }
  };
  return Hi.ConversationConnectionConfig = t, t.privHost = "dev.microsofttranslator.com", t.privRestPath = "/capito/room", t.privApiVersion = "2.0", t.privDefaultLanguageCode = "en-US", t.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15", t.privWebSocketPath = "/capito/translate", t.privTranscriptionEventKeys = ["iCalUid", "callId", "organizer", "FLAC", "MTUri", "DifferentiateGuestSpeakers", "audiorecording", "Threadid", "OrganizerMri", "OrganizerTenantId", "UserToken"], Hi;
}
var vh;
function Xw() {
  if (vh) return Wi;
  vh = 1, Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.ConversationManager = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ yc();
  let i = class {
    constructor() {
      this.privRequestParams = o.ConversationConnectionConfig.configParams, this.privErrors = o.ConversationConnectionConfig.restErrors, this.privHost = o.ConversationConnectionConfig.host, this.privApiVersion = o.ConversationConnectionConfig.apiVersion, this.privRestPath = o.ConversationConnectionConfig.restPath, this.privRestAdapter = new e.RestMessageAdapter({});
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */
    createOrJoin(s, n, c, u) {
      try {
        t.Contracts.throwIfNullOrUndefined(s, "args");
        const l = s.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, o.ConversationConnectionConfig.defaultLanguageCode), p = s.getProperty(r.PropertyId.ConversationTranslator_Name, "conversation_host"), h = s.getProperty(r.PropertyId.ConversationTranslator_Host, this.privHost), d = s.getProperty(r.PropertyId.ConversationTranslator_CorrelationId), f = s.getProperty(r.PropertyId.SpeechServiceConnection_Key), g = s.getProperty(r.PropertyId.SpeechServiceConnection_Region), m = s.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
        t.Contracts.throwIfNullOrWhitespace(l, "languageCode"), t.Contracts.throwIfNullOrWhitespace(p, "nickname"), t.Contracts.throwIfNullOrWhitespace(h, "endpointHost");
        const v = {};
        v[this.privRequestParams.apiVersion] = this.privApiVersion, v[this.privRequestParams.languageCode] = l, v[this.privRequestParams.nickname] = p;
        const y = {};
        d && (y[this.privRequestParams.correlationId] = d), y[this.privRequestParams.clientAppId] = o.ConversationConnectionConfig.clientAppId, n !== void 0 ? v[this.privRequestParams.roomId] = n : (t.Contracts.throwIfNullOrUndefined(g, this.privErrors.authInvalidSubscriptionRegion), y[this.privRequestParams.subscriptionRegion] = g, f ? y[this.privRequestParams.subscriptionKey] = f : m ? y[this.privRequestParams.authorization] = `Bearer ${m}` : t.Contracts.throwIfNullOrUndefined(f, this.privErrors.authInvalidSubscriptionKey));
        const S = {};
        S.headers = y, this.privRestAdapter.options = S;
        const C = `https://${h}${this.privRestPath}`;
        this.privRestAdapter.request(e.RestRequestType.Post, C, v, null).then((P) => {
          const b = e.RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, P.headers);
          if (!P.ok) {
            if (u) {
              let E = this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", P.status.toString()), D;
              try {
                D = JSON.parse(P.data), E += ` [${D.error.code}: ${D.error.message}]`;
              } catch {
                E += ` [${P.data}]`;
              }
              b && (E += ` ${b}`), u(E);
            }
            return;
          }
          const A = JSON.parse(P.data);
          if (A && (A.requestId = b), c) {
            try {
              c(A);
            } catch (E) {
              u && u(E);
            }
            c = void 0;
          }
        }).catch(() => {
        });
      } catch (l) {
        if (u)
          if (l instanceof Error) {
            const p = l;
            u(p.name + ": " + p.message);
          } else
            u(l);
      }
    }
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */
    leave(s, n) {
      return new Promise((c, u) => {
        try {
          t.Contracts.throwIfNullOrUndefined(s, this.privErrors.invalidArgs.replace("{arg}", "config")), t.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "token"));
          const l = s.getProperty(r.PropertyId.ConversationTranslator_Host, this.privHost), p = s.getProperty(r.PropertyId.ConversationTranslator_CorrelationId), h = {};
          h[this.privRequestParams.apiVersion] = this.privApiVersion, h[this.privRequestParams.sessionToken] = n;
          const d = {};
          p && (d[this.privRequestParams.correlationId] = p);
          const f = {};
          f.headers = d, this.privRestAdapter.options = f;
          const g = `https://${l}${this.privRestPath}`;
          this.privRestAdapter.request(e.RestRequestType.Delete, g, h, null).then((m) => {
            m.ok, c();
          }).catch(() => {
          });
        } catch (l) {
          if (l instanceof Error) {
            const p = l;
            u(p.name + ": " + p.message);
          } else
            u(l);
        }
      });
    }
  };
  return Wi.ConversationManager = i, Wi;
}
var Tt = {}, Ki = {}, Ji = {}, Gi = {}, gh;
function tg() {
  if (gh) return Gi;
  gh = 1, Object.defineProperty(Gi, "__esModule", { value: !0 }), Gi.ConversationConnectionMessage = void 0;
  const e = /* @__PURE__ */ M();
  let t = class extends e.ConnectionMessage {
    constructor(o, i, a, s) {
      super(o, i, a, s);
      const n = JSON.parse(this.textBody);
      n.type !== void 0 && (this.privConversationMessageType = n.type);
    }
    get conversationMessageType() {
      return this.privConversationMessageType;
    }
  };
  return Gi.ConversationConnectionMessage = t, Gi;
}
var mh;
function eb() {
  if (mh) return Ji;
  mh = 1, Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.ConversationWebsocketMessageFormatter = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ tg();
  let r = class {
    /**
     * Format incoming messages: text (speech partial/final, IM) or binary (tts)
     */
    toConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = new t.ConversationConnectionMessage(i.messageType, i.textContent, {}, i.id);
          a.resolve(s);
        } else i.messageType === e.MessageType.Binary && a.resolve(new t.ConversationConnectionMessage(i.messageType, i.binaryContent, void 0, i.id));
      } catch (s) {
        a.reject(`Error formatting the message. Error: ${s}`);
      }
      return a.promise;
    }
    /**
     * Format outgoing messages: text (commands or IM)
     */
    fromConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = `${i.textBody ? i.textBody : ""}`;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Text, s, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. ${s}`);
      }
      return a.promise;
    }
  };
  return Ji.ConversationWebsocketMessageFormatter = r, Ji;
}
var yh;
function tb() {
  if (yh) return Ki;
  yh = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.ConversationConnectionFactory = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ ke(), a = /* @__PURE__ */ yc(), s = /* @__PURE__ */ eb();
  let n = class extends i.ConnectionFactoryBase {
    create(u, l, p) {
      const h = u.parameters.getProperty(o.PropertyId.ConversationTranslator_Host, a.ConversationConnectionConfig.host), d = u.parameters.getProperty(o.PropertyId.ConversationTranslator_CorrelationId, (0, t.createGuid)()), f = `wss://${h}${a.ConversationConnectionConfig.webSocketPath}`, g = u.parameters.getProperty(o.PropertyId.ConversationTranslator_Token, void 0);
      r.Contracts.throwIfNullOrUndefined(g, "token");
      const m = {};
      m[a.ConversationConnectionConfig.configParams.apiVersion] = a.ConversationConnectionConfig.apiVersion, m[a.ConversationConnectionConfig.configParams.token] = g, m[a.ConversationConnectionConfig.configParams.correlationId] = d;
      const v = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(f, m, {}, new s.ConversationWebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), v, p));
    }
  };
  return Ki.ConversationConnectionFactory = n, Ki;
}
var Qi = {}, Yi = {}, Sh;
function rb() {
  if (Sh) return Yi;
  Sh = 1, Object.defineProperty(Yi, "__esModule", { value: !0 }), Yi.ConversationRequestSession = void 0;
  const e = /* @__PURE__ */ M();
  let t = class {
    constructor(o) {
      this.privIsDisposed = !1, this.privDetachables = new Array(), this.privSessionId = o, this.privRequestId = (0, e.createNoDashGuid)(), this.privRequestCompletionDeferral = new e.Deferred();
    }
    get sessionId() {
      return this.privSessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get completionPromise() {
      return this.privRequestCompletionDeferral.promise;
    }
    onPreConnectionStart(o, i) {
      this.privSessionId = i;
    }
    onAuthCompleted(o) {
      o && this.onComplete();
    }
    onConnectionEstablishCompleted(o) {
      o !== 200 && o === 403 && this.onComplete();
    }
    onServiceTurnEndResponse(o) {
      o ? this.privRequestId = (0, e.createNoDashGuid)() : this.onComplete();
    }
    async dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = !0;
        for (const o of this.privDetachables)
          await o.detach();
      }
    }
    onComplete() {
    }
  };
  return Yi.ConversationRequestSession = t, Yi;
}
var ce = {}, Ch;
function rg() {
  if (Ch) return ce;
  Ch = 1, Object.defineProperty(ce, "__esModule", { value: !0 }), ce.ConversationReceivedTranslationEventArgs = ce.ParticipantsListEventArgs = ce.ParticipantAttributeEventArgs = ce.ParticipantEventArgs = ce.LockRoomEventArgs = ce.MuteAllEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  class t extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsMuted = c;
    }
    get isMuted() {
      return this.privIsMuted;
    }
  }
  ce.MuteAllEventArgs = t;
  class r extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsLocked = c;
    }
    get isMuted() {
      return this.privIsLocked;
    }
  }
  ce.LockRoomEventArgs = r;
  class o extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privParticipant = c;
    }
    get participant() {
      return this.privParticipant;
    }
  }
  ce.ParticipantEventArgs = o;
  class i extends e.SessionEventArgs {
    constructor(c, u, l, p) {
      super(p), this.privKey = u, this.privValue = l, this.privParticipantId = c;
    }
    get value() {
      return this.privValue;
    }
    get key() {
      return this.privKey;
    }
    get id() {
      return this.privParticipantId;
    }
  }
  ce.ParticipantAttributeEventArgs = i;
  class a extends e.SessionEventArgs {
    constructor(c, u, l, p, h, d, f, g, m) {
      super(m), this.privRoomId = c, this.privSessionToken = u, this.privTranslateTo = l, this.privProfanityFilter = p, this.privRoomProfanityFilter = h, this.privIsRoomLocked = d, this.privIsRoomLocked = f, this.privParticipants = g;
    }
    get sessionToken() {
      return this.privSessionToken;
    }
    get conversationId() {
      return this.privRoomId;
    }
    get translateTo() {
      return this.privTranslateTo;
    }
    get profanityFilter() {
      return this.privProfanityFilter;
    }
    get roomProfanityFilter() {
      return this.privRoomProfanityFilter;
    }
    get isRoomLocked() {
      return this.privIsRoomLocked;
    }
    get isMuteAll() {
      return this.privIsMuteAll;
    }
    get participants() {
      return this.privParticipants;
    }
  }
  ce.ParticipantsListEventArgs = a;
  class s {
    constructor(c, u, l) {
      this.privPayload = u, this.privCommand = c, this.privSessionId = l;
    }
    get payload() {
      return this.privPayload;
    }
    get command() {
      return this.privCommand;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  return ce.ConversationReceivedTranslationEventArgs = s, ce;
}
var Ue = {}, Rh;
function ng() {
  if (Rh) return Ue;
  Rh = 1, Object.defineProperty(Ue, "__esModule", { value: !0 }), Ue.ConversationTranslatorCommandTypes = Ue.ConversationTranslatorMessageTypes = Ue.InternalParticipants = void 0;
  class e {
    constructor(r = [], o) {
      this.participants = r, this.meId = o;
    }
    /**
     * Add or update a participant
     * @param value
     */
    addOrUpdateParticipant(r) {
      if (r === void 0)
        return;
      const o = this.getParticipantIndex(r.id);
      return o > -1 ? this.participants.splice(o, 1, r) : this.participants.push(r), this.getParticipant(r.id);
    }
    /**
     * Find the participant's position in the participants list.
     * @param id
     */
    getParticipantIndex(r) {
      return this.participants.findIndex((o) => o.id === r);
    }
    /**
     * Find the participant by id.
     * @param id
     */
    getParticipant(r) {
      return this.participants.find((o) => o.id === r);
    }
    /**
     * Remove a participant from the participants list.
     */
    deleteParticipant(r) {
      this.participants = this.participants.filter((o) => o.id !== r);
    }
    /**
     * Helper to return the conversation host.
     */
    get host() {
      return this.participants.find((r) => r.isHost === !0);
    }
    /**
     * Helper to return the current user.
     */
    get me() {
      return this.getParticipant(this.meId);
    }
  }
  return Ue.InternalParticipants = e, Ue.ConversationTranslatorMessageTypes = {
    command: "command",
    final: "final",
    info: "info",
    instantMessage: "instant_message",
    keepAlive: "keep_alive",
    partial: "partial",
    participantCommand: "participant_command",
    translatedMessage: "translated_message"
  }, Ue.ConversationTranslatorCommandTypes = {
    changeNickname: "ChangeNickname",
    disconnectSession: "DisconnectSession",
    ejectParticipant: "EjectParticipant",
    instant_message: "instant_message",
    joinSession: "JoinSession",
    leaveSession: "LeaveSession",
    participantList: "ParticipantList",
    roomExpirationWarning: "RoomExpirationWarning",
    setLockState: "SetLockState",
    setMute: "SetMute",
    setMuteAll: "SetMuteAll",
    setProfanityFiltering: "SetProfanityFiltering",
    setTranslateToLanguages: "SetTranslateToLanguages",
    setUseTTS: "SetUseTTS"
  }, Ue;
}
var Da = {}, Zi = {}, Ph;
function nb() {
  if (Ph) return Zi;
  Ph = 1, Object.defineProperty(Zi, "__esModule", { value: !0 }), Zi.CommandResponsePayload = void 0;
  const e = (r) => JSON.parse(r);
  let t = class ig {
    constructor(o) {
      this.privCommandResponse = e(o);
    }
    get type() {
      return this.privCommandResponse.type;
    }
    get command() {
      return this.privCommandResponse.command;
    }
    get id() {
      return this.privCommandResponse.id;
    }
    get nickname() {
      return this.privCommandResponse.nickname;
    }
    get participantId() {
      return this.privCommandResponse.participantId;
    }
    get roomid() {
      return this.privCommandResponse.roomid;
    }
    get value() {
      return this.privCommandResponse.value;
    }
    get token() {
      return this.privCommandResponse.token;
    }
    static fromJSON(o) {
      return new ig(o);
    }
  };
  return Zi.CommandResponsePayload = t, Zi;
}
var _t = {}, wh;
function ib() {
  if (wh) return _t;
  wh = 1, Object.defineProperty(_t, "__esModule", { value: !0 }), _t.ParticipantPayloadResponse = _t.ParticipantsListPayloadResponse = void 0;
  const e = (i) => JSON.parse(i), t = (i) => JSON.parse(i);
  class r {
    constructor(a) {
      this.privParticipantsPayloadResponse = e(a);
    }
    get roomid() {
      return this.privParticipantsPayloadResponse.roomid;
    }
    get id() {
      return this.privParticipantsPayloadResponse.id;
    }
    get command() {
      return this.privParticipantsPayloadResponse.command;
    }
    get participants() {
      return this.privParticipantsPayloadResponse.participants;
    }
    get token() {
      return this.privParticipantsPayloadResponse.token;
    }
    get translateTo() {
      return this.privParticipantsPayloadResponse.translateTo;
    }
    get profanityFilter() {
      return this.privParticipantsPayloadResponse.profanityFilter;
    }
    get roomProfanityFilter() {
      return this.privParticipantsPayloadResponse.roomProfanityFilter;
    }
    get roomLocked() {
      return this.privParticipantsPayloadResponse.roomLocked;
    }
    get muteAll() {
      return this.privParticipantsPayloadResponse.muteAll;
    }
    get type() {
      return this.privParticipantsPayloadResponse.type;
    }
    static fromJSON(a) {
      return new r(a);
    }
  }
  _t.ParticipantsListPayloadResponse = r;
  class o {
    constructor(a) {
      this.privParticipantPayloadResponse = t(a);
    }
    get nickname() {
      return this.privParticipantPayloadResponse.nickname;
    }
    get locale() {
      return this.privParticipantPayloadResponse.locale;
    }
    get usetts() {
      return this.privParticipantPayloadResponse.usetts;
    }
    get ismuted() {
      return this.privParticipantPayloadResponse.ismuted;
    }
    get ishost() {
      return this.privParticipantPayloadResponse.ishost;
    }
    get participantId() {
      return this.privParticipantPayloadResponse.participantId;
    }
    get avatar() {
      return this.privParticipantPayloadResponse.avatar;
    }
    static fromJSON(a) {
      return new o(a);
    }
  }
  return _t.ParticipantPayloadResponse = o, _t;
}
var kt = {}, bh;
function sb() {
  if (bh) return kt;
  bh = 1, Object.defineProperty(kt, "__esModule", { value: !0 }), kt.TextResponsePayload = kt.SpeechResponsePayload = void 0;
  const e = (i) => JSON.parse(i), t = (i) => JSON.parse(i);
  class r {
    constructor(a) {
      this.privSpeechResponse = e(a);
    }
    get recognition() {
      return this.privSpeechResponse.recognition;
    }
    get translations() {
      return this.privSpeechResponse.translations;
    }
    get id() {
      return this.privSpeechResponse.id;
    }
    get language() {
      return this.privSpeechResponse.language;
    }
    get nickname() {
      return this.privSpeechResponse.nickname;
    }
    get participantId() {
      return this.privSpeechResponse.participantId;
    }
    get roomid() {
      return this.privSpeechResponse.roomid;
    }
    get timestamp() {
      return this.privSpeechResponse.timestamp;
    }
    get type() {
      return this.privSpeechResponse.type;
    }
    get isFinal() {
      return this.privSpeechResponse.type === "final";
    }
    static fromJSON(a) {
      return new r(a);
    }
  }
  kt.SpeechResponsePayload = r;
  class o {
    constructor(a) {
      this.privTextResponse = t(a);
    }
    get originalText() {
      return this.privTextResponse.originalText;
    }
    get translations() {
      return this.privTextResponse.translations;
    }
    get id() {
      return this.privTextResponse.id;
    }
    get language() {
      return this.privTextResponse.language;
    }
    get nickname() {
      return this.privTextResponse.nickname;
    }
    get participantId() {
      return this.privTextResponse.participantId;
    }
    get roomid() {
      return this.privTextResponse.roomid;
    }
    get timestamp() {
      return this.privTextResponse.timestamp;
    }
    get type() {
      return this.privTextResponse.type;
    }
    static fromJSON(a) {
      return new o(a);
    }
  }
  return kt.TextResponsePayload = o, kt;
}
var Eh;
function ob() {
  return Eh || (Eh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TextResponsePayload = e.SpeechResponsePayload = e.ParticipantPayloadResponse = e.ParticipantsListPayloadResponse = e.CommandResponsePayload = void 0;
    var t = /* @__PURE__ */ nb();
    Object.defineProperty(e, "CommandResponsePayload", { enumerable: !0, get: function() {
      return t.CommandResponsePayload;
    } });
    var r = /* @__PURE__ */ ib();
    Object.defineProperty(e, "ParticipantsListPayloadResponse", { enumerable: !0, get: function() {
      return r.ParticipantsListPayloadResponse;
    } }), Object.defineProperty(e, "ParticipantPayloadResponse", { enumerable: !0, get: function() {
      return r.ParticipantPayloadResponse;
    } });
    var o = /* @__PURE__ */ sb();
    Object.defineProperty(e, "SpeechResponsePayload", { enumerable: !0, get: function() {
      return o.SpeechResponsePayload;
    } }), Object.defineProperty(e, "TextResponsePayload", { enumerable: !0, get: function() {
      return o.TextResponsePayload;
    } });
  }(Da)), Da;
}
var Ih;
function ab() {
  if (Ih) return Qi;
  Ih = 1, Object.defineProperty(Qi, "__esModule", { value: !0 }), Qi.ConversationServiceAdapter = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ tg(), i = /* @__PURE__ */ rb(), a = /* @__PURE__ */ rg(), s = /* @__PURE__ */ ng(), n = /* @__PURE__ */ ob();
  let c = class extends r.ServiceRecognizerBase {
    constructor(l, p, h, d, f) {
      super(l, p, h, d, f), this.privConnectionConfigPromise = void 0, this.privLastPartialUtteranceId = "", this.privConversationServiceConnector = f, this.privConversationAuthentication = l, this.receiveMessageOverride = () => this.receiveConversationMessageOverride(), this.recognizeOverride = () => this.noOp(), this.postConnectImplOverride = (g) => this.conversationConnectImpl(g), this.configConnectionOverride = () => this.configConnection(), this.disconnectOverride = () => this.privDisconnect(), this.privConversationRequestSession = new i.ConversationRequestSession((0, e.createNoDashGuid)()), this.privConversationConnectionFactory = p, this.privConversationIsDisposed = !1;
    }
    isDisposed() {
      return super.isDisposed() || this.privConversationIsDisposed;
    }
    async dispose(l) {
      this.privConversationIsDisposed = !0, this.privConnectionConfigPromise !== void 0 && await (await this.privConnectionConfigPromise).dispose(l), await super.dispose(l);
    }
    async sendMessage(l) {
      return (await this.fetchConnection()).send(new o.ConversationConnectionMessage(e.MessageType.Text, l));
    }
    async sendMessageAsync(l) {
      await (await this.fetchConnection()).send(new o.ConversationConnectionMessage(e.MessageType.Text, l));
    }
    privDisconnect() {
      if (!this.terminateMessageLoop)
        return this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, t.CancellationReason.Error, t.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async processTypeSpecificMessages() {
      return !0;
    }
    // Cancels recognition.
    cancelRecognition(l, p, h, d, f) {
      this.terminateMessageLoop = !0;
      const g = new t.ConversationTranslationCanceledEventArgs(h, f, d, void 0, l);
      try {
        this.privConversationServiceConnector.canceled && this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, g);
      } catch {
      }
    }
    /**
     * Establishes a websocket connection to the end point.
     */
    async conversationConnectImpl(l) {
      return this.privConnectionLoop = this.startMessageLoop(), l;
    }
    /**
     * Process incoming websocket messages
     */
    async receiveConversationMessageOverride() {
      if (this.isDisposed() || this.terminateMessageLoop)
        return Promise.resolve();
      const l = new e.Deferred();
      try {
        const h = await (await this.fetchConnection()).read();
        if (this.isDisposed() || this.terminateMessageLoop)
          return l.resolve(), Promise.resolve();
        if (!h)
          return this.receiveConversationMessageOverride();
        const d = this.privConversationRequestSession.sessionId, f = h.conversationMessageType.toLowerCase();
        let g = !1;
        try {
          switch (f) {
            case "info":
            case "participant_command":
            case "command":
              const m = n.CommandResponsePayload.fromJSON(h.textBody);
              switch (m.command.toLowerCase()) {
                /**
                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.
                 * The consuming client must wait for this message to arrive
                 * before starting to send their own data.
                 */
                case "participantlist":
                  const b = n.ParticipantsListPayloadResponse.fromJSON(h.textBody), A = b.participants.map((x) => ({
                    avatar: x.avatar,
                    displayName: x.nickname,
                    id: x.participantId,
                    isHost: x.ishost,
                    isMuted: x.ismuted,
                    isUsingTts: x.usetts,
                    preferredLanguage: x.locale
                  }));
                  this.privConversationServiceConnector.participantsListReceived && this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new a.ParticipantsListEventArgs(b.roomid, b.token, b.translateTo, b.profanityFilter, b.roomProfanityFilter, b.roomLocked, b.muteAll, A, d));
                  break;
                /**
                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).
                 * This is sent at the start of the Conversation
                 */
                case "settranslatetolanguages":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setTranslateToLanguages, m.value, d));
                  break;
                /**
                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.
                 * If sent by the participant the setting will effect only their own profanity level.
                 * If sent by the host, the setting will effect all participants including the host.
                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'
                 */
                case "setprofanityfiltering":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setProfanityFiltering, m.value, d));
                  break;
                /**
                 * 'SetMute' is sent if the participant has been muted by the host.
                 * Check the 'participantId' to determine if the current user has been muted.
                 */
                case "setmute":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setMute, m.value, d));
                  break;
                /**
                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.
                 */
                case "setmuteall":
                  this.privConversationServiceConnector.muteAllCommandReceived && this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new a.MuteAllEventArgs(m.value, d));
                  break;
                /**
                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.
                 */
                case "roomexpirationwarning":
                  this.privConversationServiceConnector.conversationExpiration && this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new t.ConversationExpirationEventArgs(m.value, this.privConversationRequestSession.sessionId));
                  break;
                /**
                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.
                 */
                case "setusetts":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setUseTTS, m.value, d));
                  break;
                /**
                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.
                 */
                case "setlockstate":
                  this.privConversationServiceConnector.lockRoomCommandReceived && this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new a.LockRoomEventArgs(m.value, d));
                  break;
                /**
                 * 'ChangeNickname' is received if a user changes their display name.
                 * Any cached particpiants list should be updated to reflect the display name.
                 */
                case "changenickname":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.changeNickname, m.value, d));
                  break;
                /**
                 * 'JoinSession' is sent when a user joins the Conversation.
                 */
                case "joinsession":
                  const E = n.ParticipantPayloadResponse.fromJSON(h.textBody), D = {
                    avatar: E.avatar,
                    displayName: E.nickname,
                    id: E.participantId,
                    isHost: E.ishost,
                    isMuted: E.ismuted,
                    isUsingTts: E.usetts,
                    preferredLanguage: E.locale
                  };
                  this.privConversationServiceConnector.participantJoinCommandReceived && this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new a.ParticipantEventArgs(D, d));
                  break;
                /**
                 * 'LeaveSession' is sent when a user leaves the Conversation'.
                 */
                case "leavesession":
                  const R = {
                    id: m.participantId
                  };
                  this.privConversationServiceConnector.participantLeaveCommandReceived && this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new a.ParticipantEventArgs(R, d));
                  break;
                /**
                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).
                 * Check the 'ParticipantId' to check whether the message is for the current user.
                 */
                case "disconnectsession":
                  const j = {
                    id: m.participantId
                  };
                  break;
                case "token":
                  const T = new r.CognitiveTokenAuthentication(() => {
                    const x = m.token;
                    return Promise.resolve(x);
                  }, () => {
                    const x = m.token;
                    return Promise.resolve(x);
                  });
                  this.authentication = T, this.privConversationServiceConnector.onToken(T);
                  break;
                /**
                 * Message not recognized.
                 */
                default:
                  break;
              }
              break;
            /**
             * 'partial' (or 'hypothesis') represents a unfinalized speech message.
             */
            case "partial":
            /**
             * 'final' (or 'phrase') represents a finalized speech message.
             */
            case "final":
              const v = n.SpeechResponsePayload.fromJSON(h.textBody), y = f === "final" ? t.ResultReason.TranslatedParticipantSpeech : t.ResultReason.TranslatingParticipantSpeech, S = new t.ConversationTranslationResult(v.participantId, this.getTranslations(v.translations), v.language, v.id, y, v.recognition, void 0, void 0, h.textBody, void 0);
              v.isFinal ? ((S.text !== void 0 && S.text.length > 0 || v.id === this.privLastPartialUtteranceId) && (g = !0), g && this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.final, S, d))) : S.text !== void 0 && (this.privLastPartialUtteranceId = v.id, this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.partial, S, d)));
              break;
            /**
             * "translated_message" is a text message or instant message (IM).
             */
            case "translated_message":
              const C = n.TextResponsePayload.fromJSON(h.textBody), P = new t.ConversationTranslationResult(C.participantId, this.getTranslations(C.translations), C.language, void 0, void 0, C.originalText, void 0, void 0, void 0, h.textBody, void 0);
              this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.instantMessage, P, d));
              break;
            default:
              break;
          }
        } catch {
        }
        return this.receiveConversationMessageOverride();
      } catch {
        this.terminateMessageLoop = !0;
      }
      return l.promise;
    }
    async startMessageLoop() {
      if (this.isDisposed())
        return Promise.resolve();
      this.terminateMessageLoop = !1;
      const l = this.receiveConversationMessageOverride();
      try {
        return await l;
      } catch (p) {
        return this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", t.CancellationReason.Error, t.CancellationErrorCode.RuntimeError, p), null;
      }
    }
    // Takes an established websocket connection to the endpoint
    configConnection() {
      return this.isDisposed() ? Promise.resolve(void 0) : this.privConnectionConfigPromise !== void 0 ? this.privConnectionConfigPromise.then((l) => l.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection()) : this.privConnectionConfigPromise, () => (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection())) : this.terminateMessageLoop ? Promise.resolve(void 0) : (this.privConnectionConfigPromise = this.connectImpl().then((l) => l), this.privConnectionConfigPromise);
    }
    getTranslations(l) {
      let p;
      if (l !== void 0) {
        p = new t.Translations();
        for (const h of l)
          p.set(h.lang, h.translation);
      }
      return p;
    }
  };
  return Qi.ConversationServiceAdapter = c, Qi;
}
var Ah;
function cb() {
  if (Ah) return Tt;
  Ah = 1, Object.defineProperty(Tt, "__esModule", { value: !0 }), Tt.ConversationTranslatorRecognizer = Tt.ConversationRecognizerFactory = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ tb(), a = /* @__PURE__ */ ab();
  class s {
    static fromConfig(u, l, p) {
      return new n(u, l, p);
    }
  }
  Tt.ConversationRecognizerFactory = s;
  let n = class extends o.Recognizer {
    constructor(u, l, p) {
      const h = l;
      r.Contracts.throwIfNull(h, "speechConfig");
      const d = u;
      r.Contracts.throwIfNull(d, "conversationImpl"), super(p, h.properties, new i.ConversationConnectionFactory()), this.privConversation = d, this.privIsDisposed = !1, this.privProperties = h.properties.clone(), this.privConnection = o.Connection.fromRecognizer(this), this.privProperties.getProperty(o.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? (this.privSetTimeout = t.Timeout.setTimeout, this.privClearTimeout = t.Timeout.clearTimeout) : typeof window < "u" ? (this.privSetTimeout = window.setTimeout.bind(window), this.privClearTimeout = window.clearTimeout.bind(window)) : (this.privSetTimeout = setTimeout, this.privClearTimeout = clearTimeout);
    }
    set connected(u) {
      this.privConnection.connected = u;
    }
    set disconnected(u) {
      this.privConnection.disconnected = u;
    }
    /**
     * Return the speech language used by the recognizer
     */
    get speechRecognitionLanguage() {
      return this.privSpeechRecognitionLanguage;
    }
    /**
     * Return the properties for the recognizer
     */
    get properties() {
      return this.privProperties;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    /**
     * Connect to the recognizer
     * @param token
     */
    connect(u, l, p) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfNullOrWhitespace(u, "token"), this.privReco.conversationTranslatorToken = u, this.resetConversationTimeout(), this.privReco.connectAsync(l, p);
      } catch (h) {
        if (p)
          if (h instanceof Error) {
            const d = h;
            p(d.name + ": " + d.message);
          } else
            p(h);
      }
    }
    /**
     * Disconnect from the recognizer
     */
    disconnect(u, l) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privReco.disconnect().then(() => {
          u && u();
        }, (p) => {
          l && l(p);
        });
      } catch (p) {
        if (l)
          if (p instanceof Error) {
            const h = p;
            l(h.name + ": " + h.message);
          } else
            l(p);
        this.dispose(!0).catch((h) => {
          t.Events.instance.onEvent(new t.BackgroundEvent(h));
        });
      }
    }
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendRequest(u, l, p) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), this.sendMessage(u, l, p);
      } catch (h) {
        if (p)
          if (h instanceof Error) {
            const d = h;
            p(d.name + ": " + d.message);
          } else
            p(h);
        this.dispose(!0).catch((d) => {
          t.Events.instance.onEvent(new t.BackgroundEvent(d));
        });
      }
    }
    /**
     * Handle update of service auth token (#694)
     */
    onToken(u) {
      this.privConversation.onToken(u);
    }
    /**
     * Close and dispose the recognizer
     */
    async close() {
      this.privIsDisposed || (this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close()), this.privConnection = void 0, await this.dispose(!0));
    }
    /**
     * Dispose the recognizer
     * @param disposing
     */
    async dispose(u) {
      this.privIsDisposed || u && (this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privIsDisposed = !0, this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close(), this.privConnection = void 0), await super.dispose(u));
    }
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    createRecognizerConfig(u) {
      return new e.RecognizerConfig(u, this.privProperties);
    }
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    createServiceRecognizer(u, l, p, h) {
      const d = p;
      return new a.ConversationServiceAdapter(u, l, d, h, this);
    }
    sendMessage(u, l, p) {
      const h = this.privReco;
      ((f, g, m) => {
        f !== void 0 ? f.then(() => {
          try {
            g && g();
          } catch (v) {
            m && m(`'Unhandled error on promise callback: ${v}'`);
          }
        }, (v) => {
          try {
            m && m(v);
          } catch {
          }
        }) : m && m("Null promise");
      })(h.sendMessageAsync(u), l, p), this.resetConversationTimeout();
    }
    resetConversationTimeout() {
      this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privTimeoutToken = this.privSetTimeout(() => {
        this.sendRequest(this.privConversation.getKeepAlive());
      }, 6e4);
    }
  };
  return Tt.ConversationTranslatorRecognizer = n, Tt;
}
var Xi = {}, Th;
function ub() {
  if (Th) return Xi;
  Th = 1, Object.defineProperty(Xi, "__esModule", { value: !0 }), Xi.TranscriberRecognizer = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ we();
  let a = class extends r.Recognizer {
    /**
     * TranscriberRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      t.Contracts.throwIfNull(u, "speechTranslationConfig");
      const l = c;
      t.Contracts.throwIfNull(l, "audioConfigImpl"), t.Contracts.throwIfNullOrWhitespace(u.speechRecognitionLanguage, r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new o.TranscriberConnectionFactory()), this.privDisposedRecognizer = !1, this.isMeetingRecognizer = !1;
    }
    get speechRecognitionLanguage() {
      return t.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    get properties() {
      return this.privProperties;
    }
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(n) {
      t.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    set conversation(n) {
      t.Contracts.throwIfNullOrUndefined(n, "Conversation"), this.isMeetingRecognizer = !1, this.privConversation = n;
    }
    getConversationInfo() {
      return t.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation"), this.privConversation.conversationInfo;
    }
    set meeting(n) {
      t.Contracts.throwIfNullOrUndefined(n, "Meeting"), this.isMeetingRecognizer = !0, this.privMeeting = n;
    }
    getMeetingInfo() {
      return t.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting"), this.privMeeting.meetingInfo;
    }
    IsMeetingRecognizer() {
      return this.isMeetingRecognizer;
    }
    startContinuousRecognitionAsync(n, c) {
      (0, e.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(i.RecognitionMode.Conversation), n, c);
    }
    stopContinuousRecognitionAsync(n, c) {
      (0, e.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    async close() {
      this.privDisposedRecognizer || await this.dispose(!0);
    }
    // Push async join/leave conversation message via serviceRecognizer
    async pushConversationEvent(n, c) {
      const u = this.privReco;
      t.Contracts.throwIfNullOrUndefined(u, "serviceRecognizer"), await u.sendSpeechEventAsync(n, c);
    }
    // Push async join/leave meeting message via serviceRecognizer
    async pushMeetingEvent(n, c) {
      const u = this.privReco;
      t.Contracts.throwIfNullOrUndefined(u, "serviceRecognizer"), await u.sendMeetingSpeechEventAsync(n, c);
    }
    async enforceAudioGating() {
      const u = (await this.audioConfig.format).channels;
      if (u === 1) {
        if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true")
          throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
      } else if (u !== 8)
        throw new Error(`Unsupported audio configuration: Detected ${u}-channel audio`);
    }
    connectMeetingCallbacks(n) {
      this.isMeetingRecognizer = !0, this.canceled = (c, u) => {
        n.canceled && n.canceled(n, u);
      }, this.recognizing = (c, u) => {
        n.transcribing && n.transcribing(n, u);
      }, this.recognized = (c, u) => {
        n.transcribed && n.transcribed(n, u);
      }, this.sessionStarted = (c, u) => {
        n.sessionStarted && n.sessionStarted(n, u);
      }, this.sessionStopped = (c, u) => {
        n.sessionStopped && n.sessionStopped(n, u);
      };
    }
    disconnectCallbacks() {
      this.canceled = void 0, this.recognizing = void 0, this.recognized = void 0, this.sessionStarted = void 0, this.sessionStopped = void 0;
    }
    /**
     * Disposes any resources held by the object.
     * @member ConversationTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new o.RecognizerConfig(n, this.properties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new o.TranscriptionServiceRecognizer(n, c, p, l, this);
    }
  };
  return Xi.TranscriberRecognizer = a, Xi;
}
var _h;
function lb() {
  return _h || (_h = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.InternalParticipants = e.ConversationTranslatorMessageTypes = e.ConversationTranslatorCommandTypes = e.ParticipantsListEventArgs = e.ParticipantEventArgs = e.ParticipantAttributeEventArgs = e.MuteAllEventArgs = e.LockRoomEventArgs = e.ConversationReceivedTranslationEventArgs = e.TranscriberRecognizer = e.ConversationRecognizerFactory = e.ConversationConnectionConfig = e.ConversationManager = void 0;
    var t = /* @__PURE__ */ Xw();
    Object.defineProperty(e, "ConversationManager", { enumerable: !0, get: function() {
      return t.ConversationManager;
    } });
    var r = /* @__PURE__ */ yc();
    Object.defineProperty(e, "ConversationConnectionConfig", { enumerable: !0, get: function() {
      return r.ConversationConnectionConfig;
    } });
    var o = /* @__PURE__ */ cb();
    Object.defineProperty(e, "ConversationRecognizerFactory", { enumerable: !0, get: function() {
      return o.ConversationRecognizerFactory;
    } });
    var i = /* @__PURE__ */ ub();
    Object.defineProperty(e, "TranscriberRecognizer", { enumerable: !0, get: function() {
      return i.TranscriberRecognizer;
    } });
    var a = /* @__PURE__ */ rg();
    Object.defineProperty(e, "ConversationReceivedTranslationEventArgs", { enumerable: !0, get: function() {
      return a.ConversationReceivedTranslationEventArgs;
    } }), Object.defineProperty(e, "LockRoomEventArgs", { enumerable: !0, get: function() {
      return a.LockRoomEventArgs;
    } }), Object.defineProperty(e, "MuteAllEventArgs", { enumerable: !0, get: function() {
      return a.MuteAllEventArgs;
    } }), Object.defineProperty(e, "ParticipantAttributeEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantAttributeEventArgs;
    } }), Object.defineProperty(e, "ParticipantEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantEventArgs;
    } }), Object.defineProperty(e, "ParticipantsListEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantsListEventArgs;
    } });
    var s = /* @__PURE__ */ ng();
    Object.defineProperty(e, "ConversationTranslatorCommandTypes", { enumerable: !0, get: function() {
      return s.ConversationTranslatorCommandTypes;
    } }), Object.defineProperty(e, "ConversationTranslatorMessageTypes", { enumerable: !0, get: function() {
      return s.ConversationTranslatorMessageTypes;
    } }), Object.defineProperty(e, "InternalParticipants", { enumerable: !0, get: function() {
      return s.InternalParticipants;
    } });
  }(Ma)), Ma;
}
var xa = {}, kh;
function sg() {
  return kh || (kh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SynthesisAudioMetadata = e.MetadataType = void 0, function(r) {
      r.WordBoundary = "WordBoundary", r.Bookmark = "Bookmark", r.Viseme = "Viseme", r.SentenceBoundary = "SentenceBoundary", r.SessionEnd = "SessionEnd", r.AvatarSignal = "TalkingAvatarSignal";
    }(e.MetadataType || (e.MetadataType = {}));
    class t {
      constructor(o) {
        this.privSynthesisAudioMetadata = JSON.parse(o);
      }
      static fromJSON(o) {
        return new t(o);
      }
      get Metadata() {
        return this.privSynthesisAudioMetadata.Metadata;
      }
    }
    e.SynthesisAudioMetadata = t;
  }(xa)), xa;
}
var es = {}, Te = {}, Oh;
function pb() {
  if (Oh) return Te;
  Oh = 1, Object.defineProperty(Te, "__esModule", { value: !0 }), Te.SynthesisStartedEvent = Te.ConnectingToSynthesisServiceEvent = Te.SynthesisTriggeredEvent = Te.SpeechSynthesisEvent = void 0;
  const e = /* @__PURE__ */ M();
  class t extends e.PlatformEvent {
    constructor(s, n, c = e.EventType.Info) {
      super(s, c), this.privRequestId = n;
    }
    get requestId() {
      return this.privRequestId;
    }
  }
  Te.SpeechSynthesisEvent = t;
  class r extends t {
    constructor(s, n, c) {
      super("SynthesisTriggeredEvent", s), this.privSessionAudioDestinationId = n, this.privTurnAudioDestinationId = c;
    }
    get audioSessionDestinationId() {
      return this.privSessionAudioDestinationId;
    }
    get audioTurnDestinationId() {
      return this.privTurnAudioDestinationId;
    }
  }
  Te.SynthesisTriggeredEvent = r;
  class o extends t {
    constructor(s, n) {
      super("ConnectingToSynthesisServiceEvent", s), this.privAuthFetchEventId = n;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  Te.ConnectingToSynthesisServiceEvent = o;
  class i extends t {
    constructor(s, n) {
      super("SynthesisStartedEvent", s), this.privAuthFetchEventId = n;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  return Te.SynthesisStartedEvent = i, Te;
}
var Mh;
function db() {
  if (Mh) return es;
  Mh = 1, Object.defineProperty(es, "__esModule", { value: !0 }), es.SynthesisTurn = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ Kt(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ sg(), i = /* @__PURE__ */ pb();
  let a = class Xa {
    constructor() {
      this.privIsDisposed = !1, this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !1, this.privBytesReceived = 0, this.privInTurn = !1, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privRequestId = (0, e.createNoDashGuid)(), this.privTurnDeferral = new e.Deferred(), this.privTurnDeferral.resolve();
    }
    get requestId() {
      return this.privRequestId;
    }
    get streamId() {
      return this.privStreamId;
    }
    set streamId(n) {
      this.privStreamId = n;
    }
    get audioOutputFormat() {
      return this.privAudioOutputFormat;
    }
    set audioOutputFormat(n) {
      this.privAudioOutputFormat = n;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSynthesisEnded() {
      return this.privIsSynthesisEnded;
    }
    get isSynthesizing() {
      return this.privIsSynthesizing;
    }
    get currentTextOffset() {
      return this.privTextOffset;
    }
    get currentSentenceOffset() {
      return this.privSentenceOffset;
    }
    // The number of bytes received for current turn
    get bytesReceived() {
      return this.privBytesReceived;
    }
    get audioDuration() {
      return this.privAudioDuration;
    }
    get extraProperties() {
      if (this.privWebRTCSDP) {
        const n = new r.PropertyCollection();
        return n.setProperty(r.PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP), n;
      }
    }
    async getAllReceivedAudio() {
      return this.privReceivedAudio ? Promise.resolve(this.privReceivedAudio) : this.privIsSynthesisEnded ? (await this.readAllAudioFromStream(), Promise.resolve(this.privReceivedAudio)) : null;
    }
    async getAllReceivedAudioWithHeader() {
      if (this.privReceivedAudioWithHeader)
        return this.privReceivedAudioWithHeader;
      if (!this.privIsSynthesisEnded)
        return null;
      if (this.audioOutputFormat.hasHeader) {
        const n = await this.getAllReceivedAudio();
        return this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(n), this.privReceivedAudioWithHeader;
      } else
        return this.getAllReceivedAudio();
    }
    startNewSynthesis(n, c, u, l) {
      this.privIsSynthesisEnded = !1, this.privIsSynthesizing = !0, this.privRequestId = n, this.privRawText = c, this.privIsSSML = u, this.privAudioOutputStream = new t.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privAudioOutputFormat, this.privReceivedAudio = null, this.privReceivedAudioWithHeader = null, this.privBytesReceived = 0, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privPartialVisemeAnimation = "", this.privWebRTCSDP = "", l !== void 0 && (this.privTurnAudioDestination = l, this.privTurnAudioDestination.format = this.privAudioOutputFormat), this.onEvent(new i.SynthesisTriggeredEvent(this.requestId, void 0, l === void 0 ? void 0 : l.id()));
    }
    onPreConnectionStart(n) {
      this.privAuthFetchEventId = n, this.onEvent(new i.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
    }
    onAuthCompleted(n) {
      n && this.onComplete();
    }
    onConnectionEstablishCompleted(n) {
      if (n === 200) {
        this.onEvent(new i.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId)), this.privBytesReceived = 0;
        return;
      } else n === 403 && this.onComplete();
    }
    onServiceResponseMessage(n) {
      const c = JSON.parse(n);
      this.streamId = c.audio.streamId;
    }
    onServiceTurnEndResponse() {
      this.privInTurn = !1, this.privTurnDeferral.resolve(), this.onComplete();
    }
    onServiceTurnStartResponse(n) {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new e.Deferred();
      const c = JSON.parse(n);
      c.webrtc && (this.privWebRTCSDP = c.webrtc.connectionString);
    }
    onAudioChunkReceived(n) {
      this.isSynthesizing && (this.privAudioOutputStream.write(n), this.privBytesReceived += n.byteLength, this.privTurnAudioDestination !== void 0 && this.privTurnAudioDestination.write(n));
    }
    onTextBoundaryEvent(n) {
      this.updateTextOffset(n.Data.text.Text, n.Type);
    }
    onVisemeMetadataReceived(n) {
      n.Data.AnimationChunk !== void 0 && (this.privPartialVisemeAnimation += n.Data.AnimationChunk);
    }
    onSessionEnd(n) {
      this.privAudioDuration = n.Data.Offset;
    }
    async constructSynthesisResult() {
      const n = await this.getAllReceivedAudioWithHeader();
      return new r.SpeechSynthesisResult(this.requestId, r.ResultReason.SynthesizingAudioCompleted, n, void 0, this.extraProperties, this.audioDuration);
    }
    dispose() {
      this.privIsDisposed || (this.privIsDisposed = !0);
    }
    onStopSynthesizing() {
      this.onComplete();
    }
    /**
     * Gets the viseme animation string (merged from animation chunk), and clears the internal
     * partial animation.
     */
    getAndClearVisemeAnimation() {
      const n = this.privPartialVisemeAnimation;
      return this.privPartialVisemeAnimation = "", n;
    }
    onEvent(n) {
      e.Events.instance.onEvent(n);
    }
    /**
     * Check if the text is an XML(SSML) tag
     * @param text
     * @private
     */
    static isXmlTag(n) {
      return n.length >= 2 && n[0] === "<" && n[n.length - 1] === ">";
    }
    updateTextOffset(n, c) {
      c === o.MetadataType.WordBoundary ? (this.privTextOffset = this.privRawText.indexOf(n, this.privNextSearchTextIndex), this.privTextOffset >= 0 && (this.privNextSearchTextIndex = this.privTextOffset + n.length, this.privIsSSML && this.withinXmlTag(this.privTextOffset) && !Xa.isXmlTag(n) && this.updateTextOffset(n, c))) : (this.privSentenceOffset = this.privRawText.indexOf(n, this.privNextSearchSentenceIndex), this.privSentenceOffset >= 0 && (this.privNextSearchSentenceIndex = this.privSentenceOffset + n.length, this.privIsSSML && this.withinXmlTag(this.privSentenceOffset) && !Xa.isXmlTag(n) && this.updateTextOffset(n, c)));
    }
    onComplete() {
      this.privIsSynthesizing && (this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !0, this.privAudioOutputStream.close(), this.privInTurn = !1, this.privTurnAudioDestination !== void 0 && (this.privTurnAudioDestination.close(), this.privTurnAudioDestination = void 0));
    }
    async readAllAudioFromStream() {
      if (this.privIsSynthesisEnded) {
        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
        try {
          await this.privAudioOutputStream.read(this.privReceivedAudio);
        } catch {
          this.privReceivedAudio = new ArrayBuffer(0);
        }
      }
    }
    /**
     * Check if current idx is in XML(SSML) tag
     * @param idx
     * @private
     */
    withinXmlTag(n) {
      return this.privRawText.indexOf("<", n + 1) > this.privRawText.indexOf(">", n + 1);
    }
  };
  return es.SynthesisTurn = a, es;
}
var ts = {}, Dh;
function hb() {
  if (Dh) return ts;
  Dh = 1, Object.defineProperty(ts, "__esModule", { value: !0 }), ts.SynthesisAdapterBase = void 0;
  const e = /* @__PURE__ */ M(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Jt();
  let i = class {
    constructor(s, n, c, u) {
      if (this.speakOverride = void 0, this.receiveMessageOverride = void 0, this.connectImplOverride = void 0, this.configConnectionOverride = void 0, this.privConnectionConfigurationPromise = void 0, !s)
        throw new e.ArgumentNullError("authentication");
      if (!n)
        throw new e.ArgumentNullError("connectionFactory");
      if (!c)
        throw new e.ArgumentNullError("synthesizerConfig");
      this.privAuthentication = s, this.privConnectionFactory = n, this.privSynthesizerConfig = c, this.privIsDisposed = !1, this.privSessionAudioDestination = u, this.privSynthesisTurn = new r.SynthesisTurn(), this.privConnectionEvents = new e.EventSource(), this.privServiceEvents = new e.EventSource(), this.privSynthesisContext = new r.SynthesisContext(), this.privAgentConfig = new r.AgentConfig(), this.connectionEvents.attach((l) => {
        if (l.name === "ConnectionClosedEvent") {
          const p = l;
          p.statusCode !== 1e3 && this.cancelSynthesisLocal(t.CancellationReason.Error, p.statusCode === 1007 ? t.CancellationErrorCode.BadRequestParameters : t.CancellationErrorCode.ConnectionFailure, `${p.reason} websocket error code: ${p.statusCode}`);
        }
      });
    }
    get synthesisContext() {
      return this.privSynthesisContext;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    set activityTemplate(s) {
      this.privActivityTemplate = s;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set audioOutputFormat(s) {
      this.privAudioOutputFormat = s, this.privSynthesisTurn.audioOutputFormat = s, this.privSessionAudioDestination !== void 0 && (this.privSessionAudioDestination.format = s), this.synthesisContext !== void 0 && (this.synthesisContext.audioOutputFormat = s);
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(s) {
      this.privIsDisposed = !0, this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.close(), this.privConnectionConfigurationPromise !== void 0 && await (await this.privConnectionConfigurationPromise).dispose(s);
    }
    async connect() {
      await this.connectImpl();
    }
    async sendNetworkMessage(s, n) {
      const c = typeof n == "string" ? e.MessageType.Text : e.MessageType.Binary, u = typeof n == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new o.SpeechConnectionMessage(c, s, this.privSynthesisTurn.requestId, u, n));
    }
    async Speak(s, n, c, u, l, p) {
      let h;
      if (n ? h = s : h = this.privSynthesizer.buildSsml(s), this.speakOverride !== void 0)
        return this.speakOverride(h, c, u, l);
      this.privSuccessCallback = u, this.privErrorCallback = l, this.privSynthesisTurn.startNewSynthesis(c, s, n, p);
      try {
        await this.connectImpl();
        const d = await this.fetchConnection();
        await this.sendSynthesisContext(d), await this.sendSsmlMessage(d, h, c), this.onSynthesisStarted(c), this.receiveMessage();
      } catch (d) {
        return this.cancelSynthesisLocal(t.CancellationReason.Error, t.CancellationErrorCode.ConnectionFailure, d), Promise.reject(d);
      }
    }
    async stopSpeaking() {
      return await this.connectImpl(), (await this.fetchConnection()).send(new o.SpeechConnectionMessage(e.MessageType.Text, "synthesis.control", this.privSynthesisTurn.requestId, "application/json", JSON.stringify({
        action: "stop"
      })));
    }
    // Cancels synthesis.
    cancelSynthesis(s, n, c, u) {
      const l = new t.PropertyCollection();
      l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]);
      const p = new t.SpeechSynthesisResult(s, t.ResultReason.Canceled, void 0, u, l);
      if (this.onSynthesisCancelled(p), this.privSuccessCallback)
        try {
          this.privSuccessCallback(p);
        } catch {
        }
    }
    // Cancels synthesis.
    cancelSynthesisLocal(s, n, c) {
      this.privSynthesisTurn.isSynthesizing && (this.privSynthesisTurn.onStopSynthesizing(), this.cancelSynthesis(this.privSynthesisTurn.requestId, s, n, c));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processTypeSpecificMessages(s) {
      return !0;
    }
    async receiveMessage() {
      try {
        const n = await (await this.fetchConnection()).read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (this.privIsDisposed)
          return;
        if (!n)
          return this.privSynthesisTurn.isSynthesizing ? this.receiveMessage() : void 0;
        const c = o.SpeechConnectionMessage.fromConnectionMessage(n);
        if (c.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase())
          switch (c.path.toLowerCase()) {
            case "turn.start":
              this.privSynthesisTurn.onServiceTurnStartResponse(c.textBody);
              break;
            case "response":
              this.privSynthesisTurn.onServiceResponseMessage(c.textBody);
              break;
            case "audio":
              this.privSynthesisTurn.streamId.toLowerCase() === c.streamId.toLowerCase() && c.binaryBody && (this.privSynthesisTurn.onAudioChunkReceived(c.binaryBody), this.onSynthesizing(c.binaryBody), this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.write(c.binaryBody));
              break;
            case "audio.metadata":
              const u = r.SynthesisAudioMetadata.fromJSON(c.textBody).Metadata;
              for (const p of u)
                switch (p.Type) {
                  case r.MetadataType.WordBoundary:
                  case r.MetadataType.SentenceBoundary:
                    this.privSynthesisTurn.onTextBoundaryEvent(p);
                    const h = new t.SpeechSynthesisWordBoundaryEventArgs(p.Data.Offset, p.Data.Duration, p.Data.text.Text, p.Data.text.Length, p.Type === r.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, p.Data.text.BoundaryType);
                    this.onWordBoundary(h);
                    break;
                  case r.MetadataType.Bookmark:
                    const d = new t.SpeechSynthesisBookmarkEventArgs(p.Data.Offset, p.Data.Bookmark);
                    this.onBookmarkReached(d);
                    break;
                  case r.MetadataType.Viseme:
                    if (this.privSynthesisTurn.onVisemeMetadataReceived(p), p.Data.IsLastAnimation) {
                      const f = new t.SpeechSynthesisVisemeEventArgs(p.Data.Offset, p.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                      this.onVisemeReceived(f);
                    }
                    break;
                  case r.MetadataType.AvatarSignal:
                    this.onAvatarEvent(p);
                    break;
                  case r.MetadataType.SessionEnd:
                    this.privSynthesisTurn.onSessionEnd(p);
                    break;
                }
              break;
            case "turn.end":
              this.privSynthesisTurn.onServiceTurnEndResponse();
              let l;
              try {
                l = await this.privSynthesisTurn.constructSynthesisResult(), this.privSuccessCallback && this.privSuccessCallback(l);
              } catch (p) {
                this.privErrorCallback && this.privErrorCallback(p);
              }
              this.onSynthesisCompleted(l);
              break;
            default:
              this.processTypeSpecificMessages(c) || this.privServiceEvents && this.serviceEvents.onEvent(new e.ServiceEvent(c.path.toLowerCase(), c.textBody));
          }
        return this.receiveMessage();
      } catch {
      }
    }
    sendSynthesisContext(s) {
      this.setSynthesisContextSynthesisSection();
      const n = this.synthesisContext.toJSON();
      if (n)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", n));
    }
    setSpeechConfigSynthesisSection() {
    }
    connectImpl(s = !1) {
      if (this.privConnectionPromise != null)
        return this.privConnectionPromise.then((c) => c.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()));
      this.privAuthFetchEventId = (0, e.createNoDashGuid)(), this.privConnectionId = (0, e.createNoDashGuid)(), this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
      const n = s ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
      return this.privConnectionPromise = n.then(async (c) => {
        this.privSynthesisTurn.onAuthCompleted(!1);
        const u = await this.privConnectionFactory.create(this.privSynthesizerConfig, c, this.privConnectionId);
        u.events.attach((p) => {
          this.connectionEvents.onEvent(p);
        });
        const l = await u.open();
        return l.statusCode === 200 ? (this.privSynthesisTurn.onConnectionEstablishCompleted(l.statusCode), Promise.resolve(u)) : l.statusCode === 403 && !s ? this.connectImpl(!0) : (this.privSynthesisTurn.onConnectionEstablishCompleted(l.statusCode), Promise.reject(`Unable to contact server. StatusCode: ${l.statusCode},
                    ${this.privSynthesizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Url)} Reason: ${l.reason}`));
      }, (c) => {
        throw this.privSynthesisTurn.onAuthCompleted(!0), new Error(c);
      }), this.privConnectionPromise.catch(() => {
      }), this.privConnectionPromise;
    }
    sendSpeechServiceConfig(s, n) {
      if (n)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", n));
    }
    sendSsmlMessage(s, n, c) {
      return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "ssml", c, "application/ssml+xml", n));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((s) => s.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const s = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(s) : (this.setSpeechConfigSynthesisSection(), await this.sendSpeechServiceConfig(s, this.privSynthesizerConfig.SpeechServiceConfig.serialize()), s);
    }
    onAvatarEvent(s) {
    }
    onSynthesisStarted(s) {
    }
    onSynthesizing(s) {
    }
    onSynthesisCancelled(s) {
    }
    onSynthesisCompleted(s) {
    }
    onWordBoundary(s) {
    }
    onVisemeReceived(s) {
    }
    onBookmarkReached(s) {
    }
  };
  return ts.SynthesisAdapterBase = i, i.telemetryDataEnabled = !0, ts;
}
var rs = {}, xh;
function fb() {
  if (xh) return rs;
  xh = 1, Object.defineProperty(rs, "__esModule", { value: !0 }), rs.AvatarSynthesisAdapter = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class extends t.SynthesisAdapterBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, void 0), this.privAvatarSynthesizer = n, this.privSynthesizer = n, this.privAvatarConfig = c;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(void 0);
    }
    setSpeechConfigSynthesisSection() {
      this.privSynthesizerConfig.synthesisVideoSection = {
        format: {
          bitrate: this.privAvatarConfig.videoFormat?.bitrate,
          codec: this.privAvatarConfig.videoFormat?.codec,
          crop: {
            bottomRight: {
              x: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.x,
              y: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.y
            },
            topLeft: {
              x: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.x,
              y: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.y
            }
          },
          resolution: {
            height: this.privAvatarConfig.videoFormat?.height,
            width: this.privAvatarConfig.videoFormat?.width
          }
        },
        protocol: {
          name: "WebRTC",
          webrtcConfig: {
            clientDescription: btoa(this.privSynthesizerConfig.parameters.getProperty(e.PropertyId.TalkingAvatarService_WebRTC_SDP)),
            iceServers: this.privAvatarConfig.remoteIceServers ?? this.privAvatarSynthesizer.iceServers
          }
        },
        talkingAvatar: {
          background: {
            color: this.privAvatarConfig.backgroundColor,
            image: {
              url: this.privAvatarConfig.backgroundImage?.toString()
            }
          },
          character: this.privAvatarConfig.character,
          customized: this.privAvatarConfig.customized,
          style: this.privAvatarConfig.style,
          useBuiltInVoice: this.privAvatarConfig.useBuiltInVoice
        }
      };
    }
    onAvatarEvent(i) {
      if (this.privAvatarSynthesizer.avatarEventReceived) {
        const a = new e.AvatarEventArgs(i.Data.Offset, i.Data.Name);
        try {
          this.privAvatarSynthesizer.avatarEventReceived(this.privAvatarSynthesizer, a);
        } catch {
        }
      }
    }
  };
  return rs.AvatarSynthesisAdapter = r, rs;
}
var ns = {}, Nh;
function vb() {
  if (Nh) return ns;
  Nh = 1, Object.defineProperty(ns, "__esModule", { value: !0 }), ns.SpeechSynthesisAdapter = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class extends t.SynthesisAdapterBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, c), this.privSpeechSynthesizer = n, this.privSynthesizer = n;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(this.privSpeechSynthesizer);
    }
    onSynthesisStarted(i) {
      const a = new e.SpeechSynthesisEventArgs(new e.SpeechSynthesisResult(i, e.ResultReason.SynthesizingAudioStarted));
      this.privSpeechSynthesizer.synthesisStarted && this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, a);
    }
    onSynthesizing(i) {
      if (this.privSpeechSynthesizer.synthesizing)
        try {
          const a = this.privSynthesisTurn.audioOutputFormat.addHeader(i), s = new e.SpeechSynthesisEventArgs(new e.SpeechSynthesisResult(this.privSynthesisTurn.requestId, e.ResultReason.SynthesizingAudio, a));
          this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
    onSynthesisCancelled(i) {
      if (this.privSpeechSynthesizer.SynthesisCanceled) {
        const a = new e.SpeechSynthesisEventArgs(i);
        try {
          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, a);
        } catch {
        }
      }
    }
    onSynthesisCompleted(i) {
      if (this.privSpeechSynthesizer.synthesisCompleted)
        try {
          this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new e.SpeechSynthesisEventArgs(i));
        } catch {
        }
    }
    onWordBoundary(i) {
      if (this.privSpeechSynthesizer.wordBoundary)
        try {
          this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
    onVisemeReceived(i) {
      if (this.privSpeechSynthesizer.visemeReceived)
        try {
          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
    onBookmarkReached(i) {
      if (this.privSpeechSynthesizer.bookmarkReached)
        try {
          this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
  };
  return ns.SpeechSynthesisAdapter = r, ns;
}
var is = {}, zh;
function gb() {
  if (zh) return is;
  zh = 1, Object.defineProperty(is, "__esModule", { value: !0 }), is.SynthesisRestAdapter = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ le();
  let i = class {
    constructor(s, n) {
      let c = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      if (!c) {
        const l = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, "westus"), p = r.ConnectionFactoryBase.getHostSuffix(l);
        c = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, `https://${l}.tts.speech${p}`);
      }
      this.privUri = `${c}/cognitiveservices/voices/list`;
      const u = e.RestConfigBase.requestOptions;
      this.privRestAdapter = new e.RestMessageAdapter(u), this.privAuthentication = n;
    }
    /**
     * Sends list voices request to endpoint.
     * @function
     * @public
     * @param connectionId - guid for connectionId
     * @returns {Promise<IRestResponse>} rest response to status request
     */
    getVoicesList(s) {
      return this.privRestAdapter.setHeaders(o.HeaderNames.ConnectionId, s), this.privAuthentication.fetch(s).then((n) => (this.privRestAdapter.setHeaders(n.headerName, n.token), this.privRestAdapter.request(e.RestRequestType.Get, this.privUri)));
    }
  };
  return is.SynthesisRestAdapter = i, is;
}
var Na = {}, Lh;
function mb() {
  return Lh || (Lh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SynthesizerConfig = e.SynthesisServiceType = void 0;
    const t = /* @__PURE__ */ _();
    var r;
    (function(i) {
      i[i.Standard = 0] = "Standard", i[i.Custom = 1] = "Custom";
    })(r = e.SynthesisServiceType || (e.SynthesisServiceType = {}));
    class o {
      constructor(a, s) {
        this.privSynthesisServiceType = r.Standard, this.avatarEnabled = !1, this.privSpeechServiceConfig = a || new t.SpeechServiceConfig(new t.Context(null)), this.privParameters = s;
      }
      get parameters() {
        return this.privParameters;
      }
      get synthesisServiceType() {
        return this.privSynthesisServiceType;
      }
      set synthesisServiceType(a) {
        this.privSynthesisServiceType = a;
      }
      set synthesisVideoSection(a) {
        this.privSpeechServiceConfig.Context.synthesis = {
          video: a
        };
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
    }
    e.SynthesizerConfig = o;
  }(Na)), Na;
}
var ss = {}, jh;
function yb() {
  if (jh) return ss;
  jh = 1, Object.defineProperty(ss, "__esModule", { value: !0 }), ss.SynthesisContext = void 0;
  const e = /* @__PURE__ */ I();
  let t = class {
    constructor() {
      this.privContext = {};
    }
    /**
     * Adds a section to the synthesis.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */
    setSection(o, i) {
      this.privContext[o] = i;
    }
    /**
     * Sets the audio output format for synthesis context generation.
     * @param format {AudioOutputFormatImpl} the output format
     */
    set audioOutputFormat(o) {
      this.privAudioOutputFormat = o;
    }
    toJSON() {
      return JSON.stringify(this.privContext);
    }
    setSynthesisSection(o) {
      const i = this.buildSynthesisContext(o);
      this.setSection("synthesis", i);
    }
    buildSynthesisContext(o) {
      return {
        audio: {
          metadataOptions: {
            bookmarkEnabled: !!o?.bookmarkReached,
            punctuationBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!o?.wordBoundary),
            sentenceBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, !1),
            sessionEndEnabled: !0,
            visemeEnabled: !!o?.visemeReceived,
            wordBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!o?.wordBoundary)
          },
          outputFormat: this.privAudioOutputFormat.requestAudioFormatString
        },
        language: {
          autoDetection: o?.autoDetectSourceLanguage
        }
      };
    }
  };
  return ss.SynthesisContext = t, ss;
}
var os = {}, qh;
function Sb() {
  if (qh) return os;
  qh = 1, Object.defineProperty(os, "__esModule", { value: !0 }), os.SpeakerRecognitionConfig = void 0;
  const e = /* @__PURE__ */ _();
  let t = class {
    constructor(o, i) {
      this.privContext = o || new e.Context(null), this.privParameters = i;
    }
    get parameters() {
      return this.privParameters;
    }
    get Context() {
      return this.privContext;
    }
  };
  return os.SpeakerRecognitionConfig = t, os;
}
var as = {}, Fh;
function Cb() {
  if (Fh) return as;
  Fh = 1, Object.defineProperty(as, "__esModule", { value: !0 }), as.SpeakerServiceRecognizer = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Jt();
  let a = class extends o.ServiceRecognizerBase {
    constructor(n, c, u, l, p) {
      super(n, c, u, l, p), this.privSpeakerRecognizer = p, this.privSpeakerAudioSource = u, this.recognizeSpeaker = (h) => this.recognizeSpeakerOnce(h), this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    processTypeSpecificMessages(n) {
      let c = !1;
      const u = new r.PropertyCollection();
      switch (n.messageType === t.MessageType.Text && u.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, n.textBody), n.path.toLowerCase()) {
        case "speaker.response":
          const p = JSON.parse(n.textBody);
          let h;
          p.status.statusCode.toLowerCase() !== "success" ? h = new r.SpeakerRecognitionResult(p, r.ResultReason.Canceled, r.CancellationErrorCode.ServiceError, p.status.reason) : h = new r.SpeakerRecognitionResult(p, r.ResultReason.RecognizedSpeaker), this.privResultDeferral && this.privResultDeferral.resolve(h), c = !0;
          break;
      }
      const l = new t.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(n, c, u, l, p) {
      if (new r.PropertyCollection().setProperty(o.CancellationErrorCodePropertyName, r.CancellationErrorCode[l]), this.privResultDeferral) {
        const d = new r.SpeakerRecognitionResult({
          scenario: this.privSpeakerModel.scenario,
          status: { statusCode: p, reason: p }
        }, r.ResultReason.Canceled, l, p);
        try {
          this.privResultDeferral.resolve(d);
        } catch (f) {
          this.privResultDeferral.reject(f);
        }
      }
    }
    async recognizeSpeakerOnce(n) {
      this.privSpeakerModel = n, this.voiceProfileType = n.scenario, this.privResultDeferral || (this.privResultDeferral = new t.Deferred()), this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(r.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const c = this.connectImpl(), u = this.sendPreAudioMessages(this.extractSpeakerContext(n)), l = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), p = await this.privSpeakerAudioSource.format, h = await this.privSpeakerAudioSource.deviceInfo, d = new e.ReplayableAudioNode(l, p.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(d, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: h };
      try {
        await c, await u;
      } catch (m) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, m);
      }
      const f = new r.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, f), this.receiveMessage(), this.sendAudio(d).then(() => {
      }, (m) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, m);
      }), this.privResultDeferral.promise;
    }
    async sendPreAudioMessages(n) {
      const c = await this.fetchConnection();
      await this.sendSpeakerRecognition(c, n);
    }
    async sendSpeakerRecognition(n, c) {
      const u = JSON.stringify(c);
      return n.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", u));
    }
    extractSpeakerContext(n) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: n.profileIds,
        scenario: n.scenario
      };
    }
  };
  return as.SpeakerServiceRecognizer = a, as;
}
var cs = {}, Bh;
function Rb() {
  if (Bh) return cs;
  Bh = 1, Object.defineProperty(cs, "__esModule", { value: !0 }), cs.VoiceServiceRecognizer = void 0;
  const e = /* @__PURE__ */ re(), t = /* @__PURE__ */ M(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Jt();
  let a = class extends o.ServiceRecognizerBase {
    constructor(n, c, u, l, p) {
      super(n, c, u, l, p), this.privDeferralMap = new t.DeferralMap(), this.privSpeakerAudioSource = u, this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    set SpeakerAudioSource(n) {
      this.privSpeakerAudioSource = n;
    }
    processTypeSpecificMessages(n) {
      let c = !1;
      const u = new r.PropertyCollection();
      switch (n.messageType === t.MessageType.Text && u.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, n.textBody), n.path.toLowerCase()) {
        // Profile management response for create, fetch, delete, reset
        case "speaker.profiles":
          const p = JSON.parse(n.textBody);
          switch (p.operation.toLowerCase()) {
            case "create":
              this.handleCreateResponse(p, n.requestId);
              break;
            case "delete":
            case "reset":
              this.handleResultResponse(p, n.requestId);
              break;
            case "fetch":
              const g = JSON.parse(n.textBody);
              this.handleFetchResponse(g, n.requestId);
              break;
          }
          c = !0;
          break;
        // Activation and authorization phrase response
        case "speaker.phrases":
          const h = JSON.parse(n.textBody);
          this.handlePhrasesResponse(h, n.requestId), c = !0;
          break;
        // Enrollment response
        case "speaker.profile.enrollment":
          const d = JSON.parse(n.textBody), f = new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(d.enrollment ? d.enrollment.enrollmentStatus : d.status.statusCode), d.enrollment ? JSON.stringify(d.enrollment) : void 0, d.status.reason);
          this.privDeferralMap.getId(n.requestId) && this.privDeferralMap.complete(n.requestId, f), this.privRequestSession.onSpeechEnded(), c = !0;
          break;
      }
      const l = new t.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(n, c, u, l, p) {
      new r.PropertyCollection().setProperty(o.CancellationErrorCodePropertyName, r.CancellationErrorCode[l]);
      const d = new r.VoiceProfileEnrollmentResult(r.ResultReason.Canceled, p, p);
      this.privDeferralMap.getId(c) && this.privDeferralMap.complete(c, d);
    }
    async createProfile(n, c) {
      this.voiceProfileType = n.toString();
      const u = this.connectImpl();
      try {
        const l = new t.Deferred();
        return await u, await this.sendCreateProfile(l, n, c), this.receiveMessage(), l.promise;
      } catch (l) {
        throw l;
      }
    }
    async resetProfile(n) {
      return this.voiceProfileType = n.profileType.toString(), this.sendCommonRequest("reset", n.profileType, n);
    }
    async deleteProfile(n) {
      return this.voiceProfileType = n.profileType.toString(), this.sendCommonRequest("delete", n.profileType, n);
    }
    async retrieveEnrollmentResult(n) {
      return this.voiceProfileType = n.profileType.toString(), this.privExpectedProfileId = n.profileId, this.sendCommonRequest("fetch", n.profileType, n);
    }
    async getAllProfiles(n) {
      return this.voiceProfileType = n.toString(), this.sendCommonRequest("fetch", n);
    }
    async getActivationPhrases(n, c) {
      this.voiceProfileType = n.toString();
      const u = this.connectImpl();
      try {
        const l = new t.Deferred();
        return await u, await this.sendPhrasesRequest(l, n, c), this.receiveMessage(), l.promise;
      } catch (l) {
        throw l;
      }
    }
    async enrollProfile(n) {
      this.voiceProfileType = n.profileType.toString();
      const c = new t.Deferred();
      this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(r.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const u = this.connectImpl(), l = this.sendPreAudioMessages(n, c), p = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), h = await this.privSpeakerAudioSource.format, d = await this.privSpeakerAudioSource.deviceInfo, f = new e.ReplayableAudioNode(p, h.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(f, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: d };
      try {
        await u, await l;
      } catch (v) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, v);
      }
      const g = new r.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, g), this.receiveMessage(), this.sendAudio(f).then(() => {
      }, (v) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, v);
      }), c.promise;
    }
    async sendPreAudioMessages(n, c) {
      const u = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, c), await this.sendBaseRequest(u, "enroll", this.scenarioFrom(n.profileType), n);
    }
    async sendPhrasesRequest(n, c, u) {
      const l = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, n);
      const p = this.scenarioFrom(c), h = {
        locale: u,
        scenario: p
      };
      return l.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(h)));
    }
    async sendCreateProfile(n, c, u) {
      const l = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, n);
      const p = c === r.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : c === r.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification", h = {
        locale: u,
        number: "1",
        scenario: p
      };
      return l.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(h)));
    }
    async sendCommonRequest(n, c, u = void 0) {
      const l = this.connectImpl();
      try {
        const p = new t.Deferred();
        this.privRequestSession.onSpeechContext(), await l;
        const h = await this.fetchConnection();
        return this.privDeferralMap.add(this.privRequestSession.requestId, p), await this.sendBaseRequest(h, n, this.scenarioFrom(c), u), this.receiveMessage(), p.promise;
      } catch (p) {
        throw p;
      }
    }
    async sendBaseRequest(n, c, u, l) {
      const p = {
        scenario: u
      };
      return l ? p.profileIds = [l.profileId] : p.maxPageSize = -1, n.send(new i.SpeechConnectionMessage(t.MessageType.Text, `speaker.profile.${c}`, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(p)));
    }
    extractSpeakerContext(n) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: n.profileIds,
        scenario: n.scenario
      };
    }
    handlePhrasesResponse(n, c) {
      if (this.privDeferralMap.getId(c))
        if (n.status.statusCode.toLowerCase() !== "success") {
          const u = r.ResultReason.Canceled, l = new r.VoiceProfilePhraseResult(u, n.status.statusCode, n.passPhraseType, []);
          this.privDeferralMap.complete(c, l);
        } else if (n.phrases && n.phrases.length > 0) {
          const u = r.ResultReason.EnrollingVoiceProfile, l = new r.VoiceProfilePhraseResult(u, n.status.statusCode, n.passPhraseType, n.phrases);
          this.privDeferralMap.complete(c, l);
        } else
          throw new Error("Voice Profile get activation phrases failed, no phrases received");
      else
        throw new Error(`Voice Profile get activation phrases request for requestID ${c} not found`);
    }
    handleCreateResponse(n, c) {
      if (n.profiles && n.profiles.length > 0)
        if (this.privDeferralMap.getId(c)) {
          const u = n.profiles.map((l) => l.profileId);
          this.privDeferralMap.complete(c, u);
        } else
          throw new Error(`Voice Profile create request for requestID ${c} not found`);
      else
        throw new Error("Voice Profile create failed, no profile id received");
    }
    handleResultResponse(n, c) {
      if (this.privDeferralMap.getId(c)) {
        const u = n.operation.toLowerCase() === "delete" ? r.ResultReason.DeletedVoiceProfile : r.ResultReason.ResetVoiceProfile, l = n.status.statusCode.toLowerCase() === "success" ? u : r.ResultReason.Canceled, p = new r.VoiceProfileResult(l, `statusCode: ${n.status.statusCode}, errorDetails: ${n.status.reason}`);
        this.privDeferralMap.complete(c, p);
      } else
        throw new Error(`Voice Profile create request for requestID ${c} not found`);
    }
    handleFetchResponse(n, c) {
      if (this.privDeferralMap.getId(c) && n.profiles[0]) {
        if (this.privExpectedProfileId && n.profiles.length === 1 && n.profiles[0].profileId === this.privExpectedProfileId) {
          this.privExpectedProfileId = void 0;
          const u = n.profiles[0], l = new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(u.enrollmentStatus), JSON.stringify(u), n.status.reason);
          this.privDeferralMap.complete(c, l);
        } else if (n.profiles.length > 0) {
          const u = n.profiles, l = [];
          for (const p of u)
            l.push(new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(p.enrollmentStatus), JSON.stringify(p), n.status.reason));
          this.privDeferralMap.complete(c, l);
        }
      } else
        throw new Error(`Voice Profile fetch request for requestID ${c} not found`);
    }
    enrollmentReasonFrom(n) {
      switch (n.toLowerCase()) {
        case "enrolled":
          return r.ResultReason.EnrolledVoiceProfile;
        case "invalidlocale":
        case "invalidphrase":
        case "invalidaudioformat":
        case "invalidscenario":
        case "invalidprofilecount":
        case "invalidoperation":
        case "audiotooshort":
        case "audiotoolong":
        case "toomanyenrollments":
        case "storageconflict":
        case "profilenotfound":
        case "incompatibleprofiles":
        case "incompleteenrollment":
          return r.ResultReason.Canceled;
        default:
          return r.ResultReason.EnrollingVoiceProfile;
      }
    }
    scenarioFrom(n) {
      return n === r.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : n === r.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    }
  };
  return cs.VoiceServiceRecognizer = a, cs;
}
var za = {}, Uh;
function Pb() {
  return Uh || (Uh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.type = e.connectivity = e.Device = e.OS = e.System = e.Context = e.SpeechServiceConfig = void 0;
    class t {
      constructor(n) {
        this.context = n;
      }
      serialize() {
        return JSON.stringify(this, (n, c) => {
          if (c && typeof c == "object" && !Array.isArray(c)) {
            const u = {};
            for (const l in c)
              Object.hasOwnProperty.call(c, l) && (u[l && l.charAt(0).toLowerCase() + l.substring(1)] = c[l]);
            return u;
          }
          return c;
        });
      }
      get Context() {
        return this.context;
      }
      get Recognition() {
        return this.recognition;
      }
      set Recognition(n) {
        this.recognition = n.toLowerCase();
      }
    }
    e.SpeechServiceConfig = t;
    class r {
      constructor(n) {
        this.system = new o(), this.os = n;
      }
    }
    e.Context = r;
    class o {
      constructor() {
        const n = "1.44.1";
        this.name = "SpeechSDK", this.version = n, this.build = "JavaScript", this.lang = "JavaScript";
      }
    }
    e.System = o;
    class i {
      constructor(n, c, u) {
        this.platform = n, this.name = c, this.version = u;
      }
    }
    e.OS = i;
    class a {
      constructor(n, c, u) {
        this.manufacturer = n, this.model = c, this.version = u;
      }
    }
    e.Device = a, function(s) {
      s.Bluetooth = "Bluetooth", s.Wired = "Wired", s.WiFi = "WiFi", s.Cellular = "Cellular", s.InBuilt = "InBuilt", s.Unknown = "Unknown";
    }(e.connectivity || (e.connectivity = {})), function(s) {
      s.Phone = "Phone", s.Speaker = "Speaker", s.Car = "Car", s.Headset = "Headset", s.Thermostat = "Thermostat", s.Microphones = "Microphones", s.Deskphone = "Deskphone", s.RemoteControl = "RemoteControl", s.Unknown = "Unknown", s.File = "File", s.Stream = "Stream";
    }(e.type || (e.type = {}));
  }(za)), za;
}
var $h;
function _() {
  return $h || ($h = 1, function(e) {
    var t = ut && ut.__createBinding || (Object.create ? function(a, s, n, c) {
      c === void 0 && (c = n), Object.defineProperty(a, c, { enumerable: !0, get: function() {
        return s[n];
      } });
    } : function(a, s, n, c) {
      c === void 0 && (c = n), a[c] = s[n];
    }), r = ut && ut.__exportStar || function(a, s) {
      for (var n in a) n !== "default" && !Object.prototype.hasOwnProperty.call(s, n) && t(s, a, n);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AutoDetectSourceLanguagesOpenRangeOptionName = e.ForceDictationPropertyName = e.ServicePropertiesPropertyName = e.CancellationErrorCodePropertyName = e.OutputFormatPropertyName = e.SpeechSynthesisAdapter = e.AvatarSynthesisAdapter = void 0, r(/* @__PURE__ */ YC(), e), r(/* @__PURE__ */ ZC(), e), r(/* @__PURE__ */ dc(), e), r(/* @__PURE__ */ XC(), e), r(/* @__PURE__ */ eR(), e), r(/* @__PURE__ */ rw(), e), r(/* @__PURE__ */ nw(), e), r(/* @__PURE__ */ mc(), e), r(/* @__PURE__ */ hw(), e), r(/* @__PURE__ */ fw(), e), r(/* @__PURE__ */ vw(), e), r(/* @__PURE__ */ gw(), e), r(/* @__PURE__ */ mw(), e), r(/* @__PURE__ */ yw(), e), r(/* @__PURE__ */ Sw(), e), r(/* @__PURE__ */ Cw(), e), r(/* @__PURE__ */ Rw(), e), r(/* @__PURE__ */ Vv(), e), r(/* @__PURE__ */ Pw(), e), r(/* @__PURE__ */ ww(), e), r(/* @__PURE__ */ bw(), e), r(/* @__PURE__ */ Ew(), e), r(/* @__PURE__ */ Iw(), e), r(/* @__PURE__ */ Aw(), e), r(/* @__PURE__ */ Tw(), e), r(/* @__PURE__ */ _w(), e), r(/* @__PURE__ */ kw(), e), r(/* @__PURE__ */ Ow(), e), r(/* @__PURE__ */ Dw(), e), r(/* @__PURE__ */ xw(), e), r(/* @__PURE__ */ Nw(), e), r(/* @__PURE__ */ zw(), e), r(/* @__PURE__ */ Lw(), e), r(/* @__PURE__ */ jw(), e), r(/* @__PURE__ */ qw(), e), r(/* @__PURE__ */ Fw(), e), r(/* @__PURE__ */ Uw(), e), r(/* @__PURE__ */ Vw(), e), r(/* @__PURE__ */ Hw(), e), r(/* @__PURE__ */ Yw(), e), r(/* @__PURE__ */ Zw(), e), r(/* @__PURE__ */ lb(), e), r(/* @__PURE__ */ sg(), e), r(/* @__PURE__ */ db(), e), r(/* @__PURE__ */ hb(), e);
    var o = /* @__PURE__ */ fb();
    Object.defineProperty(e, "AvatarSynthesisAdapter", { enumerable: !0, get: function() {
      return o.AvatarSynthesisAdapter;
    } });
    var i = /* @__PURE__ */ vb();
    Object.defineProperty(e, "SpeechSynthesisAdapter", { enumerable: !0, get: function() {
      return i.SpeechSynthesisAdapter;
    } }), r(/* @__PURE__ */ gb(), e), r(/* @__PURE__ */ mb(), e), r(/* @__PURE__ */ yb(), e), r(/* @__PURE__ */ Sb(), e), r(/* @__PURE__ */ Cb(), e), r(/* @__PURE__ */ Rb(), e), r(/* @__PURE__ */ Pb(), e), e.OutputFormatPropertyName = "OutputFormat", e.CancellationErrorCodePropertyName = "CancellationErrorCode", e.ServicePropertiesPropertyName = "ServiceProperties", e.ForceDictationPropertyName = "ForceDictation", e.AutoDetectSourceLanguagesOpenRangeOptionName = "UND";
  }(ut)), ut;
}
var Vh;
function wb() {
  return Vh || (Vh = 1, function(e) {
    var t = ct && ct.__createBinding || (Object.create ? function(i, a, s, n) {
      n === void 0 && (n = s), Object.defineProperty(i, n, { enumerable: !0, get: function() {
        return a[s];
      } });
    } : function(i, a, s, n) {
      n === void 0 && (n = s), i[n] = a[s];
    }), r = ct && ct.__exportStar || function(i, a) {
      for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(a, s) && t(a, i, s);
    };
    Object.defineProperty(e, "__esModule", { value: !0 });
    const o = /* @__PURE__ */ _();
    new o.AgentConfig(), r(/* @__PURE__ */ I(), e);
  }(ct)), ct;
}
var us = /* @__PURE__ */ wb();
const bb = Ss.Provider, Eb = Ss.Root, Ib = Ss.Trigger, og = Z.forwardRef(({ className: e, sideOffset: t = 4, ...r }, o) => /* @__PURE__ */ w(
  Ss.Content,
  {
    ref: o,
    sideOffset: t,
    className: Pe(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      e
    ),
    ...r
  }
));
og.displayName = Ss.Content.displayName;
const Ab = {
  en: "en-US",
  es: "es-ES",
  pt: "pt-PT",
  fr: "fr-FR",
  de: "de-DE",
  zh: "zh-CN",
  ja: "ja-JP",
  hi: "hi-IN",
  ar: "ar-SA",
  ru: "ru-RU"
};
function ag({
  avatarName: e,
  disabled: t = !1,
  voiceMode: r,
  setSpokenText: o,
  setIsSpeaking: i,
  setInterruptReplica: a,
  region: s,
  speechKey: n
}) {
  const [c, u] = O(!1), [l, p] = O(!1), [h, d] = O(null), [f, g] = O("en");
  U(() => {
    typeof window < "u" && g(localStorage.getItem("lang") || "en");
  }, []);
  const m = c ? `You're now talking to ${e}` : `Click here to talk to ${e}`;
  U(() => (c ? v() : y(), () => {
    y();
  }), [c]);
  const v = async () => {
    try {
      const C = us.SpeechConfig.fromSubscription(
        n,
        s
      );
      C.speechRecognitionLanguage = Ab[f || "en"];
      const P = us.AudioConfig.fromDefaultMicrophoneInput(), b = new us.SpeechRecognizer(C, P);
      b.recognizing = (A, E) => {
        console.log(`RECOGNIZING: Text=${E.result.text}`);
      }, b.recognized = (A, E) => {
        E.result.reason === us.ResultReason.RecognizedSpeech && (console.log(`RECOGNIZED: Text=${E.result.text}`), E.result.text && (o(E.result.text), u(!1), i(!1), a(!1)));
      }, b.canceled = (A, E) => {
        console.log(`CANCELED: Reason=${E.reason}`), E.reason === us.CancellationReason.Error && console.error(`ERROR: Details=${E.errorDetails}`), u(!1), i(!1);
      }, b.sessionStopped = () => {
        u(!1), i(!1);
      }, await b.startContinuousRecognitionAsync(), d(b), i(!0), a(!0);
    } catch (C) {
      console.error("Error starting continuous recognition:", C), u(!1), i(!1);
    }
  }, y = async () => {
    if (h)
      try {
        await h.stopContinuousRecognitionAsync(), h.close(), d(null);
      } catch (C) {
        console.error("Error stopping recognition:", C);
      }
  }, S = () => {
    t || l || u(!c);
  };
  return r ? /* @__PURE__ */ w(bb, { children: /* @__PURE__ */ k(Eb, { children: [
    /* @__PURE__ */ w(Ib, { asChild: !0, children: /* @__PURE__ */ w(
      Wt,
      {
        variant: "outline",
        size: "icon",
        onClick: S,
        disabled: t || l || !1,
        className: "rounded-full bg-primary hover:bg-secondary h-9 w-9",
        children: l ? /* @__PURE__ */ w(Fa, { className: "w-6 h-6 text-white animate-spin" }) : c ? /* @__PURE__ */ w(Og, { className: "w-6 h-6 text-white" }) : /* @__PURE__ */ w(Mg, { className: "w-6 h-6 text-white" })
      }
    ) }),
    /* @__PURE__ */ w(og, { children: /* @__PURE__ */ w("p", { children: m }) })
  ] }) }) : null;
}
const Wh = async (e, t = "", r = "", o = "chat", i = "", a = 0, s = 1, n = "en", c) => {
  for (let u = 0; u < s; u++) {
    const l = new Headers();
    l.append("Accept", "application/json");
    const p = e + "Language: " + n, h = "52533633434137384342", d = new FormData();
    d.append("Input", p), d.append("UserId", t || h), d.append("BusinessId", r), d.append("Intent", o), d.append("SessionId", i), d.append("Platform", "EF0306CD"), c && c.size > 0 ? (d.append("Files", c), console.log("File appended to FormData")) : console.log("No file to append");
    const f = new AbortController(), g = setTimeout(() => f.abort(), 9e4), m = {
      method: "POST",
      headers: l,
      body: d,
      signal: f.signal
      // Add the abort signal to the request
    };
    try {
      const y = await fetch(
        "https://developmentapis.azure-api.net/demo/v1/api/AI/assistant",
        m
      );
      if (clearTimeout(g), !y.ok) {
        const C = await y.json();
        throw new Error(
          C?.Message || `HTTP error! Status: ${y.status}`
        );
      }
      const S = await y.json();
      if (S.Success && (S.Data?.Message === null || S.Data?.Message.toUpperCase() === "INVALID JSON" || S.Data?.Message === "local variable 'result' referenced before assignment" || S.Data?.Message === "Object reference not set to an instance of an object." || S.Data?.Message?.toLowerCase().includes("exception thrown"))) {
        console.warn(
          `Attempt ${u + 1}: Success but received null data. Retrying...`
        ), a > 0 && await new Promise((C) => setTimeout(C, a));
        continue;
      }
      return S;
    } catch (v) {
      if (clearTimeout(g), v instanceof Error && v.name === "AbortError")
        return console.error("Request timed out after 90 seconds"), { Success: !1, Message: "ERROR: API timed out", Data: null };
      console.error("Error in chat API:", v);
    }
  }
  return {
    Success: !1,
    Message: "API call failed after all retries",
    Data: null
  };
}, Tb = () => "https://developmentapis.azure-api.net/sandbox/v1/api", Sc = (e) => {
  const t = Tb().replace(/\/$/, "");
  let r = e.startsWith("/") ? e : `/${e}`;
  return t.endsWith("/api") && r.startsWith("/api/") && (r = r.replace(/^\/api/, "")), `${t}${r}`;
}, _b = async (e, t, r, o) => {
  const a = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
      // Indicate JSON payload
    },
    body: JSON.stringify({
      Input: e,
      UserId: t,
      BusinessId: r,
      Accepted: o
    })
    // Convert the payload to a JSON string
  };
  let s;
  try {
    const n = await fetch(
      Sc("/api/AI/training"),
      a
    );
    if (!n.ok) {
      const c = await n.text();
      throw console.error("Error details:", c), new Error(`Failed: ${n.statusText} - ${c}`);
    }
    if (n.headers.get("content-length") === "0")
      s = {};
    else {
      const c = n.headers.get("content-type");
      c && c.includes("application/json") ? s = await n.json() : console.error("Unexpected response format:", c);
    }
  } catch (n) {
    console.error("Saving chat error:", n);
  }
  return s;
}, kb = ({
  onStart: e,
  loading: t,
  buttonText: r = "Start Conversation",
  videoRef: o,
  platform: i,
  replicaId: a,
  containerClassName: s = "",
  imageHeight: n = "auto",
  buttonSize: c = "md",
  learningPrompts: u,
  onPromptClick: l,
  userCredits: p,
  avatars: h,
  personaName: d,
  config: f
}) => {
  const [g, m] = O("en");
  U(() => {
    typeof window < "u" && m(localStorage.getItem("lang") || "en");
  }, []);
  const [v, y] = O({ loading: "Loading...", avatarNotFound: "Avatar not found" }), S = h.find((P) => P.ExternalId === a), C = {
    sm: "text-sm px-4 py-2",
    md: "text-base px-6 py-3",
    lg: "text-lg px-8 py-4"
  };
  return U(() => {
    (async () => {
      if (g !== "en") {
        const [b, A] = await Qs(["Loading...", "Avatar not found"], g, "en", f?.azureTranslatorKey || "", f?.azureTranslatorEndpoint || "", f?.azureTranslatorRegion || "");
        y({ loading: b, avatarNotFound: A });
      } else
        y({ loading: "Loading...", avatarNotFound: "Avatar not found" });
    })();
  }, [g]), /* @__PURE__ */ k("div", { className: `flex flex-col items-center justify-center ${s}`, children: [
    /* @__PURE__ */ w("div", { className: `w-full ${n} max-h-[300px] mb-6 relative`, children: S ? /* @__PURE__ */ k(et, { children: [
      /* @__PURE__ */ w(
        "img",
        {
          ref: o,
          src: S.ImageUrl,
          alt: S.Name,
          className: "w-full h-full object-cover rounded-lg"
        }
      ),
      /* @__PURE__ */ k("div", { className: "absolute top-3 right-3 flex items-center bg-black/70 px-2 py-1 rounded-full text-white text-xs font-medium shadow-md", children: [
        /* @__PURE__ */ k("div", { className: "relative flex h-3 w-3 mr-1.5", children: [
          /* @__PURE__ */ w("span", { className: "animate-ping absolute inline-flex h-full w-full rounded-full bg-green-500 opacity-75" }),
          /* @__PURE__ */ w("span", { className: "relative inline-flex rounded-full h-3 w-3 bg-green-600" })
        ] }),
        /* @__PURE__ */ w("span", { children: "LIVE" })
      ] }),
      /* @__PURE__ */ w("div", { className: "absolute bottom-3 left-3 right-3 bg-gradient-to-t from-black/70 to-transparent p-3 rounded-b-lg", children: /* @__PURE__ */ w("p", { className: "text-white/80 text-xs", children: d }) })
    ] }) : /* @__PURE__ */ w("div", { className: "w-full h-full bg-light rounded-lg flex items-center justify-center", children: /* @__PURE__ */ w("p", { className: "text-secondary", children: v.avatarNotFound }) }) }),
    /* @__PURE__ */ w(
      "button",
      {
        onClick: e,
        disabled: t || p !== void 0 && p <= 0,
        className: `bg-primary text-white rounded-full font-semibold hover:bg-secondary transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${C[c]}`,
        children: t ? v.loading : r
      }
    ),
    u && u.length > 0 && /* @__PURE__ */ k("div", { className: "mt-6 w-full", children: [
      /* @__PURE__ */ w("h3", { className: "text-lg font-semibold mb-3", children: "Try asking about:" }),
      /* @__PURE__ */ w("div", { className: "space-y-2", children: u.map((P, b) => /* @__PURE__ */ w(
        "button",
        {
          onClick: () => l?.(P),
          className: "w-full text-left p-3 bg-gray-50 hover:bg-gray-100 rounded-lg transition-colors",
          children: P
        },
        b
      )) })
    ] })
  ] });
}, cg = ({ id: e, style: t = {} }) => {
  const r = yf(e), o = r?.isOff, [i, a] = O(!1), s = We(null);
  return U(() => {
    const n = s.current;
    if (!n) return;
    const c = () => a(!0);
    return n.addEventListener("canplay", c), () => {
      n.removeEventListener("canplay", c);
    };
  }, [r]), /* @__PURE__ */ k(
    "div",
    {
      className: `w-full rounded-lg overflow-hidden bg-slate-100 relative transition-all duration-300 mx-auto\r
                    h-[200px] sm:h-[250px] md:h-[350px] lg:h-[450px] xl:h-[500px]`,
      style: t,
      children: [
        e && /* @__PURE__ */ w(
          Fg,
          {
            automirror: !0,
            sessionId: e,
            type: "video",
            ref: s,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              display: o || !i ? "none" : "block"
            }
          }
        ),
        !i && !o && /* @__PURE__ */ w("div", { className: "absolute top-0 left-0 w-full h-full flex items-center justify-center bg-slate-100 z-10", children: /* @__PURE__ */ k(
          "svg",
          {
            className: "animate-spin h-8 w-8 text-blue-500",
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ w(
                "circle",
                {
                  className: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ w(
                "path",
                {
                  className: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                }
              )
            ]
          }
        ) }),
        o && /* @__PURE__ */ w("div", { className: "absolute top-0 left-0 w-full h-full flex items-center justify-center bg-slate-100 z-5", children: /* @__PURE__ */ w(
          "svg",
          {
            className: "h-1/2 w-auto",
            width: "24px",
            height: "24px",
            viewBox: "0 0 24 24",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg",
            children: /* @__PURE__ */ k("g", { stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: [
              /* @__PURE__ */ w(
                "path",
                {
                  d: "M18.571,4 C19.142,4 19.557,4.23 19.815,4.689 C20.073,5.148 20.073,5.622 19.815,6.111 L16,12 L19.815,17.889 C20.073,18.377 20.073,18.852 19.815,19.311 C19.557,19.77 19.142,20 18.571,20 L5.429,20 C4.857,20 4.443,19.77 4.185,19.311 C3.927,18.852 3.927,18.377 4.185,17.889 L8,12 L4.185,6.111 C3.927,5.622 3.927,5.148 4.185,4.689 C4.443,4.23 4.857,4 5.429,4 L18.571,4 Z",
                  fill: "#555555"
                }
              ),
              /* @__PURE__ */ w(
                "line",
                {
                  x1: "4",
                  y1: "4",
                  x2: "20",
                  y2: "20",
                  stroke: "#E92A09",
                  strokeWidth: "2.5",
                  strokeLinecap: "round"
                }
              )
            ] })
          }
        ) })
      ]
    }
  );
}, Ob = ({
  handleJoin: e,
  handleEnd: t,
  platform: r,
  setScreen: o,
  containerClassName: i = "",
  videoDimensions: a = { width: "100%", height: "auto" },
  buttonsSize: s = "md"
}) => {
  const n = Sf(), c = Ws();
  U(() => {
    (async () => {
      if (c) {
        const p = c?.meetingState();
        if (p === "new" || p === "loading")
          try {
            c.startCamera({ startVideoOff: !0, startAudioOff: !0 }), o("call");
          } catch (h) {
            console.warn("Failed to start camera:", h);
          }
        else
          console.log("Call already started, skipping startCamera()");
      }
    })();
  }, [c, n]);
  const u = {
    sm: "px-3 py-1.5 text-xs",
    md: "px-4 py-2 text-sm",
    lg: "px-6 py-3 text-base"
  };
  return /* @__PURE__ */ k(
    qg.div,
    {
      className: `flex flex-col items-center ${i}`,
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      transition: { duration: 0.3 },
      children: [
        /* @__PURE__ */ k("div", { className: "mb-4 flex flex-col items-center justify-center gap-4 text-center w-full max-w-2xl mx-auto mt-4 px-2", children: [
          /* @__PURE__ */ w("h2", { className: "text-xl font-bold text-secondary mb-1", children: "Check your camera and microphone" }),
          /* @__PURE__ */ w("p", { className: "text-sm text-secondary", children: "Make sure your devices are working properly before joining" })
        ] }),
        /* @__PURE__ */ w("div", { className: "w-full max-w-lg mb-6 rounded-lg border border-gray-300 overflow-hidden bg-gray-100", children: /* @__PURE__ */ w("div", { className: "p-8 flex items-center justify-center bg-gradient-to-b from-gray-800 to-primary/60 text-white", children: /* @__PURE__ */ k("div", { className: "text-center", children: [
          /* @__PURE__ */ w("div", { className: "mx-auto h-24 w-24 rounded-full bg-black/80 flex items-center justify-center mb-4", children: /* @__PURE__ */ k(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "32",
              height: "32",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ w("path", { d: "M23 7l-7 5 7 5V7z" }),
                /* @__PURE__ */ w("rect", { x: "1", y: "5", width: "15", height: "14", rx: "2", ry: "2" })
              ]
            }
          ) }),
          /* @__PURE__ */ w(
            "div",
            {
              className: "relative rounded-xl border-4 border-primary overflow-hidden shadow-lg",
              style: {
                width: a.width || "100%",
                height: a.height || "auto"
              },
              children: /* @__PURE__ */ w(cg, { id: n })
            }
          )
        ] }) }) }),
        /* @__PURE__ */ k("div", { className: `flex flex-wrap gap-4 mt-2 justify-center ${s === "sm" ? "scale-90" : s === "lg" ? "scale-110" : ""}`, children: [
          /* @__PURE__ */ k("div", { className: "flex items-center gap-2 px-3 py-2 bg-black/5 rounded-md", children: [
            /* @__PURE__ */ k(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "18",
                height: "18",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ w("path", { d: "M23 7l-7 5 7 5V7z" }),
                  /* @__PURE__ */ w("rect", { x: "1", y: "5", width: "15", height: "14", rx: "2", ry: "2" })
                ]
              }
            ),
            /* @__PURE__ */ w("span", { className: "text-sm", children: "Camera: Ready" })
          ] }),
          /* @__PURE__ */ k("div", { className: "flex items-center gap-2 px-3 py-2 bg-black/5 rounded-md", children: [
            /* @__PURE__ */ k(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "18",
                height: "18",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ w("path", { d: "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" }),
                  /* @__PURE__ */ w("path", { d: "M19 10v2a7 7 0 0 1-14 0v-2" }),
                  /* @__PURE__ */ w("line", { x1: "12", y1: "19", x2: "12", y2: "23" }),
                  /* @__PURE__ */ w("line", { x1: "8", y1: "23", x2: "16", y2: "23" })
                ]
              }
            ),
            /* @__PURE__ */ w("span", { className: "text-sm", children: "Microphone: Ready" })
          ] })
        ] }),
        /* @__PURE__ */ k("div", { className: "flex gap-4 mt-6", children: [
          /* @__PURE__ */ w(
            "button",
            {
              onClick: t,
              className: `border border-primary text-primary rounded-md hover:bg-secondary transition ${u[s]}`,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ w(
            "button",
            {
              onClick: e,
              className: `bg-primary hover:bg-secondary text-white rounded-md transition ${u[s]}`,
              children: "Join Conversation"
            }
          )
        ] })
      ]
    }
  );
}, Mb = ({
  actionLabel: e,
  onAction: t,
  cancelLabel: r,
  onCancel: o,
  chatLabel: i,
  onChat: a,
  chatVisible: s = !1,
  platform: n,
  setInterruptReplica: c,
  setIsSpeaking: u,
  setSpokenText: l,
  region: p,
  speechKey: h
}) => {
  Ws();
  const { currentCam: d, currentMic: f, refreshDevices: g } = Bg(), m = Sf(), v = yf(m), y = Ug(m);
  v.isOff, y.isOff;
  const [S, C] = O(!1);
  return U(() => {
    (() => {
      document.querySelectorAll("[data-replit-metadata]").forEach((A) => {
        A.hasAttribute("data-replit-metadata") && A.removeAttribute("data-replit-metadata");
      });
    })();
  }, []), $g(
    "camera-error",
    sc(() => {
      C(!0);
    }, [])
  ), /* @__PURE__ */ k("div", { className: "mt-2 p-2 rounded-lg max-w-md flex gap-4 justify-around items-center mx-auto bg-primary", children: [
    /* @__PURE__ */ w("div", { className: "flex items-center", children: /* @__PURE__ */ w(
      ag,
      {
        avatarName: n === "university" ? "Instructor" : n === "pr" ? "PR Strategist" : n === "business_advisor" ? "Medical Advisor" : n === "survey" ? "AI Surveyor" : n === "concierge" ? "Concierge" : "Business Expert",
        disabled: !1,
        voiceMode: !0,
        setSpokenText: l,
        setIsSpeaking: u,
        setInterruptReplica: c,
        region: p,
        speechKey: h
      }
    ) }),
    e && e === "End Conversation" && /* @__PURE__ */ w(
      "button",
      {
        onClick: t,
        disabled: S || (!d || !f) && n !== "home" && n !== "university" && n !== "concierge" && n !== "pr" && n !== "business_advisor" && n !== "survey",
        className: "flex items-center justify-center p-1 rounded-full border border-white text-white w-10 h-10",
        children: /* @__PURE__ */ w(Dg, { className: "w-6 h-6" })
      }
    )
  ] });
};
var La, Hh;
function Db() {
  return Hh || (Hh = 1, La = function(e, t) {
    t = t || {}, t.listUnicodeChar = t.hasOwnProperty("listUnicodeChar") ? t.listUnicodeChar : !1, t.stripListLeaders = t.hasOwnProperty("stripListLeaders") ? t.stripListLeaders : !0, t.gfm = t.hasOwnProperty("gfm") ? t.gfm : !0, t.useImgAltText = t.hasOwnProperty("useImgAltText") ? t.useImgAltText : !0, t.abbr = t.hasOwnProperty("abbr") ? t.abbr : !1, t.replaceLinksWithURL = t.hasOwnProperty("replaceLinksWithURL") ? t.replaceLinksWithURL : !1, t.htmlTagsToSkip = t.hasOwnProperty("htmlTagsToSkip") ? t.htmlTagsToSkip : [], t.throwError = t.hasOwnProperty("throwError") ? t.throwError : !1;
    var r = e || "";
    r = r.replace(/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/gm, "");
    try {
      t.stripListLeaders && (t.listUnicodeChar ? r = r.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, t.listUnicodeChar + " $1") : r = r.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1")), t.gfm && (r = r.replace(/\n={2,}/g, `
`).replace(/~{3}.*\n/g, "").replace(/~~/g, "").replace(/```(?:.*)\n([\s\S]*?)```/g, (i, a) => a.trim())), t.abbr && (r = r.replace(/\*\[.*\]:.*\n/, ""));
      let o = /<[^>]*>/g;
      if (t.htmlTagsToSkip && t.htmlTagsToSkip.length > 0) {
        const i = t.htmlTagsToSkip.join("|");
        o = new RegExp(
          `<(?!/?(${i})(?=>|s[^>]*>))[^>]*>`,
          "g"
        );
      }
      r = r.replace(o, "").replace(/^[=\-]{2,}\s*$/g, "").replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(/\!\[(.*?)\][\[\(].*?[\]\)]/g, t.useImgAltText ? "$1" : "").replace(/\[([\s\S]*?)\]\s*[\(\[].*?[\)\]]/g, t.replaceLinksWithURL ? "$2" : "$1").replace(/^(\n)?\s{0,3}>\s?/gm, "$1").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(/^(\n)?\s{0,}#{1,6}\s*( (.+))? +#+$|^(\n)?\s{0,}#{1,6}\s*( (.+))?$/gm, "$1$3$4$6").replace(/([\*]+)(\S)(.*?\S)??\1/g, "$2$3").replace(/(^|\W)([_]+)(\S)(.*?\S)??\2($|\W)/g, "$1$3$4$5").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/`(.+?)`/g, "$1").replace(/~(.*?)~/g, "$1");
    } catch (o) {
      if (t.throwError) throw o;
      return console.error("remove-markdown encountered error: %s", o), e;
    }
    return r;
  }), La;
}
var xb = Db();
const Nb = /* @__PURE__ */ vC(xb), zb = ({
  conversationId: e,
  platform: t,
  videoMode: r,
  endConv: o,
  onAction: i,
  videoHeight: a = "auto",
  aspectRatio: s = "16:9",
  setInterruptReplica: n,
  currentScript: c,
  interruptReplica: u,
  personaName: l,
  config: p
}) => {
  const h = Ws(), d = Vg({ filter: "remote" }), [f, g] = O("full"), [m, v] = O([]), [y, S] = O(!1), [C, P] = O("en");
  U(() => {
    typeof window < "u" && P(localStorage.getItem("lang") || "en");
  }, []);
  const b = Wg({
    onAppMessage: sc((T) => {
      const x = T.data;
      v((q) => [...q, x]);
    }, [])
  }), [A, E] = O({ waiting: `${l} will be here shortly...`, endConversation: "Ending Conversation..." });
  U(() => {
    (async () => {
      if (C !== "en") {
        const [x, q] = await Qs([`${l} will be here shortly...`, "Ending Conversation..."], C, "en", p?.azureTranslatorKey || "", p?.azureTranslatorEndpoint || "", p?.azureTranslatorRegion || "");
        E({ waiting: x, endConversation: q });
      } else
        E({ waiting: `${l} will be here shortly...`, endConversation: "Ending Conversation..." });
    })();
  }, [C]);
  const D = (T) => T ? Nb(T).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "").replace(/[^\w\s.,!?'"-]/g, "").replace(/\s+/g, " ").trim() : "";
  U(() => {
    const T = () => S(!0);
    return h && h.on("joined-meeting", T), () => {
      h && h.off("joined-meeting", T);
    };
  }, [h]), U(() => {
    try {
      if (h && y && c) {
        n(!1);
        const T = D(c);
        R(T);
      }
    } catch (T) {
      console.error("Error sending echo interaction:", T);
    }
  }, [c, y]), U(() => {
    h && y && u && j();
  }, [u]), U(() => {
    r && g(r);
  }, [r]);
  const R = (T) => {
    const x = {
      message_type: "conversation",
      event_type: "conversation.echo",
      conversation_id: e,
      properties: {
        modality: "text",
        text: `${T}`
      }
    };
    console.log("Sending Echo Interaction:", x), b(x, "*");
  }, j = () => {
    const T = {
      message_type: "conversation",
      event_type: "conversation.interrupt",
      conversation_id: e
    };
    console.log("Sending Echo Interaction:", T), b(T, "*");
  };
  return /* @__PURE__ */ k(et, { children: [
    /* @__PURE__ */ w("div", { className: "flex flex-col items-center justify-center gap-4 text-center mx-auto px-2 h-full overflow-hidden", children: /* @__PURE__ */ w("div", { className: "relative w-full h-full rounded-xl border-4 border-neutral overflow-hidden shadow-lg", children: d.length > 0 ? /* @__PURE__ */ w(
      "div",
      {
        className: "relative w-full h-full",
        style: {
          backgroundColor: "#000",
          position: "relative",
          overflow: "hidden"
          // To contain absolutely positioned elements
        },
        children: /* @__PURE__ */ w(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              // Add flex to center content if needed
              justifyContent: "center",
              // Center content horizontally
              alignItems: "center"
              // Center content vertically
            },
            children: /* @__PURE__ */ w(
              cg,
              {
                id: d[0],
                style: {
                  borderRadius: "0px",
                  objectFit: "contain",
                  width: "100%",
                  height: "100%",
                  backgroundColor: "#000"
                }
              }
            )
          }
        )
      }
    ) : /* @__PURE__ */ w(
      "div",
      {
        className: "relative flex justify-center items-center w-full h-full",
        style: {
          backgroundColor: "#000",
          width: "100%",
          height: "100%",
          position: "relative"
        },
        children: /* @__PURE__ */ w("div", { className: "absolute inset-0 flex justify-center items-center", children: /* @__PURE__ */ w("h2", { className: "text-white text-xl text-center px-4", children: o ? A.endConversation : A.waiting }) })
      }
    ) }) }),
    /* @__PURE__ */ w(Hg, {})
  ] });
}, Lb = ({
  conversation: e,
  handleEnd: t,
  platform: r,
  videoMode: o,
  endConv: i,
  chatVisible: a,
  toggleChat: s,
  containerClassName: n = "",
  videoHeight: c = "auto",
  controlsSize: u = "md",
  aspectRatio: l = "16:9",
  setInterruptReplica: p,
  currentScript: h,
  setCurrentScript: d,
  interruptReplica: f,
  setIsSpeaking: g,
  setSpokenText: m,
  region: v,
  speechKey: y,
  personaName: S,
  config: C
}) => {
  const P = Ws();
  U(() => {
    (() => {
      document.querySelectorAll("[data-replit-metadata]").forEach((T) => {
        T.hasAttribute("data-replit-metadata") && T.removeAttribute("data-replit-metadata");
      });
    })();
  }, []), U(() => {
    if (e && P) {
      const { conversation_url: R } = e;
      P.join({
        url: R
      });
    }
  }, [P, e]);
  const b = async () => {
    await P?.leave(), t();
  }, A = {
    sm: "scale-75",
    md: "",
    lg: "scale-125"
  }, E = "bottom-4", D = () => c === "auto" ? "min-h-[360px]" : c;
  return /* @__PURE__ */ w("div", { className: `flex flex-col w-full h-full relative ${n}`, children: /* @__PURE__ */ k("div", { className: "flex-1 w-full h-full relative overflow-hidden", children: [
    /* @__PURE__ */ w(
      zb,
      {
        conversationId: e.conversation_id,
        platform: r,
        videoMode: o,
        endConv: i,
        onAction: b,
        videoHeight: D(),
        aspectRatio: l,
        setInterruptReplica: p,
        currentScript: h,
        interruptReplica: f,
        config: C,
        personaName: S
      }
    ),
    /* @__PURE__ */ w("div", { className: `absolute ${E} left-0 right-0 z-10 flex justify-center ${A[u]}`, children: /* @__PURE__ */ w(
      Mb,
      {
        actionLabel: "End Conversation",
        onAction: b,
        platform: r,
        chatLabel: "Open Chat",
        onChat: s,
        chatVisible: a,
        setInterruptReplica: p,
        setIsSpeaking: g,
        setSpokenText: m,
        region: v,
        speechKey: y
      }
    ) })
  ] }) });
}, jb = async ({
  replicaId: e,
  personaId: t,
  conversationName: r,
  conversationalContext: o,
  customGreeting: i,
  language: a,
  apiKey: s
}) => {
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": s
    },
    body: JSON.stringify({
      replica_id: e,
      persona_id: t,
      conversation_name: r,
      conversational_context: o,
      custom_greeting: i,
      properties: {
        enable_recording: !1,
        participant_absent_timeout: 180,
        language: a
      }
    })
  };
  try {
    const c = await fetch(
      "https://tavusapi.com/v2/conversations",
      n
    );
    if (!c.ok) {
      const l = c.headers.get("content-type");
      let p;
      throw l && l.includes("application/json") ? p = await c.json() : p = { message: await c.text() }, new Error(
        p?.message || `HTTP error! Status: ${c.status}`
      );
    }
    return await c.json();
  } catch (c) {
    throw console.error("Error creating Tavus conversation:", c), c;
  }
}, Kh = async ({
  conversationId: e,
  apiKey: t
}) => {
  const r = {
    method: "POST",
    headers: {
      "x-api-key": t
    }
  };
  try {
    await fetch(
      `https://tavusapi.com/v2/conversations/${e}/end`,
      r
    );
  } catch {
  }
}, ug = async () => {
  const e = new Headers();
  e.append("Accept", "application/json");
  const t = {
    method: "GET",
    headers: e,
    redirect: "follow"
  };
  let r;
  try {
    const o = await fetch(Sc("/api/Avatar/get/all"), t);
    if (!o.ok)
      throw new Error(`HTTP error! status: ${o.status}`);
    r = o.headers.get("content-length") === "0" ? { Success: !0, Data: [] } : await o.json();
  } catch (o) {
    console.error("Error fetching avatars:", o);
  }
  return r;
}, N = (e) => typeof e == "string", ls = () => {
  let e, t;
  const r = new Promise((o, i) => {
    e = o, t = i;
  });
  return r.resolve = e, r.reject = t, r;
}, Jh = (e) => e == null ? "" : "" + e, qb = (e, t, r) => {
  e.forEach((o) => {
    t[o] && (r[o] = t[o]);
  });
}, Fb = /###/g, Gh = (e) => e && e.indexOf("###") > -1 ? e.replace(Fb, ".") : e, Qh = (e) => !e || N(e), ds = (e, t, r) => {
  const o = N(t) ? t.split(".") : t;
  let i = 0;
  for (; i < o.length - 1; ) {
    if (Qh(e)) return {};
    const a = Gh(o[i]);
    !e[a] && r && (e[a] = new r()), Object.prototype.hasOwnProperty.call(e, a) ? e = e[a] : e = {}, ++i;
  }
  return Qh(e) ? {} : {
    obj: e,
    k: Gh(o[i])
  };
}, Yh = (e, t, r) => {
  const {
    obj: o,
    k: i
  } = ds(e, t, Object);
  if (o !== void 0 || t.length === 1) {
    o[i] = r;
    return;
  }
  let a = t[t.length - 1], s = t.slice(0, t.length - 1), n = ds(e, s, Object);
  for (; n.obj === void 0 && s.length; )
    a = `${s[s.length - 1]}.${a}`, s = s.slice(0, s.length - 1), n = ds(e, s, Object), n?.obj && typeof n.obj[`${n.k}.${a}`] < "u" && (n.obj = void 0);
  n.obj[`${n.k}.${a}`] = r;
}, Bb = (e, t, r, o) => {
  const {
    obj: i,
    k: a
  } = ds(e, t, Object);
  i[a] = i[a] || [], i[a].push(r);
}, Fs = (e, t) => {
  const {
    obj: r,
    k: o
  } = ds(e, t);
  if (r && Object.prototype.hasOwnProperty.call(r, o))
    return r[o];
}, Ub = (e, t, r) => {
  const o = Fs(e, r);
  return o !== void 0 ? o : Fs(t, r);
}, lg = (e, t, r) => {
  for (const o in t)
    o !== "__proto__" && o !== "constructor" && (o in e ? N(e[o]) || e[o] instanceof String || N(t[o]) || t[o] instanceof String ? r && (e[o] = t[o]) : lg(e[o], t[o], r) : e[o] = t[o]);
  return e;
}, Bt = (e) => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var $b = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const Vb = (e) => N(e) ? e.replace(/[&<>"'\/]/g, (t) => $b[t]) : e;
class Wb {
  constructor(t) {
    this.capacity = t, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(t) {
    const r = this.regExpMap.get(t);
    if (r !== void 0)
      return r;
    const o = new RegExp(t);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, o), this.regExpQueue.push(t), o;
  }
}
const Hb = [" ", ",", "?", "!", ";"], Kb = new Wb(20), Jb = (e, t, r) => {
  t = t || "", r = r || "";
  const o = Hb.filter((s) => t.indexOf(s) < 0 && r.indexOf(s) < 0);
  if (o.length === 0) return !0;
  const i = Kb.getRegExp(`(${o.map((s) => s === "?" ? "\\?" : s).join("|")})`);
  let a = !i.test(e);
  if (!a) {
    const s = e.indexOf(r);
    s > 0 && !i.test(e.substring(0, s)) && (a = !0);
  }
  return a;
}, ec = (e, t, r = ".") => {
  if (!e) return;
  if (e[t])
    return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0;
  const o = t.split(r);
  let i = e;
  for (let a = 0; a < o.length; ) {
    if (!i || typeof i != "object")
      return;
    let s, n = "";
    for (let c = a; c < o.length; ++c)
      if (c !== a && (n += r), n += o[c], s = i[n], s !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof s) > -1 && c < o.length - 1)
          continue;
        a += c - a + 1;
        break;
      }
    i = s;
  }
  return i;
}, vs = (e) => e?.replace("_", "-"), Gb = {
  type: "logger",
  log(e) {
    this.output("log", e);
  },
  warn(e) {
    this.output("warn", e);
  },
  error(e) {
    this.output("error", e);
  },
  output(e, t) {
    console?.[e]?.apply?.(console, t);
  }
};
class Bs {
  constructor(t, r = {}) {
    this.init(t, r);
  }
  init(t, r = {}) {
    this.prefix = r.prefix || "i18next:", this.logger = t || Gb, this.options = r, this.debug = r.debug;
  }
  log(...t) {
    return this.forward(t, "log", "", !0);
  }
  warn(...t) {
    return this.forward(t, "warn", "", !0);
  }
  error(...t) {
    return this.forward(t, "error", "");
  }
  deprecate(...t) {
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(t, r, o, i) {
    return i && !this.debug ? null : (N(t[0]) && (t[0] = `${o}${this.prefix} ${t[0]}`), this.logger[r](t));
  }
  create(t) {
    return new Bs(this.logger, {
      prefix: `${this.prefix}:${t}:`,
      ...this.options
    });
  }
  clone(t) {
    return t = t || this.options, t.prefix = t.prefix || this.prefix, new Bs(this.logger, t);
  }
}
var Me = new Bs();
class Xs {
  constructor() {
    this.observers = {};
  }
  on(t, r) {
    return t.split(" ").forEach((o) => {
      this.observers[o] || (this.observers[o] = /* @__PURE__ */ new Map());
      const i = this.observers[o].get(r) || 0;
      this.observers[o].set(r, i + 1);
    }), this;
  }
  off(t, r) {
    if (this.observers[t]) {
      if (!r) {
        delete this.observers[t];
        return;
      }
      this.observers[t].delete(r);
    }
  }
  emit(t, ...r) {
    this.observers[t] && Array.from(this.observers[t].entries()).forEach(([i, a]) => {
      for (let s = 0; s < a; s++)
        i(...r);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([i, a]) => {
      for (let s = 0; s < a; s++)
        i.apply(i, [t, ...r]);
    });
  }
}
class Zh extends Xs {
  constructor(t, r = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super(), this.data = t || {}, this.options = r, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(t) {
    this.options.ns.indexOf(t) < 0 && this.options.ns.push(t);
  }
  removeNamespaces(t) {
    const r = this.options.ns.indexOf(t);
    r > -1 && this.options.ns.splice(r, 1);
  }
  getResource(t, r, o, i = {}) {
    const a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, s = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let n;
    t.indexOf(".") > -1 ? n = t.split(".") : (n = [t, r], o && (Array.isArray(o) ? n.push(...o) : N(o) && a ? n.push(...o.split(a)) : n.push(o)));
    const c = Fs(this.data, n);
    return !c && !r && !o && t.indexOf(".") > -1 && (t = n[0], r = n[1], o = n.slice(2).join(".")), c || !s || !N(o) ? c : ec(this.data?.[t]?.[r], o, a);
  }
  addResource(t, r, o, i, a = {
    silent: !1
  }) {
    const s = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator;
    let n = [t, r];
    o && (n = n.concat(s ? o.split(s) : o)), t.indexOf(".") > -1 && (n = t.split("."), i = r, r = n[1]), this.addNamespaces(r), Yh(this.data, n, i), a.silent || this.emit("added", t, r, o, i);
  }
  addResources(t, r, o, i = {
    silent: !1
  }) {
    for (const a in o)
      (N(o[a]) || Array.isArray(o[a])) && this.addResource(t, r, a, o[a], {
        silent: !0
      });
    i.silent || this.emit("added", t, r, o);
  }
  addResourceBundle(t, r, o, i, a, s = {
    silent: !1,
    skipCopy: !1
  }) {
    let n = [t, r];
    t.indexOf(".") > -1 && (n = t.split("."), i = o, o = r, r = n[1]), this.addNamespaces(r);
    let c = Fs(this.data, n) || {};
    s.skipCopy || (o = JSON.parse(JSON.stringify(o))), i ? lg(c, o, a) : c = {
      ...c,
      ...o
    }, Yh(this.data, n, c), s.silent || this.emit("added", t, r, o);
  }
  removeResourceBundle(t, r) {
    this.hasResourceBundle(t, r) && delete this.data[t][r], this.removeNamespaces(r), this.emit("removed", t, r);
  }
  hasResourceBundle(t, r) {
    return this.getResource(t, r) !== void 0;
  }
  getResourceBundle(t, r) {
    return r || (r = this.options.defaultNS), this.getResource(t, r);
  }
  getDataByLanguage(t) {
    return this.data[t];
  }
  hasLanguageSomeTranslations(t) {
    const r = this.getDataByLanguage(t);
    return !!(r && Object.keys(r) || []).find((i) => r[i] && Object.keys(r[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var pg = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e;
  },
  handle(e, t, r, o, i) {
    return e.forEach((a) => {
      t = this.processors[a]?.process(t, r, o, i) ?? t;
    }), t;
  }
};
const dg = Symbol("i18next/PATH_KEY");
function Qb() {
  const e = [], t = /* @__PURE__ */ Object.create(null);
  let r;
  return t.get = (o, i) => (r?.revoke?.(), i === dg ? e : (e.push(i), r = Proxy.revocable(o, t), r.proxy)), Proxy.revocable(/* @__PURE__ */ Object.create(null), t).proxy;
}
function tc(e, t) {
  const {
    [dg]: r
  } = e(Qb());
  return r.join(t?.keySeparator ?? ".");
}
const Xh = {}, ef = (e) => !N(e) && typeof e != "boolean" && typeof e != "number";
class Us extends Xs {
  constructor(t, r = {}) {
    super(), qb(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = r, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Me.create("translator");
  }
  changeLanguage(t) {
    t && (this.language = t);
  }
  exists(t, r = {
    interpolation: {}
  }) {
    const o = {
      ...r
    };
    return t == null ? !1 : this.resolve(t, o)?.res !== void 0;
  }
  extractFromKey(t, r) {
    let o = r.nsSeparator !== void 0 ? r.nsSeparator : this.options.nsSeparator;
    o === void 0 && (o = ":");
    const i = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator;
    let a = r.ns || this.options.defaultNS || [];
    const s = o && t.indexOf(o) > -1, n = !this.options.userDefinedKeySeparator && !r.keySeparator && !this.options.userDefinedNsSeparator && !r.nsSeparator && !Jb(t, o, i);
    if (s && !n) {
      const c = t.match(this.interpolator.nestingRegexp);
      if (c && c.length > 0)
        return {
          key: t,
          namespaces: N(a) ? [a] : a
        };
      const u = t.split(o);
      (o !== i || o === i && this.options.ns.indexOf(u[0]) > -1) && (a = u.shift()), t = u.join(i);
    }
    return {
      key: t,
      namespaces: N(a) ? [a] : a
    };
  }
  translate(t, r, o) {
    let i = typeof r == "object" ? {
      ...r
    } : r;
    if (typeof i != "object" && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), typeof i == "object" && (i = {
      ...i
    }), i || (i = {}), t == null) return "";
    typeof t == "function" && (t = tc(t, {
      ...this.options,
      ...i
    })), Array.isArray(t) || (t = [String(t)]);
    const a = i.returnDetails !== void 0 ? i.returnDetails : this.options.returnDetails, s = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, {
      key: n,
      namespaces: c
    } = this.extractFromKey(t[t.length - 1], i), u = c[c.length - 1];
    let l = i.nsSeparator !== void 0 ? i.nsSeparator : this.options.nsSeparator;
    l === void 0 && (l = ":");
    const p = i.lng || this.language, h = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (p?.toLowerCase() === "cimode")
      return h ? a ? {
        res: `${u}${l}${n}`,
        usedKey: n,
        exactUsedKey: n,
        usedLng: p,
        usedNS: u,
        usedParams: this.getUsedParamsDetails(i)
      } : `${u}${l}${n}` : a ? {
        res: n,
        usedKey: n,
        exactUsedKey: n,
        usedLng: p,
        usedNS: u,
        usedParams: this.getUsedParamsDetails(i)
      } : n;
    const d = this.resolve(t, i);
    let f = d?.res;
    const g = d?.usedKey || n, m = d?.exactUsedKey || n, v = ["[object Number]", "[object Function]", "[object RegExp]"], y = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays, S = !this.i18nFormat || this.i18nFormat.handleAsObject, C = i.count !== void 0 && !N(i.count), P = Us.hasDefaultValue(i), b = C ? this.pluralResolver.getSuffix(p, i.count, i) : "", A = i.ordinal && C ? this.pluralResolver.getSuffix(p, i.count, {
      ordinal: !1
    }) : "", E = C && !i.ordinal && i.count === 0, D = E && i[`defaultValue${this.options.pluralSeparator}zero`] || i[`defaultValue${b}`] || i[`defaultValue${A}`] || i.defaultValue;
    let R = f;
    S && !f && P && (R = D);
    const j = ef(R), T = Object.prototype.toString.apply(R);
    if (S && R && j && v.indexOf(T) < 0 && !(N(y) && Array.isArray(R))) {
      if (!i.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const x = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(g, R, {
          ...i,
          ns: c
        }) : `key '${n} (${this.language})' returned an object instead of string.`;
        return a ? (d.res = x, d.usedParams = this.getUsedParamsDetails(i), d) : x;
      }
      if (s) {
        const x = Array.isArray(R), q = x ? [] : {}, pe = x ? m : g;
        for (const W in R)
          if (Object.prototype.hasOwnProperty.call(R, W)) {
            const G = `${pe}${s}${W}`;
            P && !f ? q[W] = this.translate(G, {
              ...i,
              defaultValue: ef(D) ? D[W] : void 0,
              joinArrays: !1,
              ns: c
            }) : q[W] = this.translate(G, {
              ...i,
              joinArrays: !1,
              ns: c
            }), q[W] === G && (q[W] = R[W]);
          }
        f = q;
      }
    } else if (S && N(y) && Array.isArray(f))
      f = f.join(y), f && (f = this.extendTranslation(f, t, i, o));
    else {
      let x = !1, q = !1;
      !this.isValidLookup(f) && P && (x = !0, f = D), this.isValidLookup(f) || (q = !0, f = n);
      const W = (i.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && q ? void 0 : f, G = P && D !== f && this.options.updateMissing;
      if (q || x || G) {
        if (this.logger.log(G ? "updateKey" : "missingKey", p, u, n, G ? D : f), s) {
          const V = this.resolve(n, {
            ...i,
            keySeparator: !1
          });
          V && V.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let ne = [];
        const oe = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && oe && oe[0])
          for (let V = 0; V < oe.length; V++)
            ne.push(oe[V]);
        else this.options.saveMissingTo === "all" ? ne = this.languageUtils.toResolveHierarchy(i.lng || this.language) : ne.push(i.lng || this.language);
        const ye = (V, te, Se) => {
          const Ce = P && Se !== f ? Se : W;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(V, u, te, Ce, G, i) : this.backendConnector?.saveMissing && this.backendConnector.saveMissing(V, u, te, Ce, G, i), this.emit("missingKey", V, u, te, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && C ? ne.forEach((V) => {
          const te = this.pluralResolver.getSuffixes(V, i);
          E && i[`defaultValue${this.options.pluralSeparator}zero`] && te.indexOf(`${this.options.pluralSeparator}zero`) < 0 && te.push(`${this.options.pluralSeparator}zero`), te.forEach((Se) => {
            ye([V], n + Se, i[`defaultValue${Se}`] || D);
          });
        }) : ye(ne, n, D));
      }
      f = this.extendTranslation(f, t, i, d, o), q && f === n && this.options.appendNamespaceToMissingKey && (f = `${u}${l}${n}`), (q || x) && this.options.parseMissingKeyHandler && (f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${u}${l}${n}` : n, x ? f : void 0, i));
    }
    return a ? (d.res = f, d.usedParams = this.getUsedParamsDetails(i), d) : f;
  }
  extendTranslation(t, r, o, i, a) {
    if (this.i18nFormat?.parse)
      t = this.i18nFormat.parse(t, {
        ...this.options.interpolation.defaultVariables,
        ...o
      }, o.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!o.skipInterpolation) {
      o.interpolation && this.interpolator.init({
        ...o,
        interpolation: {
          ...this.options.interpolation,
          ...o.interpolation
        }
      });
      const c = N(t) && (o?.interpolation?.skipOnVariables !== void 0 ? o.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let u;
      if (c) {
        const p = t.match(this.interpolator.nestingRegexp);
        u = p && p.length;
      }
      let l = o.replace && !N(o.replace) ? o.replace : o;
      if (this.options.interpolation.defaultVariables && (l = {
        ...this.options.interpolation.defaultVariables,
        ...l
      }), t = this.interpolator.interpolate(t, l, o.lng || this.language || i.usedLng, o), c) {
        const p = t.match(this.interpolator.nestingRegexp), h = p && p.length;
        u < h && (o.nest = !1);
      }
      !o.lng && i && i.res && (o.lng = this.language || i.usedLng), o.nest !== !1 && (t = this.interpolator.nest(t, (...p) => a?.[0] === p[0] && !o.context ? (this.logger.warn(`It seems you are nesting recursively key: ${p[0]} in key: ${r[0]}`), null) : this.translate(...p, r), o)), o.interpolation && this.interpolator.reset();
    }
    const s = o.postProcess || this.options.postProcess, n = N(s) ? [s] : s;
    return t != null && n?.length && o.applyPostProcessor !== !1 && (t = pg.handle(n, t, r, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(o)
      },
      ...o
    } : o, this)), t;
  }
  resolve(t, r = {}) {
    let o, i, a, s, n;
    return N(t) && (t = [t]), t.forEach((c) => {
      if (this.isValidLookup(o)) return;
      const u = this.extractFromKey(c, r), l = u.key;
      i = l;
      let p = u.namespaces;
      this.options.fallbackNS && (p = p.concat(this.options.fallbackNS));
      const h = r.count !== void 0 && !N(r.count), d = h && !r.ordinal && r.count === 0, f = r.context !== void 0 && (N(r.context) || typeof r.context == "number") && r.context !== "", g = r.lngs ? r.lngs : this.languageUtils.toResolveHierarchy(r.lng || this.language, r.fallbackLng);
      p.forEach((m) => {
        this.isValidLookup(o) || (n = m, !Xh[`${g[0]}-${m}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(n) && (Xh[`${g[0]}-${m}`] = !0, this.logger.warn(`key "${i}" for languages "${g.join(", ")}" won't get resolved as namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), g.forEach((v) => {
          if (this.isValidLookup(o)) return;
          s = v;
          const y = [l];
          if (this.i18nFormat?.addLookupKeys)
            this.i18nFormat.addLookupKeys(y, l, v, m, r);
          else {
            let C;
            h && (C = this.pluralResolver.getSuffix(v, r.count, r));
            const P = `${this.options.pluralSeparator}zero`, b = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (h && (r.ordinal && C.indexOf(b) === 0 && y.push(l + C.replace(b, this.options.pluralSeparator)), y.push(l + C), d && y.push(l + P)), f) {
              const A = `${l}${this.options.contextSeparator || "_"}${r.context}`;
              y.push(A), h && (r.ordinal && C.indexOf(b) === 0 && y.push(A + C.replace(b, this.options.pluralSeparator)), y.push(A + C), d && y.push(A + P));
            }
          }
          let S;
          for (; S = y.pop(); )
            this.isValidLookup(o) || (a = S, o = this.getResource(v, m, S, r));
        }));
      });
    }), {
      res: o,
      usedKey: i,
      exactUsedKey: a,
      usedLng: s,
      usedNS: n
    };
  }
  isValidLookup(t) {
    return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "");
  }
  getResource(t, r, o, i = {}) {
    return this.i18nFormat?.getResource ? this.i18nFormat.getResource(t, r, o, i) : this.resourceStore.getResource(t, r, o, i);
  }
  getUsedParamsDetails(t = {}) {
    const r = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], o = t.replace && !N(t.replace);
    let i = o ? t.replace : t;
    if (o && typeof t.count < "u" && (i.count = t.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !o) {
      i = {
        ...i
      };
      for (const a of r)
        delete i[a];
    }
    return i;
  }
  static hasDefaultValue(t) {
    const r = "defaultValue";
    for (const o in t)
      if (Object.prototype.hasOwnProperty.call(t, o) && r === o.substring(0, r.length) && t[o] !== void 0)
        return !0;
    return !1;
  }
}
class tf {
  constructor(t) {
    this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Me.create("languageUtils");
  }
  getScriptPartFromCode(t) {
    if (t = vs(t), !t || t.indexOf("-") < 0) return null;
    const r = t.split("-");
    return r.length === 2 || (r.pop(), r[r.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(r.join("-"));
  }
  getLanguagePartFromCode(t) {
    if (t = vs(t), !t || t.indexOf("-") < 0) return t;
    const r = t.split("-");
    return this.formatLanguageCode(r[0]);
  }
  formatLanguageCode(t) {
    if (N(t) && t.indexOf("-") > -1) {
      let r;
      try {
        r = Intl.getCanonicalLocales(t)[0];
      } catch {
      }
      return r && this.options.lowerCaseLng && (r = r.toLowerCase()), r || (this.options.lowerCaseLng ? t.toLowerCase() : t);
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
  }
  isSupportedCode(t) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1;
  }
  getBestMatchFromCodes(t) {
    if (!t) return null;
    let r;
    return t.forEach((o) => {
      if (r) return;
      const i = this.formatLanguageCode(o);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (r = i);
    }), !r && this.options.supportedLngs && t.forEach((o) => {
      if (r) return;
      const i = this.getScriptPartFromCode(o);
      if (this.isSupportedCode(i)) return r = i;
      const a = this.getLanguagePartFromCode(o);
      if (this.isSupportedCode(a)) return r = a;
      r = this.options.supportedLngs.find((s) => {
        if (s === a) return s;
        if (!(s.indexOf("-") < 0 && a.indexOf("-") < 0) && (s.indexOf("-") > 0 && a.indexOf("-") < 0 && s.substring(0, s.indexOf("-")) === a || s.indexOf(a) === 0 && a.length > 1))
          return s;
      });
    }), r || (r = this.getFallbackCodes(this.options.fallbackLng)[0]), r;
  }
  getFallbackCodes(t, r) {
    if (!t) return [];
    if (typeof t == "function" && (t = t(r)), N(t) && (t = [t]), Array.isArray(t)) return t;
    if (!r) return t.default || [];
    let o = t[r];
    return o || (o = t[this.getScriptPartFromCode(r)]), o || (o = t[this.formatLanguageCode(r)]), o || (o = t[this.getLanguagePartFromCode(r)]), o || (o = t.default), o || [];
  }
  toResolveHierarchy(t, r) {
    const o = this.getFallbackCodes((r === !1 ? [] : r) || this.options.fallbackLng || [], t), i = [], a = (s) => {
      s && (this.isSupportedCode(s) ? i.push(s) : this.logger.warn(`rejecting language code not found in supportedLngs: ${s}`));
    };
    return N(t) && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && a(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && a(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && a(this.getLanguagePartFromCode(t))) : N(t) && a(this.formatLanguageCode(t)), o.forEach((s) => {
      i.indexOf(s) < 0 && a(this.formatLanguageCode(s));
    }), i;
  }
}
const rf = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, nf = {
  select: (e) => e === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class Yb {
  constructor(t, r = {}) {
    this.languageUtils = t, this.options = r, this.logger = Me.create("pluralResolver"), this.pluralRulesCache = {};
  }
  addRule(t, r) {
    this.rules[t] = r;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(t, r = {}) {
    const o = vs(t === "dev" ? "en" : t), i = r.ordinal ? "ordinal" : "cardinal", a = JSON.stringify({
      cleanedCode: o,
      type: i
    });
    if (a in this.pluralRulesCache)
      return this.pluralRulesCache[a];
    let s;
    try {
      s = new Intl.PluralRules(o, {
        type: i
      });
    } catch {
      if (!Intl)
        return this.logger.error("No Intl support, please use an Intl polyfill!"), nf;
      if (!t.match(/-|_/)) return nf;
      const c = this.languageUtils.getLanguagePartFromCode(t);
      s = this.getRule(c, r);
    }
    return this.pluralRulesCache[a] = s, s;
  }
  needsPlural(t, r = {}) {
    let o = this.getRule(t, r);
    return o || (o = this.getRule("dev", r)), o?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(t, r, o = {}) {
    return this.getSuffixes(t, o).map((i) => `${r}${i}`);
  }
  getSuffixes(t, r = {}) {
    let o = this.getRule(t, r);
    return o || (o = this.getRule("dev", r)), o ? o.resolvedOptions().pluralCategories.sort((i, a) => rf[i] - rf[a]).map((i) => `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : [];
  }
  getSuffix(t, r, o = {}) {
    const i = this.getRule(t, o);
    return i ? `${this.options.prepend}${o.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(r)}` : (this.logger.warn(`no plural rule found for: ${t}`), this.getSuffix("dev", r, o));
  }
}
const sf = (e, t, r, o = ".", i = !0) => {
  let a = Ub(e, t, r);
  return !a && i && N(r) && (a = ec(e, r, o), a === void 0 && (a = ec(t, r, o))), a;
}, ja = (e) => e.replace(/\$/g, "$$$$");
class Zb {
  constructor(t = {}) {
    this.logger = Me.create("interpolator"), this.options = t, this.format = t?.interpolation?.format || ((r) => r), this.init(t);
  }
  init(t = {}) {
    t.interpolation || (t.interpolation = {
      escapeValue: !0
    });
    const {
      escape: r,
      escapeValue: o,
      useRawValueToEscape: i,
      prefix: a,
      prefixEscaped: s,
      suffix: n,
      suffixEscaped: c,
      formatSeparator: u,
      unescapeSuffix: l,
      unescapePrefix: p,
      nestingPrefix: h,
      nestingPrefixEscaped: d,
      nestingSuffix: f,
      nestingSuffixEscaped: g,
      nestingOptionsSeparator: m,
      maxReplaces: v,
      alwaysFormat: y
    } = t.interpolation;
    this.escape = r !== void 0 ? r : Vb, this.escapeValue = o !== void 0 ? o : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = a ? Bt(a) : s || "{{", this.suffix = n ? Bt(n) : c || "}}", this.formatSeparator = u || ",", this.unescapePrefix = l ? "" : p || "-", this.unescapeSuffix = this.unescapePrefix ? "" : l || "", this.nestingPrefix = h ? Bt(h) : d || Bt("$t("), this.nestingSuffix = f ? Bt(f) : g || Bt(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = v || 1e3, this.alwaysFormat = y !== void 0 ? y : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const t = (r, o) => r?.source === o ? (r.lastIndex = 0, r) : new RegExp(o, "g");
    this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
  }
  interpolate(t, r, o, i) {
    let a, s, n;
    const c = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, u = (d) => {
      if (d.indexOf(this.formatSeparator) < 0) {
        const v = sf(r, c, d, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(v, void 0, o, {
          ...i,
          ...r,
          interpolationkey: d
        }) : v;
      }
      const f = d.split(this.formatSeparator), g = f.shift().trim(), m = f.join(this.formatSeparator).trim();
      return this.format(sf(r, c, g, this.options.keySeparator, this.options.ignoreJSONStructure), m, o, {
        ...i,
        ...r,
        interpolationkey: g
      });
    };
    this.resetRegExp();
    const l = i?.missingInterpolationHandler || this.options.missingInterpolationHandler, p = i?.interpolation?.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (d) => ja(d)
    }, {
      regex: this.regexp,
      safeValue: (d) => this.escapeValue ? ja(this.escape(d)) : ja(d)
    }].forEach((d) => {
      for (n = 0; a = d.regex.exec(t); ) {
        const f = a[1].trim();
        if (s = u(f), s === void 0)
          if (typeof l == "function") {
            const m = l(t, a, i);
            s = N(m) ? m : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, f))
            s = "";
          else if (p) {
            s = a[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${f} for interpolating ${t}`), s = "";
        else !N(s) && !this.useRawValueToEscape && (s = Jh(s));
        const g = d.safeValue(s);
        if (t = t.replace(a[0], g), p ? (d.regex.lastIndex += s.length, d.regex.lastIndex -= a[0].length) : d.regex.lastIndex = 0, n++, n >= this.maxReplaces)
          break;
      }
    }), t;
  }
  nest(t, r, o = {}) {
    let i, a, s;
    const n = (c, u) => {
      const l = this.nestingOptionsSeparator;
      if (c.indexOf(l) < 0) return c;
      const p = c.split(new RegExp(`${l}[ ]*{`));
      let h = `{${p[1]}`;
      c = p[0], h = this.interpolate(h, s);
      const d = h.match(/'/g), f = h.match(/"/g);
      ((d?.length ?? 0) % 2 === 0 && !f || f.length % 2 !== 0) && (h = h.replace(/'/g, '"'));
      try {
        s = JSON.parse(h), u && (s = {
          ...u,
          ...s
        });
      } catch (g) {
        return this.logger.warn(`failed parsing options string in nesting for key ${c}`, g), `${c}${l}${h}`;
      }
      return s.defaultValue && s.defaultValue.indexOf(this.prefix) > -1 && delete s.defaultValue, c;
    };
    for (; i = this.nestingRegexp.exec(t); ) {
      let c = [];
      s = {
        ...o
      }, s = s.replace && !N(s.replace) ? s.replace : s, s.applyPostProcessor = !1, delete s.defaultValue;
      const u = /{.*}/.test(i[1]) ? i[1].lastIndexOf("}") + 1 : i[1].indexOf(this.formatSeparator);
      if (u !== -1 && (c = i[1].slice(u).split(this.formatSeparator).map((l) => l.trim()).filter(Boolean), i[1] = i[1].slice(0, u)), a = r(n.call(this, i[1].trim(), s), s), a && i[0] === t && !N(a)) return a;
      N(a) || (a = Jh(a)), a || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`), a = ""), c.length && (a = c.reduce((l, p) => this.format(l, p, o.lng, {
        ...o,
        interpolationkey: i[1].trim()
      }), a.trim())), t = t.replace(i[0], a), this.regexp.lastIndex = 0;
    }
    return t;
  }
}
const Xb = (e) => {
  let t = e.toLowerCase().trim();
  const r = {};
  if (e.indexOf("(") > -1) {
    const o = e.split("(");
    t = o[0].toLowerCase().trim();
    const i = o[1].substring(0, o[1].length - 1);
    t === "currency" && i.indexOf(":") < 0 ? r.currency || (r.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? r.range || (r.range = i.trim()) : i.split(";").forEach((s) => {
      if (s) {
        const [n, ...c] = s.split(":"), u = c.join(":").trim().replace(/^'+|'+$/g, ""), l = n.trim();
        r[l] || (r[l] = u), u === "false" && (r[l] = !1), u === "true" && (r[l] = !0), isNaN(u) || (r[l] = parseInt(u, 10));
      }
    });
  }
  return {
    formatName: t,
    formatOptions: r
  };
}, of = (e) => {
  const t = {};
  return (r, o, i) => {
    let a = i;
    i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (a = {
      ...a,
      [i.interpolationkey]: void 0
    });
    const s = o + JSON.stringify(a);
    let n = t[s];
    return n || (n = e(vs(o), i), t[s] = n), n(r);
  };
}, eE = (e) => (t, r, o) => e(vs(r), o)(t);
class tE {
  constructor(t = {}) {
    this.logger = Me.create("formatter"), this.options = t, this.init(t);
  }
  init(t, r = {
    interpolation: {}
  }) {
    this.formatSeparator = r.interpolation.formatSeparator || ",";
    const o = r.cacheInBuiltFormats ? of : eE;
    this.formats = {
      number: o((i, a) => {
        const s = new Intl.NumberFormat(i, {
          ...a
        });
        return (n) => s.format(n);
      }),
      currency: o((i, a) => {
        const s = new Intl.NumberFormat(i, {
          ...a,
          style: "currency"
        });
        return (n) => s.format(n);
      }),
      datetime: o((i, a) => {
        const s = new Intl.DateTimeFormat(i, {
          ...a
        });
        return (n) => s.format(n);
      }),
      relativetime: o((i, a) => {
        const s = new Intl.RelativeTimeFormat(i, {
          ...a
        });
        return (n) => s.format(n, a.range || "day");
      }),
      list: o((i, a) => {
        const s = new Intl.ListFormat(i, {
          ...a
        });
        return (n) => s.format(n);
      })
    };
  }
  add(t, r) {
    this.formats[t.toLowerCase().trim()] = r;
  }
  addCached(t, r) {
    this.formats[t.toLowerCase().trim()] = of(r);
  }
  format(t, r, o, i = {}) {
    const a = r.split(this.formatSeparator);
    if (a.length > 1 && a[0].indexOf("(") > 1 && a[0].indexOf(")") < 0 && a.find((n) => n.indexOf(")") > -1)) {
      const n = a.findIndex((c) => c.indexOf(")") > -1);
      a[0] = [a[0], ...a.splice(1, n)].join(this.formatSeparator);
    }
    return a.reduce((n, c) => {
      const {
        formatName: u,
        formatOptions: l
      } = Xb(c);
      if (this.formats[u]) {
        let p = n;
        try {
          const h = i?.formatParams?.[i.interpolationkey] || {}, d = h.locale || h.lng || i.locale || i.lng || o;
          p = this.formats[u](n, d, {
            ...l,
            ...i,
            ...h
          });
        } catch (h) {
          this.logger.warn(h);
        }
        return p;
      } else
        this.logger.warn(`there was no format function for ${u}`);
      return n;
    }, t);
  }
}
const rE = (e, t) => {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
};
class nE extends Xs {
  constructor(t, r, o, i = {}) {
    super(), this.backend = t, this.store = r, this.services = o, this.languageUtils = o.languageUtils, this.options = i, this.logger = Me.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend?.init?.(o, i.backend, i);
  }
  queueLoad(t, r, o, i) {
    const a = {}, s = {}, n = {}, c = {};
    return t.forEach((u) => {
      let l = !0;
      r.forEach((p) => {
        const h = `${u}|${p}`;
        !o.reload && this.store.hasResourceBundle(u, p) ? this.state[h] = 2 : this.state[h] < 0 || (this.state[h] === 1 ? s[h] === void 0 && (s[h] = !0) : (this.state[h] = 1, l = !1, s[h] === void 0 && (s[h] = !0), a[h] === void 0 && (a[h] = !0), c[p] === void 0 && (c[p] = !0)));
      }), l || (n[u] = !0);
    }), (Object.keys(a).length || Object.keys(s).length) && this.queue.push({
      pending: s,
      pendingCount: Object.keys(s).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(a),
      pending: Object.keys(s),
      toLoadLanguages: Object.keys(n),
      toLoadNamespaces: Object.keys(c)
    };
  }
  loaded(t, r, o) {
    const i = t.split("|"), a = i[0], s = i[1];
    r && this.emit("failedLoading", a, s, r), !r && o && this.store.addResourceBundle(a, s, o, void 0, void 0, {
      skipCopy: !0
    }), this.state[t] = r ? -1 : 2, r && o && (this.state[t] = 0);
    const n = {};
    this.queue.forEach((c) => {
      Bb(c.loaded, [a], s), rE(c, t), r && c.errors.push(r), c.pendingCount === 0 && !c.done && (Object.keys(c.loaded).forEach((u) => {
        n[u] || (n[u] = {});
        const l = c.loaded[u];
        l.length && l.forEach((p) => {
          n[u][p] === void 0 && (n[u][p] = !0);
        });
      }), c.done = !0, c.errors.length ? c.callback(c.errors) : c.callback());
    }), this.emit("loaded", n), this.queue = this.queue.filter((c) => !c.done);
  }
  read(t, r, o, i = 0, a = this.retryTimeout, s) {
    if (!t.length) return s(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: t,
        ns: r,
        fcName: o,
        tried: i,
        wait: a,
        callback: s
      });
      return;
    }
    this.readingCalls++;
    const n = (u, l) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const p = this.waitingReads.shift();
        this.read(p.lng, p.ns, p.fcName, p.tried, p.wait, p.callback);
      }
      if (u && l && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, t, r, o, i + 1, a * 2, s);
        }, a);
        return;
      }
      s(u, l);
    }, c = this.backend[o].bind(this.backend);
    if (c.length === 2) {
      try {
        const u = c(t, r);
        u && typeof u.then == "function" ? u.then((l) => n(null, l)).catch(n) : n(null, u);
      } catch (u) {
        n(u);
      }
      return;
    }
    return c(t, r, n);
  }
  prepareLoading(t, r, o = {}, i) {
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    N(t) && (t = this.languageUtils.toResolveHierarchy(t)), N(r) && (r = [r]);
    const a = this.queueLoad(t, r, o, i);
    if (!a.toLoad.length)
      return a.pending.length || i(), null;
    a.toLoad.forEach((s) => {
      this.loadOne(s);
    });
  }
  load(t, r, o) {
    this.prepareLoading(t, r, {}, o);
  }
  reload(t, r, o) {
    this.prepareLoading(t, r, {
      reload: !0
    }, o);
  }
  loadOne(t, r = "") {
    const o = t.split("|"), i = o[0], a = o[1];
    this.read(i, a, "read", void 0, void 0, (s, n) => {
      s && this.logger.warn(`${r}loading namespace ${a} for language ${i} failed`, s), !s && n && this.logger.log(`${r}loaded namespace ${a} for language ${i}`, n), this.loaded(t, s, n);
    });
  }
  saveMissing(t, r, o, i, a, s = {}, n = () => {
  }) {
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(r)) {
      this.logger.warn(`did not save key "${o}" as the namespace "${r}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(o == null || o === "")) {
      if (this.backend?.create) {
        const c = {
          ...s,
          isUpdate: a
        }, u = this.backend.create.bind(this.backend);
        if (u.length < 6)
          try {
            let l;
            u.length === 5 ? l = u(t, r, o, i, c) : l = u(t, r, o, i), l && typeof l.then == "function" ? l.then((p) => n(null, p)).catch(n) : n(null, l);
          } catch (l) {
            n(l);
          }
        else
          u(t, r, o, i, n, c);
      }
      !t || !t[0] || this.store.addResource(t[0], r, o, i);
    }
  }
}
const af = () => ({
  debug: !1,
  initAsync: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (e) => {
    let t = {};
    if (typeof e[1] == "object" && (t = e[1]), N(e[1]) && (t.defaultValue = e[1]), N(e[2]) && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
      const r = e[3] || e[2];
      Object.keys(r).forEach((o) => {
        t[o] = r[o];
      });
    }
    return t;
  },
  interpolation: {
    escapeValue: !0,
    format: (e) => e,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  },
  cacheInBuiltFormats: !0
}), cf = (e) => (N(e.ns) && (e.ns = [e.ns]), N(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), N(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs?.indexOf?.("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), typeof e.initImmediate == "boolean" && (e.initAsync = e.initImmediate), e), Ds = () => {
}, iE = (e) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((r) => {
    typeof e[r] == "function" && (e[r] = e[r].bind(e));
  });
};
class gs extends Xs {
  constructor(t = {}, r) {
    if (super(), this.options = cf(t), this.services = {}, this.logger = Me, this.modules = {
      external: []
    }, iE(this), r && !this.isInitialized && !t.isClone) {
      if (!this.options.initAsync)
        return this.init(t, r), this;
      setTimeout(() => {
        this.init(t, r);
      }, 0);
    }
  }
  init(t = {}, r) {
    this.isInitializing = !0, typeof t == "function" && (r = t, t = {}), t.defaultNS == null && t.ns && (N(t.ns) ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const o = af();
    this.options = {
      ...o,
      ...this.options,
      ...cf(t)
    }, this.options.interpolation = {
      ...o.interpolation,
      ...this.options.interpolation
    }, t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    const i = (u) => u ? typeof u == "function" ? new u() : u : null;
    if (!this.options.isClone) {
      this.modules.logger ? Me.init(i(this.modules.logger), this.options) : Me.init(null, this.options);
      let u;
      this.modules.formatter ? u = this.modules.formatter : u = tE;
      const l = new tf(this.options);
      this.store = new Zh(this.options.resources, this.options);
      const p = this.services;
      p.logger = Me, p.resourceStore = this.store, p.languageUtils = l, p.pluralResolver = new Yb(l, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), this.options.interpolation.format && this.options.interpolation.format !== o.interpolation.format && this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), u && (!this.options.interpolation.format || this.options.interpolation.format === o.interpolation.format) && (p.formatter = i(u), p.formatter.init && p.formatter.init(p, this.options), this.options.interpolation.format = p.formatter.format.bind(p.formatter)), p.interpolator = new Zb(this.options), p.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, p.backendConnector = new nE(i(this.modules.backend), p.resourceStore, p, this.options), p.backendConnector.on("*", (d, ...f) => {
        this.emit(d, ...f);
      }), this.modules.languageDetector && (p.languageDetector = i(this.modules.languageDetector), p.languageDetector.init && p.languageDetector.init(p, this.options.detection, this.options)), this.modules.i18nFormat && (p.i18nFormat = i(this.modules.i18nFormat), p.i18nFormat.init && p.i18nFormat.init(this)), this.translator = new Us(this.services, this.options), this.translator.on("*", (d, ...f) => {
        this.emit(d, ...f);
      }), this.modules.external.forEach((d) => {
        d.init && d.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, r || (r = Ds), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((u) => {
      this[u] = (...l) => this.store[u](...l);
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((u) => {
      this[u] = (...l) => (this.store[u](...l), this);
    });
    const n = ls(), c = () => {
      const u = (l, p) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), n.resolve(p), r(l, p);
      };
      if (this.languages && !this.isInitialized) return u(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, u);
    };
    return this.options.resources || !this.options.initAsync ? c() : setTimeout(c, 0), n;
  }
  loadResources(t, r = Ds) {
    let o = r;
    const i = N(t) ? t : this.language;
    if (typeof t == "function" && (o = t), !this.options.resources || this.options.partialBundledLanguages) {
      if (i?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return o();
      const a = [], s = (n) => {
        if (!n || n === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(n).forEach((u) => {
          u !== "cimode" && a.indexOf(u) < 0 && a.push(u);
        });
      };
      i ? s(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((c) => s(c)), this.options.preload?.forEach?.((n) => s(n)), this.services.backendConnector.load(a, this.options.ns, (n) => {
        !n && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), o(n);
      });
    } else
      o(null);
  }
  reloadResources(t, r, o) {
    const i = ls();
    return typeof t == "function" && (o = t, t = void 0), typeof r == "function" && (o = r, r = void 0), t || (t = this.languages), r || (r = this.options.ns), o || (o = Ds), this.services.backendConnector.reload(t, r, (a) => {
      i.resolve(), o(a);
    }), i;
  }
  use(t) {
    if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && pg.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this;
  }
  setResolvedLanguage(t) {
    if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1)) {
      for (let r = 0; r < this.languages.length; r++) {
        const o = this.languages[r];
        if (!(["cimode", "dev"].indexOf(o) > -1) && this.store.hasLanguageSomeTranslations(o)) {
          this.resolvedLanguage = o;
          break;
        }
      }
      !this.resolvedLanguage && this.languages.indexOf(t) < 0 && this.store.hasLanguageSomeTranslations(t) && (this.resolvedLanguage = t, this.languages.unshift(t));
    }
  }
  changeLanguage(t, r) {
    this.isLanguageChangingTo = t;
    const o = ls();
    this.emit("languageChanging", t);
    const i = (n) => {
      this.language = n, this.languages = this.services.languageUtils.toResolveHierarchy(n), this.resolvedLanguage = void 0, this.setResolvedLanguage(n);
    }, a = (n, c) => {
      c ? this.isLanguageChangingTo === t && (i(c), this.translator.changeLanguage(c), this.isLanguageChangingTo = void 0, this.emit("languageChanged", c), this.logger.log("languageChanged", c)) : this.isLanguageChangingTo = void 0, o.resolve((...u) => this.t(...u)), r && r(n, (...u) => this.t(...u));
    }, s = (n) => {
      !t && !n && this.services.languageDetector && (n = []);
      const c = N(n) ? n : n && n[0], u = this.store.hasLanguageSomeTranslations(c) ? c : this.services.languageUtils.getBestMatchFromCodes(N(n) ? [n] : n);
      u && (this.language || i(u), this.translator.language || this.translator.changeLanguage(u), this.services.languageDetector?.cacheUserLanguage?.(u)), this.loadResources(u, (l) => {
        a(l, u);
      });
    };
    return !t && this.services.languageDetector && !this.services.languageDetector.async ? s(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(s) : this.services.languageDetector.detect(s) : s(t), o;
  }
  getFixedT(t, r, o) {
    const i = (a, s, ...n) => {
      let c;
      typeof s != "object" ? c = this.options.overloadTranslationOptionHandler([a, s].concat(n)) : c = {
        ...s
      }, c.lng = c.lng || i.lng, c.lngs = c.lngs || i.lngs, c.ns = c.ns || i.ns, c.keyPrefix !== "" && (c.keyPrefix = c.keyPrefix || o || i.keyPrefix);
      const u = this.options.keySeparator || ".";
      let l;
      return c.keyPrefix && Array.isArray(a) ? l = a.map((p) => (typeof p == "function" && (p = tc(p, {
        ...this.options,
        ...s
      })), `${c.keyPrefix}${u}${p}`)) : (typeof a == "function" && (a = tc(a, {
        ...this.options,
        ...s
      })), l = c.keyPrefix ? `${c.keyPrefix}${u}${a}` : a), this.t(l, c);
    };
    return N(t) ? i.lng = t : i.lngs = t, i.ns = r, i.keyPrefix = o, i;
  }
  t(...t) {
    return this.translator?.translate(...t);
  }
  exists(...t) {
    return this.translator?.exists(...t);
  }
  setDefaultNamespace(t) {
    this.options.defaultNS = t;
  }
  hasLoadedNamespace(t, r = {}) {
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const o = r.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, a = this.languages[this.languages.length - 1];
    if (o.toLowerCase() === "cimode") return !0;
    const s = (n, c) => {
      const u = this.services.backendConnector.state[`${n}|${c}`];
      return u === -1 || u === 0 || u === 2;
    };
    if (r.precheck) {
      const n = r.precheck(this, s);
      if (n !== void 0) return n;
    }
    return !!(this.hasResourceBundle(o, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || s(o, t) && (!i || s(a, t)));
  }
  loadNamespaces(t, r) {
    const o = ls();
    return this.options.ns ? (N(t) && (t = [t]), t.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      o.resolve(), r && r(i);
    }), o) : (r && r(), Promise.resolve());
  }
  loadLanguages(t, r) {
    const o = ls();
    N(t) && (t = [t]);
    const i = this.options.preload || [], a = t.filter((s) => i.indexOf(s) < 0 && this.services.languageUtils.isSupportedCode(s));
    return a.length ? (this.options.preload = i.concat(a), this.loadResources((s) => {
      o.resolve(), r && r(s);
    }), o) : (r && r(), Promise.resolve());
  }
  dir(t) {
    if (t || (t = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language)), !t) return "rtl";
    try {
      const i = new Intl.Locale(t);
      if (i && i.getTextInfo) {
        const a = i.getTextInfo();
        if (a && a.direction) return a.direction;
      }
    } catch {
    }
    const r = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], o = this.services?.languageUtils || new tf(af());
    return t.toLowerCase().indexOf("-latn") > 1 ? "ltr" : r.indexOf(o.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(t = {}, r) {
    return new gs(t, r);
  }
  cloneInstance(t = {}, r = Ds) {
    const o = t.forkResourceStore;
    o && delete t.forkResourceStore;
    const i = {
      ...this.options,
      ...t,
      isClone: !0
    }, a = new gs(i);
    if ((t.debug !== void 0 || t.prefix !== void 0) && (a.logger = a.logger.clone(t)), ["store", "services", "language"].forEach((n) => {
      a[n] = this[n];
    }), a.services = {
      ...this.services
    }, a.services.utils = {
      hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
    }, o) {
      const n = Object.keys(this.store.data).reduce((c, u) => (c[u] = {
        ...this.store.data[u]
      }, c[u] = Object.keys(c[u]).reduce((l, p) => (l[p] = {
        ...c[u][p]
      }, l), c[u]), c), {});
      a.store = new Zh(n, i), a.services.resourceStore = a.store;
    }
    return a.translator = new Us(a.services, i), a.translator.on("*", (n, ...c) => {
      a.emit(n, ...c);
    }), a.init(i, r), a.translator.options = i, a.translator.backendConnector.services.utils = {
      hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
    }, a;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const se = gs.createInstance();
se.createInstance = gs.createInstance;
se.createInstance;
se.dir;
se.init;
se.loadResources;
se.reloadResources;
se.use;
se.changeLanguage;
se.getFixedT;
se.t;
se.exists;
se.setDefaultNamespace;
se.hasLoadedNamespace;
se.loadNamespaces;
se.loadLanguages;
var eo = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    return this.listeners.add(e), this.onSubscribe(), () => {
      this.listeners.delete(e), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, to = typeof window > "u" || "Deno" in globalThis;
function _e() {
}
function sE(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function oE(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function aE(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function rc(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function cE(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function uf(e, t) {
  const {
    type: r = "all",
    exact: o,
    fetchStatus: i,
    predicate: a,
    queryKey: s,
    stale: n
  } = e;
  if (s) {
    if (o) {
      if (t.queryHash !== Cc(s, t.options))
        return !1;
    } else if (!ys(t.queryKey, s))
      return !1;
  }
  if (r !== "all") {
    const c = t.isActive();
    if (r === "active" && !c || r === "inactive" && c)
      return !1;
  }
  return !(typeof n == "boolean" && t.isStale() !== n || i && i !== t.state.fetchStatus || a && !a(t));
}
function lf(e, t) {
  const { exact: r, status: o, predicate: i, mutationKey: a } = e;
  if (a) {
    if (!t.options.mutationKey)
      return !1;
    if (r) {
      if (ms(t.options.mutationKey) !== ms(a))
        return !1;
    } else if (!ys(t.options.mutationKey, a))
      return !1;
  }
  return !(o && t.state.status !== o || i && !i(t));
}
function Cc(e, t) {
  return (t?.queryKeyHashFn || ms)(e);
}
function ms(e) {
  return JSON.stringify(
    e,
    (t, r) => ic(r) ? Object.keys(r).sort().reduce((o, i) => (o[i] = r[i], o), {}) : r
  );
}
function ys(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every((r) => ys(e[r], t[r])) : !1;
}
function nc(e, t) {
  if (e === t)
    return e;
  const r = pf(e) && pf(t);
  if (r || ic(e) && ic(t)) {
    const o = r ? e : Object.keys(e), i = o.length, a = r ? t : Object.keys(t), s = a.length, n = r ? [] : {}, c = new Set(o);
    let u = 0;
    for (let l = 0; l < s; l++) {
      const p = r ? l : a[l];
      (!r && c.has(p) || r) && e[p] === void 0 && t[p] === void 0 ? (n[p] = void 0, u++) : (n[p] = nc(e[p], t[p]), n[p] === e[p] && e[p] !== void 0 && u++);
    }
    return i === s && u === i ? e : n;
  }
  return t;
}
function pf(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function ic(e) {
  if (!df(e))
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const r = t.prototype;
  return !(!df(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function df(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function uE(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function lE(e, t, r) {
  if (typeof r.structuralSharing == "function")
    return r.structuralSharing(e, t);
  if (r.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return nc(e, t);
      } catch (o) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${o}`
        ), o;
      }
    return nc(e, t);
  }
  return t;
}
function pE(e, t, r = 0) {
  const o = [...e, t];
  return r && o.length > r ? o.slice(1) : o;
}
function dE(e, t, r = 0) {
  const o = [t, ...e];
  return r && o.length > r ? o.slice(0, -1) : o;
}
var $s = Symbol();
function hg(e, t) {
  return process.env.NODE_ENV !== "production" && e.queryFn === $s && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${e.queryHash}'`
  ), !e.queryFn && t?.initialPromise ? () => t.initialPromise : !e.queryFn || e.queryFn === $s ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
var hE = class extends eo {
  #e;
  #t;
  #r;
  constructor() {
    super(), this.#r = (e) => {
      if (!to && window.addEventListener) {
        const t = () => e();
        return window.addEventListener("visibilitychange", t, !1), () => {
          window.removeEventListener("visibilitychange", t);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#r);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(e) {
    this.#r = e, this.#t?.(), this.#t = e((t) => {
      typeof t == "boolean" ? this.setFocused(t) : this.onFocus();
    });
  }
  setFocused(e) {
    this.#e !== e && (this.#e = e, this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  isFocused() {
    return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden";
  }
}, fg = new hE(), fE = class extends eo {
  #e = !0;
  #t;
  #r;
  constructor() {
    super(), this.#r = (e) => {
      if (!to && window.addEventListener) {
        const t = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", t, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", t), window.removeEventListener("offline", r);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#r);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(e) {
    this.#r = e, this.#t?.(), this.#t = e(this.setOnline.bind(this));
  }
  setOnline(e) {
    this.#e !== e && (this.#e = e, this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return this.#e;
  }
}, Vs = new fE();
function vE() {
  let e, t;
  const r = new Promise((i, a) => {
    e = i, t = a;
  });
  r.status = "pending", r.catch(() => {
  });
  function o(i) {
    Object.assign(r, i), delete r.resolve, delete r.reject;
  }
  return r.resolve = (i) => {
    o({
      status: "fulfilled",
      value: i
    }), e(i);
  }, r.reject = (i) => {
    o({
      status: "rejected",
      reason: i
    }), t(i);
  }, r;
}
function gE(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function vg(e) {
  return (e ?? "online") === "online" ? Vs.isOnline() : !0;
}
var gg = class extends Error {
  constructor(e) {
    super("CancelledError"), this.revert = e?.revert, this.silent = e?.silent;
  }
};
function qa(e) {
  return e instanceof gg;
}
function mg(e) {
  let t = !1, r = 0, o = !1, i;
  const a = vE(), s = (g) => {
    o || (h(new gg(g)), e.abort?.());
  }, n = () => {
    t = !0;
  }, c = () => {
    t = !1;
  }, u = () => fg.isFocused() && (e.networkMode === "always" || Vs.isOnline()) && e.canRun(), l = () => vg(e.networkMode) && e.canRun(), p = (g) => {
    o || (o = !0, e.onSuccess?.(g), i?.(), a.resolve(g));
  }, h = (g) => {
    o || (o = !0, e.onError?.(g), i?.(), a.reject(g));
  }, d = () => new Promise((g) => {
    i = (m) => {
      (o || u()) && g(m);
    }, e.onPause?.();
  }).then(() => {
    i = void 0, o || e.onContinue?.();
  }), f = () => {
    if (o)
      return;
    let g;
    const m = r === 0 ? e.initialPromise : void 0;
    try {
      g = m ?? e.fn();
    } catch (v) {
      g = Promise.reject(v);
    }
    Promise.resolve(g).then(p).catch((v) => {
      if (o)
        return;
      const y = e.retry ?? (to ? 0 : 3), S = e.retryDelay ?? gE, C = typeof S == "function" ? S(r, v) : S, P = y === !0 || typeof y == "number" && r < y || typeof y == "function" && y(r, v);
      if (t || !P) {
        h(v);
        return;
      }
      r++, e.onFail?.(r, v), uE(C).then(() => u() ? void 0 : d()).then(() => {
        t ? h(v) : f();
      });
    });
  };
  return {
    promise: a,
    cancel: s,
    continue: () => (i?.(), a),
    cancelRetry: n,
    continueRetry: c,
    canStart: l,
    start: () => (l() ? f() : d().then(f), a)
  };
}
var mE = (e) => setTimeout(e, 0);
function yE() {
  let e = [], t = 0, r = (n) => {
    n();
  }, o = (n) => {
    n();
  }, i = mE;
  const a = (n) => {
    t ? e.push(n) : i(() => {
      r(n);
    });
  }, s = () => {
    const n = e;
    e = [], n.length && i(() => {
      o(() => {
        n.forEach((c) => {
          r(c);
        });
      });
    });
  };
  return {
    batch: (n) => {
      let c;
      t++;
      try {
        c = n();
      } finally {
        t--, t || s();
      }
      return c;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (n) => (...c) => {
      a(() => {
        n(...c);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (n) => {
      r = n;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (n) => {
      o = n;
    },
    setScheduler: (n) => {
      i = n;
    }
  };
}
var ue = yE(), yg = class {
  #e;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), oE(this.gcTime) && (this.#e = setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(e) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      e ?? (to ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    this.#e && (clearTimeout(this.#e), this.#e = void 0);
  }
}, SE = class extends yg {
  #e;
  #t;
  #r;
  #i;
  #n;
  #o;
  #a;
  constructor(e) {
    super(), this.#a = !1, this.#o = e.defaultOptions, this.setOptions(e.options), this.observers = [], this.#i = e.client, this.#r = this.#i.getQueryCache(), this.queryKey = e.queryKey, this.queryHash = e.queryHash, this.#e = RE(this.options), this.state = e.state ?? this.#e, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#n?.promise;
  }
  setOptions(e) {
    this.options = { ...this.#o, ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.#r.remove(this);
  }
  setData(e, t) {
    const r = lE(this.state.data, e, this.options);
    return this.#s({
      data: r,
      type: "success",
      dataUpdatedAt: t?.updatedAt,
      manual: t?.manual
    }), r;
  }
  setState(e, t) {
    this.#s({ type: "setState", state: e, setStateOptions: t });
  }
  cancel(e) {
    const t = this.#n?.promise;
    return this.#n?.cancel(e), t ? t.then(_e).catch(_e) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(this.#e);
  }
  isActive() {
    return this.observers.some(
      (e) => cE(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === $s || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => rc(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !aE(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#n?.continue();
  }
  onOnline() {
    this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#n?.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), this.#r.notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((t) => t !== e), this.observers.length || (this.#n && (this.#a ? this.#n.cancel({ revert: !0 }) : this.#n.cancelRetry()), this.scheduleGc()), this.#r.notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.#s({ type: "invalidate" });
  }
  fetch(e, t) {
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && t?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (this.#n)
        return this.#n.continueRetry(), this.#n.promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const c = this.observers.find((u) => u.options.queryFn);
      c && this.setOptions(c.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), o = (c) => {
      Object.defineProperty(c, "signal", {
        enumerable: !0,
        get: () => (this.#a = !0, r.signal)
      });
    }, i = () => {
      const c = hg(this.options, t), l = (() => {
        const p = {
          client: this.#i,
          queryKey: this.queryKey,
          meta: this.meta
        };
        return o(p), p;
      })();
      return this.#a = !1, this.options.persister ? this.options.persister(
        c,
        l,
        this
      ) : c(l);
    }, s = (() => {
      const c = {
        fetchOptions: t,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#i,
        state: this.state,
        fetchFn: i
      };
      return o(c), c;
    })();
    this.options.behavior?.onFetch(s, this), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== s.fetchOptions?.meta) && this.#s({ type: "fetch", meta: s.fetchOptions?.meta });
    const n = (c) => {
      qa(c) && c.silent || this.#s({
        type: "error",
        error: c
      }), qa(c) || (this.#r.config.onError?.(
        c,
        this
      ), this.#r.config.onSettled?.(
        this.state.data,
        c,
        this
      )), this.scheduleGc();
    };
    return this.#n = mg({
      initialPromise: t?.initialPromise,
      fn: s.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (c) => {
        if (c === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), n(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(c);
        } catch (u) {
          n(u);
          return;
        }
        this.#r.config.onSuccess?.(c, this), this.#r.config.onSettled?.(
          c,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: n,
      onFail: (c, u) => {
        this.#s({ type: "failed", failureCount: c, error: u });
      },
      onPause: () => {
        this.#s({ type: "pause" });
      },
      onContinue: () => {
        this.#s({ type: "continue" });
      },
      retry: s.options.retry,
      retryDelay: s.options.retryDelay,
      networkMode: s.options.networkMode,
      canRun: () => !0
    }), this.#n.start();
  }
  #s(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return {
            ...r,
            fetchFailureCount: e.failureCount,
            fetchFailureReason: e.error
          };
        case "pause":
          return {
            ...r,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...r,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...r,
            ...CE(r.data, this.options),
            fetchMeta: e.meta ?? null
          };
        case "success":
          return this.#t = void 0, {
            ...r,
            data: e.data,
            dataUpdateCount: r.dataUpdateCount + 1,
            dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!e.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const o = e.error;
          return qa(o) && o.revert && this.#t ? { ...this.#t, fetchStatus: "idle" } : {
            ...r,
            error: o,
            errorUpdateCount: r.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: r.fetchFailureCount + 1,
            fetchFailureReason: o,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...r,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...r,
            ...e.state
          };
      }
    };
    this.state = t(this.state), ue.batch(() => {
      this.observers.forEach((r) => {
        r.onQueryUpdate();
      }), this.#r.notify({ query: this, type: "updated", action: e });
    });
  }
};
function CE(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: vg(t.networkMode) ? "fetching" : "paused",
    ...e === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function RE(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, r = t !== void 0, o = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? o ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var PE = class extends eo {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Map();
  }
  #e;
  build(e, t, r) {
    const o = t.queryKey, i = t.queryHash ?? Cc(o, t);
    let a = this.get(i);
    return a || (a = new SE({
      client: e,
      queryKey: o,
      queryHash: i,
      options: e.defaultQueryOptions(t),
      state: r,
      defaultOptions: e.getQueryDefaults(o)
    }), this.add(a)), a;
  }
  add(e) {
    this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const t = this.#e.get(e.queryHash);
    t && (e.destroy(), t === e && this.#e.delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    ue.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.#e.get(e);
  }
  getAll() {
    return [...this.#e.values()];
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (r) => uf(t, r)
    );
  }
  findAll(e = {}) {
    const t = this.getAll();
    return Object.keys(e).length > 0 ? t.filter((r) => uf(e, r)) : t;
  }
  notify(e) {
    ue.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  onFocus() {
    ue.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    ue.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, wE = class extends yg {
  #e;
  #t;
  #r;
  constructor(e) {
    super(), this.mutationId = e.mutationId, this.#t = e.mutationCache, this.#e = [], this.state = e.state || bE(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    this.#e.includes(e) || (this.#e.push(e), this.clearGcTimeout(), this.#t.notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    this.#e = this.#e.filter((t) => t !== e), this.scheduleGc(), this.#t.notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    this.#e.length || (this.state.status === "pending" ? this.scheduleGc() : this.#t.remove(this));
  }
  continue() {
    return this.#r?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    const t = () => {
      this.#i({ type: "continue" });
    };
    this.#r = mg({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (i, a) => {
        this.#i({ type: "failed", failureCount: i, error: a });
      },
      onPause: () => {
        this.#i({ type: "pause" });
      },
      onContinue: t,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#t.canRun(this)
    });
    const r = this.state.status === "pending", o = !this.#r.canStart();
    try {
      if (r)
        t();
      else {
        this.#i({ type: "pending", variables: e, isPaused: o }), await this.#t.config.onMutate?.(
          e,
          this
        );
        const a = await this.options.onMutate?.(e);
        a !== this.state.context && this.#i({
          type: "pending",
          context: a,
          variables: e,
          isPaused: o
        });
      }
      const i = await this.#r.start();
      return await this.#t.config.onSuccess?.(
        i,
        e,
        this.state.context,
        this
      ), await this.options.onSuccess?.(i, e, this.state.context), await this.#t.config.onSettled?.(
        i,
        null,
        this.state.variables,
        this.state.context,
        this
      ), await this.options.onSettled?.(i, null, e, this.state.context), this.#i({ type: "success", data: i }), i;
    } catch (i) {
      try {
        throw await this.#t.config.onError?.(
          i,
          e,
          this.state.context,
          this
        ), await this.options.onError?.(
          i,
          e,
          this.state.context
        ), await this.#t.config.onSettled?.(
          void 0,
          i,
          this.state.variables,
          this.state.context,
          this
        ), await this.options.onSettled?.(
          void 0,
          i,
          e,
          this.state.context
        ), i;
      } finally {
        this.#i({ type: "error", error: i });
      }
    } finally {
      this.#t.runNext(this);
    }
  }
  #i(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return {
            ...r,
            failureCount: e.failureCount,
            failureReason: e.error
          };
        case "pause":
          return {
            ...r,
            isPaused: !0
          };
        case "continue":
          return {
            ...r,
            isPaused: !1
          };
        case "pending":
          return {
            ...r,
            context: e.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: e.isPaused,
            status: "pending",
            variables: e.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...r,
            data: e.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...r,
            data: void 0,
            error: e.error,
            failureCount: r.failureCount + 1,
            failureReason: e.error,
            isPaused: !1,
            status: "error"
          };
      }
    };
    this.state = t(this.state), ue.batch(() => {
      this.#e.forEach((r) => {
        r.onMutationUpdate(e);
      }), this.#t.notify({
        mutation: this,
        type: "updated",
        action: e
      });
    });
  }
};
function bE() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var EE = class extends eo {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Set(), this.#t = /* @__PURE__ */ new Map(), this.#r = 0;
  }
  #e;
  #t;
  #r;
  build(e, t, r) {
    const o = new wE({
      mutationCache: this,
      mutationId: ++this.#r,
      options: e.defaultMutationOptions(t),
      state: r
    });
    return this.add(o), o;
  }
  add(e) {
    this.#e.add(e);
    const t = xs(e);
    if (typeof t == "string") {
      const r = this.#t.get(t);
      r ? r.push(e) : this.#t.set(t, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (this.#e.delete(e)) {
      const t = xs(e);
      if (typeof t == "string") {
        const r = this.#t.get(t);
        if (r)
          if (r.length > 1) {
            const o = r.indexOf(e);
            o !== -1 && r.splice(o, 1);
          } else r[0] === e && this.#t.delete(t);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const t = xs(e);
    if (typeof t == "string") {
      const o = this.#t.get(t)?.find(
        (i) => i.state.status === "pending"
      );
      return !o || o === e;
    } else
      return !0;
  }
  runNext(e) {
    const t = xs(e);
    return typeof t == "string" ? this.#t.get(t)?.find((o) => o !== e && o.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    ue.batch(() => {
      this.#e.forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), this.#e.clear(), this.#t.clear();
    });
  }
  getAll() {
    return Array.from(this.#e);
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (r) => lf(t, r)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((t) => lf(e, t));
  }
  notify(e) {
    ue.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((t) => t.state.isPaused);
    return ue.batch(
      () => Promise.all(
        e.map((t) => t.continue().catch(_e))
      )
    );
  }
};
function xs(e) {
  return e.options.scope?.id;
}
function hf(e) {
  return {
    onFetch: (t, r) => {
      const o = t.options, i = t.fetchOptions?.meta?.fetchMore?.direction, a = t.state.data?.pages || [], s = t.state.data?.pageParams || [];
      let n = { pages: [], pageParams: [] }, c = 0;
      const u = async () => {
        let l = !1;
        const p = (f) => {
          Object.defineProperty(f, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? l = !0 : t.signal.addEventListener("abort", () => {
              l = !0;
            }), t.signal)
          });
        }, h = hg(t.options, t.fetchOptions), d = async (f, g, m) => {
          if (l)
            return Promise.reject();
          if (g == null && f.pages.length)
            return Promise.resolve(f);
          const y = (() => {
            const b = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: g,
              direction: m ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(b), b;
          })(), S = await h(y), { maxPages: C } = t.options, P = m ? dE : pE;
          return {
            pages: P(f.pages, S, C),
            pageParams: P(f.pageParams, g, C)
          };
        };
        if (i && a.length) {
          const f = i === "backward", g = f ? IE : ff, m = {
            pages: a,
            pageParams: s
          }, v = g(o, m);
          n = await d(m, v, f);
        } else {
          const f = e ?? a.length;
          do {
            const g = c === 0 ? s[0] ?? o.initialPageParam : ff(o, n);
            if (c > 0 && g == null)
              break;
            n = await d(n, g), c++;
          } while (c < f);
        }
        return n;
      };
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        u,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        r
      ) : t.fetchFn = u;
    }
  };
}
function ff(e, { pages: t, pageParams: r }) {
  const o = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[o],
    t,
    r[o],
    r
  ) : void 0;
}
function IE(e, { pages: t, pageParams: r }) {
  return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, r[0], r) : void 0;
}
var AE = class {
  #e;
  #t;
  #r;
  #i;
  #n;
  #o;
  #a;
  #s;
  constructor(e = {}) {
    this.#e = e.queryCache || new PE(), this.#t = e.mutationCache || new EE(), this.#r = e.defaultOptions || {}, this.#i = /* @__PURE__ */ new Map(), this.#n = /* @__PURE__ */ new Map(), this.#o = 0;
  }
  mount() {
    this.#o++, this.#o === 1 && (this.#a = fg.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onFocus());
    }), this.#s = Vs.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onOnline());
    }));
  }
  unmount() {
    this.#o--, this.#o === 0 && (this.#a?.(), this.#a = void 0, this.#s?.(), this.#s = void 0);
  }
  isFetching(e) {
    return this.#e.findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return this.#t.findAll({ ...e, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(t.queryHash)?.state.data;
  }
  ensureQueryData(e) {
    const t = this.defaultQueryOptions(e), r = this.#e.build(this, t), o = r.state.data;
    return o === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && r.isStaleByTime(rc(t.staleTime, r)) && this.prefetchQuery(t), Promise.resolve(o));
  }
  getQueriesData(e) {
    return this.#e.findAll(e).map(({ queryKey: t, state: r }) => {
      const o = r.data;
      return [t, o];
    });
  }
  setQueryData(e, t, r) {
    const o = this.defaultQueryOptions({ queryKey: e }), a = this.#e.get(
      o.queryHash
    )?.state.data, s = sE(t, a);
    if (s !== void 0)
      return this.#e.build(this, o).setData(s, { ...r, manual: !0 });
  }
  setQueriesData(e, t, r) {
    return ue.batch(
      () => this.#e.findAll(e).map(({ queryKey: o }) => [
        o,
        this.setQueryData(o, t, r)
      ])
    );
  }
  getQueryState(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(
      t.queryHash
    )?.state;
  }
  removeQueries(e) {
    const t = this.#e;
    ue.batch(() => {
      t.findAll(e).forEach((r) => {
        t.remove(r);
      });
    });
  }
  resetQueries(e, t) {
    const r = this.#e;
    return ue.batch(() => (r.findAll(e).forEach((o) => {
      o.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...e
      },
      t
    )));
  }
  cancelQueries(e, t = {}) {
    const r = { revert: !0, ...t }, o = ue.batch(
      () => this.#e.findAll(e).map((i) => i.cancel(r))
    );
    return Promise.all(o).then(_e).catch(_e);
  }
  invalidateQueries(e, t = {}) {
    return ue.batch(() => (this.#e.findAll(e).forEach((r) => {
      r.invalidate();
    }), e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...e,
        type: e?.refetchType ?? e?.type ?? "active"
      },
      t
    )));
  }
  refetchQueries(e, t = {}) {
    const r = {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }, o = ue.batch(
      () => this.#e.findAll(e).filter((i) => !i.isDisabled() && !i.isStatic()).map((i) => {
        let a = i.fetch(void 0, r);
        return r.throwOnError || (a = a.catch(_e)), i.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(o).then(_e);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const r = this.#e.build(this, t);
    return r.isStaleByTime(
      rc(t.staleTime, r)
    ) ? r.fetch(t) : Promise.resolve(r.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(_e).catch(_e);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = hf(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(_e).catch(_e);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = hf(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return Vs.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return this.#e;
  }
  getMutationCache() {
    return this.#t;
  }
  getDefaultOptions() {
    return this.#r;
  }
  setDefaultOptions(e) {
    this.#r = e;
  }
  setQueryDefaults(e, t) {
    this.#i.set(ms(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...this.#i.values()], r = {};
    return t.forEach((o) => {
      ys(e, o.queryKey) && Object.assign(r, o.defaultOptions);
    }), r;
  }
  setMutationDefaults(e, t) {
    this.#n.set(ms(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...this.#n.values()], r = {};
    return t.forEach((o) => {
      ys(e, o.mutationKey) && Object.assign(r, o.defaultOptions);
    }), r;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...this.#r.queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = Cc(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === $s && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e?._defaulted ? e : {
      ...this.#r.mutations,
      ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    this.#e.clear(), this.#t.clear();
  }
};
async function TE(e) {
  if (!e.ok) {
    const t = await e.text() || e.statusText;
    throw new Error(`${e.status}: ${t}`);
  }
}
function _E() {
  return "https://developmentapis.azure-api.net/sandbox/v1/";
}
const kE = ({ on401: e }) => async ({ queryKey: t }) => {
  const r = t[0], o = r.startsWith("http") ? r : `${_E()}${r}`, i = await fetch(o, {
    credentials: "include"
  });
  return await TE(i), await i.json();
};
new AE({
  defaultOptions: {
    queries: {
      queryFn: kE({ on401: "throw" }),
      refetchInterval: !1,
      refetchOnWindowFocus: !1,
      staleTime: 1 / 0,
      retry: !1
    },
    mutations: {
      retry: !1
    }
  }
});
const OE = "Welcome to Your Personal AI Medical Concierge", ME = "Your intelligent health assistant will ask you key questions to understand your needs and build a personalized profile to support your well-being and care journey.", DE = { title: "How It Works", steps: ["Your AI concierge asks you questions to find out how {{brand}} can help you succeed", "The concierge will personalize recommendations based on your needs", "Access tailored resources, courses, and marketplace options"] }, xE = { resetChat: "Reset Chat", retry: "Retry", continue: "Continue", upload: "Upload", uploading: "Uploading..." }, NE = { yourAIConcierge: "Your AI Concierge", chooseAvatar: "Choose Your Avatar", startConversation: "Start Conversation" }, zE = { chooseAvatarTitle: "Choose Your Avatar", chooseAvatarMessage: "Please select an avatar from the left panel to start your conversation with your AI Concierge.", mode: "Chat Mode", modes: { care: "Care", clear: "Clear", clinical: "Clinical" } }, LE = {
  title: OE,
  description: ME,
  howItWorks: DE,
  buttons: xE,
  avatar: NE,
  chat: zE
}, jE = "Bienvenido a tu Asistente de IA Personal de Salud", qE = "Tu asistente digital inteligente te hará preguntas clave para entender tus necesidades y crear un perfil personalizado para apoyarte en tu viaje de bienestar y cuidado.", FE = { title: "Cómo Funciona", steps: ["Tu asistente de IA te hará preguntas para averiguar cómo {{brand}} puede ayudarte a tener éxito", "El asistente personalizará recomendaciones basadas en tus necesidades", "Accede a recursos, cursos y opciones de mercado personalizados"] }, BE = { resetChat: "Restablecer Chat", retry: "Reintentar", continue: "Continuar", upload: "Cargar", uploading: "Cargando..." }, UE = { yourAIConcierge: "Tu Asistente de IA", chooseAvatar: "Elige tu Avatar", startConversation: "Iniciar Conversación" }, $E = { chooseAvatarTitle: "Elige tu Avatar", chooseAvatarMessage: "Por favor, selecciona un avatar de la izquierda para iniciar tu conversación con tu Asistente de IA.", mode: "Modo de Chat", modes: { care: "Cuidado", clear: "Claro", clinical: "Clínico" } }, VE = {
  title: jE,
  description: qE,
  howItWorks: FE,
  buttons: BE,
  avatar: UE,
  chat: $E
}, WE = "Bienvenue chez votre Assistant IA de Santé", HE = "Votre assistant numérique intelligent vous posera des questions clés pour comprendre vos besoins et créer un profil personnalisé pour vous aider dans votre parcours de bien-être et de soins.", KE = { title: "Comment ça Marche", steps: ["Votre assistant IA vous pose des questions pour savoir comment {{brand}} peut vous aider", "L'assistant personnalise des recommandations selon vos besoins", "Accédez à des ressources, cours et options adaptées"] }, JE = { resetChat: "Réinitialiser le Chat", retry: "Réessayer", continue: "Continuer", upload: "Télécharger", uploading: "Téléchargement..." }, GE = { yourAIConcierge: "Votre Assistant IA", chooseAvatar: "Choisissez votre Avatar", startConversation: "Démarrer la Conversation" }, QE = { chooseAvatarTitle: "Choisissez votre Avatar", chooseAvatarMessage: "Veuillez sélectionner un avatar de la gauche pour démarrer votre conversation avec votre Assistant IA.", mode: "Mode de Chat", modes: { care: "Soins", clear: "Clair", clinical: "Clinique" } }, YE = {
  title: WE,
  description: HE,
  howItWorks: KE,
  buttons: JE,
  avatar: GE,
  chat: QE
}, ZE = "Willkommen bei Ihrem persönlichen KI-Medizin-Assistenten", XE = "Ihr intelligenter digitaler Assistent stellt Fragen, um Ihre Bedürfnisse zu verstehen und ein persönliches Profil zu erstellen, um Ihre Gesundheit und Pflege zu unterstützen.", eI = { title: "So funktioniert es", steps: ["Ihr KI-Assistent stellt Fragen, um herauszufinden, wie {{brand}} Sie unterstützen kann", "Der Assistent personalisiert Empfehlungen basierend auf Ihren Bedürfnissen", "Zugriff auf maßgeschneiderte Ressourcen, Kurse und Marktplatzoptionen"] }, tI = { resetChat: "Chat zurücksetzen", retry: "Wiederholen", continue: "Fortfahren", upload: "Datei hochladen", uploading: "Hochladen..." }, rI = { yourAIConcierge: "Ihr KI-Assistent", chooseAvatar: "Wählen Sie Ihren Avatar", startConversation: "Konversation starten" }, nI = { chooseAvatarTitle: "Wählen Sie Ihren Avatar", chooseAvatarMessage: "Bitte wählen Sie einen Avatar aus der linken Leiste, um mit Ihrem KI-Assistenten zu beginnen.", mode: "Chat-Modus", modes: { care: "Betreuung", clear: "Klar", clinical: "Klinisch" } }, iI = {
  title: ZE,
  description: XE,
  howItWorks: eI,
  buttons: tI,
  avatar: rI,
  chat: nI
}, sI = ["Analyzing your request", "Gathering insights", "Processing information", "Preparing response", "Almost there", "Finalizing thoughts", "Crafting the perfect response", "Connecting the dots", "Synthesizing information", "Optimizing recommendations"], oI = {
  loadingMessages: sI
}, aI = ["Analizando tu solicitud", "Recopilando información", "Procesando información", "Preparando respuesta", "Casi listo", "Finalizando pensamientos", "Elaborando la respuesta perfecta", "Conectando los puntos", "Sintetizando información", "Optimizando recomendaciones"], cI = {
  loadingMessages: aI
}, uI = ["Analyse de votre demande", "Collecte d'informations", "Traitement des informations", "Préparation de la réponse", "Presque terminé", "Finalisation des réflexions", "Élaboration de la réponse parfaite", "Connexion des points", "Synthèse des informations", "Optimisation des recommandations"], lI = {
  loadingMessages: uI
}, pI = ["Analysiere Ihre Anfrage", "Sammle Erkenntnisse", "Verarbeite Informationen", "Bereite Antwort vor", "Fast fertig", "Finalisiere Gedanken", "Erstelle die perfekte Antwort", "Verbinde die Punkte", "Synthetisiere Informationen", "Optimiere Empfehlungen"], dI = {
  loadingMessages: pI
}, hI = {
  en: {
    concierge: LE,
    common: {
      loadingMessages: oI
    }
  },
  es: {
    concierge: VE,
    common: {
      loadingMessages: cI
    }
  },
  fr: {
    concierge: YE,
    common: {
      loadingMessages: lI
    }
  },
  de: {
    concierge: iI,
    common: {
      loadingMessages: dI
    }
  }
};
se.use(Jg).init({
  resources: hI,
  lng: "en",
  // Default language
  fallbackLng: "en",
  interpolation: {
    escapeValue: !1
    // React already handles escaping
  }
});
const fI = [
  { code: "en", name: "English" },
  { code: "es", name: "Spanish" },
  { code: "fr", name: "French" },
  { code: "de", name: "German" }
], Sg = {
  region: "",
  apiBaseUrl: "",
  speechKey: "",
  azureTranslatorKey: "",
  azureTranslatorEndpoint: "",
  azureTranslatorRegion: "",
  tavusApiKey: ""
}, Cg = gf(Sg), vI = () => mf(Cg), gI = ({ value: e, children: t }) => {
  const r = { ...Sg, ...e };
  return /* @__PURE__ */ w(Cg.Provider, { value: r, children: t });
}, mI = Eg(
  ({
    replicaId: e = "r82081c7f26d",
    personaId: t = "pc9cb547c05e",
    personaName: r = "Concierge",
    conversationName: o = "Demo Conversation",
    conversationalContext: i,
    customGreeting: a,
    platform: s = "home",
    buttonText: n,
    videoMode: c,
    chatVisible: u,
    toggleChat: l,
    learningPrompts: p = [],
    onPromptClick: h,
    width: d = "100%",
    height: f = "100%",
    maxWidth: g = "2xl",
    className: m = "",
    setVoiceMode: v,
    setConversationStarted: y,
    setConversationId: S,
    setConversationUrl: C,
    setInterruptReplica: P,
    currentScript: b,
    setCurrentScript: A,
    interruptReplica: E,
    setIsSpeaking: D,
    setSpokenText: R,
    region: j,
    speechKey: T,
    config: x
  }, q) => {
    const [pe, W] = O("welcome"), [G, ne] = O(null), [oe, ye] = O(!1), [V, te] = O(!1), Se = We(null), [Ce, Gt] = O([]), [Ne, ze] = O("16:9"), { tavusApiKey: Lt } = vI(), [be, Qt] = O("en");
    U(() => {
      typeof window < "u" && Qt(localStorage.getItem("lang") || "en");
    }, []);
    const rt = fI.find((F) => F.code === be)?.name || "English", nt = We("en");
    U(() => {
      typeof window < "u" && (nt.current = localStorage.getItem("lang") || "en");
    }, []), U(() => {
      (async () => {
        if (Ce.length === 0)
          try {
            const X = await ug();
            X?.Success && X.Data && Gt(X.Data);
          } catch (X) {
            console.error("Error fetching avatars:", X);
          }
      })();
    }, [Ce.length]);
    const Ke = Ce.find((F) => F.ExternalId === e);
    U(() => {
      be && be !== "en" && be !== nt.current && (nt.current = be, de());
    }, [be]), U(() => {
      (async () => {
        if (Ke?.ImageUrl) {
          const X = new Image();
          X.onload = () => {
            const qt = X.width / X.height;
            Math.abs(qt - 1.7777777777777777) < Math.abs(qt - 0.5625) ? ze("16:9") : ze("9:16");
          }, X.onerror = () => {
            ze("16:9");
          }, X.src = Ke.ImageUrl;
        }
      })();
    }, [Ke?.ImageUrl]), U(() => () => {
      G && Kh({
        conversationId: G.conversation_id,
        apiKey: Lt
      });
    }, [G]), U(() => {
      s === "concierge" && it();
    }, [s]);
    const it = async () => {
      try {
        te(!1), ye(!0), v(!0), y(!0), Se.current && Se.current.pause();
        const F = await jb({
          replicaId: e || "r82081c7f26d",
          personaId: t || "pc9cb547c05e",
          conversationName: o || "Demo Conversation",
          conversationalContext: i ?? "",
          customGreeting: a ?? "",
          language: rt,
          apiKey: Lt
        });
        if (F?.conversation_id && F.conversation_url)
          ne(F), S(F.conversation_id), C(F.conversation_url), W("hairCheck");
        else
          throw new Error("Failed to start conversation");
      } catch (F) {
        console.error("Conversation error:", F);
      } finally {
        ye(!1);
      }
    }, de = async () => {
      te(!0), y(!1);
      try {
        if (!G) return;
        await Kh({ conversationId: G.conversation_id, apiKey: Lt });
      } catch (F) {
        console.error(F);
      } finally {
        ne(null), W("welcome");
      }
    }, bs = () => {
      W("call");
    };
    Ig(q, () => ({
      handleEnd: de,
      handleStart: it
    }));
    const Es = (F) => typeof F == "string" ? F : F ? `${F}px` : "100%", Is = (F) => typeof F == "string" ? F : F ? `${F}px` : "100%", jt = Es(d), Oe = Is(f), Je = (F) => {
      if (!F) return;
      const X = typeof F == "string" ? F : `${F}px`;
      return X.includes("sm") || parseInt(X) < 350 ? "sm" : X.includes("lg") || parseInt(X) > 600 ? "lg" : "md";
    }, ae = typeof g == "string" ? g : g ? `${g}px` : void 0, Yt = ae && !ae.includes("px") && !ae.includes("%") ? `max-w-${ae} mx-auto` : "";
    return /* @__PURE__ */ w("main", { className: `${m} relative w-full h-full`, style: { width: jt, height: Oe }, children: /* @__PURE__ */ w(Kg, { children: /* @__PURE__ */ k("div", { className: `h-full w-full ${Yt}`, style: ae && ae.includes("px") ? { maxWidth: ae } : {}, children: [
      pe === "welcome" && /* @__PURE__ */ w(
        kb,
        {
          onStart: it,
          loading: oe,
          buttonText: n,
          platform: s || "home",
          replicaId: e || "r82081c7f26d",
          containerClassName: m,
          imageHeight: Oe === "100%" ? "auto" : Oe,
          buttonSize: Je(d) || "md",
          learningPrompts: p,
          onPromptClick: h,
          userCredits: 100,
          avatars: Ce,
          config: x,
          personaName: r
        }
      ),
      pe === "hairCheck" && /* @__PURE__ */ w(
        Ob,
        {
          handleEnd: de,
          handleJoin: bs,
          setScreen: W,
          platform: s || "home",
          containerClassName: m,
          videoDimensions: {
            width: jt,
            height: Oe === "100%" ? "auto" : Oe
          },
          buttonsSize: Je(d) || "md"
        }
      ),
      pe === "call" && G && /* @__PURE__ */ w("div", { className: "w-full h-full", children: /* @__PURE__ */ w(
        Lb,
        {
          conversation: G,
          handleEnd: de,
          platform: s || "home",
          videoMode: c ?? "full",
          endConv: V,
          chatVisible: u ?? !1,
          toggleChat: l,
          containerClassName: m,
          videoHeight: Oe === "100%" ? "auto" : Oe,
          controlsSize: Je(d) || "md",
          aspectRatio: Ne,
          setInterruptReplica: P,
          currentScript: b,
          setCurrentScript: A,
          interruptReplica: E,
          setIsSpeaking: D,
          setSpokenText: R,
          region: j,
          speechKey: T,
          config: x,
          personaName: r
        }
      ) })
    ] }) }) });
  }
), yI = async (e, t, r, o, i = !1, a = !1) => {
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      UserId: e,
      CourseId: t,
      Query: r,
      Answer: o,
      Avatar: i,
      STT: a
    })
  };
  let c;
  try {
    const u = Sc("/api/User/chathistory/post"), l = await fetch(u, n);
    if (!l.ok) {
      let p = {};
      const h = l.headers.get("content-type");
      throw h && h.includes("application/json") ? p = await l.json() : p = { message: await l.text() }, console.error("Error details:", p), new Error(
        `Failed to post chat history: ${l.status} ${l.statusText} - ${JSON.stringify(p)}`
      );
    }
    return c = l.headers.get("content-length") === "0" ? { Data: !0, Success: !0, Message: "Ok" } : await l.json(), c;
  } catch (u) {
    return console.error("Error posting chat history:", u), {
      Success: !1,
      Message: u instanceof Error ? u.message : "Unknown error occurred",
      Data: null
    };
  }
}, vf = ({
  children: e,
  fallback: t = /* @__PURE__ */ w("div", { children: "Loading..." })
}) => {
  const [r, o] = O(!1);
  return U(() => {
    o(!0);
  }, []), r ? /* @__PURE__ */ w(et, { children: e }) : /* @__PURE__ */ w(et, { children: t });
}, SI = [
  { id: 1, text: "Explain my report", icon: xg },
  { id: 5, text: "Analyze my medical reports.", icon: Ng },
  { id: 6, text: "Answer my questions like a personal coach", icon: zg }
], CI = "r89e4f7ec536";
function RI({
  brandName: e = "Growth Hub",
  className: t = "",
  personaName: r = "Personal AI Concierge",
  suggestedPrompts: o = SI,
  welcomeMessage: i = "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload any lab test or medical report. If you don’t have one, lets just talk.",
  language: a = "en",
  navigateTo: s = "",
  file: n,
  onFileChange: c,
  onApiResponse: u,
  config: l = {
    region: "",
    apiBaseUrl: "",
    speechKey: "",
    azureTranslatorKey: "",
    azureTranslatorEndpoint: "",
    azureTranslatorRegion: ""
  }
}) {
  const [p, h] = O([]), [d, f] = O(null), [g, m] = O("chat"), [v, y] = O(!1), [S, C] = O(!1), [P, b] = O(!1), [A, E] = O([]), [D, R] = O(!1), [j, T] = O({}), [x, q] = O(""), [pe, W] = O(!1), [G, ne] = O(!1), [oe, ye] = O(!1), [V, te] = O(!1), [Se, Ce] = O(""), Gt = We(null), [Ne, ze] = O(""), [Lt, be] = O(!1), [Qt, rt] = O(!1), [nt, Ke] = O(!1), [it, de] = O(""), [bs, Es] = O(""), [Is, jt] = O(""), [Oe, Je] = O(""), [ae, Yt] = O(!1), F = We(null), X = We(null), [qt, As] = O([]), ro = Gg("(max-width: 768px)"), [st, no] = O(!1), [Zt, ie] = O("52533144413937384342"), [Xt, Ts] = O({
    avatar: {
      chooseAvatar: `Choose Your ${r}`,
      startConversation: "Start Conversation",
      yourAIHealthNavigator: `Your ${r}`,
      description: "I'm here to help you with your health and wellness."
    },
    buttons: {
      resetChat: "Reset Chat",
      retry: "Retry",
      continue: "Continue",
      signUp: "Sign Up Free",
      uploading: "Uploading...",
      upload: "Upload report",
      buyNow: "Buy now"
    },
    howItWorks: {
      title: "How It Works",
      steps: [
        `Your AI ${r} asks you questions to find out how ${e} can help you.`,
        `The ${r} will personalize recommendations based on your needs`,
        "Access tailored resources, courses, and marketplace options."
      ]
    }
  });
  U(() => {
    typeof window < "u" && window.scrollTo(0, 0);
  }, []), U(() => {
    (async () => {
      try {
        const ee = await ug();
        if (ee?.Success && ee.Data) {
          const H = ee.Data.find((he) => he.ExternalId === CI);
          H && (h([H]), f(H));
        }
      } catch (ee) {
        console.error("Error fetching avatar:", ee);
      }
    })();
  }, []), U(() => {
    m(ae ? "voice" : "chat");
  }, [ae]), U(() => {
    s.includes("demo") && ie("52533144413937384342");
  }, []), U(() => {
    if (!(!!l?.azureTranslatorKey && !!l?.azureTranslatorEndpoint && !!l?.azureTranslatorRegion)) {
      console.warn("Azure translation config is not yet ready.");
      return;
    }
    (async () => {
      if (a !== "en" && F.current !== a) {
        const [
          H,
          he,
          Le,
          J,
          Ee,
          Re,
          er,
          ao,
          co,
          uo,
          lo,
          po,
          ho,
          fo,
          ks
        ] = await Qs(
          [
            `Choose Your ${r}`,
            "Start Conversation",
            `Your ${r}`,
            `I'm here to help you with ${e}.`,
            "Reset Chat",
            "Retry",
            "Continue",
            "Sign Up Free",
            "Uploading...",
            "Upload Report",
            "Buy Now",
            "How It Works",
            `Your AI ${r} asks you questions to find out how ${e} can help you.`,
            `The ${r} will personalize recommendations based on your needs`,
            "Access tailored resources, courses, and marketplace options."
          ],
          a,
          "en",
          l.azureTranslatorKey,
          l.azureTranslatorEndpoint,
          l.azureTranslatorRegion
        );
        y(!1), q(""), E([]), Ts({
          avatar: {
            chooseAvatar: H,
            startConversation: he,
            yourAIHealthNavigator: Le,
            description: J
          },
          buttons: {
            resetChat: Ee,
            retry: Re,
            continue: er,
            signUp: ao,
            uploading: co,
            upload: uo,
            buyNow: lo
          },
          howItWorks: {
            title: po,
            steps: [ho, fo, ks]
          }
        }), F.current = a;
      }
      a === "en" && F.current !== "en" && (y(!1), q(""), E([]), Ts({
        avatar: {
          chooseAvatar: `Choose Your ${r}`,
          startConversation: "Start Conversation",
          yourAIHealthNavigator: `Your ${r}`,
          description: `I'm here to help you with ${e}.`
        },
        buttons: {
          resetChat: "Reset Chat",
          retry: "Retry",
          continue: "Continue",
          signUp: "Sign Up Free",
          uploading: "Uploading...",
          upload: "Upload Report",
          buyNow: "Buy Now"
        },
        howItWorks: {
          title: "How It Works",
          steps: [
            `Your AI ${r} asks you questions to find out how ${e} can help you.`,
            `The ${r} will personalize recommendations based on your needs`,
            "Access tailored resources, courses, and marketplace options."
          ]
        }
      }), F.current = "en");
    })();
  }, [
    a,
    l?.azureTranslatorKey,
    l?.azureTranslatorEndpoint,
    l?.azureTranslatorRegion,
    r,
    e
  ]), U(() => {
    n && (As([n]), ot(`Uploaded file: ${n.name}`, [n]));
  }, [n]), sc(
    async ($) => {
      C(!0);
      const H = await Wh(
        "I am user",
        "",
        "",
        "interview",
        x,
        0,
        1,
        a
      );
      return H.Success && H.Data?.Message ? H.Data.Message.includes("ERROR") ? (C(!1), de(`Hello there! I'm ${$?.Name}, your ${r}. I'm here to help you with ${e}. Can you tell me your name?`), {
        id: "welcome-message",
        sender: "ai",
        text: `Hello there! I'm ${$?.Name}, your ${r}. I'm here to help you with ${e}. Can you tell me a little about yourself?`,
        timestamp: /* @__PURE__ */ new Date()
      }) : (C(!1), q(H.Data.SessionId || ""), de(H.Data.Message), {
        id: "welcome-message",
        sender: "ai",
        text: H.Data.Message,
        timestamp: /* @__PURE__ */ new Date()
      }) : (C(!1), {
        id: "welcome-message",
        sender: "ai",
        text: `Hello there! I'm ${$?.Name}, your ${r}. I'm here to help you with ${e}. Can you tell me a little about yourself?`,
        timestamp: /* @__PURE__ */ new Date()
      });
    },
    [e]
  ), U(() => {
    Ke(!0);
  }, []), U(() => {
    Ne && Ne.trim() !== "" && (ot(Ne), ze(""));
  }, [Ne]), U(() => {
    y(!!ae);
  }, [ae]);
  const ot = async ($, ee = []) => {
    V && te(!1);
    const H = {
      id: Date.now().toString(),
      sender: "user",
      text: $ === "yes, continue" ? "Yes" : $,
      timestamp: /* @__PURE__ */ new Date()
    };
    Ce($), E((J) => [...J, H]), C(!0);
    let he = `${$}`;
    const Le = [...qt, ...ee];
    Le.length > 0 && (he += "Talk to me like I'm a 75 year old, who is afraid of medical terminology in a kind and gentle voice"), $ === "yes, continue" && (he += "Start the interview. User clicked continue.");
    try {
      const J = await Wh(
        he,
        Zt,
        // Send user ID instead of email - for testing hardcoding the userID
        "",
        // Business ID
        "interview",
        // Intent
        x,
        0,
        1,
        a,
        Le.length > 0 ? Le[0] : void 0
        // Only send last file
      );
      if (J.Success && J.Data?.Message) {
        if (J?.Data?.Message?.toLowerCase().includes("error") || J?.Data?.Type === "error") {
          C(!1);
          const Re = {
            id: (Date.now() + 1).toString(),
            sender: "ai",
            text: "Sorry, I couldn't process your request at the moment. Please try again.",
            timestamp: /* @__PURE__ */ new Date()
          };
          E((er) => [...er, Re]), de(Re.text), te(!0);
          return;
        }
        const Ee = {
          id: (Date.now() + 1).toString(),
          sender: "ai",
          text: J.Data.Message,
          timestamp: /* @__PURE__ */ new Date()
        };
        E((Re) => [...Re, Ee]), x || q(J?.Data?.SessionId || ""), de(J.Data.Message), no(!0), (J.Data.Message.toLowerCase().includes("click continue") || J.Data.Message.toLowerCase().includes("continue")) && W(!0), (J.Data.Message.toLowerCase().includes("sign up") || J.Data.Message.toLowerCase().includes("thank you for choosing") || J.Data.Message.toLowerCase().includes("ready to connect")) && ne(!0), (J.Data.Message.toLowerCase().includes("buy now") || J.Data.Message.toLowerCase().includes("ready to get your test kit")) && ye(!0), u && u(J), await yI(
          "",
          "AIReportReader",
          $,
          J.Data.Message || "",
          g === "voice",
          //isUserUsingAvatar
          $ === Ne
          // isUserSpeaking
        ), Ce("");
      } else {
        const Ee = {
          id: (Date.now() + 1).toString(),
          sender: "ai",
          text: "Sorry, I couldn't process your request. Please try again.",
          timestamp: /* @__PURE__ */ new Date()
        };
        E((Re) => [...Re, Ee]), de(Ee.text), te(!0);
      }
    } catch (J) {
      console.error("Error fetching response from LLM: ", J);
      const Ee = {
        id: (Date.now() + 1).toString(),
        sender: "ai",
        text: "Sorry, I couldn't connect to the AI service. Please try again later.",
        timestamp: /* @__PURE__ */ new Date()
      };
      E((Re) => [...Re, Ee]), de(Ee.text), te(!0);
    } finally {
      C(!1);
    }
  }, io = () => {
    console.log("Toggle chat visibility");
  }, so = () => {
    typeof window < "u" && (s ? window.location.href = s : window.location.href = "https://growth-hub-git-feature-whitelabeljun25v1-real-business.vercel.app/auth/register");
  }, _s = ($, ee) => {
    const H = ee === "like";
    T((he) => ({
      ...he,
      [$.id]: ee
    })), _b(
      $.text,
      "",
      "",
      H
    ).then((he) => {
    }).catch((he) => {
      console.error("Error sending feedback:", he);
    });
  }, oo = async ($) => {
    b(!0);
    const ee = Array.from($.target.files || []);
    if (ee.length > 0) {
      const H = ee[0];
      As([H]), c && c(H), b(!1), await ot(`Uploaded file: ${H.name}`, [H]);
    }
    $.target && ($.target.value = "");
  };
  return /* @__PURE__ */ k("div", { className: Pe("h-full min-h-0", t), children: [
    /* @__PURE__ */ k(tv, { className: "h-full min-h-0 flex flex-col overflow-hidden border border-primary/20 shadow-2xl relative", children: [
      /* @__PURE__ */ w(rv, { className: "flex-1 min-h-0 p-0 overflow-hidden", children: /* @__PURE__ */ k("div", { className: "h-full min-h-0 grid grid-cols-1 md:grid-cols-2 overflow-hidden", children: [
        /* @__PURE__ */ w("section", { className: "min-h-0 overflow-hidden p-4 md:p-6 border-b md:border-b-0 md:border-r border-primary/20", children: /* @__PURE__ */ w("div", { className: "h-full w-full min-h-0", children: v ? /* @__PURE__ */ w("div", { className: "h-full w-full rounded-xl overflow-hidden bg-white", children: d && /* @__PURE__ */ k(vf, { fallback: /* @__PURE__ */ w("div", { className: "w-full h-full bg-gray-200 rounded animate-pulse flex items-center justify-center", children: "Loading conversation..." }), children: [
          /* @__PURE__ */ k("div", { className: "hidden md:block text-center mb-6", children: [
            /* @__PURE__ */ w("div", { className: "inline-flex items-center justify-center w-12 h-12 md:w-16 md:h-16 bg-gradient-to-r from-green-500 to-blue-500 rounded-full mb-4", children: /* @__PURE__ */ w(Pc, { className: "w-6 h-6 md:w-8 md:h-8 text-white" }) }),
            /* @__PURE__ */ w("h2", { className: "text-lg font-bold text-gray-900 mb-2", children: st ? "🎉 Your Report Analysis is Ready!" : "Report analysis in progress" })
          ] }),
          /* @__PURE__ */ w(
            mI,
            {
              ref: Gt,
              replicaId: d?.ExternalId || "",
              personaId: "pb5d44035dbd",
              personaName: r,
              conversationName: `Conversation with ${d?.Name || "your" + r} ${(/* @__PURE__ */ new Date()).toISOString()}`,
              conversationalContext: "Initial medical consultation",
              customGreeting: A.length > 0 && A[A.length - 1].sender === "ai" ? A[A.length - 1].text : i,
              platform: "concierge",
              buttonText: Xt.avatar.startConversation,
              videoMode: "minimal",
              chatVisible: !1,
              toggleChat: io,
              width: "100%",
              height: ro ? "250px" : "55%",
              className: "w-full h-full",
              setVoiceMode: Ke,
              setConversationStarted: Yt,
              setConversationId: jt,
              setConversationUrl: Je,
              setInterruptReplica: rt,
              currentScript: it,
              setCurrentScript: de,
              interruptReplica: Qt,
              setIsSpeaking: be,
              setSpokenText: ze,
              region: l?.region || "",
              speechKey: l?.speechKey || "",
              config: l
            }
          ),
          /* @__PURE__ */ w("div", { className: "hidden md:block bg-gradient-to-r from-blue-50 to-teal-50 rounded-2xl p-6 mb-6", children: /* @__PURE__ */ k("div", { className: "flex items-start space-x-4", children: [
            /* @__PURE__ */ w("div", { className: "w-12 h-12 rounded-full overflow-hidden flex-shrink-0", children: /* @__PURE__ */ w(
              "img",
              {
                src: d?.ImageUrl,
                alt: d?.Name,
                className: "w-full h-full object-cover"
              }
            ) }),
            /* @__PURE__ */ w("div", { className: "flex-1 text-left", children: /* @__PURE__ */ k("p", { className: "text-gray-800 leading-relaxed", children: [
              /* @__PURE__ */ k("strong", { className: "text-[#3f62ec]", children: [
                r,
                ":"
              ] }),
              " ",
              st ? /* @__PURE__ */ k(et, { children: [
                "Great news! I’ve analyzed your ",
                n?.name ?? "health report",
                " and found some important insights for you."
              ] }) : /* @__PURE__ */ k(et, { children: [
                "Analyzing ",
                n?.name ?? "your report",
                "… this usually takes a few seconds."
              ] })
            ] }) })
          ] }) })
        ] }) }) : /* @__PURE__ */ k("div", { className: "flex flex-col items-center text-center", children: [
          /* @__PURE__ */ k("div", { className: "hidden md:block text-center mb-6", children: [
            /* @__PURE__ */ w("div", { className: "inline-flex items-center justify-center w-12 h-12 md:w-16 md:h-16 bg-gradient-to-r from-green-500 to-blue-500 rounded-full mb-4", children: /* @__PURE__ */ w(Pc, { className: "w-6 h-6 md:w-8 md:h-8 text-white" }) }),
            /* @__PURE__ */ w("h2", { className: "text-lg md:text-xl font-bold text-gray-900 mb-2", children: st ? "🎉 Your Report Analysis is Ready!" : "Report analysis in progress" })
          ] }),
          /* @__PURE__ */ k("div", { className: "mb-4 flex flex-col items-center gap-2", children: [
            /* @__PURE__ */ w(
              "img",
              {
                src: d?.ImageUrl,
                alt: d?.Name,
                className: "w-full max-w-sm h-auto rounded-2xl mx-auto lg:mx-0 shadow-lg",
                "data-testid": "img-ai-health-concierge"
              }
            ),
            /* @__PURE__ */ w(
              Wt,
              {
                onClick: () => y(!0),
                className: "w-auto bg-[#3f62ec] hover:bg-white hover:text-[#3f62ec] text-white py-3 px-6 rounded-lg font-semibold shadow-md transition",
                children: Xt.avatar.startConversation
              }
            )
          ] }),
          /* @__PURE__ */ w("div", { className: "hidden md:block bg-gradient-to-r from-blue-50 to-teal-50 rounded-2xl p-6 mb-6 w-full max-w-xl", children: /* @__PURE__ */ k("div", { className: "flex flex-col sm:flex-row items-center sm:items-start gap-4", children: [
            /* @__PURE__ */ w("div", { className: "w-12 h-12 rounded-full overflow-hidden flex-shrink-0", children: /* @__PURE__ */ w(
              "img",
              {
                src: d?.ImageUrl,
                alt: d?.Name,
                className: "w-full h-full object-cover"
              }
            ) }),
            /* @__PURE__ */ w("div", { className: "flex-1 text-center sm:text-left", children: /* @__PURE__ */ k("p", { className: "text-gray-800 leading-relaxed", children: [
              /* @__PURE__ */ k("strong", { className: "text-[#3f62ec]", children: [
                r,
                ":"
              ] }),
              " ",
              st ? /* @__PURE__ */ k(et, { children: [
                "Great news! I’ve analyzed your ",
                n?.name ?? "health report",
                " and found some important insights for you."
              ] }) : /* @__PURE__ */ k(et, { children: [
                "Analyzing ",
                n?.name ?? "your report",
                "… this usually takes a few seconds."
              ] })
            ] }) })
          ] }) })
        ] }) }) }),
        /* @__PURE__ */ w("section", { className: "min-h-0 overflow-hidden p-4 md:p-6", children: /* @__PURE__ */ w("div", { className: "h-full min-h-0 flex flex-col overflow-hidden", children: /* @__PURE__ */ w(
          lC,
          {
            language: a,
            config: l,
            setInterruptReplica: rt,
            messages: A,
            welcomeMessage: i,
            onSendMessage: ot,
            className: "h-full min-h-0",
            isLoading: S,
            rightElement: /* @__PURE__ */ w(vf, { fallback: /* @__PURE__ */ w("div", { className: "w-10 h-10 bg-gray-200 rounded animate-pulse" }), children: /* @__PURE__ */ w(
              ag,
              {
                avatarName: d?.Name || "AI Health Navigator",
                disabled: S,
                voiceMode: nt,
                setSpokenText: ze,
                setIsSpeaking: be,
                setInterruptReplica: rt,
                region: l?.region || "",
                speechKey: l?.speechKey || ""
              }
            ) }),
            suggestedPrompts: o,
            renderMessage: ($, ee) => {
              if ($.sender === "ai" && $.id !== "welcome-message") {
                const H = ee === A.length - 1;
                return /* @__PURE__ */ k("div", { className: "relative", children: [
                  /* @__PURE__ */ w(Ba, { children: $.text }),
                  /* @__PURE__ */ k("div", { className: "flex justify-end gap-2 mt-2", children: [
                    /* @__PURE__ */ w(
                      "button",
                      {
                        className: `p-1 rounded-full transition-colors ${j[$.id] === "like" ? "bg-green-100 text-green-600" : "hover:bg-gray-200 text-gray-600"}`,
                        onClick: () => _s($, "like"),
                        children: /* @__PURE__ */ w(Lg, { className: "h-4 w-4" })
                      }
                    ),
                    /* @__PURE__ */ w(
                      "button",
                      {
                        className: `p-1 rounded-full transition-colors ${j[$.id] === "dislike" ? "bg-red-100 text-red-600" : "hover:bg-gray-200 text-gray-600"}`,
                        onClick: () => _s($, "dislike"),
                        children: /* @__PURE__ */ w(jg, { className: "h-4 w-4" })
                      }
                    )
                  ] }),
                  V && H && /* @__PURE__ */ w("div", { className: "mt-4 flex", children: /* @__PURE__ */ w(
                    "button",
                    {
                      className: "bg-primary hover:bg-secondary text-white px-6 py-3 rounded-lg font-semibold shadow-md transition",
                      onClick: () => {
                        ot(Se), te(!1);
                      },
                      children: Xt.buttons.retry
                    }
                  ) }),
                  H && st && /* @__PURE__ */ w("div", { className: "mt-4 flex justify-center", children: /* @__PURE__ */ w(
                    "button",
                    {
                      className: "bg-primary hover:bg-secondary text-white px-6 py-3 rounded-lg font-semibold shadow-md transition",
                      onClick: so,
                      children: "Join Unicorn Health"
                    }
                  ) })
                ] });
              }
              return /* @__PURE__ */ w(Ba, { remarkPlugins: [ev], children: $.text });
            }
          }
        ) }) })
      ] }) }),
      /* @__PURE__ */ w("div", { className: "pointer-events-none absolute -top-4 -right-4 w-72 h-72 bg-primary/20 rounded-full blur-3xl" }),
      /* @__PURE__ */ w("div", { className: "pointer-events-none absolute -bottom-8 -left-8 w-96 h-96 bg-secondary/10 rounded-full blur-3xl" })
    ] }),
    /* @__PURE__ */ w(
      "input",
      {
        type: "file",
        ref: X,
        onChange: oo,
        accept: ".pdf,.doc,.docx,.jpg,.jpeg,.png,.txt",
        className: "hidden"
      }
    )
  ] });
}
function HT(e) {
  return /* @__PURE__ */ w(gI, { value: e.config || {}, children: /* @__PURE__ */ w(RI, { ...e }) });
}
const Rg = gf(void 0), KT = ({ children: e, value: t }) => /* @__PURE__ */ w(Rg.Provider, { value: t, children: e }), JT = () => {
  const e = mf(Rg);
  if (!e)
    throw new Error("useConciergeContext must be used within a ConciergeProvider");
  return e;
};
function GT(e, t) {
  const [r, o] = O(() => {
    if (typeof window > "u")
      return t;
    try {
      const a = window.localStorage.getItem(e);
      return a ? JSON.parse(a) : t;
    } catch (a) {
      return console.log(a), t;
    }
  });
  return [r, (a) => {
    try {
      const s = a instanceof Function ? a(r) : a;
      o(s), typeof window < "u" && window.localStorage.setItem(e, JSON.stringify(s));
    } catch (s) {
      console.log(s);
    }
  }];
}
export {
  HT as ConciergeModule,
  RI as ConciergeModuleRaw,
  KT as ConciergeProvider,
  mI as ConversationComponent,
  vf as SSRSafeWrapper,
  ag as SpeechComponent,
  JT as useConciergeContext,
  GT as useLocalStorage
};
