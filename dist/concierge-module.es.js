import { jsx as P, jsxs as N, Fragment as Ns } from "react/jsx-runtime";
import * as Z from "react";
import { useState as O, useRef as Ve, useEffect as $, useCallback as ec, createContext as pf, useContext as df, forwardRef as Eg, useImperativeHandle as Ig } from "react";
import { Bot as gc, RotateCcw as Ag, Loader2 as Na, ChevronDown as Tg, ChevronUp as _g, Send as kg, Mic as Og, MicOff as Mg, CheckCircle as mc, GraduationCap as Dg, Sparkles as Ng, MessageSquare as xg } from "lucide-react";
import xa from "react-markdown";
import * as gs from "@radix-ui/react-tooltip";
import { motion as zg } from "framer-motion";
import { useVideoTrack as hf, DailyVideo as Lg, useLocalSessionId as ff, useDaily as Us, useDevices as jg, useAudioTrack as qg, useDailyEvent as Fg, useParticipantIds as Bg, useAppMessage as Ug, DailyAudio as $g, DailyProvider as Vg } from "@daily-co/daily-react";
import Wg from "@mui/icons-material/CallEnd";
import { initReactI18next as Hg } from "react-i18next";
import { useMediaQuery as Kg } from "@mui/material";
function yc(e, t) {
  if (typeof e == "function")
    return e(t);
  e != null && (e.current = t);
}
function Jg(...e) {
  return (t) => {
    let r = !1;
    const o = e.map((i) => {
      const a = yc(i, t);
      return !r && typeof a == "function" && (r = !0), a;
    });
    if (r)
      return () => {
        for (let i = 0; i < o.length; i++) {
          const a = o[i];
          typeof a == "function" ? a() : yc(e[i], null);
        }
      };
  };
}
// @__NO_SIDE_EFFECTS__
function Gg(e) {
  const t = /* @__PURE__ */ Yg(e), r = Z.forwardRef((o, i) => {
    const { children: a, ...s } = o, n = Z.Children.toArray(a), c = n.find(Xg);
    if (c) {
      const u = c.props.children, l = n.map((p) => p === c ? Z.Children.count(u) > 1 ? Z.Children.only(null) : Z.isValidElement(u) ? u.props.children : null : p);
      return /* @__PURE__ */ P(t, { ...s, ref: i, children: Z.isValidElement(u) ? Z.cloneElement(u, void 0, l) : null });
    }
    return /* @__PURE__ */ P(t, { ...s, ref: i, children: a });
  });
  return r.displayName = `${e}.Slot`, r;
}
var Qg = /* @__PURE__ */ Gg("Slot");
// @__NO_SIDE_EFFECTS__
function Yg(e) {
  const t = Z.forwardRef((r, o) => {
    const { children: i, ...a } = r;
    if (Z.isValidElement(i)) {
      const s = tm(i), n = em(a, i.props);
      return i.type !== Z.Fragment && (n.ref = o ? Jg(o, s) : s), Z.cloneElement(i, n);
    }
    return Z.Children.count(i) > 1 ? Z.Children.only(null) : null;
  });
  return t.displayName = `${e}.SlotClone`, t;
}
var Zg = Symbol("radix.slottable");
function Xg(e) {
  return Z.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === Zg;
}
function em(e, t) {
  const r = { ...t };
  for (const o in t) {
    const i = e[o], a = t[o];
    /^on[A-Z]/.test(o) ? i && a ? r[o] = (...n) => {
      const c = a(...n);
      return i(...n), c;
    } : i && (r[o] = i) : o === "style" ? r[o] = { ...i, ...a } : o === "className" && (r[o] = [i, a].filter(Boolean).join(" "));
  }
  return { ...e, ...r };
}
function tm(e) {
  let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning;
  return r ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, r = t && "isReactWarning" in t && t.isReactWarning, r ? e.props.ref : e.props.ref || e.ref);
}
function vf(e) {
  var t, r, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var i = e.length;
    for (t = 0; t < i; t++) e[t] && (r = vf(e[t])) && (o && (o += " "), o += r);
  } else for (r in e) e[r] && (o && (o += " "), o += r);
  return o;
}
function gf() {
  for (var e, t, r = 0, o = "", i = arguments.length; r < i; r++) (e = arguments[r]) && (t = vf(e)) && (o && (o += " "), o += t);
  return o;
}
const Sc = (e) => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, Cc = gf, rm = (e, t) => (r) => {
  var o;
  if (t?.variants == null) return Cc(e, r?.class, r?.className);
  const { variants: i, defaultVariants: a } = t, s = Object.keys(i).map((u) => {
    const l = r?.[u], p = a?.[u];
    if (l === null) return null;
    const h = Sc(l) || Sc(p);
    return i[u][h];
  }), n = r && Object.entries(r).reduce((u, l) => {
    let [p, h] = l;
    return h === void 0 || (u[p] = h), u;
  }, {}), c = t == null || (o = t.compoundVariants) === null || o === void 0 ? void 0 : o.reduce((u, l) => {
    let { class: p, className: h, ...d } = l;
    return Object.entries(d).every((f) => {
      let [g, m] = f;
      return Array.isArray(m) ? m.includes({
        ...a,
        ...n
      }[g]) : {
        ...a,
        ...n
      }[g] === m;
    }) ? [
      ...u,
      p,
      h
    ] : u;
  }, []);
  return Cc(e, s, c, r?.class, r?.className);
}, tc = "-", nm = (e) => {
  const t = sm(e), {
    conflictingClassGroups: r,
    conflictingClassGroupModifiers: o
  } = e;
  return {
    getClassGroupId: (s) => {
      const n = s.split(tc);
      return n[0] === "" && n.length !== 1 && n.shift(), mf(n, t) || im(s);
    },
    getConflictingClassGroupIds: (s, n) => {
      const c = r[s] || [];
      return n && o[s] ? [...c, ...o[s]] : c;
    }
  };
}, mf = (e, t) => {
  if (e.length === 0)
    return t.classGroupId;
  const r = e[0], o = t.nextPart.get(r), i = o ? mf(e.slice(1), o) : void 0;
  if (i)
    return i;
  if (t.validators.length === 0)
    return;
  const a = e.join(tc);
  return t.validators.find(({
    validator: s
  }) => s(a))?.classGroupId;
}, Rc = /^\[(.+)\]$/, im = (e) => {
  if (Rc.test(e)) {
    const t = Rc.exec(e)[1], r = t?.substring(0, t.indexOf(":"));
    if (r)
      return "arbitrary.." + r;
  }
}, sm = (e) => {
  const {
    theme: t,
    prefix: r
  } = e, o = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return am(Object.entries(e.classGroups), r).forEach(([a, s]) => {
    za(s, o, a, t);
  }), o;
}, za = (e, t, r, o) => {
  e.forEach((i) => {
    if (typeof i == "string") {
      const a = i === "" ? t : Pc(t, i);
      a.classGroupId = r;
      return;
    }
    if (typeof i == "function") {
      if (om(i)) {
        za(i(o), t, r, o);
        return;
      }
      t.validators.push({
        validator: i,
        classGroupId: r
      });
      return;
    }
    Object.entries(i).forEach(([a, s]) => {
      za(s, Pc(t, a), r, o);
    });
  });
}, Pc = (e, t) => {
  let r = e;
  return t.split(tc).forEach((o) => {
    r.nextPart.has(o) || r.nextPart.set(o, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r = r.nextPart.get(o);
  }), r;
}, om = (e) => e.isThemeGetter, am = (e, t) => t ? e.map(([r, o]) => {
  const i = o.map((a) => typeof a == "string" ? t + a : typeof a == "object" ? Object.fromEntries(Object.entries(a).map(([s, n]) => [t + s, n])) : a);
  return [r, i];
}) : e, cm = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map();
  const i = (a, s) => {
    r.set(a, s), t++, t > e && (t = 0, o = r, r = /* @__PURE__ */ new Map());
  };
  return {
    get(a) {
      let s = r.get(a);
      if (s !== void 0)
        return s;
      if ((s = o.get(a)) !== void 0)
        return i(a, s), s;
    },
    set(a, s) {
      r.has(a) ? r.set(a, s) : i(a, s);
    }
  };
}, yf = "!", um = (e) => {
  const {
    separator: t,
    experimentalParseClassName: r
  } = e, o = t.length === 1, i = t[0], a = t.length, s = (n) => {
    const c = [];
    let u = 0, l = 0, p;
    for (let m = 0; m < n.length; m++) {
      let v = n[m];
      if (u === 0) {
        if (v === i && (o || n.slice(m, m + a) === t)) {
          c.push(n.slice(l, m)), l = m + a;
          continue;
        }
        if (v === "/") {
          p = m;
          continue;
        }
      }
      v === "[" ? u++ : v === "]" && u--;
    }
    const h = c.length === 0 ? n : n.substring(l), d = h.startsWith(yf), f = d ? h.substring(1) : h, g = p && p > l ? p - l : void 0;
    return {
      modifiers: c,
      hasImportantModifier: d,
      baseClassName: f,
      maybePostfixModifierPosition: g
    };
  };
  return r ? (n) => r({
    className: n,
    parseClassName: s
  }) : s;
}, lm = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let r = [];
  return e.forEach((o) => {
    o[0] === "[" ? (t.push(...r.sort(), o), r = []) : r.push(o);
  }), t.push(...r.sort()), t;
}, pm = (e) => ({
  cache: cm(e.cacheSize),
  parseClassName: um(e),
  ...nm(e)
}), dm = /\s+/, hm = (e, t) => {
  const {
    parseClassName: r,
    getClassGroupId: o,
    getConflictingClassGroupIds: i
  } = t, a = [], s = e.trim().split(dm);
  let n = "";
  for (let c = s.length - 1; c >= 0; c -= 1) {
    const u = s[c], {
      modifiers: l,
      hasImportantModifier: p,
      baseClassName: h,
      maybePostfixModifierPosition: d
    } = r(u);
    let f = !!d, g = o(f ? h.substring(0, d) : h);
    if (!g) {
      if (!f) {
        n = u + (n.length > 0 ? " " + n : n);
        continue;
      }
      if (g = o(h), !g) {
        n = u + (n.length > 0 ? " " + n : n);
        continue;
      }
      f = !1;
    }
    const m = lm(l).join(":"), v = p ? m + yf : m, y = v + g;
    if (a.includes(y))
      continue;
    a.push(y);
    const S = i(g, f);
    for (let C = 0; C < S.length; ++C) {
      const w = S[C];
      a.push(v + w);
    }
    n = u + (n.length > 0 ? " " + n : n);
  }
  return n;
};
function fm() {
  let e = 0, t, r, o = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (r = Sf(t)) && (o && (o += " "), o += r);
  return o;
}
const Sf = (e) => {
  if (typeof e == "string")
    return e;
  let t, r = "";
  for (let o = 0; o < e.length; o++)
    e[o] && (t = Sf(e[o])) && (r && (r += " "), r += t);
  return r;
};
function vm(e, ...t) {
  let r, o, i, a = s;
  function s(c) {
    const u = t.reduce((l, p) => p(l), e());
    return r = pm(u), o = r.cache.get, i = r.cache.set, a = n, n(c);
  }
  function n(c) {
    const u = o(c);
    if (u)
      return u;
    const l = hm(c, r);
    return i(c, l), l;
  }
  return function() {
    return a(fm.apply(null, arguments));
  };
}
const H = (e) => {
  const t = (r) => r[e] || [];
  return t.isThemeGetter = !0, t;
}, Cf = /^\[(?:([a-z-]+):)?(.+)\]$/i, gm = /^\d+\/\d+$/, mm = /* @__PURE__ */ new Set(["px", "full", "screen"]), ym = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, Sm = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, Cm = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, Rm = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, Pm = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, Le = (e) => Ut(e) || mm.has(e) || gm.test(e), Ge = (e) => Vt(e, "length", km), Ut = (e) => !!e && !Number.isNaN(Number(e)), co = (e) => Vt(e, "number", Ut), Zt = (e) => !!e && Number.isInteger(Number(e)), wm = (e) => e.endsWith("%") && Ut(e.slice(0, -1)), L = (e) => Cf.test(e), Qe = (e) => ym.test(e), bm = /* @__PURE__ */ new Set(["length", "size", "percentage"]), Em = (e) => Vt(e, bm, Rf), Im = (e) => Vt(e, "position", Rf), Am = /* @__PURE__ */ new Set(["image", "url"]), Tm = (e) => Vt(e, Am, Mm), _m = (e) => Vt(e, "", Om), Xt = () => !0, Vt = (e, t, r) => {
  const o = Cf.exec(e);
  return o ? o[1] ? typeof t == "string" ? o[1] === t : t.has(o[1]) : r(o[2]) : !1;
}, km = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Sm.test(e) && !Cm.test(e)
), Rf = () => !1, Om = (e) => Rm.test(e), Mm = (e) => Pm.test(e), Dm = () => {
  const e = H("colors"), t = H("spacing"), r = H("blur"), o = H("brightness"), i = H("borderColor"), a = H("borderRadius"), s = H("borderSpacing"), n = H("borderWidth"), c = H("contrast"), u = H("grayscale"), l = H("hueRotate"), p = H("invert"), h = H("gap"), d = H("gradientColorStops"), f = H("gradientColorStopPositions"), g = H("inset"), m = H("margin"), v = H("opacity"), y = H("padding"), S = H("saturate"), C = H("scale"), w = H("sepia"), b = H("skew"), A = H("space"), E = H("translate"), M = () => ["auto", "contain", "none"], R = () => ["auto", "hidden", "clip", "visible", "scroll"], j = () => ["auto", L, t], T = () => [L, t], D = () => ["", Le, Ge], q = () => ["auto", Ut, L], pe = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], W = () => ["solid", "dashed", "dotted", "double", "none"], G = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], re = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], oe = () => ["", "0", L], me = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], V = () => [Ut, L];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Xt],
      spacing: [Le, Ge],
      blur: ["none", "", Qe, L],
      brightness: V(),
      borderColor: [e],
      borderRadius: ["none", "", "full", Qe, L],
      borderSpacing: T(),
      borderWidth: D(),
      contrast: V(),
      grayscale: oe(),
      hueRotate: V(),
      invert: oe(),
      gap: T(),
      gradientColorStops: [e],
      gradientColorStopPositions: [wm, Ge],
      inset: j(),
      margin: j(),
      opacity: V(),
      padding: T(),
      saturate: V(),
      scale: V(),
      sepia: oe(),
      skew: V(),
      space: T(),
      translate: T()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", L]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Qe]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": me()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": me()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...pe(), L]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: R()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": R()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": R()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: M()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": M()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": M()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [g]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [g]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [g]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [g]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [g]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [g]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [g]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [g]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [g]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", Zt, L]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: j()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", L]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: oe()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: oe()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", Zt, L]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Xt]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", Zt, L]
        }, L]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": q()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": q()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Xt]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [Zt, L]
        }, L]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": q()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": q()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", L]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", L]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [h]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [h]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [h]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...re()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...re(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...re(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [y]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [y]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [y]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [y]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [y]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [y]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [y]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [y]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [y]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [m]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [m]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [m]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [m]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [m]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [m]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [m]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [m]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [m]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [A]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [A]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", L, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [L, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [L, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [Qe]
        }, Qe]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [L, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [L, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [L, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [L, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Qe, Ge]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", co]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Xt]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", L]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Ut, co]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Le, L]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", L]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", L]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [v]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [v]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...W(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", Le, Ge]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", Le, L]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: T()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", L]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", L]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [v]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...pe(), Im]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Em]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Tm]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [f]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [f]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [f]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [d]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [d]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [d]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [a]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [a]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [a]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [a]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [a]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [a]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [a]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [a]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [a]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [a]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [a]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [a]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [a]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [a]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [a]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [n]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [n]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [n]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [n]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [n]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [n]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [n]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [n]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [n]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [v]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...W(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [n]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [n]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [v]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: W()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [i]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [i]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [i]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [i]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [i]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [i]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [i]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [i]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [i]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [i]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...W()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [Le, L]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [Le, Ge]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: D()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [v]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [Le, Ge]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Qe, _m]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Xt]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [v]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...G(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": G()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [o]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [c]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Qe, L]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [u]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [l]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [p]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [S]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [w]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [o]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [c]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [u]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [l]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [p]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [v]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [S]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [w]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [s]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [s]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [s]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", L]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: V()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", L]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: V()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", L]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [C]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [C]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [C]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [Zt, L]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [E]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [E]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [b]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [b]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", L]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", L]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": T()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": T()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": T()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": T()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": T()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": T()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": T()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": T()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": T()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": T()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": T()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": T()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": T()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": T()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": T()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": T()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": T()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": T()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", L]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [Le, Ge, co]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, Nm = /* @__PURE__ */ vm(Dm);
function Ce(...e) {
  return Nm(gf(e));
}
const xm = rm(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), $t = Z.forwardRef(
  ({ className: e, variant: t, size: r, asChild: o = !1, ...i }, a) => /* @__PURE__ */ P(
    o ? Qg : "button",
    {
      className: Ce(xm({ variant: t, size: r, className: e })),
      ref: a,
      ...i
    }
  )
);
$t.displayName = "Button";
function wc(e, t) {
  const r = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let o = 0, i = r.indexOf(t);
  for (; i !== -1; )
    o++, i = r.indexOf(t, i + t.length);
  return o;
}
const ls = Vs(/[A-Za-z]/), rc = Vs(/[\dA-Za-z]/);
function zm(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
function Bt(e) {
  return e !== null && e < -2;
}
function he(e) {
  return e !== null && (e < 0 || e === 32);
}
function Ue(e) {
  return e === -2 || e === -1 || e === 32;
}
const $s = Vs(new RegExp("\\p{P}|\\p{S}", "u")), Mt = Vs(/\s/);
function Vs(e) {
  return t;
  function t(r) {
    return r !== null && r > -1 && e.test(String.fromCharCode(r));
  }
}
function Lm(e) {
  if (typeof e != "string")
    throw new TypeError("Expected a string");
  return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
const Ws = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return Bm;
    if (typeof e == "function")
      return Hs(e);
    if (typeof e == "object")
      return Array.isArray(e) ? jm(e) : qm(e);
    if (typeof e == "string")
      return Fm(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function jm(e) {
  const t = [];
  let r = -1;
  for (; ++r < e.length; )
    t[r] = Ws(e[r]);
  return Hs(o);
  function o(...i) {
    let a = -1;
    for (; ++a < t.length; )
      if (t[a].apply(this, i)) return !0;
    return !1;
  }
}
function qm(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Hs(r);
  function r(o) {
    const i = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      o
    );
    let a;
    for (a in e)
      if (i[a] !== t[a]) return !1;
    return !0;
  }
}
function Fm(e) {
  return Hs(t);
  function t(r) {
    return r && r.type === e;
  }
}
function Hs(e) {
  return t;
  function t(r, o, i) {
    return !!(Um(r) && e.call(
      this,
      r,
      typeof o == "number" ? o : void 0,
      i || void 0
    ));
  }
}
function Bm() {
  return !0;
}
function Um(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const Pf = [], $m = !0, La = !1, Vm = "skip";
function wf(e, t, r, o) {
  let i;
  typeof t == "function" && typeof r != "function" ? (o = r, r = t) : i = t;
  const a = Ws(i), s = o ? -1 : 1;
  n(e, void 0, [])();
  function n(c, u, l) {
    const p = (
      /** @type {Record<string, unknown>} */
      c && typeof c == "object" ? c : {}
    );
    if (typeof p.type == "string") {
      const d = (
        // `hast`
        typeof p.tagName == "string" ? p.tagName : (
          // `xast`
          typeof p.name == "string" ? p.name : void 0
        )
      );
      Object.defineProperty(h, "name", {
        value: "node (" + (c.type + (d ? "<" + d + ">" : "")) + ")"
      });
    }
    return h;
    function h() {
      let d = Pf, f, g, m;
      if ((!t || a(c, u, l[l.length - 1] || void 0)) && (d = Wm(r(c, l)), d[0] === La))
        return d;
      if ("children" in c && c.children) {
        const v = (
          /** @type {UnistParent} */
          c
        );
        if (v.children && d[0] !== Vm)
          for (g = (o ? v.children.length : -1) + s, m = l.concat(v); g > -1 && g < v.children.length; ) {
            const y = v.children[g];
            if (f = n(y, g, m)(), f[0] === La)
              return f;
            g = typeof f[1] == "number" ? f[1] : g + s;
          }
      }
      return d;
    }
  }
}
function Wm(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [$m, e] : e == null ? Pf : [e];
}
function Hm(e, t, r) {
  const i = Ws((r || {}).ignore || []), a = Km(t);
  let s = -1;
  for (; ++s < a.length; )
    wf(e, "text", n);
  function n(u, l) {
    let p = -1, h;
    for (; ++p < l.length; ) {
      const d = l[p], f = h ? h.children : void 0;
      if (i(
        d,
        f ? f.indexOf(d) : void 0,
        h
      ))
        return;
      h = d;
    }
    if (h)
      return c(u, l);
  }
  function c(u, l) {
    const p = l[l.length - 1], h = a[s][0], d = a[s][1];
    let f = 0;
    const m = p.children.indexOf(u);
    let v = !1, y = [];
    h.lastIndex = 0;
    let S = h.exec(u.value);
    for (; S; ) {
      const C = S.index, w = {
        index: S.index,
        input: S.input,
        stack: [...l, u]
      };
      let b = d(...S, w);
      if (typeof b == "string" && (b = b.length > 0 ? { type: "text", value: b } : void 0), b === !1 ? h.lastIndex = C + 1 : (f !== C && y.push({
        type: "text",
        value: u.value.slice(f, C)
      }), Array.isArray(b) ? y.push(...b) : b && y.push(b), f = C + S[0].length, v = !0), !h.global)
        break;
      S = h.exec(u.value);
    }
    return v ? (f < u.value.length && y.push({ type: "text", value: u.value.slice(f) }), p.children.splice(m, 1, ...y)) : y = [u], m + y.length;
  }
}
function Km(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const r = !e[0] || Array.isArray(e[0]) ? e : [e];
  let o = -1;
  for (; ++o < r.length; ) {
    const i = r[o];
    t.push([Jm(i[0]), Gm(i[1])]);
  }
  return t;
}
function Jm(e) {
  return typeof e == "string" ? new RegExp(Lm(e), "g") : e;
}
function Gm(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const uo = "phrasing", lo = ["autolink", "link", "image", "label"];
function Qm() {
  return {
    transforms: [ny],
    enter: {
      literalAutolink: Zm,
      literalAutolinkEmail: po,
      literalAutolinkHttp: po,
      literalAutolinkWww: po
    },
    exit: {
      literalAutolink: ry,
      literalAutolinkEmail: ty,
      literalAutolinkHttp: Xm,
      literalAutolinkWww: ey
    }
  };
}
function Ym() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: uo,
        notInConstruct: lo
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: uo,
        notInConstruct: lo
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: uo,
        notInConstruct: lo
      }
    ]
  };
}
function Zm(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function po(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function Xm(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function ey(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function ty(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function ry(e) {
  this.exit(e);
}
function ny(e) {
  Hm(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, iy],
      [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), sy]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function iy(e, t, r, o, i) {
  let a = "";
  if (!bf(i) || (/^w/i.test(t) && (r = t + r, t = "", a = "http://"), !oy(r)))
    return !1;
  const s = ay(r + o);
  if (!s[0]) return !1;
  const n = {
    type: "link",
    title: null,
    url: a + t + s[0],
    children: [{ type: "text", value: t + s[0] }]
  };
  return s[1] ? [n, { type: "text", value: s[1] }] : n;
}
function sy(e, t, r, o) {
  return (
    // Not an expected previous character.
    !bf(o, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(r) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + r,
      children: [{ type: "text", value: t + "@" + r }]
    }
  );
}
function oy(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function ay(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let r = t[0], o = r.indexOf(")");
  const i = wc(e, "(");
  let a = wc(e, ")");
  for (; o !== -1 && i > a; )
    e += r.slice(0, o + 1), r = r.slice(o + 1), o = r.indexOf(")"), a++;
  return [e, r];
}
function bf(e, t) {
  const r = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || Mt(r) || $s(r)) && // If it’s an email, the previous character should not be a slash.
  (!t || r !== 47);
}
function ms(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
Ef.peek = gy;
function cy() {
  this.buffer();
}
function uy(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function ly() {
  this.buffer();
}
function py(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function dy(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = ms(
    this.sliceSerialize(e)
  ).toLowerCase(), r.label = t;
}
function hy(e) {
  this.exit(e);
}
function fy(e) {
  const t = this.resume(), r = this.stack[this.stack.length - 1];
  r.type, r.identifier = ms(
    this.sliceSerialize(e)
  ).toLowerCase(), r.label = t;
}
function vy(e) {
  this.exit(e);
}
function gy() {
  return "[";
}
function Ef(e, t, r, o) {
  const i = r.createTracker(o);
  let a = i.move("[^");
  const s = r.enter("footnoteReference"), n = r.enter("reference");
  return a += i.move(
    r.safe(r.associationId(e), { after: "]", before: a })
  ), n(), s(), a += i.move("]"), a;
}
function my() {
  return {
    enter: {
      gfmFootnoteCallString: cy,
      gfmFootnoteCall: uy,
      gfmFootnoteDefinitionLabelString: ly,
      gfmFootnoteDefinition: py
    },
    exit: {
      gfmFootnoteCallString: dy,
      gfmFootnoteCall: hy,
      gfmFootnoteDefinitionLabelString: fy,
      gfmFootnoteDefinition: vy
    }
  };
}
function yy(e) {
  let t = !1;
  return e && e.firstLineBlank && (t = !0), {
    handlers: { footnoteDefinition: r, footnoteReference: Ef },
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }]
  };
  function r(o, i, a, s) {
    const n = a.createTracker(s);
    let c = n.move("[^");
    const u = a.enter("footnoteDefinition"), l = a.enter("label");
    return c += n.move(
      a.safe(a.associationId(o), { before: c, after: "]" })
    ), l(), c += n.move("]:"), o.children && o.children.length > 0 && (n.shift(4), c += n.move(
      (t ? `
` : " ") + a.indentLines(
        a.containerFlow(o, n.current()),
        t ? If : Sy
      )
    )), u(), c;
  }
}
function Sy(e, t, r) {
  return t === 0 ? e : If(e, t, r);
}
function If(e, t, r) {
  return (r ? "" : "    ") + e;
}
const Cy = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
Af.peek = Ey;
function Ry() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: wy },
    exit: { strikethrough: by }
  };
}
function Py() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Cy
      }
    ],
    handlers: { delete: Af }
  };
}
function wy(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function by(e) {
  this.exit(e);
}
function Af(e, t, r, o) {
  const i = r.createTracker(o), a = r.enter("strikethrough");
  let s = i.move("~~");
  return s += r.containerPhrasing(e, {
    ...i.current(),
    before: s,
    after: "~"
  }), s += i.move("~~"), a(), s;
}
function Ey() {
  return "~";
}
function Iy(e) {
  return e.length;
}
function Ay(e, t) {
  const r = t || {}, o = (r.align || []).concat(), i = r.stringLength || Iy, a = [], s = [], n = [], c = [];
  let u = 0, l = -1;
  for (; ++l < e.length; ) {
    const g = [], m = [];
    let v = -1;
    for (e[l].length > u && (u = e[l].length); ++v < e[l].length; ) {
      const y = Ty(e[l][v]);
      if (r.alignDelimiters !== !1) {
        const S = i(y);
        m[v] = S, (c[v] === void 0 || S > c[v]) && (c[v] = S);
      }
      g.push(y);
    }
    s[l] = g, n[l] = m;
  }
  let p = -1;
  if (typeof o == "object" && "length" in o)
    for (; ++p < u; )
      a[p] = bc(o[p]);
  else {
    const g = bc(o);
    for (; ++p < u; )
      a[p] = g;
  }
  p = -1;
  const h = [], d = [];
  for (; ++p < u; ) {
    const g = a[p];
    let m = "", v = "";
    g === 99 ? (m = ":", v = ":") : g === 108 ? m = ":" : g === 114 && (v = ":");
    let y = r.alignDelimiters === !1 ? 1 : Math.max(
      1,
      c[p] - m.length - v.length
    );
    const S = m + "-".repeat(y) + v;
    r.alignDelimiters !== !1 && (y = m.length + y + v.length, y > c[p] && (c[p] = y), d[p] = y), h[p] = S;
  }
  s.splice(1, 0, h), n.splice(1, 0, d), l = -1;
  const f = [];
  for (; ++l < s.length; ) {
    const g = s[l], m = n[l];
    p = -1;
    const v = [];
    for (; ++p < u; ) {
      const y = g[p] || "";
      let S = "", C = "";
      if (r.alignDelimiters !== !1) {
        const w = c[p] - (m[p] || 0), b = a[p];
        b === 114 ? S = " ".repeat(w) : b === 99 ? w % 2 ? (S = " ".repeat(w / 2 + 0.5), C = " ".repeat(w / 2 - 0.5)) : (S = " ".repeat(w / 2), C = S) : C = " ".repeat(w);
      }
      r.delimiterStart !== !1 && !p && v.push("|"), r.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(r.alignDelimiters === !1 && y === "") && (r.delimiterStart !== !1 || p) && v.push(" "), r.alignDelimiters !== !1 && v.push(S), v.push(y), r.alignDelimiters !== !1 && v.push(C), r.padding !== !1 && v.push(" "), (r.delimiterEnd !== !1 || p !== u - 1) && v.push("|");
    }
    f.push(
      r.delimiterEnd === !1 ? v.join("").replace(/ +$/, "") : v.join("")
    );
  }
  return f.join(`
`);
}
function Ty(e) {
  return e == null ? "" : String(e);
}
function bc(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function _y(e, t, r, o) {
  const i = r.enter("blockquote"), a = r.createTracker(o);
  a.move("> "), a.shift(2);
  const s = r.indentLines(
    r.containerFlow(e, a.current()),
    ky
  );
  return i(), s;
}
function ky(e, t, r) {
  return ">" + (r ? "" : " ") + e;
}
function Oy(e, t) {
  return Ec(e, t.inConstruct, !0) && !Ec(e, t.notInConstruct, !1);
}
function Ec(e, t, r) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return r;
  let o = -1;
  for (; ++o < t.length; )
    if (e.includes(t[o]))
      return !0;
  return !1;
}
function Ic(e, t, r, o) {
  let i = -1;
  for (; ++i < r.unsafe.length; )
    if (r.unsafe[i].character === `
` && Oy(r.stack, r.unsafe[i]))
      return /[ \t]/.test(o.before) ? "" : " ";
  return `\\
`;
}
function My(e, t) {
  const r = String(e);
  let o = r.indexOf(t), i = o, a = 0, s = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; o !== -1; )
    o === i ? ++a > s && (s = a) : a = 1, i = o + t.length, o = r.indexOf(t, i);
  return s;
}
function Dy(e, t) {
  return !!(t.options.fences === !1 && e.value && // If there’s no info…
  !e.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function Ny(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function xy(e, t, r, o) {
  const i = Ny(r), a = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde";
  if (Dy(e, r)) {
    const p = r.enter("codeIndented"), h = r.indentLines(a, zy);
    return p(), h;
  }
  const n = r.createTracker(o), c = i.repeat(Math.max(My(a, i) + 1, 3)), u = r.enter("codeFenced");
  let l = n.move(c);
  if (e.lang) {
    const p = r.enter(`codeFencedLang${s}`);
    l += n.move(
      r.safe(e.lang, {
        before: l,
        after: " ",
        encode: ["`"],
        ...n.current()
      })
    ), p();
  }
  if (e.lang && e.meta) {
    const p = r.enter(`codeFencedMeta${s}`);
    l += n.move(" "), l += n.move(
      r.safe(e.meta, {
        before: l,
        after: `
`,
        encode: ["`"],
        ...n.current()
      })
    ), p();
  }
  return l += n.move(`
`), a && (l += n.move(a + `
`)), l += n.move(c), u(), l;
}
function zy(e, t, r) {
  return (r ? "" : "    ") + e;
}
function nc(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function Ly(e, t, r, o) {
  const i = nc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.enter("definition");
  let n = r.enter("label");
  const c = r.createTracker(o);
  let u = c.move("[");
  return u += c.move(
    r.safe(r.associationId(e), {
      before: u,
      after: "]",
      ...c.current()
    })
  ), u += c.move("]: "), n(), // If there’s no url, or…
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (n = r.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    r.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (n = r.enter("destinationRaw"), u += c.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : `
`,
      ...c.current()
    })
  )), n(), e.title && (n = r.enter(`title${a}`), u += c.move(" " + i), u += c.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), n()), s(), u;
}
function jy(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
function ps(e) {
  return "&#x" + e.toString(16).toUpperCase() + ";";
}
function xs(e) {
  if (e === null || he(e) || Mt(e))
    return 1;
  if ($s(e))
    return 2;
}
function zs(e, t, r) {
  const o = xs(e), i = xs(t);
  return o === void 0 ? i === void 0 ? (
    // Letter inside:
    // we have to encode *both* letters for `_` as it is looser.
    // it already forms for `*` (and GFMs `~`).
    r === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (letter, whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: encode outer (letter)
    { inside: !1, outside: !0 }
  ) : o === 1 ? i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode both (whitespace).
    { inside: !0, outside: !0 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === void 0 ? (
    // Letter inside: already forms.
    { inside: !1, outside: !1 }
  ) : i === 1 ? (
    // Whitespace inside: encode inner (whitespace).
    { inside: !0, outside: !1 }
  ) : (
    // Punctuation inside: already forms.
    { inside: !1, outside: !1 }
  );
}
Tf.peek = qy;
function Tf(e, t, r, o) {
  const i = jy(r), a = r.enter("emphasis"), s = r.createTracker(o), n = s.move(i);
  let c = s.move(
    r.containerPhrasing(e, {
      after: i,
      before: n,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), l = zs(
    o.before.charCodeAt(o.before.length - 1),
    u,
    i
  );
  l.inside && (c = ps(u) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), h = zs(o.after.charCodeAt(0), p, i);
  h.inside && (c = c.slice(0, -1) + ps(p));
  const d = s.move(i);
  return a(), r.attentionEncodeSurroundingInfo = {
    after: h.outside,
    before: l.outside
  }, n + c + d;
}
function qy(e, t, r) {
  return r.options.emphasis || "*";
}
function Fy(e, t, r, o) {
  let i, a, s;
  typeof t == "function" && typeof r != "function" ? (a = void 0, s = t, i = r) : (a = t, s = r, i = o), wf(e, a, n, i);
  function n(c, u) {
    const l = u[u.length - 1], p = l ? l.children.indexOf(c) : void 0;
    return s(c, p, l);
  }
}
const By = {};
function _f(e, t) {
  const r = By, o = typeof r.includeImageAlt == "boolean" ? r.includeImageAlt : !0, i = typeof r.includeHtml == "boolean" ? r.includeHtml : !0;
  return kf(e, o, i);
}
function kf(e, t, r) {
  if (Uy(e)) {
    if ("value" in e)
      return e.type === "html" && !r ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return Ac(e.children, t, r);
  }
  return Array.isArray(e) ? Ac(e, t, r) : "";
}
function Ac(e, t, r) {
  const o = [];
  let i = -1;
  for (; ++i < e.length; )
    o[i] = kf(e[i], t, r);
  return o.join("");
}
function Uy(e) {
  return !!(e && typeof e == "object");
}
function $y(e, t) {
  let r = !1;
  return Fy(e, function(o) {
    if ("value" in o && /\r?\n|\r/.test(o.value) || o.type === "break")
      return r = !0, La;
  }), !!((!e.depth || e.depth < 3) && _f(e) && (t.options.setext || r));
}
function Vy(e, t, r, o) {
  const i = Math.max(Math.min(6, e.depth || 1), 1), a = r.createTracker(o);
  if ($y(e, r)) {
    const l = r.enter("headingSetext"), p = r.enter("phrasing"), h = r.containerPhrasing(e, {
      ...a.current(),
      before: `
`,
      after: `
`
    });
    return p(), l(), h + `
` + (i === 1 ? "=" : "-").repeat(
      // The whole size…
      h.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(h.lastIndexOf("\r"), h.lastIndexOf(`
`)) + 1)
    );
  }
  const s = "#".repeat(i), n = r.enter("headingAtx"), c = r.enter("phrasing");
  a.move(s + " ");
  let u = r.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...a.current()
  });
  return /^[\t ]/.test(u) && (u = ps(u.charCodeAt(0)) + u.slice(1)), u = u ? s + " " + u : s, r.options.closeAtx && (u += " " + s), c(), n(), u;
}
Of.peek = Wy;
function Of(e) {
  return e.value || "";
}
function Wy() {
  return "<";
}
Mf.peek = Hy;
function Mf(e, t, r, o) {
  const i = nc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.enter("image");
  let n = r.enter("label");
  const c = r.createTracker(o);
  let u = c.move("![");
  return u += c.move(
    r.safe(e.alt, { before: u, after: "]", ...c.current() })
  ), u += c.move("]("), n(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (n = r.enter("destinationLiteral"), u += c.move("<"), u += c.move(
    r.safe(e.url, { before: u, after: ">", ...c.current() })
  ), u += c.move(">")) : (n = r.enter("destinationRaw"), u += c.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...c.current()
    })
  )), n(), e.title && (n = r.enter(`title${a}`), u += c.move(" " + i), u += c.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...c.current()
    })
  ), u += c.move(i), n()), u += c.move(")"), s(), u;
}
function Hy() {
  return "!";
}
Df.peek = Ky;
function Df(e, t, r, o) {
  const i = e.referenceType, a = r.enter("imageReference");
  let s = r.enter("label");
  const n = r.createTracker(o);
  let c = n.move("![");
  const u = r.safe(e.alt, {
    before: c,
    after: "]",
    ...n.current()
  });
  c += n.move(u + "]["), s();
  const l = r.stack;
  r.stack = [], s = r.enter("reference");
  const p = r.safe(r.associationId(e), {
    before: c,
    after: "]",
    ...n.current()
  });
  return s(), r.stack = l, a(), i === "full" || !u || u !== p ? c += n.move(p + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += n.move("]"), c;
}
function Ky() {
  return "!";
}
Nf.peek = Jy;
function Nf(e, t, r) {
  let o = e.value || "", i = "`", a = -1;
  for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(o); )
    i += "`";
  for (/[^ \r\n]/.test(o) && (/^[ \r\n]/.test(o) && /[ \r\n]$/.test(o) || /^`|`$/.test(o)) && (o = " " + o + " "); ++a < r.unsafe.length; ) {
    const s = r.unsafe[a], n = r.compilePattern(s);
    let c;
    if (s.atBreak)
      for (; c = n.exec(o); ) {
        let u = c.index;
        o.charCodeAt(u) === 10 && o.charCodeAt(u - 1) === 13 && u--, o = o.slice(0, u) + " " + o.slice(c.index + 1);
      }
  }
  return i + o + i;
}
function Jy() {
  return "`";
}
function xf(e, t) {
  const r = _f(e);
  return !!(!t.options.resourceLink && // If there’s a url…
  e.url && // And there’s a no title…
  !e.title && // And the content of `node` is a single text node…
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content…
  (r === e.url || "mailto:" + r === e.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e.url));
}
zf.peek = Gy;
function zf(e, t, r, o) {
  const i = nc(r), a = i === '"' ? "Quote" : "Apostrophe", s = r.createTracker(o);
  let n, c;
  if (xf(e, r)) {
    const l = r.stack;
    r.stack = [], n = r.enter("autolink");
    let p = s.move("<");
    return p += s.move(
      r.containerPhrasing(e, {
        before: p,
        after: ">",
        ...s.current()
      })
    ), p += s.move(">"), n(), r.stack = l, p;
  }
  n = r.enter("link"), c = r.enter("label");
  let u = s.move("[");
  return u += s.move(
    r.containerPhrasing(e, {
      before: u,
      after: "](",
      ...s.current()
    })
  ), u += s.move("]("), c(), // If there’s no url but there is a title…
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (c = r.enter("destinationLiteral"), u += s.move("<"), u += s.move(
    r.safe(e.url, { before: u, after: ">", ...s.current() })
  ), u += s.move(">")) : (c = r.enter("destinationRaw"), u += s.move(
    r.safe(e.url, {
      before: u,
      after: e.title ? " " : ")",
      ...s.current()
    })
  )), c(), e.title && (c = r.enter(`title${a}`), u += s.move(" " + i), u += s.move(
    r.safe(e.title, {
      before: u,
      after: i,
      ...s.current()
    })
  ), u += s.move(i), c()), u += s.move(")"), n(), u;
}
function Gy(e, t, r) {
  return xf(e, r) ? "<" : "[";
}
Lf.peek = Qy;
function Lf(e, t, r, o) {
  const i = e.referenceType, a = r.enter("linkReference");
  let s = r.enter("label");
  const n = r.createTracker(o);
  let c = n.move("[");
  const u = r.containerPhrasing(e, {
    before: c,
    after: "]",
    ...n.current()
  });
  c += n.move(u + "]["), s();
  const l = r.stack;
  r.stack = [], s = r.enter("reference");
  const p = r.safe(r.associationId(e), {
    before: c,
    after: "]",
    ...n.current()
  });
  return s(), r.stack = l, a(), i === "full" || !u || u !== p ? c += n.move(p + "]") : i === "shortcut" ? c = c.slice(0, -1) : c += n.move("]"), c;
}
function Qy() {
  return "[";
}
function ic(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function Yy(e) {
  const t = ic(e), r = e.options.bulletOther;
  if (!r)
    return t === "*" ? "-" : "*";
  if (r !== "*" && r !== "+" && r !== "-")
    throw new Error(
      "Cannot serialize items with `" + r + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (r === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + r + "`) to be different"
    );
  return r;
}
function Zy(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function jf(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function Xy(e, t, r, o) {
  const i = r.enter("list"), a = r.bulletCurrent;
  let s = e.ordered ? Zy(r) : ic(r);
  const n = e.ordered ? s === "." ? ")" : "." : Yy(r);
  let c = t && r.bulletLastUsed ? s === r.bulletLastUsed : !1;
  if (!e.ordered) {
    const l = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (s === "*" || s === "-") && // Empty first list item:
      l && (!l.children || !l.children[0]) && // Directly in two other list items:
      r.stack[r.stack.length - 1] === "list" && r.stack[r.stack.length - 2] === "listItem" && r.stack[r.stack.length - 3] === "list" && r.stack[r.stack.length - 4] === "listItem" && // That are each the first child.
      r.indexStack[r.indexStack.length - 1] === 0 && r.indexStack[r.indexStack.length - 2] === 0 && r.indexStack[r.indexStack.length - 3] === 0 && (c = !0), jf(r) === s && l
    ) {
      let p = -1;
      for (; ++p < e.children.length; ) {
        const h = e.children[p];
        if (h && h.type === "listItem" && h.children && h.children[0] && h.children[0].type === "thematicBreak") {
          c = !0;
          break;
        }
      }
    }
  }
  c && (s = n), r.bulletCurrent = s;
  const u = r.containerFlow(e, o);
  return r.bulletLastUsed = s, r.bulletCurrent = a, i(), u;
}
function eS(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function tS(e, t, r, o) {
  const i = eS(r);
  let a = r.bulletCurrent || ic(r);
  t && t.type === "list" && t.ordered && (a = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (r.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + a);
  let s = a.length + 1;
  (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4);
  const n = r.createTracker(o);
  n.move(a + " ".repeat(s - a.length)), n.shift(s);
  const c = r.enter("listItem"), u = r.indentLines(
    r.containerFlow(e, n.current()),
    l
  );
  return c(), u;
  function l(p, h, d) {
    return h ? (d ? "" : " ".repeat(s)) + p : (d ? a : a + " ".repeat(s - a.length)) + p;
  }
}
function rS(e, t, r, o) {
  const i = r.enter("paragraph"), a = r.enter("phrasing"), s = r.containerPhrasing(e, o);
  return a(), i(), s;
}
const nS = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Ws([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function iS(e, t, r, o) {
  return (e.children.some(function(s) {
    return nS(s);
  }) ? r.containerPhrasing : r.containerFlow).call(r, e, o);
}
function sS(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
qf.peek = oS;
function qf(e, t, r, o) {
  const i = sS(r), a = r.enter("strong"), s = r.createTracker(o), n = s.move(i + i);
  let c = s.move(
    r.containerPhrasing(e, {
      after: i,
      before: n,
      ...s.current()
    })
  );
  const u = c.charCodeAt(0), l = zs(
    o.before.charCodeAt(o.before.length - 1),
    u,
    i
  );
  l.inside && (c = ps(u) + c.slice(1));
  const p = c.charCodeAt(c.length - 1), h = zs(o.after.charCodeAt(0), p, i);
  h.inside && (c = c.slice(0, -1) + ps(p));
  const d = s.move(i + i);
  return a(), r.attentionEncodeSurroundingInfo = {
    after: h.outside,
    before: l.outside
  }, n + c + d;
}
function oS(e, t, r) {
  return r.options.strong || "*";
}
function aS(e, t, r, o) {
  return r.safe(e.value, o);
}
function cS(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function uS(e, t, r) {
  const o = (jf(r) + (r.options.ruleSpaces ? " " : "")).repeat(cS(r));
  return r.options.ruleSpaces ? o.slice(0, -1) : o;
}
const Ff = {
  blockquote: _y,
  break: Ic,
  code: xy,
  definition: Ly,
  emphasis: Tf,
  hardBreak: Ic,
  heading: Vy,
  html: Of,
  image: Mf,
  imageReference: Df,
  inlineCode: Nf,
  link: zf,
  linkReference: Lf,
  list: Xy,
  listItem: tS,
  paragraph: rS,
  root: iS,
  strong: qf,
  text: aS,
  thematicBreak: uS
};
function lS() {
  return {
    enter: {
      table: pS,
      tableData: Tc,
      tableHeader: Tc,
      tableRow: hS
    },
    exit: {
      codeText: fS,
      table: dS,
      tableData: ho,
      tableHeader: ho,
      tableRow: ho
    }
  };
}
function pS(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(r) {
        return r === "none" ? null : r;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function dS(e) {
  this.exit(e), this.data.inTable = void 0;
}
function hS(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function ho(e) {
  this.exit(e);
}
function Tc(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function fS(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, vS));
  const r = this.stack[this.stack.length - 1];
  r.type, r.value = t, this.exit(e);
}
function vS(e, t) {
  return t === "|" ? t : e;
}
function gS(e) {
  const t = e || {}, r = t.tableCellPadding, o = t.tablePipeAlign, i = t.stringLength, a = r ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: h,
      table: s,
      tableCell: c,
      tableRow: n
    }
  };
  function s(d, f, g, m) {
    return u(l(d, g, m), d.align);
  }
  function n(d, f, g, m) {
    const v = p(d, g, m), y = u([v]);
    return y.slice(0, y.indexOf(`
`));
  }
  function c(d, f, g, m) {
    const v = g.enter("tableCell"), y = g.enter("phrasing"), S = g.containerPhrasing(d, {
      ...m,
      before: a,
      after: a
    });
    return y(), v(), S;
  }
  function u(d, f) {
    return Ay(d, {
      align: f,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: o,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: i
    });
  }
  function l(d, f, g) {
    const m = d.children;
    let v = -1;
    const y = [], S = f.enter("table");
    for (; ++v < m.length; )
      y[v] = p(m[v], f, g);
    return S(), y;
  }
  function p(d, f, g) {
    const m = d.children;
    let v = -1;
    const y = [], S = f.enter("tableRow");
    for (; ++v < m.length; )
      y[v] = c(m[v], d, f, g);
    return S(), y;
  }
  function h(d, f, g) {
    let m = Ff.inlineCode(d, f, g);
    return g.stack.includes("tableCell") && (m = m.replace(/\|/g, "\\$&")), m;
  }
}
function mS() {
  return {
    exit: {
      taskListCheckValueChecked: _c,
      taskListCheckValueUnchecked: _c,
      paragraph: SS
    }
  };
}
function yS() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: CS }
  };
}
function _c(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function SS(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const r = this.stack[this.stack.length - 1];
    r.type;
    const o = r.children[0];
    if (o && o.type === "text") {
      const i = t.children;
      let a = -1, s;
      for (; ++a < i.length; ) {
        const n = i[a];
        if (n.type === "paragraph") {
          s = n;
          break;
        }
      }
      s === r && (o.value = o.value.slice(1), o.value.length === 0 ? r.children.shift() : r.position && o.position && typeof o.position.start.offset == "number" && (o.position.start.column++, o.position.start.offset++, r.position.start = Object.assign({}, o.position.start)));
    }
  }
  this.exit(e);
}
function CS(e, t, r, o) {
  const i = e.children[0], a = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", n = r.createTracker(o);
  a && n.move(s);
  let c = Ff.listItem(e, t, r, {
    ...o,
    ...n.current()
  });
  return a && (c = c.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, u)), c;
  function u(l) {
    return l + s;
  }
}
function RS() {
  return [
    Qm(),
    my(),
    Ry(),
    lS(),
    mS()
  ];
}
function PS(e) {
  return {
    extensions: [
      Ym(),
      yy(e),
      Py(),
      gS(e),
      yS()
    ]
  };
}
function Os(e, t, r, o) {
  const i = e.length;
  let a = 0, s;
  if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, r = r > 0 ? r : 0, o.length < 1e4)
    s = Array.from(o), s.unshift(t, r), e.splice(...s);
  else
    for (r && e.splice(t, r); a < o.length; )
      s = o.slice(a, a + 1e4), s.unshift(t, 0), e.splice(...s), a += 1e4, t += 1e4;
}
const kc = {}.hasOwnProperty;
function wS(e) {
  const t = {};
  let r = -1;
  for (; ++r < e.length; )
    bS(t, e[r]);
  return t;
}
function bS(e, t) {
  let r;
  for (r in t) {
    const i = (kc.call(e, r) ? e[r] : void 0) || (e[r] = {}), a = t[r];
    let s;
    if (a)
      for (s in a) {
        kc.call(i, s) || (i[s] = []);
        const n = a[s];
        ES(
          // @ts-expect-error Looks like a list.
          i[s],
          Array.isArray(n) ? n : n ? [n] : []
        );
      }
  }
}
function ES(e, t) {
  let r = -1;
  const o = [];
  for (; ++r < t.length; )
    (t[r].add === "after" ? e : o).push(t[r]);
  Os(e, 0, 0, o);
}
const IS = {
  tokenize: MS,
  partial: !0
}, Bf = {
  tokenize: DS,
  partial: !0
}, Uf = {
  tokenize: NS,
  partial: !0
}, $f = {
  tokenize: xS,
  partial: !0
}, AS = {
  tokenize: zS,
  partial: !0
}, Vf = {
  name: "wwwAutolink",
  tokenize: kS,
  previous: Hf
}, Wf = {
  name: "protocolAutolink",
  tokenize: OS,
  previous: Kf
}, We = {
  name: "emailAutolink",
  tokenize: _S,
  previous: Jf
}, De = {};
function TS() {
  return {
    text: De
  };
}
let st = 48;
for (; st < 123; )
  De[st] = We, st++, st === 58 ? st = 65 : st === 91 && (st = 97);
De[43] = We;
De[45] = We;
De[46] = We;
De[95] = We;
De[72] = [We, Wf];
De[104] = [We, Wf];
De[87] = [We, Vf];
De[119] = [We, Vf];
function _S(e, t, r) {
  const o = this;
  let i, a;
  return s;
  function s(p) {
    return !ja(p) || !Jf.call(o, o.previous) || sc(o.events) ? r(p) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), n(p));
  }
  function n(p) {
    return ja(p) ? (e.consume(p), n) : p === 64 ? (e.consume(p), c) : r(p);
  }
  function c(p) {
    return p === 46 ? e.check(AS, l, u)(p) : p === 45 || p === 95 || rc(p) ? (a = !0, e.consume(p), c) : l(p);
  }
  function u(p) {
    return e.consume(p), i = !0, c;
  }
  function l(p) {
    return a && i && ls(o.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(p)) : r(p);
  }
}
function kS(e, t, r) {
  const o = this;
  return i;
  function i(s) {
    return s !== 87 && s !== 119 || !Hf.call(o, o.previous) || sc(o.events) ? r(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(IS, e.attempt(Bf, e.attempt(Uf, a), r), r)(s));
  }
  function a(s) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s);
  }
}
function OS(e, t, r) {
  const o = this;
  let i = "", a = !1;
  return s;
  function s(p) {
    return (p === 72 || p === 104) && Kf.call(o, o.previous) && !sc(o.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(p), e.consume(p), n) : r(p);
  }
  function n(p) {
    if (ls(p) && i.length < 5)
      return i += String.fromCodePoint(p), e.consume(p), n;
    if (p === 58) {
      const h = i.toLowerCase();
      if (h === "http" || h === "https")
        return e.consume(p), c;
    }
    return r(p);
  }
  function c(p) {
    return p === 47 ? (e.consume(p), a ? u : (a = !0, c)) : r(p);
  }
  function u(p) {
    return p === null || zm(p) || he(p) || Mt(p) || $s(p) ? r(p) : e.attempt(Bf, e.attempt(Uf, l), r)(p);
  }
  function l(p) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(p);
  }
}
function MS(e, t, r) {
  let o = 0;
  return i;
  function i(s) {
    return (s === 87 || s === 119) && o < 3 ? (o++, e.consume(s), i) : s === 46 && o === 3 ? (e.consume(s), a) : r(s);
  }
  function a(s) {
    return s === null ? r(s) : t(s);
  }
}
function DS(e, t, r) {
  let o, i, a;
  return s;
  function s(u) {
    return u === 46 || u === 95 ? e.check($f, c, n)(u) : u === null || he(u) || Mt(u) || u !== 45 && $s(u) ? c(u) : (a = !0, e.consume(u), s);
  }
  function n(u) {
    return u === 95 ? o = !0 : (i = o, o = void 0), e.consume(u), s;
  }
  function c(u) {
    return i || o || !a ? r(u) : t(u);
  }
}
function NS(e, t) {
  let r = 0, o = 0;
  return i;
  function i(s) {
    return s === 40 ? (r++, e.consume(s), i) : s === 41 && o < r ? a(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check($f, t, a)(s) : s === null || he(s) || Mt(s) ? t(s) : (e.consume(s), i);
  }
  function a(s) {
    return s === 41 && o++, e.consume(s), i;
  }
}
function xS(e, t, r) {
  return o;
  function o(n) {
    return n === 33 || n === 34 || n === 39 || n === 41 || n === 42 || n === 44 || n === 46 || n === 58 || n === 59 || n === 63 || n === 95 || n === 126 ? (e.consume(n), o) : n === 38 ? (e.consume(n), a) : n === 93 ? (e.consume(n), i) : (
      // `<` is an end.
      n === 60 || // So is whitespace.
      n === null || he(n) || Mt(n) ? t(n) : r(n)
    );
  }
  function i(n) {
    return n === null || n === 40 || n === 91 || he(n) || Mt(n) ? t(n) : o(n);
  }
  function a(n) {
    return ls(n) ? s(n) : r(n);
  }
  function s(n) {
    return n === 59 ? (e.consume(n), o) : ls(n) ? (e.consume(n), s) : r(n);
  }
}
function zS(e, t, r) {
  return o;
  function o(a) {
    return e.consume(a), i;
  }
  function i(a) {
    return rc(a) ? r(a) : t(a);
  }
}
function Hf(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || he(e);
}
function Kf(e) {
  return !ls(e);
}
function Jf(e) {
  return !(e === 47 || ja(e));
}
function ja(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || rc(e);
}
function sc(e) {
  let t = e.length, r = !1;
  for (; t--; ) {
    const o = e[t][1];
    if ((o.type === "labelLink" || o.type === "labelImage") && !o._balanced) {
      r = !0;
      break;
    }
    if (o._gfmAutolinkLiteralWalkedInto) {
      r = !1;
      break;
    }
  }
  return e.length > 0 && !r && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), r;
}
function LS(e, t, r) {
  const o = [];
  let i = -1;
  for (; ++i < e.length; ) {
    const a = e[i].resolveAll;
    a && !o.includes(a) && (t = a(t, r), o.push(a));
  }
  return t;
}
function $e(e, t, r, o) {
  const i = o ? o - 1 : Number.POSITIVE_INFINITY;
  let a = 0;
  return s;
  function s(c) {
    return Ue(c) ? (e.enter(r), n(c)) : t(c);
  }
  function n(c) {
    return Ue(c) && a++ < i ? (e.consume(c), n) : (e.exit(r), t(c));
  }
}
const jS = {
  partial: !0,
  tokenize: qS
};
function qS(e, t, r) {
  return o;
  function o(a) {
    return Ue(a) ? $e(e, i, "linePrefix")(a) : i(a);
  }
  function i(a) {
    return a === null || Bt(a) ? t(a) : r(a);
  }
}
const FS = {
  tokenize: JS,
  partial: !0
};
function BS() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: WS,
        continuation: {
          tokenize: HS
        },
        exit: KS
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: VS
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: US,
        resolveTo: $S
      }
    }
  };
}
function US(e, t, r) {
  const o = this;
  let i = o.events.length;
  const a = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let s;
  for (; i--; ) {
    const c = o.events[i][1];
    if (c.type === "labelImage") {
      s = c;
      break;
    }
    if (c.type === "gfmFootnoteCall" || c.type === "labelLink" || c.type === "label" || c.type === "image" || c.type === "link")
      break;
  }
  return n;
  function n(c) {
    if (!s || !s._balanced)
      return r(c);
    const u = ms(o.sliceSerialize({
      start: s.end,
      end: o.now()
    }));
    return u.codePointAt(0) !== 94 || !a.includes(u.slice(1)) ? r(c) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(c), e.exit("gfmFootnoteCallLabelMarker"), t(c));
  }
}
function $S(e, t) {
  let r = e.length;
  for (; r--; )
    if (e[r][1].type === "labelImage" && e[r][0] === "enter") {
      e[r][1];
      break;
    }
  e[r + 1][1].type = "data", e[r + 3][1].type = "gfmFootnoteCallLabelMarker";
  const o = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[r + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, i = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[r + 3][1].end),
    end: Object.assign({}, e[r + 3][1].end)
  };
  i.end.column++, i.end.offset++, i.end._bufferIndex++;
  const a = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, i.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, s = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, a.start),
    end: Object.assign({}, a.end)
  }, n = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[r + 1],
    e[r + 2],
    ["enter", o, t],
    // The `[`
    e[r + 3],
    e[r + 4],
    // The `^`.
    ["enter", i, t],
    ["exit", i, t],
    // Everything in between.
    ["enter", a, t],
    ["enter", s, t],
    ["exit", s, t],
    ["exit", a, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", o, t]
  ];
  return e.splice(r, e.length - r + 1, ...n), e;
}
function VS(e, t, r) {
  const o = this, i = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let a = 0, s;
  return n;
  function n(p) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), c;
  }
  function c(p) {
    return p !== 94 ? r(p) : (e.enter("gfmFootnoteCallMarker"), e.consume(p), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", u);
  }
  function u(p) {
    if (
      // Too long.
      a > 999 || // Closing brace with nothing.
      p === 93 && !s || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      p === null || p === 91 || he(p)
    )
      return r(p);
    if (p === 93) {
      e.exit("chunkString");
      const h = e.exit("gfmFootnoteCallString");
      return i.includes(ms(o.sliceSerialize(h))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(p), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : r(p);
    }
    return he(p) || (s = !0), a++, e.consume(p), p === 92 ? l : u;
  }
  function l(p) {
    return p === 91 || p === 92 || p === 93 ? (e.consume(p), a++, u) : u(p);
  }
}
function WS(e, t, r) {
  const o = this, i = o.parser.gfmFootnotes || (o.parser.gfmFootnotes = []);
  let a, s = 0, n;
  return c;
  function c(f) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionLabelMarker"), u;
  }
  function u(f) {
    return f === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", l) : r(f);
  }
  function l(f) {
    if (
      // Too long.
      s > 999 || // Closing brace with nothing.
      f === 93 && !n || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      f === null || f === 91 || he(f)
    )
      return r(f);
    if (f === 93) {
      e.exit("chunkString");
      const g = e.exit("gfmFootnoteDefinitionLabelString");
      return a = ms(o.sliceSerialize(g)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(f), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), h;
    }
    return he(f) || (n = !0), s++, e.consume(f), f === 92 ? p : l;
  }
  function p(f) {
    return f === 91 || f === 92 || f === 93 ? (e.consume(f), s++, l) : l(f);
  }
  function h(f) {
    return f === 58 ? (e.enter("definitionMarker"), e.consume(f), e.exit("definitionMarker"), i.includes(a) || i.push(a), $e(e, d, "gfmFootnoteDefinitionWhitespace")) : r(f);
  }
  function d(f) {
    return t(f);
  }
}
function HS(e, t, r) {
  return e.check(jS, t, e.attempt(FS, t, r));
}
function KS(e) {
  e.exit("gfmFootnoteDefinition");
}
function JS(e, t, r) {
  const o = this;
  return $e(e, i, "gfmFootnoteDefinitionIndent", 5);
  function i(a) {
    const s = o.events[o.events.length - 1];
    return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(a) : r(a);
  }
}
function GS(e) {
  let r = (e || {}).singleTilde;
  const o = {
    name: "strikethrough",
    tokenize: a,
    resolveAll: i
  };
  return r == null && (r = !0), {
    text: {
      126: o
    },
    insideSpan: {
      null: [o]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function i(s, n) {
    let c = -1;
    for (; ++c < s.length; )
      if (s[c][0] === "enter" && s[c][1].type === "strikethroughSequenceTemporary" && s[c][1]._close) {
        let u = c;
        for (; u--; )
          if (s[u][0] === "exit" && s[u][1].type === "strikethroughSequenceTemporary" && s[u][1]._open && // If the sizes are the same:
          s[c][1].end.offset - s[c][1].start.offset === s[u][1].end.offset - s[u][1].start.offset) {
            s[c][1].type = "strikethroughSequence", s[u][1].type = "strikethroughSequence";
            const l = {
              type: "strikethrough",
              start: Object.assign({}, s[u][1].start),
              end: Object.assign({}, s[c][1].end)
            }, p = {
              type: "strikethroughText",
              start: Object.assign({}, s[u][1].end),
              end: Object.assign({}, s[c][1].start)
            }, h = [["enter", l, n], ["enter", s[u][1], n], ["exit", s[u][1], n], ["enter", p, n]], d = n.parser.constructs.insideSpan.null;
            d && Os(h, h.length, 0, LS(d, s.slice(u + 1, c), n)), Os(h, h.length, 0, [["exit", p, n], ["enter", s[c][1], n], ["exit", s[c][1], n], ["exit", l, n]]), Os(s, u - 1, c - u + 3, h), c = u + h.length - 2;
            break;
          }
      }
    for (c = -1; ++c < s.length; )
      s[c][1].type === "strikethroughSequenceTemporary" && (s[c][1].type = "data");
    return s;
  }
  function a(s, n, c) {
    const u = this.previous, l = this.events;
    let p = 0;
    return h;
    function h(f) {
      return u === 126 && l[l.length - 1][1].type !== "characterEscape" ? c(f) : (s.enter("strikethroughSequenceTemporary"), d(f));
    }
    function d(f) {
      const g = xs(u);
      if (f === 126)
        return p > 1 ? c(f) : (s.consume(f), p++, d);
      if (p < 2 && !r) return c(f);
      const m = s.exit("strikethroughSequenceTemporary"), v = xs(f);
      return m._open = !v || v === 2 && !!g, m._close = !g || g === 2 && !!v, n(f);
    }
  }
}
class QS {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, r, o) {
    YS(this, t, r, o);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(a, s) {
      return a[0] - s[0];
    }), this.map.length === 0)
      return;
    let r = this.map.length;
    const o = [];
    for (; r > 0; )
      r -= 1, o.push(t.slice(this.map[r][0] + this.map[r][1]), this.map[r][2]), t.length = this.map[r][0];
    o.push(t.slice()), t.length = 0;
    let i = o.pop();
    for (; i; ) {
      for (const a of i)
        t.push(a);
      i = o.pop();
    }
    this.map.length = 0;
  }
}
function YS(e, t, r, o) {
  let i = 0;
  if (!(r === 0 && o.length === 0)) {
    for (; i < e.map.length; ) {
      if (e.map[i][0] === t) {
        e.map[i][1] += r, e.map[i][2].push(...o);
        return;
      }
      i += 1;
    }
    e.map.push([t, r, o]);
  }
}
function ZS(e, t) {
  let r = !1;
  const o = [];
  for (; t < e.length; ) {
    const i = e[t];
    if (r) {
      if (i[0] === "enter")
        i[1].type === "tableContent" && o.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (i[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const a = o.length - 1;
          o[a] = o[a] === "left" ? "center" : "right";
        }
      } else if (i[1].type === "tableDelimiterRow")
        break;
    } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (r = !0);
    t += 1;
  }
  return o;
}
function XS() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: eC,
        resolveAll: tC
      }
    }
  };
}
function eC(e, t, r) {
  const o = this;
  let i = 0, a = 0, s;
  return n;
  function n(R) {
    let j = o.events.length - 1;
    for (; j > -1; ) {
      const q = o.events[j][1].type;
      if (q === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      q === "linePrefix") j--;
      else break;
    }
    const T = j > -1 ? o.events[j][1].type : null, D = T === "tableHead" || T === "tableRow" ? b : c;
    return D === b && o.parser.lazy[o.now().line] ? r(R) : D(R);
  }
  function c(R) {
    return e.enter("tableHead"), e.enter("tableRow"), u(R);
  }
  function u(R) {
    return R === 124 || (s = !0, a += 1), l(R);
  }
  function l(R) {
    return R === null ? r(R) : Bt(R) ? a > 1 ? (a = 0, o.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), d) : r(R) : Ue(R) ? $e(e, l, "whitespace")(R) : (a += 1, s && (s = !1, i += 1), R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), s = !0, l) : (e.enter("data"), p(R)));
  }
  function p(R) {
    return R === null || R === 124 || he(R) ? (e.exit("data"), l(R)) : (e.consume(R), R === 92 ? h : p);
  }
  function h(R) {
    return R === 92 || R === 124 ? (e.consume(R), p) : p(R);
  }
  function d(R) {
    return o.interrupt = !1, o.parser.lazy[o.now().line] ? r(R) : (e.enter("tableDelimiterRow"), s = !1, Ue(R) ? $e(e, f, "linePrefix", o.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(R) : f(R));
  }
  function f(R) {
    return R === 45 || R === 58 ? m(R) : R === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), g) : w(R);
  }
  function g(R) {
    return Ue(R) ? $e(e, m, "whitespace")(R) : m(R);
  }
  function m(R) {
    return R === 58 ? (a += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), v) : R === 45 ? (a += 1, v(R)) : R === null || Bt(R) ? C(R) : w(R);
  }
  function v(R) {
    return R === 45 ? (e.enter("tableDelimiterFiller"), y(R)) : w(R);
  }
  function y(R) {
    return R === 45 ? (e.consume(R), y) : R === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(R), e.exit("tableDelimiterMarker"), S) : (e.exit("tableDelimiterFiller"), S(R));
  }
  function S(R) {
    return Ue(R) ? $e(e, C, "whitespace")(R) : C(R);
  }
  function C(R) {
    return R === 124 ? f(R) : R === null || Bt(R) ? !s || i !== a ? w(R) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(R)) : w(R);
  }
  function w(R) {
    return r(R);
  }
  function b(R) {
    return e.enter("tableRow"), A(R);
  }
  function A(R) {
    return R === 124 ? (e.enter("tableCellDivider"), e.consume(R), e.exit("tableCellDivider"), A) : R === null || Bt(R) ? (e.exit("tableRow"), t(R)) : Ue(R) ? $e(e, A, "whitespace")(R) : (e.enter("data"), E(R));
  }
  function E(R) {
    return R === null || R === 124 || he(R) ? (e.exit("data"), A(R)) : (e.consume(R), R === 92 ? M : E);
  }
  function M(R) {
    return R === 92 || R === 124 ? (e.consume(R), E) : E(R);
  }
}
function tC(e, t) {
  let r = -1, o = !0, i = 0, a = [0, 0, 0, 0], s = [0, 0, 0, 0], n = !1, c = 0, u, l, p;
  const h = new QS();
  for (; ++r < e.length; ) {
    const d = e[r], f = d[1];
    d[0] === "enter" ? f.type === "tableHead" ? (n = !1, c !== 0 && (Oc(h, t, c, u, l), l = void 0, c = 0), u = {
      type: "table",
      start: Object.assign({}, f.start),
      // Note: correct end is set later.
      end: Object.assign({}, f.end)
    }, h.add(r, 0, [["enter", u, t]])) : f.type === "tableRow" || f.type === "tableDelimiterRow" ? (o = !0, p = void 0, a = [0, 0, 0, 0], s = [0, r + 1, 0, 0], n && (n = !1, l = {
      type: "tableBody",
      start: Object.assign({}, f.start),
      // Note: correct end is set later.
      end: Object.assign({}, f.end)
    }, h.add(r, 0, [["enter", l, t]])), i = f.type === "tableDelimiterRow" ? 2 : l ? 3 : 1) : i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") ? (o = !1, s[2] === 0 && (a[1] !== 0 && (s[0] = s[1], p = As(h, t, a, i, void 0, p), a = [0, 0, 0, 0]), s[2] = r)) : f.type === "tableCellDivider" && (o ? o = !1 : (a[1] !== 0 && (s[0] = s[1], p = As(h, t, a, i, void 0, p)), a = s, s = [a[1], r, 0, 0])) : f.type === "tableHead" ? (n = !0, c = r) : f.type === "tableRow" || f.type === "tableDelimiterRow" ? (c = r, a[1] !== 0 ? (s[0] = s[1], p = As(h, t, a, i, r, p)) : s[1] !== 0 && (p = As(h, t, s, i, r, p)), i = 0) : i && (f.type === "data" || f.type === "tableDelimiterMarker" || f.type === "tableDelimiterFiller") && (s[3] = r);
  }
  for (c !== 0 && Oc(h, t, c, u, l), h.consume(t.events), r = -1; ++r < t.events.length; ) {
    const d = t.events[r];
    d[0] === "enter" && d[1].type === "table" && (d[1]._align = ZS(t.events, r));
  }
  return e;
}
function As(e, t, r, o, i, a) {
  const s = o === 1 ? "tableHeader" : o === 2 ? "tableDelimiter" : "tableData", n = "tableContent";
  r[0] !== 0 && (a.end = Object.assign({}, Ft(t.events, r[0])), e.add(r[0], 0, [["exit", a, t]]));
  const c = Ft(t.events, r[1]);
  if (a = {
    type: s,
    start: Object.assign({}, c),
    // Note: correct end is set later.
    end: Object.assign({}, c)
  }, e.add(r[1], 0, [["enter", a, t]]), r[2] !== 0) {
    const u = Ft(t.events, r[2]), l = Ft(t.events, r[3]), p = {
      type: n,
      start: Object.assign({}, u),
      end: Object.assign({}, l)
    };
    if (e.add(r[2], 0, [["enter", p, t]]), o !== 2) {
      const h = t.events[r[2]], d = t.events[r[3]];
      if (h[1].end = Object.assign({}, d[1].end), h[1].type = "chunkText", h[1].contentType = "text", r[3] > r[2] + 1) {
        const f = r[2] + 1, g = r[3] - r[2] - 1;
        e.add(f, g, []);
      }
    }
    e.add(r[3] + 1, 0, [["exit", p, t]]);
  }
  return i !== void 0 && (a.end = Object.assign({}, Ft(t.events, i)), e.add(i, 0, [["exit", a, t]]), a = void 0), a;
}
function Oc(e, t, r, o, i) {
  const a = [], s = Ft(t.events, r);
  i && (i.end = Object.assign({}, s), a.push(["exit", i, t])), o.end = Object.assign({}, s), a.push(["exit", o, t]), e.add(r + 1, 0, a);
}
function Ft(e, t) {
  const r = e[t], o = r[0] === "enter" ? "start" : "end";
  return r[1][o];
}
const rC = {
  name: "tasklistCheck",
  tokenize: iC
};
function nC() {
  return {
    text: {
      91: rC
    }
  };
}
function iC(e, t, r) {
  const o = this;
  return i;
  function i(c) {
    return (
      // Exit if there’s stuff before.
      o.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !o._gfmTasklistFirstContentOfListItem ? r(c) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), a)
    );
  }
  function a(c) {
    return he(c) ? (e.enter("taskListCheckValueUnchecked"), e.consume(c), e.exit("taskListCheckValueUnchecked"), s) : c === 88 || c === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(c), e.exit("taskListCheckValueChecked"), s) : r(c);
  }
  function s(c) {
    return c === 93 ? (e.enter("taskListCheckMarker"), e.consume(c), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), n) : r(c);
  }
  function n(c) {
    return Bt(c) ? t(c) : Ue(c) ? e.check({
      tokenize: sC
    }, t, r)(c) : r(c);
  }
}
function sC(e, t, r) {
  return $e(e, o, "whitespace");
  function o(i) {
    return i === null ? r(i) : t(i);
  }
}
function oC(e) {
  return wS([
    TS(),
    BS(),
    GS(e),
    XS(),
    nC()
  ]);
}
const aC = {};
function qa(e) {
  const t = (
    /** @type {Processor<Root>} */
    this
  ), r = e || aC, o = t.data(), i = o.micromarkExtensions || (o.micromarkExtensions = []), a = o.fromMarkdownExtensions || (o.fromMarkdownExtensions = []), s = o.toMarkdownExtensions || (o.toMarkdownExtensions = []);
  i.push(oC(r)), a.push(RS()), s.push(PS(r));
}
const Ks = async (e, t, r = "en", o, i, a) => {
  try {
    const n = `${i.replace(/\/+$/, "")}/translate?api-version=3.0&from=${r}&to=${t}`, c = await fetch(
      n,
      {
        method: "POST",
        headers: {
          "Ocp-Apim-Subscription-Key": o,
          "Ocp-Apim-Subscription-Region": a,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(e.map((l) => ({ Text: l })))
      }
    );
    if (!c.ok)
      throw new Error(`Translation failed: ${c.statusText}`);
    return (await c.json()).map((l) => l.translations?.[0]?.text || "");
  } catch (s) {
    return console.error("Batch translation error:", s), e;
  }
};
function cC({
  messages: e,
  welcomeMessage: t,
  onSendMessage: r,
  className: o = "",
  isLoading: i = !1,
  rightElement: a,
  suggestedPrompts: s,
  renderMessage: n,
  showRetryButton: c = !1,
  handleRetry: u,
  setInterruptReplica: l,
  language: p,
  config: h
}) {
  const [d, f] = O(""), g = Ve(null), [m, v] = O(!0), y = Ve(null), S = Ve(null), [C, w] = O({ insufficientCredits: "Insufficient Credits", insufficientCreditsDescription: "Please purchase more credits to continue.", placeholder: "Type your message...", suggestedPrompts: "Suggested Prompts", thinking: "Thinking...", retry: "Retry" });
  $(() => {
    setTimeout(() => {
      if (g.current) {
        const R = g.current.closest("[data-radix-scroll-area-viewport]") || y.current;
        R && (R.scrollTop = R.scrollHeight);
      }
    }, 0);
  }, [e, i]), $(() => {
    setTimeout(() => {
      if (g.current) {
        const R = g.current.closest("[data-radix-scroll-area-viewport]") || y.current;
        R && (R.scrollTop = R.scrollHeight);
      }
    }, 0);
  }, []), $(() => {
    (async () => {
      if (p !== "en" && S.current !== p) {
        const [j, T, D, q, pe, W] = await Ks(["Insufficient Credits", "Please purchase more credits to continue.", "Type your message...", "Suggested Prompts", "Thinking...", "Retry", "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload any lab test or medical report. If you don’t have one, lets just talk."], p, "en", h?.azureTranslatorKey || "", h?.azureTranslatorEndpoint || "", h?.azureTranslatorRegion || "");
        w({ insufficientCredits: j, insufficientCreditsDescription: T, placeholder: D, suggestedPrompts: q, thinking: pe, retry: W }), S.current = p;
      }
      p === "en" && S.current !== "en" && (w({ insufficientCredits: "Insufficient Credits", insufficientCreditsDescription: "Please purchase more credits to continue.", placeholder: "Type your message...", suggestedPrompts: "Suggested Prompts", thinking: "Thinking...", retry: "Retry" }), S.current = "en");
    })();
  }, [p, h]);
  const b = () => {
    d.trim() === "" || i || (r(d), f(""));
  }, A = (R) => {
    R.key === "Enter" && !R.shiftKey && (R.preventDefault(), b());
  }, E = (R) => {
    f(R);
  }, M = () => {
    v(!m);
  };
  return /* @__PURE__ */ N("div", { className: `flex flex-col h-full min-h-0 bg-white rounded-lg border border-primary/20 overflow-hidden ${o}`, children: [
    /* @__PURE__ */ P("div", { ref: y, className: "flex-1 min-h-0 overflow-y-auto p-3 bg-white/80", children: /* @__PURE__ */ N("div", { className: "space-y-3", children: [
      e?.length === 0 ? /* @__PURE__ */ N("div", { className: "flex items-start", children: [
        /* @__PURE__ */ P("div", { className: "w-8 h-8 rounded-full bg-[#3f62ec] flex items-center justify-center text-white flex-shrink-0", children: /* @__PURE__ */ P(gc, { size: 14 }) }),
        /* @__PURE__ */ P("div", { className: "ml-2 px-3 py-2 rounded-lg bg-secondary/10", children: /* @__PURE__ */ P("div", { className: "text-sm text-[#3f62ec]", children: t }) })
      ] }) : e?.map((R, j) => {
        const D = j === e.length - 1 && R.sender === "ai", q = c && D && u && R.sender === "ai";
        return /* @__PURE__ */ P(
          "div",
          {
            className: Ce(
              "flex",
              R.sender === "user" ? "justify-end" : "justify-start",
              "mb-4"
            ),
            children: /* @__PURE__ */ N(
              "div",
              {
                className: Ce(
                  "max-w-[80%] rounded-lg p-3",
                  R.sender === "user" ? "bg-[#3f62ec] text-white" : "bg-white text-[#3f62ec]"
                ),
                children: [
                  n ? n(R, j) : R.sender === "user" ? /* @__PURE__ */ P("div", { className: "text-sm", children: R.text }) : /* @__PURE__ */ P("div", { className: "text-sm", children: /* @__PURE__ */ P(xa, { remarkPlugins: [qa], children: R.text }) }),
                  q && /* @__PURE__ */ P("div", { className: "mt-2 flex justify-end", children: /* @__PURE__ */ N(
                    $t,
                    {
                      variant: "ghost",
                      size: "sm",
                      onClick: u,
                      className: "h-6 px-2 text-xs hover:bg-secondary/20",
                      children: [
                        /* @__PURE__ */ P(Ag, { className: "h-3 w-3 mr-1" }),
                        C.retry
                      ]
                    }
                  ) })
                ]
              }
            )
          },
          R.id
        );
      }),
      i && /* @__PURE__ */ N("div", { className: "flex items-start", children: [
        /* @__PURE__ */ P("div", { className: "w-8 h-8 rounded-full bg-[#3f62ec] flex items-center justify-center text-white flex-shrink-0", children: /* @__PURE__ */ P(gc, { size: 14 }) }),
        /* @__PURE__ */ N("div", { className: "ml-2 px-3 py-2 rounded-lg bg-secondary/10 flex items-center", children: [
          /* @__PURE__ */ P(Na, { className: "h-4 w-4 animate-spin mr-2 text-[#3f62ec]" }),
          /* @__PURE__ */ P("span", { className: "text-sm text-secondary", children: C.thinking })
        ] })
      ] }),
      /* @__PURE__ */ P("div", { ref: g })
    ] }) }),
    /* @__PURE__ */ N("div", { className: "p-3 border-t border-light bg-white shrink-0", children: [
      s && s?.length > 0 && /* @__PURE__ */ N("div", { className: "bg-white border-b border-light flex-shrink-0", children: [
        /* @__PURE__ */ N(
          "button",
          {
            onClick: M,
            className: "w-full p-2 flex items-center justify-center hover:bg-secondary/10 transition-colors",
            children: [
              /* @__PURE__ */ P("span", { className: "text-sm font-medium text-secondary", children: C.suggestedPrompts }),
              m ? /* @__PURE__ */ P(Tg, { className: "h-4 w-4 text-secondary" }) : /* @__PURE__ */ P(_g, { className: "h-4 w-4 text-secondary" })
            ]
          }
        ),
        !m && /* @__PURE__ */ P("div", { className: "p-3 grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-2", children: s.map(({ id: R, text: j, icon: T }) => /* @__PURE__ */ N(
          $t,
          {
            variant: "outline",
            className: Ce(
              "w-full justify-start text-left text-sm h-auto min-h-[40px] py-2 px-3",
              "whitespace-normal break-words"
            ),
            onClick: () => E(j),
            children: [
              /* @__PURE__ */ P(T, { className: "h-4 w-4 mr-2 text-primary flex-shrink-0" }),
              /* @__PURE__ */ P("span", { className: "text-left", children: j })
            ]
          },
          R
        )) })
      ] }),
      /* @__PURE__ */ N("div", { className: "flex items-end", children: [
        /* @__PURE__ */ P(
          "textarea",
          {
            value: d,
            onChange: (R) => {
              f(R.target.value), l(!0), R.target.style.height = "auto", R.target.style.height = Math.min(R.target.scrollHeight, 120) + "px";
            },
            onKeyDown: A,
            placeholder: C.placeholder,
            className: "flex-1 rounded-l-lg rounded-r-none focus-visible:ring-0 focus-visible:ring-offset-0 text-[#3f62ec] border-r-0 resize-none min-h-[40px] max-h-[120px] p-3 text-sm border border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
            disabled: i || !1,
            rows: 1
          }
        ),
        /* @__PURE__ */ P(
          $t,
          {
            onClick: b,
            className: "rounded-l-none bg-primary hover:bg-secondary h-[40px]",
            disabled: d.trim() === "" || i,
            children: i ? /* @__PURE__ */ P(Na, { className: "h-5 w-5 animate-spin" }) : /* @__PURE__ */ P(kg, { size: 18 })
          }
        ),
        a && /* @__PURE__ */ P("div", { className: "ml-2", children: a })
      ] })
    ] })
  ] });
}
const Gf = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ P(
  "div",
  {
    ref: r,
    className: Ce(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      e
    ),
    ...t
  }
));
Gf.displayName = "Card";
const uC = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ P(
  "div",
  {
    ref: r,
    className: Ce("flex flex-col space-y-1.5 p-6", e),
    ...t
  }
));
uC.displayName = "CardHeader";
const lC = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ P(
  "h3",
  {
    ref: r,
    className: Ce(
      "text-2xl font-semibold leading-none tracking-tight",
      e
    ),
    ...t
  }
));
lC.displayName = "CardTitle";
const pC = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ P(
  "p",
  {
    ref: r,
    className: Ce("text-sm text-muted-foreground", e),
    ...t
  }
));
pC.displayName = "CardDescription";
const Qf = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ P("div", { ref: r, className: Ce("p-6 pt-0", e), ...t }));
Qf.displayName = "CardContent";
const dC = Z.forwardRef(({ className: e, ...t }, r) => /* @__PURE__ */ P(
  "div",
  {
    ref: r,
    className: Ce("flex items-center p-6 pt-0", e),
    ...t
  }
));
dC.displayName = "CardFooter";
function hC(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function fC(e) {
  if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
  var t = e.default;
  if (typeof t == "function") {
    var r = function o() {
      var i = !1;
      try {
        i = this instanceof o;
      } catch {
      }
      return i ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    r.prototype = t.prototype;
  } else r = {};
  return Object.defineProperty(r, "__esModule", { value: !0 }), Object.keys(e).forEach(function(o) {
    var i = Object.getOwnPropertyDescriptor(e, o);
    Object.defineProperty(r, o, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[o];
      }
    });
  }), r;
}
var ot = {}, at = {}, er = {}, ct = {}, Q = {}, fo = {}, ut = {}, vo = {}, tr = {}, Ts = {}, Mc;
function Yf() {
  if (Mc) return Ts;
  Mc = 1, Object.defineProperty(Ts, "__esModule", {
    value: !0
  }), Ts.default = r;
  let e;
  const t = new Uint8Array(16);
  function r() {
    if (!e && (e = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !e))
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return e(t);
  }
  return Ts;
}
var jt = {}, rr = {}, nr = {}, Dc;
function vC() {
  if (Dc) return nr;
  Dc = 1, Object.defineProperty(nr, "__esModule", {
    value: !0
  }), nr.default = void 0;
  var e = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
  return nr.default = e, nr;
}
var Nc;
function Js() {
  if (Nc) return rr;
  Nc = 1, Object.defineProperty(rr, "__esModule", {
    value: !0
  }), rr.default = void 0;
  var e = t(/* @__PURE__ */ vC());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    return typeof i == "string" && e.default.test(i);
  }
  var o = r;
  return rr.default = o, rr;
}
var xc;
function Gs() {
  if (xc) return jt;
  xc = 1, Object.defineProperty(jt, "__esModule", {
    value: !0
  }), jt.default = void 0, jt.unsafeStringify = o;
  var e = t(/* @__PURE__ */ Js());
  function t(s) {
    return s && s.__esModule ? s : { default: s };
  }
  const r = [];
  for (let s = 0; s < 256; ++s)
    r.push((s + 256).toString(16).slice(1));
  function o(s, n = 0) {
    return r[s[n + 0]] + r[s[n + 1]] + r[s[n + 2]] + r[s[n + 3]] + "-" + r[s[n + 4]] + r[s[n + 5]] + "-" + r[s[n + 6]] + r[s[n + 7]] + "-" + r[s[n + 8]] + r[s[n + 9]] + "-" + r[s[n + 10]] + r[s[n + 11]] + r[s[n + 12]] + r[s[n + 13]] + r[s[n + 14]] + r[s[n + 15]];
  }
  function i(s, n = 0) {
    const c = o(s, n);
    if (!(0, e.default)(c))
      throw TypeError("Stringified UUID is invalid");
    return c;
  }
  var a = i;
  return jt.default = a, jt;
}
var zc;
function gC() {
  if (zc) return tr;
  zc = 1, Object.defineProperty(tr, "__esModule", {
    value: !0
  }), tr.default = void 0;
  var e = r(/* @__PURE__ */ Yf()), t = /* @__PURE__ */ Gs();
  function r(u) {
    return u && u.__esModule ? u : { default: u };
  }
  let o, i, a = 0, s = 0;
  function n(u, l, p) {
    let h = l && p || 0;
    const d = l || new Array(16);
    u = u || {};
    let f = u.node || o, g = u.clockseq !== void 0 ? u.clockseq : i;
    if (f == null || g == null) {
      const w = u.random || (u.rng || e.default)();
      f == null && (f = o = [w[0] | 1, w[1], w[2], w[3], w[4], w[5]]), g == null && (g = i = (w[6] << 8 | w[7]) & 16383);
    }
    let m = u.msecs !== void 0 ? u.msecs : Date.now(), v = u.nsecs !== void 0 ? u.nsecs : s + 1;
    const y = m - a + (v - s) / 1e4;
    if (y < 0 && u.clockseq === void 0 && (g = g + 1 & 16383), (y < 0 || m > a) && u.nsecs === void 0 && (v = 0), v >= 1e4)
      throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    a = m, s = v, i = g, m += 122192928e5;
    const S = ((m & 268435455) * 1e4 + v) % 4294967296;
    d[h++] = S >>> 24 & 255, d[h++] = S >>> 16 & 255, d[h++] = S >>> 8 & 255, d[h++] = S & 255;
    const C = m / 4294967296 * 1e4 & 268435455;
    d[h++] = C >>> 8 & 255, d[h++] = C & 255, d[h++] = C >>> 24 & 15 | 16, d[h++] = C >>> 16 & 255, d[h++] = g >>> 8 | 128, d[h++] = g & 255;
    for (let w = 0; w < 6; ++w)
      d[h + w] = f[w];
    return l || (0, t.unsafeStringify)(d);
  }
  var c = n;
  return tr.default = c, tr;
}
var ir = {}, Ye = {}, sr = {}, Lc;
function Zf() {
  if (Lc) return sr;
  Lc = 1, Object.defineProperty(sr, "__esModule", {
    value: !0
  }), sr.default = void 0;
  var e = t(/* @__PURE__ */ Js());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    if (!(0, e.default)(i))
      throw TypeError("Invalid UUID");
    let a;
    const s = new Uint8Array(16);
    return s[0] = (a = parseInt(i.slice(0, 8), 16)) >>> 24, s[1] = a >>> 16 & 255, s[2] = a >>> 8 & 255, s[3] = a & 255, s[4] = (a = parseInt(i.slice(9, 13), 16)) >>> 8, s[5] = a & 255, s[6] = (a = parseInt(i.slice(14, 18), 16)) >>> 8, s[7] = a & 255, s[8] = (a = parseInt(i.slice(19, 23), 16)) >>> 8, s[9] = a & 255, s[10] = (a = parseInt(i.slice(24, 36), 16)) / 1099511627776 & 255, s[11] = a / 4294967296 & 255, s[12] = a >>> 24 & 255, s[13] = a >>> 16 & 255, s[14] = a >>> 8 & 255, s[15] = a & 255, s;
  }
  var o = r;
  return sr.default = o, sr;
}
var jc;
function Xf() {
  if (jc) return Ye;
  jc = 1, Object.defineProperty(Ye, "__esModule", {
    value: !0
  }), Ye.URL = Ye.DNS = void 0, Ye.default = s;
  var e = /* @__PURE__ */ Gs(), t = r(/* @__PURE__ */ Zf());
  function r(n) {
    return n && n.__esModule ? n : { default: n };
  }
  function o(n) {
    n = unescape(encodeURIComponent(n));
    const c = [];
    for (let u = 0; u < n.length; ++u)
      c.push(n.charCodeAt(u));
    return c;
  }
  const i = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
  Ye.DNS = i;
  const a = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
  Ye.URL = a;
  function s(n, c, u) {
    function l(p, h, d, f) {
      var g;
      if (typeof p == "string" && (p = o(p)), typeof h == "string" && (h = (0, t.default)(h)), ((g = h) === null || g === void 0 ? void 0 : g.length) !== 16)
        throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
      let m = new Uint8Array(16 + p.length);
      if (m.set(h), m.set(p, h.length), m = u(m), m[6] = m[6] & 15 | c, m[8] = m[8] & 63 | 128, d) {
        f = f || 0;
        for (let v = 0; v < 16; ++v)
          d[f + v] = m[v];
        return d;
      }
      return (0, e.unsafeStringify)(m);
    }
    try {
      l.name = n;
    } catch {
    }
    return l.DNS = i, l.URL = a, l;
  }
  return Ye;
}
var or = {}, qc;
function mC() {
  if (qc) return or;
  qc = 1, Object.defineProperty(or, "__esModule", {
    value: !0
  }), or.default = void 0;
  function e(d) {
    if (typeof d == "string") {
      const f = unescape(encodeURIComponent(d));
      d = new Uint8Array(f.length);
      for (let g = 0; g < f.length; ++g)
        d[g] = f.charCodeAt(g);
    }
    return t(o(i(d), d.length * 8));
  }
  function t(d) {
    const f = [], g = d.length * 32, m = "0123456789abcdef";
    for (let v = 0; v < g; v += 8) {
      const y = d[v >> 5] >>> v % 32 & 255, S = parseInt(m.charAt(y >>> 4 & 15) + m.charAt(y & 15), 16);
      f.push(S);
    }
    return f;
  }
  function r(d) {
    return (d + 64 >>> 9 << 4) + 14 + 1;
  }
  function o(d, f) {
    d[f >> 5] |= 128 << f % 32, d[r(f) - 1] = f;
    let g = 1732584193, m = -271733879, v = -1732584194, y = 271733878;
    for (let S = 0; S < d.length; S += 16) {
      const C = g, w = m, b = v, A = y;
      g = c(g, m, v, y, d[S], 7, -680876936), y = c(y, g, m, v, d[S + 1], 12, -389564586), v = c(v, y, g, m, d[S + 2], 17, 606105819), m = c(m, v, y, g, d[S + 3], 22, -1044525330), g = c(g, m, v, y, d[S + 4], 7, -176418897), y = c(y, g, m, v, d[S + 5], 12, 1200080426), v = c(v, y, g, m, d[S + 6], 17, -1473231341), m = c(m, v, y, g, d[S + 7], 22, -45705983), g = c(g, m, v, y, d[S + 8], 7, 1770035416), y = c(y, g, m, v, d[S + 9], 12, -1958414417), v = c(v, y, g, m, d[S + 10], 17, -42063), m = c(m, v, y, g, d[S + 11], 22, -1990404162), g = c(g, m, v, y, d[S + 12], 7, 1804603682), y = c(y, g, m, v, d[S + 13], 12, -40341101), v = c(v, y, g, m, d[S + 14], 17, -1502002290), m = c(m, v, y, g, d[S + 15], 22, 1236535329), g = u(g, m, v, y, d[S + 1], 5, -165796510), y = u(y, g, m, v, d[S + 6], 9, -1069501632), v = u(v, y, g, m, d[S + 11], 14, 643717713), m = u(m, v, y, g, d[S], 20, -373897302), g = u(g, m, v, y, d[S + 5], 5, -701558691), y = u(y, g, m, v, d[S + 10], 9, 38016083), v = u(v, y, g, m, d[S + 15], 14, -660478335), m = u(m, v, y, g, d[S + 4], 20, -405537848), g = u(g, m, v, y, d[S + 9], 5, 568446438), y = u(y, g, m, v, d[S + 14], 9, -1019803690), v = u(v, y, g, m, d[S + 3], 14, -187363961), m = u(m, v, y, g, d[S + 8], 20, 1163531501), g = u(g, m, v, y, d[S + 13], 5, -1444681467), y = u(y, g, m, v, d[S + 2], 9, -51403784), v = u(v, y, g, m, d[S + 7], 14, 1735328473), m = u(m, v, y, g, d[S + 12], 20, -1926607734), g = l(g, m, v, y, d[S + 5], 4, -378558), y = l(y, g, m, v, d[S + 8], 11, -2022574463), v = l(v, y, g, m, d[S + 11], 16, 1839030562), m = l(m, v, y, g, d[S + 14], 23, -35309556), g = l(g, m, v, y, d[S + 1], 4, -1530992060), y = l(y, g, m, v, d[S + 4], 11, 1272893353), v = l(v, y, g, m, d[S + 7], 16, -155497632), m = l(m, v, y, g, d[S + 10], 23, -1094730640), g = l(g, m, v, y, d[S + 13], 4, 681279174), y = l(y, g, m, v, d[S], 11, -358537222), v = l(v, y, g, m, d[S + 3], 16, -722521979), m = l(m, v, y, g, d[S + 6], 23, 76029189), g = l(g, m, v, y, d[S + 9], 4, -640364487), y = l(y, g, m, v, d[S + 12], 11, -421815835), v = l(v, y, g, m, d[S + 15], 16, 530742520), m = l(m, v, y, g, d[S + 2], 23, -995338651), g = p(g, m, v, y, d[S], 6, -198630844), y = p(y, g, m, v, d[S + 7], 10, 1126891415), v = p(v, y, g, m, d[S + 14], 15, -1416354905), m = p(m, v, y, g, d[S + 5], 21, -57434055), g = p(g, m, v, y, d[S + 12], 6, 1700485571), y = p(y, g, m, v, d[S + 3], 10, -1894986606), v = p(v, y, g, m, d[S + 10], 15, -1051523), m = p(m, v, y, g, d[S + 1], 21, -2054922799), g = p(g, m, v, y, d[S + 8], 6, 1873313359), y = p(y, g, m, v, d[S + 15], 10, -30611744), v = p(v, y, g, m, d[S + 6], 15, -1560198380), m = p(m, v, y, g, d[S + 13], 21, 1309151649), g = p(g, m, v, y, d[S + 4], 6, -145523070), y = p(y, g, m, v, d[S + 11], 10, -1120210379), v = p(v, y, g, m, d[S + 2], 15, 718787259), m = p(m, v, y, g, d[S + 9], 21, -343485551), g = a(g, C), m = a(m, w), v = a(v, b), y = a(y, A);
    }
    return [g, m, v, y];
  }
  function i(d) {
    if (d.length === 0)
      return [];
    const f = d.length * 8, g = new Uint32Array(r(f));
    for (let m = 0; m < f; m += 8)
      g[m >> 5] |= (d[m / 8] & 255) << m % 32;
    return g;
  }
  function a(d, f) {
    const g = (d & 65535) + (f & 65535);
    return (d >> 16) + (f >> 16) + (g >> 16) << 16 | g & 65535;
  }
  function s(d, f) {
    return d << f | d >>> 32 - f;
  }
  function n(d, f, g, m, v, y) {
    return a(s(a(a(f, d), a(m, y)), v), g);
  }
  function c(d, f, g, m, v, y, S) {
    return n(f & g | ~f & m, d, f, v, y, S);
  }
  function u(d, f, g, m, v, y, S) {
    return n(f & m | g & ~m, d, f, v, y, S);
  }
  function l(d, f, g, m, v, y, S) {
    return n(f ^ g ^ m, d, f, v, y, S);
  }
  function p(d, f, g, m, v, y, S) {
    return n(g ^ (f | ~m), d, f, v, y, S);
  }
  var h = e;
  return or.default = h, or;
}
var Fc;
function yC() {
  if (Fc) return ir;
  Fc = 1, Object.defineProperty(ir, "__esModule", {
    value: !0
  }), ir.default = void 0;
  var e = r(/* @__PURE__ */ Xf()), t = r(/* @__PURE__ */ mC());
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = (0, e.default)("v3", 48, t.default);
  return ir.default = i, ir;
}
var ar = {}, cr = {}, Bc;
function SC() {
  if (Bc) return cr;
  Bc = 1, Object.defineProperty(cr, "__esModule", {
    value: !0
  }), cr.default = void 0;
  var t = {
    randomUUID: typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto)
  };
  return cr.default = t, cr;
}
var Uc;
function CC() {
  if (Uc) return ar;
  Uc = 1, Object.defineProperty(ar, "__esModule", {
    value: !0
  }), ar.default = void 0;
  var e = o(/* @__PURE__ */ SC()), t = o(/* @__PURE__ */ Yf()), r = /* @__PURE__ */ Gs();
  function o(s) {
    return s && s.__esModule ? s : { default: s };
  }
  function i(s, n, c) {
    if (e.default.randomUUID && !n && !s)
      return e.default.randomUUID();
    s = s || {};
    const u = s.random || (s.rng || t.default)();
    if (u[6] = u[6] & 15 | 64, u[8] = u[8] & 63 | 128, n) {
      c = c || 0;
      for (let l = 0; l < 16; ++l)
        n[c + l] = u[l];
      return n;
    }
    return (0, r.unsafeStringify)(u);
  }
  var a = i;
  return ar.default = a, ar;
}
var ur = {}, lr = {}, $c;
function RC() {
  if ($c) return lr;
  $c = 1, Object.defineProperty(lr, "__esModule", {
    value: !0
  }), lr.default = void 0;
  function e(i, a, s, n) {
    switch (i) {
      case 0:
        return a & s ^ ~a & n;
      case 1:
        return a ^ s ^ n;
      case 2:
        return a & s ^ a & n ^ s & n;
      case 3:
        return a ^ s ^ n;
    }
  }
  function t(i, a) {
    return i << a | i >>> 32 - a;
  }
  function r(i) {
    const a = [1518500249, 1859775393, 2400959708, 3395469782], s = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof i == "string") {
      const l = unescape(encodeURIComponent(i));
      i = [];
      for (let p = 0; p < l.length; ++p)
        i.push(l.charCodeAt(p));
    } else Array.isArray(i) || (i = Array.prototype.slice.call(i));
    i.push(128);
    const n = i.length / 4 + 2, c = Math.ceil(n / 16), u = new Array(c);
    for (let l = 0; l < c; ++l) {
      const p = new Uint32Array(16);
      for (let h = 0; h < 16; ++h)
        p[h] = i[l * 64 + h * 4] << 24 | i[l * 64 + h * 4 + 1] << 16 | i[l * 64 + h * 4 + 2] << 8 | i[l * 64 + h * 4 + 3];
      u[l] = p;
    }
    u[c - 1][14] = (i.length - 1) * 8 / Math.pow(2, 32), u[c - 1][14] = Math.floor(u[c - 1][14]), u[c - 1][15] = (i.length - 1) * 8 & 4294967295;
    for (let l = 0; l < c; ++l) {
      const p = new Uint32Array(80);
      for (let v = 0; v < 16; ++v)
        p[v] = u[l][v];
      for (let v = 16; v < 80; ++v)
        p[v] = t(p[v - 3] ^ p[v - 8] ^ p[v - 14] ^ p[v - 16], 1);
      let h = s[0], d = s[1], f = s[2], g = s[3], m = s[4];
      for (let v = 0; v < 80; ++v) {
        const y = Math.floor(v / 20), S = t(h, 5) + e(y, d, f, g) + m + a[y] + p[v] >>> 0;
        m = g, g = f, f = t(d, 30) >>> 0, d = h, h = S;
      }
      s[0] = s[0] + h >>> 0, s[1] = s[1] + d >>> 0, s[2] = s[2] + f >>> 0, s[3] = s[3] + g >>> 0, s[4] = s[4] + m >>> 0;
    }
    return [s[0] >> 24 & 255, s[0] >> 16 & 255, s[0] >> 8 & 255, s[0] & 255, s[1] >> 24 & 255, s[1] >> 16 & 255, s[1] >> 8 & 255, s[1] & 255, s[2] >> 24 & 255, s[2] >> 16 & 255, s[2] >> 8 & 255, s[2] & 255, s[3] >> 24 & 255, s[3] >> 16 & 255, s[3] >> 8 & 255, s[3] & 255, s[4] >> 24 & 255, s[4] >> 16 & 255, s[4] >> 8 & 255, s[4] & 255];
  }
  var o = r;
  return lr.default = o, lr;
}
var Vc;
function PC() {
  if (Vc) return ur;
  Vc = 1, Object.defineProperty(ur, "__esModule", {
    value: !0
  }), ur.default = void 0;
  var e = r(/* @__PURE__ */ Xf()), t = r(/* @__PURE__ */ RC());
  function r(a) {
    return a && a.__esModule ? a : { default: a };
  }
  var i = (0, e.default)("v5", 80, t.default);
  return ur.default = i, ur;
}
var pr = {}, Wc;
function wC() {
  if (Wc) return pr;
  Wc = 1, Object.defineProperty(pr, "__esModule", {
    value: !0
  }), pr.default = void 0;
  var e = "00000000-0000-0000-0000-000000000000";
  return pr.default = e, pr;
}
var dr = {}, Hc;
function bC() {
  if (Hc) return dr;
  Hc = 1, Object.defineProperty(dr, "__esModule", {
    value: !0
  }), dr.default = void 0;
  var e = t(/* @__PURE__ */ Js());
  function t(i) {
    return i && i.__esModule ? i : { default: i };
  }
  function r(i) {
    if (!(0, e.default)(i))
      throw TypeError("Invalid UUID");
    return parseInt(i.slice(14, 15), 16);
  }
  var o = r;
  return dr.default = o, dr;
}
var Kc;
function EC() {
  return Kc || (Kc = 1, function(e) {
    Object.defineProperty(e, "__esModule", {
      value: !0
    }), Object.defineProperty(e, "NIL", {
      enumerable: !0,
      get: function() {
        return a.default;
      }
    }), Object.defineProperty(e, "parse", {
      enumerable: !0,
      get: function() {
        return u.default;
      }
    }), Object.defineProperty(e, "stringify", {
      enumerable: !0,
      get: function() {
        return c.default;
      }
    }), Object.defineProperty(e, "v1", {
      enumerable: !0,
      get: function() {
        return t.default;
      }
    }), Object.defineProperty(e, "v3", {
      enumerable: !0,
      get: function() {
        return r.default;
      }
    }), Object.defineProperty(e, "v4", {
      enumerable: !0,
      get: function() {
        return o.default;
      }
    }), Object.defineProperty(e, "v5", {
      enumerable: !0,
      get: function() {
        return i.default;
      }
    }), Object.defineProperty(e, "validate", {
      enumerable: !0,
      get: function() {
        return n.default;
      }
    }), Object.defineProperty(e, "version", {
      enumerable: !0,
      get: function() {
        return s.default;
      }
    });
    var t = l(/* @__PURE__ */ gC()), r = l(/* @__PURE__ */ yC()), o = l(/* @__PURE__ */ CC()), i = l(/* @__PURE__ */ PC()), a = l(/* @__PURE__ */ wC()), s = l(/* @__PURE__ */ bC()), n = l(/* @__PURE__ */ Js()), c = l(/* @__PURE__ */ Gs()), u = l(/* @__PURE__ */ Zf());
    function l(p) {
      return p && p.__esModule ? p : { default: p };
    }
  }(vo)), vo;
}
var Jc;
function Dt() {
  if (Jc) return ut;
  Jc = 1, Object.defineProperty(ut, "__esModule", { value: !0 }), ut.createNoDashGuid = ut.createGuid = void 0;
  const e = /* @__PURE__ */ EC(), t = () => (0, e.v4)();
  ut.createGuid = t;
  const r = () => t().replace(new RegExp("-", "g"), "").toUpperCase();
  return ut.createNoDashGuid = r, ut;
}
var Gc;
function ys() {
  return Gc || (Gc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PlatformEvent = e.EventType = void 0;
    const t = /* @__PURE__ */ Dt();
    (function(o) {
      o[o.Debug = 0] = "Debug", o[o.Info = 1] = "Info", o[o.Warning = 2] = "Warning", o[o.Error = 3] = "Error", o[o.None = 4] = "None";
    })(e.EventType || (e.EventType = {}));
    class r {
      constructor(i, a) {
        this.privName = i, this.privEventId = (0, t.createNoDashGuid)(), this.privEventTime = (/* @__PURE__ */ new Date()).toISOString(), this.privEventType = a, this.privMetadata = {};
      }
      get name() {
        return this.privName;
      }
      get eventId() {
        return this.privEventId;
      }
      get eventTime() {
        return this.privEventTime;
      }
      get eventType() {
        return this.privEventType;
      }
      get metadata() {
        return this.privMetadata;
      }
    }
    e.PlatformEvent = r;
  }(fo)), fo;
}
var Qc;
function IC() {
  if (Qc) return Q;
  Qc = 1, Object.defineProperty(Q, "__esModule", { value: !0 }), Q.AudioStreamNodeErrorEvent = Q.AudioStreamNodeDetachedEvent = Q.AudioStreamNodeAttachedEvent = Q.AudioStreamNodeAttachingEvent = Q.AudioStreamNodeEvent = Q.AudioSourceErrorEvent = Q.AudioSourceOffEvent = Q.AudioSourceReadyEvent = Q.AudioSourceInitializingEvent = Q.AudioSourceEvent = void 0;
  const e = /* @__PURE__ */ ys();
  class t extends e.PlatformEvent {
    constructor(h, d, f = e.EventType.Info) {
      super(h, f), this.privAudioSourceId = d;
    }
    get audioSourceId() {
      return this.privAudioSourceId;
    }
  }
  Q.AudioSourceEvent = t;
  class r extends t {
    constructor(h) {
      super("AudioSourceInitializingEvent", h);
    }
  }
  Q.AudioSourceInitializingEvent = r;
  class o extends t {
    constructor(h) {
      super("AudioSourceReadyEvent", h);
    }
  }
  Q.AudioSourceReadyEvent = o;
  class i extends t {
    constructor(h) {
      super("AudioSourceOffEvent", h);
    }
  }
  Q.AudioSourceOffEvent = i;
  class a extends t {
    constructor(h, d) {
      super("AudioSourceErrorEvent", h, e.EventType.Error), this.privError = d;
    }
    get error() {
      return this.privError;
    }
  }
  Q.AudioSourceErrorEvent = a;
  class s extends t {
    constructor(h, d, f) {
      super(h, d), this.privAudioNodeId = f;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
  }
  Q.AudioStreamNodeEvent = s;
  class n extends s {
    constructor(h, d) {
      super("AudioStreamNodeAttachingEvent", h, d);
    }
  }
  Q.AudioStreamNodeAttachingEvent = n;
  class c extends s {
    constructor(h, d) {
      super("AudioStreamNodeAttachedEvent", h, d);
    }
  }
  Q.AudioStreamNodeAttachedEvent = c;
  class u extends s {
    constructor(h, d) {
      super("AudioStreamNodeDetachedEvent", h, d);
    }
  }
  Q.AudioStreamNodeDetachedEvent = u;
  class l extends s {
    constructor(h, d, f) {
      super("AudioStreamNodeErrorEvent", h, d), this.privError = f;
    }
    get error() {
      return this.privError;
    }
  }
  return Q.AudioStreamNodeErrorEvent = l, Q;
}
var Y = {}, Yc;
function AC() {
  if (Yc) return Y;
  Yc = 1, Object.defineProperty(Y, "__esModule", { value: !0 }), Y.ConnectionRedirectEvent = Y.ConnectionMessageSentEvent = Y.ConnectionMessageReceivedEvent = Y.ConnectionEstablishErrorEvent = Y.ConnectionErrorEvent = Y.ConnectionClosedEvent = Y.ConnectionEstablishedEvent = Y.ConnectionStartEvent = Y.ConnectionEvent = Y.ServiceEvent = void 0;
  const e = /* @__PURE__ */ ys();
  class t extends e.PlatformEvent {
    constructor(h, d, f = e.EventType.Info) {
      super(h, f), this.privJsonResult = d;
    }
    get jsonString() {
      return this.privJsonResult;
    }
  }
  Y.ServiceEvent = t;
  class r extends e.PlatformEvent {
    constructor(h, d, f = e.EventType.Info) {
      super(h, f), this.privConnectionId = d;
    }
    get connectionId() {
      return this.privConnectionId;
    }
  }
  Y.ConnectionEvent = r;
  class o extends r {
    constructor(h, d, f) {
      super("ConnectionStartEvent", h), this.privUri = d, this.privHeaders = f;
    }
    get uri() {
      return this.privUri;
    }
    get headers() {
      return this.privHeaders;
    }
  }
  Y.ConnectionStartEvent = o;
  class i extends r {
    constructor(h) {
      super("ConnectionEstablishedEvent", h);
    }
  }
  Y.ConnectionEstablishedEvent = i;
  class a extends r {
    constructor(h, d, f) {
      super("ConnectionClosedEvent", h, e.EventType.Debug), this.privReason = f, this.privStatusCode = d;
    }
    get reason() {
      return this.privReason;
    }
    get statusCode() {
      return this.privStatusCode;
    }
  }
  Y.ConnectionClosedEvent = a;
  class s extends r {
    constructor(h, d, f) {
      super("ConnectionErrorEvent", h, e.EventType.Debug), this.privMessage = d, this.privType = f;
    }
    get message() {
      return this.privMessage;
    }
    get type() {
      return this.privType;
    }
  }
  Y.ConnectionErrorEvent = s;
  class n extends r {
    constructor(h, d, f) {
      super("ConnectionEstablishErrorEvent", h, e.EventType.Error), this.privStatusCode = d, this.privReason = f;
    }
    get reason() {
      return this.privReason;
    }
    get statusCode() {
      return this.privStatusCode;
    }
  }
  Y.ConnectionEstablishErrorEvent = n;
  class c extends r {
    constructor(h, d, f) {
      super("ConnectionMessageReceivedEvent", h), this.privNetworkReceivedTime = d, this.privMessage = f;
    }
    get networkReceivedTime() {
      return this.privNetworkReceivedTime;
    }
    get message() {
      return this.privMessage;
    }
  }
  Y.ConnectionMessageReceivedEvent = c;
  class u extends r {
    constructor(h, d, f) {
      super("ConnectionMessageSentEvent", h), this.privNetworkSentTime = d, this.privMessage = f;
    }
    get networkSentTime() {
      return this.privNetworkSentTime;
    }
    get message() {
      return this.privMessage;
    }
  }
  Y.ConnectionMessageSentEvent = u;
  class l extends r {
    constructor(h, d, f, g) {
      super("ConnectionRedirectEvent", h, e.EventType.Info), this.privRedirectUrl = d, this.privOriginalUrl = f, this.privContext = g;
    }
    get redirectUrl() {
      return this.privRedirectUrl;
    }
    get originalUrl() {
      return this.privOriginalUrl;
    }
    get context() {
      return this.privContext;
    }
  }
  return Y.ConnectionRedirectEvent = l, Y;
}
var go = {}, je = {}, Zc;
function Ne() {
  if (Zc) return je;
  Zc = 1, Object.defineProperty(je, "__esModule", { value: !0 }), je.ObjectDisposedError = je.InvalidOperationError = je.ArgumentNullError = void 0;
  class e extends Error {
    /**
     * Creates an instance of ArgumentNullError.
     *
     * @param {string} argumentName - Name of the argument that is null
     *
     * @memberOf ArgumentNullError
     */
    constructor(i) {
      super(i), this.name = "ArgumentNull", this.message = i;
    }
  }
  je.ArgumentNullError = e;
  class t extends Error {
    /**
     * Creates an instance of InvalidOperationError.
     *
     * @param {string} error - The error
     *
     * @memberOf InvalidOperationError
     */
    constructor(i) {
      super(i), this.name = "InvalidOperation", this.message = i;
    }
  }
  je.InvalidOperationError = t;
  class r extends Error {
    /**
     * Creates an instance of ObjectDisposedError.
     *
     * @param {string} objectName - The object that is disposed
     * @param {string} error - The error
     *
     * @memberOf ObjectDisposedError
     */
    constructor(i, a) {
      super(a), this.name = i + "ObjectDisposed", this.message = a;
    }
  }
  return je.ObjectDisposedError = r, je;
}
var Xc;
function ev() {
  return Xc || (Xc = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionMessage = e.MessageType = void 0;
    const t = /* @__PURE__ */ Ne(), r = /* @__PURE__ */ Dt();
    var o;
    (function(a) {
      a[a.Text = 0] = "Text", a[a.Binary = 1] = "Binary";
    })(o = e.MessageType || (e.MessageType = {}));
    class i {
      constructor(s, n, c, u) {
        if (this.privBody = null, s === o.Text && n && typeof n != "string")
          throw new t.InvalidOperationError("Payload must be a string");
        if (s === o.Binary && n && !(n instanceof ArrayBuffer))
          throw new t.InvalidOperationError("Payload must be ArrayBuffer");
        switch (this.privMessageType = s, this.privBody = n, this.privHeaders = c || {}, this.privId = u || (0, r.createNoDashGuid)(), this.messageType) {
          case o.Binary:
            this.privSize = this.binaryBody !== null ? this.binaryBody.byteLength : 0;
            break;
          case o.Text:
            this.privSize = this.textBody.length;
        }
      }
      get messageType() {
        return this.privMessageType;
      }
      get headers() {
        return this.privHeaders;
      }
      get body() {
        return this.privBody;
      }
      get textBody() {
        if (this.privMessageType === o.Binary)
          throw new t.InvalidOperationError("Not supported for binary message");
        return this.privBody;
      }
      get binaryBody() {
        if (this.privMessageType === o.Text)
          throw new t.InvalidOperationError("Not supported for text message");
        return this.privBody;
      }
      get id() {
        return this.privId;
      }
    }
    e.ConnectionMessage = i;
  }(go)), go;
}
var hr = {}, eu;
function TC() {
  if (eu) return hr;
  eu = 1, Object.defineProperty(hr, "__esModule", { value: !0 }), hr.ConnectionOpenResponse = void 0;
  let e = class {
    constructor(r, o) {
      this.privStatusCode = r, this.privReason = o;
    }
    get statusCode() {
      return this.privStatusCode;
    }
    get reason() {
      return this.privReason;
    }
  };
  return hr.ConnectionOpenResponse = e, hr;
}
var fr = {}, tu;
function _C() {
  if (tu) return fr;
  tu = 1, Object.defineProperty(fr, "__esModule", { value: !0 }), fr.DeferralMap = void 0;
  let e = class {
    constructor() {
      this.privMap = {};
    }
    add(r, o) {
      this.privMap[r] = o;
    }
    getId(r) {
      return this.privMap[r];
    }
    complete(r, o) {
      try {
        this.privMap[r].resolve(o);
      } catch (i) {
        this.privMap[r].reject(i);
      } finally {
        this.privMap[r] = void 0;
      }
    }
  };
  return fr.DeferralMap = e, fr;
}
var lt = {}, ru;
function tv() {
  if (ru) return lt;
  ru = 1, Object.defineProperty(lt, "__esModule", { value: !0 }), lt.SendingAgentContextMessageEvent = lt.DialogEvent = void 0;
  const e = /* @__PURE__ */ ys();
  class t extends e.PlatformEvent {
    constructor(i, a = e.EventType.Info) {
      super(i, a);
    }
  }
  lt.DialogEvent = t;
  class r extends t {
    constructor(i) {
      super("SendingAgentContextMessageEvent"), this.privAgentConfig = i;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
  }
  return lt.SendingAgentContextMessageEvent = r, lt;
}
var vr = {}, gr = {}, nu;
function rv() {
  if (nu) return gr;
  nu = 1, Object.defineProperty(gr, "__esModule", { value: !0 }), gr.EventSource = void 0;
  const e = /* @__PURE__ */ Ne(), t = /* @__PURE__ */ Dt();
  let r = class {
    constructor(i) {
      this.privEventListeners = {}, this.privIsDisposed = !1, this.privConsoleListener = void 0, this.privMetadata = i;
    }
    onEvent(i) {
      if (this.isDisposed())
        throw new e.ObjectDisposedError("EventSource");
      if (this.metadata)
        for (const a in this.metadata)
          a && i.metadata && (i.metadata[a] || (i.metadata[a] = this.metadata[a]));
      for (const a in this.privEventListeners)
        a && this.privEventListeners[a] && this.privEventListeners[a](i);
    }
    attach(i) {
      const a = (0, t.createNoDashGuid)();
      return this.privEventListeners[a] = i, {
        detach: () => (delete this.privEventListeners[a], Promise.resolve())
      };
    }
    attachListener(i) {
      return this.attach((a) => i.onEvent(a));
    }
    attachConsoleListener(i) {
      return this.privConsoleListener && this.privConsoleListener.detach(), this.privConsoleListener = this.attach((a) => i.onEvent(a)), this.privConsoleListener;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.privEventListeners = null, this.privIsDisposed = !0;
    }
    get metadata() {
      return this.privMetadata;
    }
  };
  return gr.EventSource = r, gr;
}
var iu;
function kC() {
  if (iu) return vr;
  iu = 1, Object.defineProperty(vr, "__esModule", { value: !0 }), vr.Events = void 0;
  const e = /* @__PURE__ */ Ne(), t = /* @__PURE__ */ rv();
  let r = class Fa {
    static setEventSource(i) {
      if (!i)
        throw new e.ArgumentNullError("eventSource");
      Fa.privInstance = i;
    }
    static get instance() {
      return Fa.privInstance;
    }
  };
  return vr.Events = r, r.privInstance = new t.EventSource(), vr;
}
var mo = {}, su;
function OC() {
  return su || (su = 1, Object.defineProperty(mo, "__esModule", { value: !0 })), mo;
}
var yo = {}, ou;
function MC() {
  return ou || (ou = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionState = void 0, function(t) {
      t[t.None = 0] = "None", t[t.Connected = 1] = "Connected", t[t.Connecting = 2] = "Connecting", t[t.Disconnected = 3] = "Disconnected";
    }(e.ConnectionState || (e.ConnectionState = {}));
  }(yo)), yo;
}
var So = {}, au;
function DC() {
  return au || (au = 1, Object.defineProperty(So, "__esModule", { value: !0 })), So;
}
var Co = {}, cu;
function NC() {
  return cu || (cu = 1, Object.defineProperty(Co, "__esModule", { value: !0 })), Co;
}
var Ro = {}, uu;
function xC() {
  return uu || (uu = 1, Object.defineProperty(Ro, "__esModule", { value: !0 })), Ro;
}
var Po = {}, lu;
function zC() {
  return lu || (lu = 1, Object.defineProperty(Po, "__esModule", { value: !0 })), Po;
}
var wo = {}, pu;
function LC() {
  return pu || (pu = 1, Object.defineProperty(wo, "__esModule", { value: !0 })), wo;
}
var bo = {}, du;
function jC() {
  return du || (du = 1, Object.defineProperty(bo, "__esModule", { value: !0 })), bo;
}
var Eo = {}, hu;
function qC() {
  return hu || (hu = 1, Object.defineProperty(Eo, "__esModule", { value: !0 })), Eo;
}
var Io = {}, fu;
function FC() {
  return fu || (fu = 1, Object.defineProperty(Io, "__esModule", { value: !0 })), Io;
}
var mr = {}, vu;
function nv() {
  if (vu) return mr;
  vu = 1, Object.defineProperty(mr, "__esModule", { value: !0 }), mr.List = void 0;
  const e = /* @__PURE__ */ Ne();
  let t = class _t {
    constructor(o) {
      if (this.privSubscriptionIdCounter = 0, this.privAddSubscriptions = {}, this.privRemoveSubscriptions = {}, this.privDisposedSubscriptions = {}, this.privDisposeReason = null, this.privList = [], o)
        for (const i of o)
          this.privList.push(i);
    }
    get(o) {
      return this.throwIfDisposed(), this.privList[o];
    }
    first() {
      return this.get(0);
    }
    last() {
      return this.get(this.length() - 1);
    }
    add(o) {
      this.throwIfDisposed(), this.insertAt(this.privList.length, o);
    }
    insertAt(o, i) {
      this.throwIfDisposed(), o === 0 ? this.privList.unshift(i) : o === this.privList.length ? this.privList.push(i) : this.privList.splice(o, 0, i), this.triggerSubscriptions(this.privAddSubscriptions);
    }
    removeFirst() {
      return this.throwIfDisposed(), this.removeAt(0);
    }
    removeLast() {
      return this.throwIfDisposed(), this.removeAt(this.length() - 1);
    }
    removeAt(o) {
      return this.throwIfDisposed(), this.remove(o, 1)[0];
    }
    remove(o, i) {
      this.throwIfDisposed();
      const a = this.privList.splice(o, i);
      return this.triggerSubscriptions(this.privRemoveSubscriptions), a;
    }
    clear() {
      this.throwIfDisposed(), this.remove(0, this.length());
    }
    length() {
      return this.throwIfDisposed(), this.privList.length;
    }
    onAdded(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privAddSubscriptions[i] = o, {
        detach: () => (delete this.privAddSubscriptions[i], Promise.resolve())
      };
    }
    onRemoved(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privRemoveSubscriptions[i] = o, {
        detach: () => (delete this.privRemoveSubscriptions[i], Promise.resolve())
      };
    }
    onDisposed(o) {
      this.throwIfDisposed();
      const i = this.privSubscriptionIdCounter++;
      return this.privDisposedSubscriptions[i] = o, {
        detach: () => (delete this.privDisposedSubscriptions[i], Promise.resolve())
      };
    }
    join(o) {
      return this.throwIfDisposed(), this.privList.join(o);
    }
    toArray() {
      const o = Array();
      return this.privList.forEach((i) => {
        o.push(i);
      }), o;
    }
    any(o) {
      return this.throwIfDisposed(), o ? this.where(o).length() > 0 : this.length() > 0;
    }
    all(o) {
      return this.throwIfDisposed(), this.where(o).length() === this.length();
    }
    forEach(o) {
      this.throwIfDisposed();
      for (let i = 0; i < this.length(); i++)
        o(this.privList[i], i);
    }
    select(o) {
      this.throwIfDisposed();
      const i = [];
      for (let a = 0; a < this.privList.length; a++)
        i.push(o(this.privList[a], a));
      return new _t(i);
    }
    where(o) {
      this.throwIfDisposed();
      const i = new _t();
      for (let a = 0; a < this.privList.length; a++)
        o(this.privList[a], a) && i.add(this.privList[a]);
      return i;
    }
    orderBy(o) {
      this.throwIfDisposed();
      const a = this.toArray().sort(o);
      return new _t(a);
    }
    orderByDesc(o) {
      return this.throwIfDisposed(), this.orderBy((i, a) => o(a, i));
    }
    clone() {
      return this.throwIfDisposed(), new _t(this.toArray());
    }
    concat(o) {
      return this.throwIfDisposed(), new _t(this.privList.concat(o.toArray()));
    }
    concatArray(o) {
      return this.throwIfDisposed(), new _t(this.privList.concat(o));
    }
    isDisposed() {
      return this.privList == null;
    }
    dispose(o) {
      this.isDisposed() || (this.privDisposeReason = o, this.privList = null, this.privAddSubscriptions = null, this.privRemoveSubscriptions = null, this.triggerSubscriptions(this.privDisposedSubscriptions));
    }
    throwIfDisposed() {
      if (this.isDisposed())
        throw new e.ObjectDisposedError("List", this.privDisposeReason);
    }
    triggerSubscriptions(o) {
      if (o)
        for (const i in o)
          i && o[i]();
    }
  };
  return mr.List = t, mr;
}
var Ao = {}, gu;
function iv() {
  return gu || (gu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.marshalPromiseToCallbacks = e.Sink = e.Deferred = e.PromiseResultEventSource = e.PromiseResult = e.PromiseState = void 0;
    var t;
    (function(n) {
      n[n.None = 0] = "None", n[n.Resolved = 1] = "Resolved", n[n.Rejected = 2] = "Rejected";
    })(t = e.PromiseState || (e.PromiseState = {}));
    class r {
      constructor(c) {
        this.throwIfError = () => {
          if (this.isError)
            throw this.error;
        }, c.on((u) => {
          this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !1, this.privResult = u);
        }, (u) => {
          this.privIsCompleted || (this.privIsCompleted = !0, this.privIsError = !0, this.privError = u);
        });
      }
      get isCompleted() {
        return this.privIsCompleted;
      }
      get isError() {
        return this.privIsError;
      }
      get error() {
        return this.privError;
      }
      get result() {
        return this.privResult;
      }
    }
    e.PromiseResult = r;
    class o {
      constructor() {
        this.setResult = (c) => {
          this.privOnSetResult(c);
        }, this.setError = (c) => {
          this.privOnSetError(c);
        }, this.on = (c, u) => {
          this.privOnSetResult = c, this.privOnSetError = u;
        };
      }
    }
    e.PromiseResultEventSource = o;
    class i {
      constructor() {
        this.resolve = (c) => (this.privResolve(c), this), this.reject = (c) => (this.privReject(c), this), this.privPromise = new Promise((c, u) => {
          this.privResolve = c, this.privReject = u;
        });
      }
      get promise() {
        return this.privPromise;
      }
    }
    e.Deferred = i;
    class a {
      constructor() {
        this.privState = t.None, this.privPromiseResult = null, this.privPromiseResultEvents = null, this.privSuccessHandlers = [], this.privErrorHandlers = [], this.privPromiseResultEvents = new o(), this.privPromiseResult = new r(this.privPromiseResultEvents);
      }
      get state() {
        return this.privState;
      }
      get result() {
        return this.privPromiseResult;
      }
      resolve(c) {
        if (this.privState !== t.None)
          throw new Error("'Cannot resolve a completed promise'");
        this.privState = t.Resolved, this.privPromiseResultEvents.setResult(c);
        for (let u = 0; u < this.privSuccessHandlers.length; u++)
          this.executeSuccessCallback(c, this.privSuccessHandlers[u], this.privErrorHandlers[u]);
        this.detachHandlers();
      }
      reject(c) {
        if (this.privState !== t.None)
          throw new Error("'Cannot reject a completed promise'");
        this.privState = t.Rejected, this.privPromiseResultEvents.setError(c);
        for (const u of this.privErrorHandlers)
          this.executeErrorCallback(c, u);
        this.detachHandlers();
      }
      on(c, u) {
        c == null && (c = () => {
        }), this.privState === t.None ? (this.privSuccessHandlers.push(c), this.privErrorHandlers.push(u)) : (this.privState === t.Resolved ? this.executeSuccessCallback(this.privPromiseResult.result, c, u) : this.privState === t.Rejected && this.executeErrorCallback(this.privPromiseResult.error, u), this.detachHandlers());
      }
      executeSuccessCallback(c, u, l) {
        try {
          u(c);
        } catch (p) {
          this.executeErrorCallback(`'Unhandled callback error: ${p}'`, l);
        }
      }
      executeErrorCallback(c, u) {
        if (u)
          try {
            u(c);
          } catch (l) {
            throw new Error(`'Unhandled callback error: ${l}. InnerError: ${c}'`);
          }
        else
          throw new Error(`'Unhandled error: ${c}'`);
      }
      detachHandlers() {
        this.privErrorHandlers = [], this.privSuccessHandlers = [];
      }
    }
    e.Sink = a;
    function s(n, c, u) {
      n.then((l) => {
        try {
          c && c(l);
        } catch (p) {
          if (u)
            try {
              if (p instanceof Error) {
                const h = p;
                u(h.name + ": " + h.message);
              } else
                u(p);
            } catch {
            }
        }
      }, (l) => {
        if (u)
          try {
            if (l instanceof Error) {
              const p = l;
              u(p.name + ": " + p.message);
            } else
              u(l);
          } catch {
          }
      });
    }
    e.marshalPromiseToCallbacks = s;
  }(Ao)), Ao;
}
var yr = {}, mu;
function sv() {
  if (mu) return yr;
  mu = 1, Object.defineProperty(yr, "__esModule", { value: !0 }), yr.Queue = void 0;
  const e = /* @__PURE__ */ Ne(), t = /* @__PURE__ */ nv(), r = /* @__PURE__ */ iv();
  var o;
  (function(a) {
    a[a.Dequeue = 0] = "Dequeue", a[a.Peek = 1] = "Peek";
  })(o || (o = {}));
  let i = class {
    constructor(s) {
      this.privPromiseStore = new t.List(), this.privIsDrainInProgress = !1, this.privIsDisposing = !1, this.privDisposeReason = null, this.privList = s || new t.List(), this.privDetachables = [], this.privSubscribers = new t.List(), this.privDetachables.push(this.privList.onAdded(() => this.drain()));
    }
    enqueue(s) {
      this.throwIfDispose(), this.enqueueFromPromise(new Promise((n) => n(s)));
    }
    enqueueFromPromise(s) {
      this.throwIfDispose(), s.then((n) => {
        this.privList.add(n);
      }, () => {
      });
    }
    dequeue() {
      this.throwIfDispose();
      const s = new r.Deferred();
      return this.privSubscribers && (this.privSubscribers.add({ deferral: s, type: o.Dequeue }), this.drain()), s.promise;
    }
    peek() {
      this.throwIfDispose();
      const s = new r.Deferred();
      return this.privSubscribers && (this.privSubscribers.add({ deferral: s, type: o.Peek }), this.drain()), s.promise;
    }
    length() {
      return this.throwIfDispose(), this.privList.length();
    }
    isDisposed() {
      return this.privSubscribers == null;
    }
    async drainAndDispose(s, n) {
      if (!this.isDisposed() && !this.privIsDisposing) {
        this.privDisposeReason = n, this.privIsDisposing = !0;
        const c = this.privSubscribers;
        if (c) {
          for (; c.length() > 0; )
            c.removeFirst().deferral.resolve(void 0);
          this.privSubscribers === c && (this.privSubscribers = c);
        }
        for (const u of this.privDetachables)
          await u.detach();
        if (this.privPromiseStore.length() > 0 && s) {
          const u = [];
          return this.privPromiseStore.toArray().forEach((l) => {
            u.push(l);
          }), Promise.all(u).finally(() => {
            this.privSubscribers = null, this.privList.forEach((l) => {
              s(l);
            }), this.privList = null;
          }).then();
        } else
          this.privSubscribers = null, this.privList = null;
      }
    }
    async dispose(s) {
      await this.drainAndDispose(null, s);
    }
    drain() {
      if (!this.privIsDrainInProgress && !this.privIsDisposing) {
        this.privIsDrainInProgress = !0;
        const s = this.privSubscribers, n = this.privList;
        if (s && n) {
          for (; n.length() > 0 && s.length() > 0 && !this.privIsDisposing; ) {
            const c = s.removeFirst();
            if (c.type === o.Peek)
              c.deferral.resolve(n.first());
            else {
              const u = n.removeFirst();
              c.deferral.resolve(u);
            }
          }
          this.privSubscribers === s && (this.privSubscribers = s), this.privList === n && (this.privList = n);
        }
        this.privIsDrainInProgress = !1;
      }
    }
    throwIfDispose() {
      if (this.isDisposed())
        throw this.privDisposeReason ? new e.InvalidOperationError(this.privDisposeReason) : new e.ObjectDisposedError("Queue");
      if (this.privIsDisposing)
        throw new e.InvalidOperationError("Queue disposing");
    }
  };
  return yr.Queue = i, yr;
}
var Sr = {}, yu;
function BC() {
  if (yu) return Sr;
  yu = 1, Object.defineProperty(Sr, "__esModule", { value: !0 }), Sr.RawWebsocketMessage = void 0;
  const e = /* @__PURE__ */ ev(), t = /* @__PURE__ */ Ne(), r = /* @__PURE__ */ Dt();
  let o = class {
    constructor(a, s, n) {
      if (this.privPayload = null, !s)
        throw new t.ArgumentNullError("payload");
      if (a === e.MessageType.Binary && Object.getPrototypeOf(s).constructor.name !== "ArrayBuffer")
        throw new t.InvalidOperationError("Payload must be ArrayBuffer");
      if (a === e.MessageType.Text && typeof s != "string")
        throw new t.InvalidOperationError("Payload must be a string");
      this.privMessageType = a, this.privPayload = s, this.privId = n || (0, r.createNoDashGuid)();
    }
    get messageType() {
      return this.privMessageType;
    }
    get payload() {
      return this.privPayload;
    }
    get textContent() {
      if (this.privMessageType === e.MessageType.Binary)
        throw new t.InvalidOperationError("Not supported for binary message");
      return this.privPayload;
    }
    get binaryContent() {
      if (this.privMessageType === e.MessageType.Text)
        throw new t.InvalidOperationError("Not supported for text message");
      return this.privPayload;
    }
    get id() {
      return this.privId;
    }
  };
  return Sr.RawWebsocketMessage = o, Sr;
}
var Cr = {}, Su;
function UC() {
  if (Su) return Cr;
  Su = 1, Object.defineProperty(Cr, "__esModule", { value: !0 }), Cr.RiffPcmEncoder = void 0;
  let e = class {
    constructor(r, o) {
      this.privActualSampleRate = r, this.privDesiredSampleRate = o;
    }
    encode(r) {
      const o = this.downSampleAudioFrame(r, this.privActualSampleRate, this.privDesiredSampleRate);
      if (!o)
        return null;
      const i = o.length * 2, a = new ArrayBuffer(i), s = new DataView(a);
      return this.floatTo16BitPCM(s, 0, o), a;
    }
    setString(r, o, i) {
      for (let a = 0; a < i.length; a++)
        r.setUint8(o + a, i.charCodeAt(a));
    }
    floatTo16BitPCM(r, o, i) {
      for (let a = 0; a < i.length; a++, o += 2) {
        const s = Math.max(-1, Math.min(1, i[a]));
        r.setInt16(o, s < 0 ? s * 32768 : s * 32767, !0);
      }
    }
    downSampleAudioFrame(r, o, i) {
      if (!r)
        return null;
      if (i === o || i > o)
        return r;
      const a = o / i, s = Math.round(r.length / a), n = new Float32Array(s);
      let c = 0, u = 0;
      for (; u < s; ) {
        const l = Math.round((u + 1) * a);
        let p = 0, h = 0;
        for (; c < l && c < r.length; )
          p += r[c++], h++;
        n[u++] = p / h;
      }
      return n;
    }
  };
  return Cr.RiffPcmEncoder = e, Cr;
}
var Rr = {}, Cu;
function $C() {
  if (Cu) return Rr;
  Cu = 1, Object.defineProperty(Rr, "__esModule", { value: !0 }), Rr.Stream = void 0;
  const e = /* @__PURE__ */ Ne(), t = /* @__PURE__ */ Dt(), r = /* @__PURE__ */ sv();
  let o = class {
    constructor(a) {
      this.privIsWriteEnded = !1, this.privIsReadEnded = !1, this.privId = a || (0, t.createNoDashGuid)(), this.privReaderQueue = new r.Queue();
    }
    get isClosed() {
      return this.privIsWriteEnded;
    }
    get isReadEnded() {
      return this.privIsReadEnded;
    }
    get id() {
      return this.privId;
    }
    close() {
      this.privIsWriteEnded || (this.writeStreamChunk({
        buffer: null,
        isEnd: !0,
        timeReceived: Date.now()
      }), this.privIsWriteEnded = !0);
    }
    writeStreamChunk(a) {
      if (this.throwIfClosed(), !this.privReaderQueue.isDisposed())
        try {
          this.privReaderQueue.enqueue(a);
        } catch {
        }
    }
    read() {
      if (this.privIsReadEnded)
        throw new e.InvalidOperationError("Stream read has already finished");
      return this.privReaderQueue.dequeue().then(async (a) => ((a === void 0 || a.isEnd) && await this.privReaderQueue.dispose("End of stream reached"), a));
    }
    readEnded() {
      this.privIsReadEnded || (this.privIsReadEnded = !0, this.privReaderQueue = new r.Queue());
    }
    throwIfClosed() {
      if (this.privIsWriteEnded)
        throw new e.InvalidOperationError("Stream closed");
    }
  };
  return Rr.Stream = o, Rr;
}
var To = {}, Ru;
function oc() {
  return Ru || (Ru = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TranslationStatus = void 0, function(t) {
      t[t.Success = 0] = "Success", t[t.Error = 1] = "Error";
    }(e.TranslationStatus || (e.TranslationStatus = {}));
  }(To)), To;
}
var Pr = {}, Pu;
function VC() {
  if (Pu) return Pr;
  Pu = 1, Object.defineProperty(Pr, "__esModule", { value: !0 }), Pr.ChunkedArrayBufferStream = void 0;
  const e = /* @__PURE__ */ k();
  let t = class extends e.Stream {
    constructor(o, i) {
      super(i), this.privTargetChunkSize = Math.round(o), this.privNextBufferReadyBytes = 0;
    }
    writeStreamChunk(o) {
      if (o.isEnd || this.privNextBufferReadyBytes === 0 && o.buffer.byteLength === this.privTargetChunkSize) {
        super.writeStreamChunk(o);
        return;
      }
      let i = 0;
      for (; i < o.buffer.byteLength; ) {
        this.privNextBufferToWrite === void 0 && (this.privNextBufferToWrite = new ArrayBuffer(this.privTargetChunkSize), this.privNextBufferStartTime = o.timeReceived);
        const a = Math.min(o.buffer.byteLength - i, this.privTargetChunkSize - this.privNextBufferReadyBytes), s = new Uint8Array(this.privNextBufferToWrite), n = new Uint8Array(o.buffer.slice(i, a + i));
        s.set(n, this.privNextBufferReadyBytes), this.privNextBufferReadyBytes += a, i += a, this.privNextBufferReadyBytes === this.privTargetChunkSize && (super.writeStreamChunk({
          buffer: this.privNextBufferToWrite,
          isEnd: !1,
          timeReceived: this.privNextBufferStartTime
        }), this.privNextBufferReadyBytes = 0, this.privNextBufferToWrite = void 0);
      }
    }
    close() {
      this.privNextBufferReadyBytes !== 0 && !this.isClosed && super.writeStreamChunk({
        buffer: this.privNextBufferToWrite.slice(0, this.privNextBufferReadyBytes),
        isEnd: !1,
        timeReceived: this.privNextBufferStartTime
      }), super.close();
    }
  };
  return Pr.ChunkedArrayBufferStream = t, Pr;
}
var _o = {}, wu;
function WC() {
  return wu || (wu = 1, Object.defineProperty(_o, "__esModule", { value: !0 })), _o;
}
var wr = {}, bu;
function HC() {
  if (bu) return wr;
  bu = 1, Object.defineProperty(wr, "__esModule", { value: !0 }), wr.Timeout = void 0;
  let e = class Ze {
    static load() {
      const r = /* @__PURE__ */ new Map([[0, () => {
      }]]), o = /* @__PURE__ */ new Map(), a = "data:text/javascript;base64," + btoa(`!function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=14)}([function(e,t,n){"use strict";n.d(t,"a",(function(){return i})),n.d(t,"b",(function(){return u})),n.d(t,"c",(function(){return a})),n.d(t,"d",(function(){return d}));const r=new Map,o=new Map,i=e=>{const t=r.get(e);if(void 0===t)throw new Error('There is no interval scheduled with the given id "'.concat(e,'".'));clearTimeout(t),r.delete(e)},u=e=>{const t=o.get(e);if(void 0===t)throw new Error('There is no timeout scheduled with the given id "'.concat(e,'".'));clearTimeout(t),o.delete(e)},f=(e,t)=>{let n,r;if("performance"in self){const o=performance.now();n=o,r=e-Math.max(0,o-t)}else n=Date.now(),r=e;return{expected:n+r,remainingDelay:r}},c=(e,t,n,r)=>{const o="performance"in self?performance.now():Date.now();o>n?postMessage({id:null,method:"call",params:{timerId:t}}):e.set(t,setTimeout(c,n-o,e,t,n))},a=(e,t,n)=>{const{expected:o,remainingDelay:i}=f(e,n);r.set(t,setTimeout(c,i,r,t,o))},d=(e,t,n)=>{const{expected:r,remainingDelay:i}=f(e,n);o.set(t,setTimeout(c,i,o,t,r))}},function(e,t,n){"use strict";n.r(t);var r=n(2);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(3);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(4);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o);var f=n(5);for(var o in f)"default"!==o&&function(e){n.d(t,e,(function(){return f[e]}))}(o);var c=n(6);for(var o in c)"default"!==o&&function(e){n.d(t,e,(function(){return c[e]}))}(o);var a=n(7);for(var o in a)"default"!==o&&function(e){n.d(t,e,(function(){return a[e]}))}(o);var d=n(8);for(var o in d)"default"!==o&&function(e){n.d(t,e,(function(){return d[e]}))}(o);var s=n(9);for(var o in s)"default"!==o&&function(e){n.d(t,e,(function(){return s[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(11);for(var o in r)"default"!==o&&function(e){n.d(t,e,(function(){return r[e]}))}(o);var i=n(12);for(var o in i)"default"!==o&&function(e){n.d(t,e,(function(){return i[e]}))}(o);var u=n(13);for(var o in u)"default"!==o&&function(e){n.d(t,e,(function(){return u[e]}))}(o)},function(e,t){},function(e,t){},function(e,t){},function(e,t,n){"use strict";n.r(t);var r=n(0),o=n(1);for(var i in o)"default"!==i&&function(e){n.d(t,e,(function(){return o[e]}))}(i);var u=n(10);for(var i in u)"default"!==i&&function(e){n.d(t,e,(function(){return u[e]}))}(i);addEventListener("message",({data:e})=>{try{if("clear"===e.method){const{id:t,params:{timerId:n}}=e;Object(r.b)(n),postMessage({error:null,id:t})}else{if("set"!==e.method)throw new Error('The given method "'.concat(e.method,'" is not supported'));{const{params:{delay:t,now:n,timerId:o}}=e;Object(r.d)(t,o,n)}}}catch(t){postMessage({error:{message:t.message},id:e.id,result:null})}})}]);`), s = new Worker(a);
      return s.addEventListener("message", ({ data: u }) => {
        if (Ze.isCallNotification(u)) {
          const { params: { timerId: l } } = u, p = r.get(l);
          if (typeof p == "number") {
            const h = o.get(p);
            if (h === void 0 || h !== l)
              throw new Error("The timer is in an undefined state.");
          } else if (typeof p < "u")
            p(), r.delete(l);
          else
            throw new Error("The timer is in an undefined state.");
        } else if (Ze.isClearResponse(u)) {
          const { id: l } = u, p = o.get(l);
          if (p === void 0)
            throw new Error("The timer is in an undefined state.");
          o.delete(l), r.delete(p);
        } else {
          const { error: { message: l } } = u;
          throw new Error(l);
        }
      }), {
        clearTimeout: (u) => {
          const l = Math.random();
          o.set(l, u), r.set(u, l), s.postMessage({
            id: l,
            method: "clear",
            params: { timerId: u }
          });
        },
        setTimeout: (u, l) => {
          const p = Math.random();
          return r.set(p, u), s.postMessage({
            id: null,
            method: "set",
            params: {
              delay: l,
              now: performance.now(),
              timerId: p
            }
          }), p;
        }
      };
    }
    static loadWorkerTimers() {
      return () => (Ze.workerTimers !== null || (Ze.workerTimers = Ze.load()), Ze.workerTimers);
    }
    static isCallNotification(r) {
      return r.method !== void 0 && r.method === "call";
    }
    static isClearResponse(r) {
      return r.error === null && typeof r.id == "number";
    }
  };
  return wr.Timeout = e, e.workerTimers = null, e.clearTimeout = (t) => e.timers().clearTimeout(t), e.setTimeout = (t, r) => e.timers().setTimeout(t, r), e.timers = e.loadWorkerTimers(), wr;
}
var B = {}, Eu;
function KC() {
  if (Eu) return B;
  Eu = 1, Object.defineProperty(B, "__esModule", { value: !0 }), B.OCSPCacheUpdateErrorEvent = B.OCSPResponseRetrievedEvent = B.OCSPCacheFetchErrorEvent = B.OCSPVerificationFailedEvent = B.OCSPCacheHitEvent = B.OCSPCacheEntryNeedsRefreshEvent = B.OCSPCacheEntryExpiredEvent = B.OCSPWSUpgradeStartedEvent = B.OCSPStapleReceivedEvent = B.OCSPCacheUpdateCompleteEvent = B.OCSPDiskCacheStoreEvent = B.OCSPMemoryCacheStoreEvent = B.OCSPCacheUpdateNeededEvent = B.OCSPDiskCacheHitEvent = B.OCSPCacheMissEvent = B.OCSPMemoryCacheHitEvent = B.OCSPEvent = void 0;
  const e = /* @__PURE__ */ ys();
  class t extends e.PlatformEvent {
    constructor(S, C, w) {
      super(S, C), this.privSignature = w;
    }
  }
  B.OCSPEvent = t;
  class r extends t {
    constructor(S) {
      super("OCSPMemoryCacheHitEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPMemoryCacheHitEvent = r;
  class o extends t {
    constructor(S) {
      super("OCSPCacheMissEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPCacheMissEvent = o;
  class i extends t {
    constructor(S) {
      super("OCSPDiskCacheHitEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPDiskCacheHitEvent = i;
  class a extends t {
    constructor(S) {
      super("OCSPCacheUpdateNeededEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPCacheUpdateNeededEvent = a;
  class s extends t {
    constructor(S) {
      super("OCSPMemoryCacheStoreEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPMemoryCacheStoreEvent = s;
  class n extends t {
    constructor(S) {
      super("OCSPDiskCacheStoreEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPDiskCacheStoreEvent = n;
  class c extends t {
    constructor(S) {
      super("OCSPCacheUpdateCompleteEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPCacheUpdateCompleteEvent = c;
  class u extends t {
    constructor() {
      super("OCSPStapleReceivedEvent", e.EventType.Debug, "");
    }
  }
  B.OCSPStapleReceivedEvent = u;
  class l extends t {
    constructor(S) {
      super("OCSPWSUpgradeStartedEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPWSUpgradeStartedEvent = l;
  class p extends t {
    constructor(S, C) {
      super("OCSPCacheEntryExpiredEvent", e.EventType.Debug, S), this.privExpireTime = C;
    }
  }
  B.OCSPCacheEntryExpiredEvent = p;
  class h extends t {
    constructor(S, C, w) {
      super("OCSPCacheEntryNeedsRefreshEvent", e.EventType.Debug, S), this.privExpireTime = w, this.privStartTime = C;
    }
  }
  B.OCSPCacheEntryNeedsRefreshEvent = h;
  class d extends t {
    constructor(S, C, w) {
      super("OCSPCacheHitEvent", e.EventType.Debug, S), this.privExpireTime = w, this.privExpireTimeString = new Date(w).toLocaleDateString(), this.privStartTime = C, this.privStartTimeString = new Date(C).toLocaleTimeString();
    }
  }
  B.OCSPCacheHitEvent = d;
  class f extends t {
    constructor(S, C) {
      super("OCSPVerificationFailedEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  B.OCSPVerificationFailedEvent = f;
  class g extends t {
    constructor(S, C) {
      super("OCSPCacheFetchErrorEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  B.OCSPCacheFetchErrorEvent = g;
  class m extends t {
    constructor(S) {
      super("OCSPResponseRetrievedEvent", e.EventType.Debug, S);
    }
  }
  B.OCSPResponseRetrievedEvent = m;
  class v extends t {
    constructor(S, C) {
      super("OCSPCacheUpdateErrorEvent", e.EventType.Debug, S), this.privError = C;
    }
  }
  return B.OCSPCacheUpdateErrorEvent = v, B;
}
var br = {}, Iu;
function JC() {
  if (Iu) return br;
  Iu = 1, Object.defineProperty(br, "__esModule", { value: !0 }), br.BackgroundEvent = void 0;
  const e = /* @__PURE__ */ k();
  class t extends e.PlatformEvent {
    constructor(o) {
      super("BackgroundEvent", e.EventType.Error), this.privError = o;
    }
    get error() {
      return this.privError;
    }
  }
  return br.BackgroundEvent = t, br;
}
var Au;
function k() {
  return Au || (Au = 1, function(e) {
    var t = ct && ct.__createBinding || (Object.create ? function(i, a, s, n) {
      n === void 0 && (n = s), Object.defineProperty(i, n, { enumerable: !0, get: function() {
        return a[s];
      } });
    } : function(i, a, s, n) {
      n === void 0 && (n = s), i[n] = a[s];
    }), r = ct && ct.__exportStar || function(i, a) {
      for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(a, s) && t(a, i, s);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TranslationStatus = void 0, r(/* @__PURE__ */ IC(), e), r(/* @__PURE__ */ AC(), e), r(/* @__PURE__ */ ev(), e), r(/* @__PURE__ */ TC(), e), r(/* @__PURE__ */ _C(), e), r(/* @__PURE__ */ tv(), e), r(/* @__PURE__ */ Ne(), e), r(/* @__PURE__ */ kC(), e), r(/* @__PURE__ */ rv(), e), r(/* @__PURE__ */ Dt(), e), r(/* @__PURE__ */ OC(), e), r(/* @__PURE__ */ MC(), e), r(/* @__PURE__ */ DC(), e), r(/* @__PURE__ */ NC(), e), r(/* @__PURE__ */ xC(), e), r(/* @__PURE__ */ zC(), e), r(/* @__PURE__ */ LC(), e), r(/* @__PURE__ */ jC(), e), r(/* @__PURE__ */ qC(), e), r(/* @__PURE__ */ FC(), e), r(/* @__PURE__ */ nv(), e), r(/* @__PURE__ */ ys(), e), r(/* @__PURE__ */ iv(), e), r(/* @__PURE__ */ sv(), e), r(/* @__PURE__ */ BC(), e), r(/* @__PURE__ */ UC(), e), r(/* @__PURE__ */ $C(), e);
    var o = /* @__PURE__ */ oc();
    Object.defineProperty(e, "TranslationStatus", { enumerable: !0, get: function() {
      return o.TranslationStatus;
    } }), r(/* @__PURE__ */ VC(), e), r(/* @__PURE__ */ WC(), e), r(/* @__PURE__ */ HC(), e), r(/* @__PURE__ */ KC(), e), r(/* @__PURE__ */ JC(), e);
  }(ct)), ct;
}
var Er = {}, Tu;
function le() {
  if (Tu) return Er;
  Tu = 1, Object.defineProperty(Er, "__esModule", { value: !0 }), Er.HeaderNames = void 0;
  let e = class {
  };
  return Er.HeaderNames = e, e.AuthKey = "Ocp-Apim-Subscription-Key", e.Authorization = "Authorization", e.SpIDAuthKey = "Apim-Subscription-Id", e.ConnectionId = "X-ConnectionId", e.ContentType = "Content-Type", e.CustomCommandsAppId = "X-CommandsAppId", e.Path = "Path", e.RequestId = "X-RequestId", e.RequestStreamId = "X-StreamId", e.RequestTimestamp = "X-Timestamp", Er;
}
var Ir = {}, _u;
function ac() {
  if (_u) return Ir;
  _u = 1, Object.defineProperty(Ir, "__esModule", { value: !0 }), Ir.AuthInfo = void 0;
  class e {
    constructor(r, o) {
      this.privHeaderName = r, this.privToken = o;
    }
    get headerName() {
      return this.privHeaderName;
    }
    get token() {
      return this.privToken;
    }
  }
  return Ir.AuthInfo = e, Ir;
}
var ku;
function GC() {
  if (ku) return er;
  ku = 1, Object.defineProperty(er, "__esModule", { value: !0 }), er.CognitiveSubscriptionKeyAuthentication = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ le(), r = /* @__PURE__ */ ac();
  let o = class {
    /**
     * Creates and initializes an instance of the CognitiveSubscriptionKeyAuthentication class.
     * @constructor
     * @param {string} subscriptionKey - The subscription key
     */
    constructor(a) {
      if (!a)
        throw new e.ArgumentNullError("subscriptionKey");
      this.privAuthInfo = new r.AuthInfo(t.HeaderNames.AuthKey, a);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fetch(a) {
      return Promise.resolve(this.privAuthInfo);
    }
    /**
     * Fetches the subscription key.
     * @member
     * @function
     * @public
     * @param {string} authFetchEventId - The id to fetch.
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    fetchOnExpiry(a) {
      return Promise.resolve(this.privAuthInfo);
    }
  };
  return er.CognitiveSubscriptionKeyAuthentication = o, er;
}
var Ar = {}, Ou;
function QC() {
  if (Ou) return Ar;
  Ou = 1, Object.defineProperty(Ar, "__esModule", { value: !0 }), Ar.CognitiveTokenAuthentication = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ ac(), r = /* @__PURE__ */ le();
  let o = class Ba {
    constructor(a, s) {
      if (!a)
        throw new e.ArgumentNullError("fetchCallback");
      if (!s)
        throw new e.ArgumentNullError("fetchOnExpiryCallback");
      this.privFetchCallback = a, this.privFetchOnExpiryCallback = s;
    }
    fetch(a) {
      return this.privFetchCallback(a).then((s) => new t.AuthInfo(r.HeaderNames.Authorization, s === void 0 ? void 0 : Ba.privTokenPrefix + s));
    }
    fetchOnExpiry(a) {
      return this.privFetchOnExpiryCallback(a).then((s) => new t.AuthInfo(r.HeaderNames.Authorization, s === void 0 ? void 0 : Ba.privTokenPrefix + s));
    }
  };
  return Ar.CognitiveTokenAuthentication = o, o.privTokenPrefix = "Bearer ", Ar;
}
var ko = {}, Mu;
function YC() {
  return Mu || (Mu = 1, Object.defineProperty(ko, "__esModule", { value: !0 })), ko;
}
var Oo = {}, Du;
function ZC() {
  return Du || (Du = 1, Object.defineProperty(Oo, "__esModule", { value: !0 })), Oo;
}
var Tr = {}, pt = {}, Ie = {};
const XC = {}, eR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: XC
}, Symbol.toStringTag, { value: "Module" })), Ot = /* @__PURE__ */ fC(eR);
var Mo = {}, Nu;
function ov() {
  return Nu || (Nu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LogLevel = void 0;
    const t = /* @__PURE__ */ k();
    Object.defineProperty(e, "LogLevel", { enumerable: !0, get: function() {
      return t.EventType;
    } });
  }(Mo)), Mo;
}
var _r = {}, xu;
function z() {
  if (xu) return _r;
  xu = 1, Object.defineProperty(_r, "__esModule", { value: !0 }), _r.Contracts = void 0;
  let e = class kt {
    static throwIfNullOrUndefined(r, o) {
      if (r == null)
        throw new Error("throwIfNullOrUndefined:" + o);
    }
    static throwIfNull(r, o) {
      if (r === null)
        throw new Error("throwIfNull:" + o);
    }
    static throwIfNullOrWhitespace(r, o) {
      if (kt.throwIfNullOrUndefined(r, o), ("" + r).trim().length < 1)
        throw new Error("throwIfNullOrWhitespace:" + o);
    }
    static throwIfNullOrTooLong(r, o, i) {
      if (kt.throwIfNullOrUndefined(r, o), ("" + r).length > i)
        throw new Error("throwIfNullOrTooLong:" + o + " (more than " + i.toString() + " characters)");
    }
    static throwIfNullOrTooShort(r, o, i) {
      if (kt.throwIfNullOrUndefined(r, o), ("" + r).length < i)
        throw new Error("throwIfNullOrTooShort:" + o + " (less than " + i.toString() + " characters)");
    }
    static throwIfDisposed(r) {
      if (r)
        throw new Error("the object is already disposed");
    }
    static throwIfArrayEmptyOrWhitespace(r, o) {
      if (kt.throwIfNullOrUndefined(r, o), r.length === 0)
        throw new Error("throwIfArrayEmptyOrWhitespace:" + o);
      for (const i of r)
        kt.throwIfNullOrWhitespace(i, o);
    }
    static throwIfFileDoesNotExist(r, o) {
      kt.throwIfNullOrWhitespace(r, o);
    }
    static throwIfNotUndefined(r, o) {
      if (r !== void 0)
        throw new Error("throwIfNotUndefined:" + o);
    }
  };
  return _r.Contracts = e, _r;
}
var zu;
function tR() {
  if (zu) return Ie;
  zu = 1;
  var e = Ie && Ie.__createBinding || (Object.create ? function(n, c, u, l) {
    l === void 0 && (l = u), Object.defineProperty(n, l, { enumerable: !0, get: function() {
      return c[u];
    } });
  } : function(n, c, u, l) {
    l === void 0 && (l = u), n[l] = c[u];
  }), t = Ie && Ie.__setModuleDefault || (Object.create ? function(n, c) {
    Object.defineProperty(n, "default", { enumerable: !0, value: c });
  } : function(n, c) {
    n.default = c;
  }), r = Ie && Ie.__importStar || function(n) {
    if (n && n.__esModule) return n;
    var c = {};
    if (n != null) for (var u in n) u !== "default" && Object.prototype.hasOwnProperty.call(n, u) && e(c, n, u);
    return t(c, n), c;
  };
  Object.defineProperty(Ie, "__esModule", { value: !0 }), Ie.ConsoleLoggingListener = void 0;
  const o = r(Ot), i = /* @__PURE__ */ ov(), a = /* @__PURE__ */ z();
  let s = class {
    constructor(c = i.LogLevel.None) {
      this.privLogPath = void 0, this.privEnableConsoleOutput = !0, this.privLogLevelFilter = c;
    }
    set logPath(c) {
      a.Contracts.throwIfNullOrUndefined(o.openSync, `
File System access not available`), this.privLogPath = c;
    }
    set enableConsoleOutput(c) {
      this.privEnableConsoleOutput = c;
    }
    onEvent(c) {
      if (c.eventType >= this.privLogLevelFilter) {
        const u = this.toString(c);
        if (this.logCallback && this.logCallback(u), this.privLogPath && o.writeFileSync(this.privLogPath, u + `
`, { flag: "a+" }), this.privEnableConsoleOutput)
          switch (c.eventType) {
            case i.LogLevel.Debug:
              console.debug(u);
              break;
            case i.LogLevel.Info:
              console.info(u);
              break;
            case i.LogLevel.Warning:
              console.warn(u);
              break;
            case i.LogLevel.Error:
              console.error(u);
              break;
            default:
              console.log(u);
              break;
          }
      }
    }
    toString(c) {
      const u = [
        `${c.eventTime}`,
        `${c.name}`
      ], l = c;
      for (const p in l)
        if (p && c.hasOwnProperty(p) && p !== "eventTime" && p !== "eventType" && p !== "eventId" && p !== "name" && p !== "constructor") {
          const h = l[p];
          let d = "<NULL>";
          h != null && (typeof h == "number" || typeof h == "string" ? d = h.toString() : d = JSON.stringify(h)), u.push(`${p}: ${d}`);
        }
      return u.join(" | ");
    }
  };
  return Ie.ConsoleLoggingListener = s, Ie;
}
var Do = {}, Lu;
function rR() {
  return Lu || (Lu = 1, Object.defineProperty(Do, "__esModule", { value: !0 })), Do;
}
var No = {}, xo = {}, ju;
function Nt() {
  return ju || (ju = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AudioStreamFormatImpl = e.AudioStreamFormat = e.AudioFormatTag = void 0;
    var t;
    (function(i) {
      i[i.PCM = 1] = "PCM", i[i.MuLaw = 2] = "MuLaw", i[i.Siren = 3] = "Siren", i[i.MP3 = 4] = "MP3", i[i.SILKSkype = 5] = "SILKSkype", i[i.OGG_OPUS = 6] = "OGG_OPUS", i[i.WEBM_OPUS = 7] = "WEBM_OPUS", i[i.ALaw = 8] = "ALaw", i[i.FLAC = 9] = "FLAC", i[i.OPUS = 10] = "OPUS", i[i.AMR_WB = 11] = "AMR_WB", i[i.G722 = 12] = "G722";
    })(t = e.AudioFormatTag || (e.AudioFormatTag = {}));
    class r {
      /**
       * Creates an audio stream format object representing the default audio stream
       * format (16KHz 16bit mono PCM).
       * @member AudioStreamFormat.getDefaultInputFormat
       * @function
       * @public
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getDefaultInputFormat() {
        return o.getDefaultInputFormat();
      }
      /**
       * Creates an audio stream format object with the specified format characteristics.
       * @member AudioStreamFormat.getWaveFormat
       * @function
       * @public
       * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
       * @param {number} bitsPerSample - Bits per sample, typically 16.
       * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
       * uses one channel and stereo data uses two channels.
       * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getWaveFormat(a, s, n, c) {
        return new o(a, s, n, c);
      }
      /**
       * Creates an audio stream format object with the specified pcm waveformat characteristics.
       * @member AudioStreamFormat.getWaveFormatPCM
       * @function
       * @public
       * @param {number} samplesPerSecond - Sample rate, in samples per second (Hertz).
       * @param {number} bitsPerSample - Bits per sample, typically 16.
       * @param {number} channels - Number of channels in the waveform-audio data. Monaural data
       * uses one channel and stereo data uses two channels.
       * @returns {AudioStreamFormat} The audio stream format being created.
       */
      static getWaveFormatPCM(a, s, n) {
        return new o(a, s, n);
      }
    }
    e.AudioStreamFormat = r;
    class o extends r {
      /**
       * Creates an instance with the given values.
       * @constructor
       * @param {number} samplesPerSec - Samples per second.
       * @param {number} bitsPerSample - Bits per sample.
       * @param {number} channels - Number of channels.
       * @param {AudioFormatTag} format - Audio format (PCM, alaw or mulaw).
       */
      constructor(a = 16e3, s = 16, n = 1, c = t.PCM) {
        super();
        let u = !0;
        switch (c) {
          case t.PCM:
            this.formatTag = 1;
            break;
          case t.ALaw:
            this.formatTag = 6;
            break;
          case t.MuLaw:
            this.formatTag = 7;
            break;
          default:
            u = !1;
        }
        if (this.bitsPerSample = s, this.samplesPerSec = a, this.channels = n, this.avgBytesPerSec = this.samplesPerSec * this.channels * (this.bitsPerSample / 8), this.blockAlign = this.channels * Math.max(this.bitsPerSample, 8), u) {
          this.privHeader = new ArrayBuffer(44);
          const l = new DataView(this.privHeader);
          this.setString(l, 0, "RIFF"), l.setUint32(4, 0, !0), this.setString(l, 8, "WAVEfmt "), l.setUint32(16, 16, !0), l.setUint16(20, this.formatTag, !0), l.setUint16(22, this.channels, !0), l.setUint32(24, this.samplesPerSec, !0), l.setUint32(28, this.avgBytesPerSec, !0), l.setUint16(32, this.channels * (this.bitsPerSample / 8), !0), l.setUint16(34, this.bitsPerSample, !0), this.setString(l, 36, "data"), l.setUint32(40, 0, !0);
        }
      }
      /**
       * Retrieves the default input format.
       * @member AudioStreamFormatImpl.getDefaultInputFormat
       * @function
       * @public
       * @returns {AudioStreamFormatImpl} The default input format.
       */
      static getDefaultInputFormat() {
        return new o();
      }
      /**
       * Creates an audio context appropriate to current browser
       * @member AudioStreamFormatImpl.getAudioContext
       * @function
       * @public
       * @returns {AudioContext} An audio context instance
       */
      /* eslint-disable */
      static getAudioContext(a) {
        const s = window.AudioContext || window.webkitAudioContext || !1;
        if (s)
          return a !== void 0 && navigator.mediaDevices.getSupportedConstraints().sampleRate ? new s({ sampleRate: a }) : new s();
        throw new Error("Browser does not support Web Audio API (AudioContext is not available).");
      }
      /* eslint-enable */
      /**
       * Closes the configuration object.
       * @member AudioStreamFormatImpl.prototype.close
       * @function
       * @public
       */
      close() {
      }
      get header() {
        return this.privHeader;
      }
      setString(a, s, n) {
        for (let c = 0; c < n.length; c++)
          a.setUint8(s + c, n.charCodeAt(c));
      }
    }
    e.AudioStreamFormatImpl = o;
  }(xo)), xo;
}
var qu;
function nR() {
  return qu || (qu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MicAudioSource = e.AudioWorkletSourceURLPropertyName = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ k(), o = /* @__PURE__ */ Nt();
    e.AudioWorkletSourceURLPropertyName = "MICROPHONE-WorkletSourceUrl";
    class i {
      constructor(s, n, c, u) {
        this.privRecorder = s, this.deviceId = n, this.privStreams = {}, this.privOutputChunkSize = i.AUDIOFORMAT.avgBytesPerSec / 10, this.privId = c || (0, r.createNoDashGuid)(), this.privEvents = new r.EventSource(), this.privMediaStream = u || null, this.privIsClosing = !1;
      }
      get format() {
        return Promise.resolve(i.AUDIOFORMAT);
      }
      turnOn() {
        if (this.privInitializeDeferral)
          return this.privInitializeDeferral.promise;
        this.privInitializeDeferral = new r.Deferred();
        try {
          this.createAudioContext();
        } catch (c) {
          if (c instanceof Error) {
            const u = c;
            this.privInitializeDeferral.reject(u.name + ": " + u.message);
          } else
            this.privInitializeDeferral.reject(c);
          return this.privInitializeDeferral.promise;
        }
        const s = window.navigator;
        let n = (
          // eslint-disable-next-line
          s.getUserMedia || s.webkitGetUserMedia || s.mozGetUserMedia || s.msGetUserMedia
        );
        if (s.mediaDevices && (n = (c, u, l) => {
          s.mediaDevices.getUserMedia(c).then(u).catch(l);
        }), n) {
          const c = () => {
            this.onEvent(new r.AudioSourceInitializingEvent(this.privId)), this.privMediaStream && this.privMediaStream.active ? (this.onEvent(new r.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve()) : n({ audio: this.deviceId ? { deviceId: this.deviceId } : !0, video: !1 }, (u) => {
              this.privMediaStream = u, this.onEvent(new r.AudioSourceReadyEvent(this.privId)), this.privInitializeDeferral.resolve();
            }, (u) => {
              const l = `Error occurred during microphone initialization: ${u}`;
              this.privInitializeDeferral.reject(l), this.onEvent(new r.AudioSourceErrorEvent(this.privId, l));
            });
          };
          this.privContext.state === "suspended" ? this.privContext.resume().then(c).catch((u) => {
            this.privInitializeDeferral.reject(`Failed to initialize audio context: ${u}`);
          }) : c();
        } else {
          const c = "Browser does not support getUserMedia.";
          this.privInitializeDeferral.reject(c), this.onEvent(new r.AudioSourceErrorEvent(c, ""));
        }
        return this.privInitializeDeferral.promise;
      }
      id() {
        return this.privId;
      }
      attach(s) {
        return this.onEvent(new r.AudioStreamNodeAttachingEvent(this.privId, s)), this.listen(s).then((n) => (this.onEvent(new r.AudioStreamNodeAttachedEvent(this.privId, s)), {
          detach: async () => (n.readEnded(), delete this.privStreams[s], this.onEvent(new r.AudioStreamNodeDetachedEvent(this.privId, s)), this.turnOff()),
          id: () => s,
          read: () => n.read()
        }));
      }
      detach(s) {
        s && this.privStreams[s] && (this.privStreams[s].close(), delete this.privStreams[s], this.onEvent(new r.AudioStreamNodeDetachedEvent(this.privId, s)));
      }
      async turnOff() {
        for (const s in this.privStreams)
          if (s) {
            const n = this.privStreams[s];
            n && n.close();
          }
        this.onEvent(new r.AudioSourceOffEvent(this.privId)), this.privInitializeDeferral && (await this.privInitializeDeferral, this.privInitializeDeferral = null), await this.destroyAudioContext();
      }
      get events() {
        return this.privEvents;
      }
      get deviceInfo() {
        return this.getMicrophoneLabel().then((s) => ({
          bitspersample: i.AUDIOFORMAT.bitsPerSample,
          channelcount: i.AUDIOFORMAT.channels,
          connectivity: t.connectivity.Unknown,
          manufacturer: "Speech SDK",
          model: s,
          samplerate: i.AUDIOFORMAT.samplesPerSec,
          type: t.type.Microphones
        }));
      }
      setProperty(s, n) {
        if (s === e.AudioWorkletSourceURLPropertyName)
          this.privRecorder.setWorkletUrl(n);
        else
          throw new Error("Property '" + s + "' is not supported on Microphone.");
      }
      getMicrophoneLabel() {
        const s = "microphone";
        if (this.privMicrophoneLabel !== void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        if (this.privMediaStream === void 0 || !this.privMediaStream.active)
          return Promise.resolve(s);
        this.privMicrophoneLabel = s;
        const n = this.privMediaStream.getTracks()[0].getSettings().deviceId;
        if (n === void 0)
          return Promise.resolve(this.privMicrophoneLabel);
        const c = new r.Deferred();
        return navigator.mediaDevices.enumerateDevices().then((u) => {
          for (const l of u)
            if (l.deviceId === n) {
              this.privMicrophoneLabel = l.label;
              break;
            }
          c.resolve(this.privMicrophoneLabel);
        }, () => c.resolve(this.privMicrophoneLabel)), c.promise;
      }
      async listen(s) {
        await this.turnOn();
        const n = new r.ChunkedArrayBufferStream(this.privOutputChunkSize, s);
        this.privStreams[s] = n;
        try {
          this.privRecorder.record(this.privContext, this.privMediaStream, n);
        } catch (u) {
          throw this.onEvent(new r.AudioStreamNodeErrorEvent(this.privId, s, u)), u;
        }
        return n;
      }
      onEvent(s) {
        this.privEvents.onEvent(s), r.Events.instance.onEvent(s);
      }
      createAudioContext() {
        this.privContext || (this.privContext = o.AudioStreamFormatImpl.getAudioContext(i.AUDIOFORMAT.samplesPerSec));
      }
      async destroyAudioContext() {
        if (!this.privContext)
          return;
        this.privRecorder.releaseMediaResources(this.privContext);
        let s = !1;
        "close" in this.privContext && (s = !0), s ? this.privIsClosing || (this.privIsClosing = !0, await this.privContext.close(), this.privContext = null, this.privIsClosing = !1) : this.privContext !== null && this.privContext.state === "running" && await this.privContext.suspend();
      }
    }
    e.MicAudioSource = i, i.AUDIOFORMAT = o.AudioStreamFormat.getDefaultInputFormat();
  }(No)), No;
}
var kr = {}, Fu;
function iR() {
  if (Fu) return kr;
  Fu = 1, Object.defineProperty(kr, "__esModule", { value: !0 }), kr.FileAudioSource = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ Nt();
  let o = class {
    constructor(a, s, n) {
      this.privStreams = {}, this.privHeaderEnd = 44, this.privId = n || (0, t.createNoDashGuid)(), this.privEvents = new t.EventSource(), this.privSource = a, typeof window < "u" && typeof Blob < "u" && this.privSource instanceof Blob ? this.privFilename = a.name : this.privFilename = s || "unknown.wav", this.privAudioFormatPromise = this.readHeader();
    }
    get format() {
      return this.privAudioFormatPromise;
    }
    turnOn() {
      if (this.privFilename.lastIndexOf(".wav") !== this.privFilename.length - 4) {
        const a = this.privFilename + " is not supported. Only WAVE files are allowed at the moment.";
        return this.onEvent(new t.AudioSourceErrorEvent(a, "")), Promise.reject(a);
      }
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    id() {
      return this.privId;
    }
    async attach(a) {
      this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, a));
      const s = await this.upload(a);
      return this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, a)), Promise.resolve({
        detach: async () => {
          s.readEnded(), delete this.privStreams[a], this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, a)), await this.turnOff();
        },
        id: () => a,
        read: () => s.read()
      });
    }
    detach(a) {
      a && this.privStreams[a] && (this.privStreams[a].close(), delete this.privStreams[a], this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, a)));
    }
    turnOff() {
      for (const a in this.privStreams)
        if (a) {
          const s = this.privStreams[a];
          s && !s.isClosed && s.close();
        }
      return this.onEvent(new t.AudioSourceOffEvent(this.privId)), Promise.resolve();
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return this.privAudioFormatPromise.then((a) => Promise.resolve({
        bitspersample: a.bitsPerSample,
        channelcount: a.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "File",
        samplerate: a.samplesPerSec,
        type: e.type.File
      }));
    }
    readHeader() {
      const s = this.privSource.slice(0, 4296), n = new t.Deferred(), c = (u) => {
        const l = new DataView(u), p = (v) => String.fromCharCode(l.getUint8(v), l.getUint8(v + 1), l.getUint8(v + 2), l.getUint8(v + 3));
        if (p(0) !== "RIFF") {
          n.reject("Invalid WAV header in file, RIFF was not found");
          return;
        }
        if (p(8) !== "WAVE" || p(12) !== "fmt ") {
          n.reject("Invalid WAV header in file, WAVEfmt was not found");
          return;
        }
        const h = l.getInt32(16, !0), d = l.getUint16(22, !0), f = l.getUint32(24, !0), g = l.getUint16(34, !0);
        let m = 36 + Math.max(h - 16, 0);
        for (; p(m) !== "data"; m += 2)
          if (m > 4288) {
            n.reject("Invalid WAV header in file, data block was not found");
            return;
          }
        this.privHeaderEnd = m + 8, n.resolve(r.AudioStreamFormat.getWaveFormatPCM(f, g, d));
      };
      if (typeof window < "u" && typeof Blob < "u" && s instanceof Blob) {
        const u = new FileReader();
        u.onload = (l) => {
          const p = l.target.result;
          c(p);
        }, u.readAsArrayBuffer(s);
      } else {
        const u = s;
        c(u.buffer.slice(u.byteOffset, u.byteOffset + u.byteLength));
      }
      return n.promise;
    }
    async upload(a) {
      const s = (n) => {
        const c = `Error occurred while processing '${this.privFilename}'. ${n}`;
        throw this.onEvent(new t.AudioStreamNodeErrorEvent(this.privId, a, c)), new Error(c);
      };
      try {
        await this.turnOn();
        const n = await this.privAudioFormatPromise, c = new t.ChunkedArrayBufferStream(n.avgBytesPerSec / 10, a);
        this.privStreams[a] = c;
        const u = this.privSource.slice(this.privHeaderEnd), l = (p) => {
          c.isClosed || (c.writeStreamChunk({
            buffer: p,
            isEnd: !1,
            timeReceived: Date.now()
          }), c.close());
        };
        if (typeof window < "u" && typeof Blob < "u" && u instanceof Blob) {
          const p = new FileReader();
          p.onerror = (h) => s(h.toString()), p.onload = (h) => {
            const d = h.target.result;
            l(d);
          }, p.readAsArrayBuffer(u);
        } else {
          const p = u;
          l(p.buffer.slice(p.byteOffset, p.byteOffset + p.byteLength));
        }
        return c;
      } catch (n) {
        s(n);
      }
    }
    onEvent(a) {
      this.privEvents.onEvent(a), t.Events.instance.onEvent(a);
    }
  };
  return kr.FileAudioSource = o, kr;
}
var Or = {}, Bu;
function sR() {
  if (Bu) return Or;
  Bu = 1, Object.defineProperty(Or, "__esModule", { value: !0 }), Or.PcmRecorder = void 0;
  const e = /* @__PURE__ */ k();
  class t {
    constructor(o) {
      this.privStopInputOnRelease = o;
    }
    record(o, i, a) {
      const n = new e.RiffPcmEncoder(o.sampleRate, 16e3), c = o.createMediaStreamSource(i), u = () => {
        const p = (() => {
          let h = 0;
          try {
            return o.createScriptProcessor(h, 1, 1);
          } catch {
            h = 2048;
            let f = o.sampleRate;
            for (; h < 16384 && f >= 32e3; )
              h <<= 1, f >>= 1;
            return o.createScriptProcessor(h, 1, 1);
          }
        })();
        p.onaudioprocess = (h) => {
          const d = h.inputBuffer.getChannelData(0);
          if (a && !a.isClosed) {
            const f = n.encode(d);
            f && a.writeStreamChunk({
              buffer: f,
              isEnd: !1,
              timeReceived: Date.now()
            });
          }
        }, c.connect(p), p.connect(o.destination), this.privMediaResources = {
          scriptProcessorNode: p,
          source: c,
          stream: i
        };
      }, l = !!this.privSpeechProcessorScript && this.privSpeechProcessorScript.toLowerCase() === "ignore";
      if (o.audioWorklet && !l) {
        if (!this.privSpeechProcessorScript) {
          const p = `class SP extends AudioWorkletProcessor {
                    constructor(options) {
                      super(options);
                    }
                    process(inputs, outputs) {
                      const input = inputs[0];
                      const output = [];
                      for (let channel = 0; channel < input.length; channel += 1) {
                        output[channel] = input[channel];
                      }
                      this.port.postMessage(output[0]);
                      return true;
                    }
                  }
                  registerProcessor('speech-processor', SP);`, h = new Blob([p], { type: "application/javascript; charset=utf-8" });
          this.privSpeechProcessorScript = URL.createObjectURL(h);
        }
        o.audioWorklet.addModule(this.privSpeechProcessorScript).then(() => {
          const p = new AudioWorkletNode(o, "speech-processor");
          p.port.onmessage = (h) => {
            const d = h.data;
            if (a && !a.isClosed) {
              const f = n.encode(d);
              f && a.writeStreamChunk({
                buffer: f,
                isEnd: !1,
                timeReceived: Date.now()
              });
            }
          }, c.connect(p), p.connect(o.destination), this.privMediaResources = {
            scriptProcessorNode: p,
            source: c,
            stream: i
          };
        }).catch(() => {
          u();
        });
      } else
        try {
          u();
        } catch (p) {
          throw new Error(`Unable to start audio worklet node for PCMRecorder: ${p}`);
        }
    }
    releaseMediaResources(o) {
      this.privMediaResources && (this.privMediaResources.scriptProcessorNode && (this.privMediaResources.scriptProcessorNode.disconnect(o.destination), this.privMediaResources.scriptProcessorNode = null), this.privMediaResources.source && (this.privMediaResources.source.disconnect(), this.privStopInputOnRelease && this.privMediaResources.stream.getTracks().forEach((i) => i.stop()), this.privMediaResources.source = null));
    }
    setWorkletUrl(o) {
      this.privSpeechProcessorScript = o;
    }
  }
  return Or.PcmRecorder = t, Or;
}
var Mr = {}, fe = {}, Uu;
function av() {
  if (Uu) return fe;
  Uu = 1;
  var e = fe && fe.__createBinding || (Object.create ? function(h, d, f, g) {
    g === void 0 && (g = f), Object.defineProperty(h, g, { enumerable: !0, get: function() {
      return d[f];
    } });
  } : function(h, d, f, g) {
    g === void 0 && (g = f), h[g] = d[f];
  }), t = fe && fe.__setModuleDefault || (Object.create ? function(h, d) {
    Object.defineProperty(h, "default", { enumerable: !0, value: d });
  } : function(h, d) {
    h.default = d;
  }), r = fe && fe.__importStar || function(h) {
    if (h && h.__esModule) return h;
    var d = {};
    if (h != null) for (var f in h) f !== "default" && Object.prototype.hasOwnProperty.call(h, f) && e(d, h, f);
    return t(d, h), d;
  }, o = fe && fe.__importDefault || function(h) {
    return h && h.__esModule ? h : { default: h };
  };
  Object.defineProperty(fe, "__esModule", { value: !0 }), fe.WebsocketMessageAdapter = void 0;
  const i = r(Ot), a = r(Ot), s = o(Ot), n = o(Ot), c = o(Ot), u = /* @__PURE__ */ le(), l = /* @__PURE__ */ k();
  let p = class Ua {
    constructor(d, f, g, m, v, y) {
      if (!d)
        throw new l.ArgumentNullError("uri");
      if (!g)
        throw new l.ArgumentNullError("messageFormatter");
      this.proxyInfo = m, this.privConnectionEvents = new l.EventSource(), this.privConnectionId = f, this.privMessageFormatter = g, this.privConnectionState = l.ConnectionState.None, this.privUri = d, this.privHeaders = v, this.privEnableCompression = y, this.privHeaders[u.HeaderNames.ConnectionId] = this.privConnectionId, this.privHeaders.connectionId = this.privConnectionId, this.privLastErrorReceived = "";
    }
    get state() {
      return this.privConnectionState;
    }
    open() {
      if (this.privConnectionState === l.ConnectionState.Disconnected)
        return Promise.reject(`Cannot open a connection that is in ${this.privConnectionState} state`);
      if (this.privConnectionEstablishDeferral)
        return this.privConnectionEstablishDeferral.promise;
      this.privConnectionEstablishDeferral = new l.Deferred(), this.privCertificateValidatedDeferral = new l.Deferred(), this.privConnectionState = l.ConnectionState.Connecting;
      try {
        if (typeof WebSocket < "u" && !Ua.forceNpmWebSocket)
          this.privCertificateValidatedDeferral.resolve(), this.privWebsocketClient = new WebSocket(this.privUri);
        else {
          let f = new URL(this.privUri).protocol;
          f?.toLocaleLowerCase() === "wss:" ? f = "https:" : f?.toLocaleLowerCase() === "ws:" && (f = "http:");
          const g = { headers: this.privHeaders, perMessageDeflate: this.privEnableCompression, followRedirects: f.toLocaleLowerCase() === "https:" };
          this.privCertificateValidatedDeferral.resolve(), g.agent = this.getAgent(), g.agent.protocol = f, this.privWebsocketClient = new c.default(this.privUri, g), this.privWebsocketClient.on("redirect", (m) => {
            const v = new l.ConnectionRedirectEvent(this.privConnectionId, m, this.privUri, `Getting redirect URL from endpoint ${this.privUri} with redirect URL '${m}'`);
            l.Events.instance.onEvent(v);
          });
        }
        this.privWebsocketClient.binaryType = "arraybuffer", this.privReceivingMessageQueue = new l.Queue(), this.privDisconnectDeferral = new l.Deferred(), this.privSendMessageQueue = new l.Queue(), this.processSendQueue().catch((d) => {
          l.Events.instance.onEvent(new l.BackgroundEvent(d));
        });
      } catch (d) {
        return this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(500, d)), this.privConnectionEstablishDeferral.promise;
      }
      return this.onEvent(new l.ConnectionStartEvent(this.privConnectionId, this.privUri)), this.privWebsocketClient.onopen = () => {
        this.privCertificateValidatedDeferral.promise.then(() => {
          this.privConnectionState = l.ConnectionState.Connected, this.onEvent(new l.ConnectionEstablishedEvent(this.privConnectionId)), this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(200, ""));
        }, (d) => {
          this.privConnectionEstablishDeferral.reject(d);
        });
      }, this.privWebsocketClient.onerror = (d) => {
        this.onEvent(new l.ConnectionErrorEvent(this.privConnectionId, d.message, d.type)), this.privLastErrorReceived = d.message;
      }, this.privWebsocketClient.onclose = (d) => {
        this.privConnectionState === l.ConnectionState.Connecting ? (this.privConnectionState = l.ConnectionState.Disconnected, this.privConnectionEstablishDeferral.resolve(new l.ConnectionOpenResponse(d.code, d.reason + " " + this.privLastErrorReceived))) : (this.privConnectionState = l.ConnectionState.Disconnected, this.privWebsocketClient = null, this.onEvent(new l.ConnectionClosedEvent(this.privConnectionId, d.code, d.reason))), this.onClose(d.code, d.reason).catch((f) => {
          l.Events.instance.onEvent(new l.BackgroundEvent(f));
        });
      }, this.privWebsocketClient.onmessage = (d) => {
        const f = (/* @__PURE__ */ new Date()).toISOString();
        if (this.privConnectionState === l.ConnectionState.Connected) {
          const g = new l.Deferred();
          if (this.privReceivingMessageQueue.enqueueFromPromise(g.promise), d.data instanceof ArrayBuffer) {
            const m = new l.RawWebsocketMessage(l.MessageType.Binary, d.data);
            this.privMessageFormatter.toConnectionMessage(m).then((v) => {
              this.onEvent(new l.ConnectionMessageReceivedEvent(this.privConnectionId, f, v)), g.resolve(v);
            }, (v) => {
              g.reject(`Invalid binary message format. Error: ${v}`);
            });
          } else {
            const m = new l.RawWebsocketMessage(l.MessageType.Text, d.data);
            this.privMessageFormatter.toConnectionMessage(m).then((v) => {
              this.onEvent(new l.ConnectionMessageReceivedEvent(this.privConnectionId, f, v)), g.resolve(v);
            }, (v) => {
              g.reject(`Invalid text message format. Error: ${v}`);
            });
          }
        }
      }, this.privConnectionEstablishDeferral.promise;
    }
    send(d) {
      if (this.privConnectionState !== l.ConnectionState.Connected)
        return Promise.reject(`Cannot send on connection that is in ${l.ConnectionState[this.privConnectionState]} state`);
      const f = new l.Deferred(), g = new l.Deferred();
      return this.privSendMessageQueue.enqueueFromPromise(g.promise), this.privMessageFormatter.fromConnectionMessage(d).then((m) => {
        g.resolve({
          Message: d,
          RawWebsocketMessage: m,
          sendStatusDeferral: f
        });
      }, (m) => {
        g.reject(`Error formatting the message. ${m}`);
      }), f.promise;
    }
    read() {
      return this.privConnectionState !== l.ConnectionState.Connected ? Promise.reject(`Cannot read on connection that is in ${this.privConnectionState} state`) : this.privReceivingMessageQueue.dequeue();
    }
    close(d) {
      if (this.privWebsocketClient)
        this.privConnectionState !== l.ConnectionState.Disconnected && this.privWebsocketClient.close(1e3, d || "Normal closure by client");
      else
        return Promise.resolve();
      return this.privDisconnectDeferral.promise;
    }
    get events() {
      return this.privConnectionEvents;
    }
    sendRawMessage(d) {
      try {
        if (!d)
          return Promise.resolve();
        if (this.onEvent(new l.ConnectionMessageSentEvent(this.privConnectionId, (/* @__PURE__ */ new Date()).toISOString(), d.Message)), this.isWebsocketOpen)
          this.privWebsocketClient.send(d.RawWebsocketMessage.payload);
        else
          return Promise.reject("websocket send error: Websocket not ready " + this.privConnectionId + " " + d.Message.id + " " + new Error().stack);
        return Promise.resolve();
      } catch (f) {
        return Promise.reject(`websocket send error: ${f}`);
      }
    }
    async onClose(d, f) {
      const g = `Connection closed. ${d}: ${f}`;
      this.privConnectionState = l.ConnectionState.Disconnected, this.privDisconnectDeferral.resolve(), await this.privReceivingMessageQueue.drainAndDispose(() => {
      }, g), await this.privSendMessageQueue.drainAndDispose((m) => {
        m.sendStatusDeferral.reject(g);
      }, g);
    }
    async processSendQueue() {
      for (; ; ) {
        const f = await this.privSendMessageQueue.dequeue();
        if (!f)
          return;
        try {
          await this.sendRawMessage(f), f.sendStatusDeferral.resolve();
        } catch (g) {
          f.sendStatusDeferral.reject(g);
        }
      }
    }
    onEvent(d) {
      this.privConnectionEvents.onEvent(d), l.Events.instance.onEvent(d);
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getAgent() {
      const d = new s.default.Agent(this.createConnection);
      return this.proxyInfo !== void 0 && this.proxyInfo.HostName !== void 0 && this.proxyInfo.Port > 0 && (d.proxyInfo = this.proxyInfo), d;
    }
    static GetProxyAgent(d) {
      const f = {
        host: d.HostName,
        port: d.Port
      };
      return d.UserName ? f.headers = {
        "Proxy-Authentication": "Basic " + new Buffer(`${d.UserName}:${d.Password === void 0 ? "" : d.Password}`).toString("base64")
      } : f.headers = {}, f.headers.requestOCSP = "true", new n.default(f);
    }
    createConnection(d, f) {
      let g;
      if (f = {
        ...f,
        requestOCSP: !0,
        servername: f.host
      }, this.proxyInfo) {
        const v = Ua.GetProxyAgent(this.proxyInfo);
        g = new Promise((y, S) => {
          v.callback(d, f, (C, w) => {
            C ? S(C) : y(w);
          });
        });
      } else
        f.secureEndpoint ? g = Promise.resolve(a.connect(f)) : g = Promise.resolve(i.connect(f));
      return g;
    }
    get isWebsocketOpen() {
      return this.privWebsocketClient && this.privWebsocketClient.readyState === this.privWebsocketClient.OPEN;
    }
  };
  return fe.WebsocketMessageAdapter = p, p.forceNpmWebSocket = !1, fe;
}
var $u;
function oR() {
  if ($u) return Mr;
  $u = 1, Object.defineProperty(Mr, "__esModule", { value: !0 }), Mr.WebsocketConnection = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ av();
  let r = class {
    constructor(i, a, s, n, c, u = !1, l) {
      if (this.privIsDisposed = !1, !i)
        throw new e.ArgumentNullError("uri");
      if (!n)
        throw new e.ArgumentNullError("messageFormatter");
      this.privMessageFormatter = n;
      let p = "", h = 0;
      if (a) {
        for (const d in a)
          if (d) {
            p += h === 0 && i.indexOf("?") === -1 ? "?" : "&";
            const f = encodeURIComponent(d);
            p += f;
            let g = a[d];
            g && (g = encodeURIComponent(g), p += `=${g}`), h++;
          }
      }
      if (s) {
        for (const d in s)
          if (d) {
            p += h === 0 && i.indexOf("?") === -1 ? "?" : "&";
            const f = encodeURIComponent(s[d]);
            p += `${d}=${f}`, h++;
          }
      }
      this.privUri = i + p, this.privId = l || (0, e.createNoDashGuid)(), this.privConnectionMessageAdapter = new t.WebsocketMessageAdapter(this.privUri, this.id, this.privMessageFormatter, c, s, u);
    }
    async dispose() {
      this.privIsDisposed = !0, this.privConnectionMessageAdapter && await this.privConnectionMessageAdapter.close();
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    get id() {
      return this.privId;
    }
    get uri() {
      return this.privUri;
    }
    state() {
      return this.privConnectionMessageAdapter.state;
    }
    open() {
      return this.privConnectionMessageAdapter.open();
    }
    send(i) {
      return this.privConnectionMessageAdapter.send(i);
    }
    read() {
      return this.privConnectionMessageAdapter.read();
    }
    get events() {
      return this.privConnectionMessageAdapter.events;
    }
  };
  return Mr.WebsocketConnection = r, Mr;
}
var Dr = {}, Vu;
function aR() {
  if (Vu) return Dr;
  Vu = 1, Object.defineProperty(Dr, "__esModule", { value: !0 }), Dr.ReplayableAudioNode = void 0;
  let e = class {
    constructor(o, i) {
      this.privBuffers = [], this.privReplayOffset = 0, this.privLastShrinkOffset = 0, this.privBufferStartOffset = 0, this.privBufferSerial = 0, this.privBufferedBytes = 0, this.privReplay = !1, this.privLastChunkAcquiredTime = 0, this.privAudioNode = o, this.privBytesPerSecond = i;
    }
    id() {
      return this.privAudioNode.id();
    }
    // Reads and returns the next chunk of audio buffer.
    // If replay of existing buffers are needed, read() will first seek and replay
    // existing content, and upoin completion it will read new content from the underlying
    // audio node, saving that content into the replayable buffers.
    read() {
      if (this.privReplay && this.privBuffers.length !== 0) {
        const o = this.privReplayOffset - this.privBufferStartOffset;
        let i = Math.round(o * this.privBytesPerSecond * 1e-7);
        i % 2 !== 0 && i++;
        let a = 0;
        for (; a < this.privBuffers.length && i >= this.privBuffers[a].chunk.buffer.byteLength; )
          i -= this.privBuffers[a++].chunk.buffer.byteLength;
        if (a < this.privBuffers.length) {
          const s = this.privBuffers[a].chunk.buffer.slice(i);
          return this.privReplayOffset += s.byteLength / this.privBytesPerSecond * 1e7, a === this.privBuffers.length - 1 && (this.privReplay = !1), Promise.resolve({
            buffer: s,
            isEnd: !1,
            timeReceived: this.privBuffers[a].chunk.timeReceived
          });
        }
      }
      return this.privAudioNode.read().then((o) => (o && o.buffer && this.privBuffers && (this.privBuffers.push(new t(o, this.privBufferSerial++, this.privBufferedBytes)), this.privBufferedBytes += o.buffer.byteLength), o));
    }
    detach() {
      return this.privBuffers = void 0, this.privAudioNode.detach();
    }
    replay() {
      this.privBuffers && this.privBuffers.length !== 0 && (this.privReplay = !0, this.privReplayOffset = this.privLastShrinkOffset);
    }
    // Shrinks the existing audio buffers to start at the new offset, or at the
    // beginning of the buffer closest to the requested offset.
    // A replay request will start from the last shrink point.
    shrinkBuffers(o) {
      if (this.privBuffers === void 0 || this.privBuffers.length === 0)
        return;
      this.privLastShrinkOffset = o;
      const i = o - this.privBufferStartOffset;
      let a = Math.round(i * this.privBytesPerSecond * 1e-7), s = 0;
      for (; s < this.privBuffers.length && a >= this.privBuffers[s].chunk.buffer.byteLength; )
        a -= this.privBuffers[s++].chunk.buffer.byteLength;
      this.privBufferStartOffset = Math.round(o - a / this.privBytesPerSecond * 1e7), this.privBuffers = this.privBuffers.slice(s);
    }
    // Finds the time a buffer of audio was first seen by offset.
    findTimeAtOffset(o) {
      if (o < this.privBufferStartOffset || this.privBuffers === void 0)
        return 0;
      for (const i of this.privBuffers) {
        const a = i.byteOffset / this.privBytesPerSecond * 1e7, s = a + i.chunk.buffer.byteLength / this.privBytesPerSecond * 1e7;
        if (o >= a && o <= s)
          return i.chunk.timeReceived;
      }
      return 0;
    }
  };
  Dr.ReplayableAudioNode = e;
  class t {
    constructor(o, i, a) {
      this.chunk = o, this.serial = i, this.byteOffset = a;
    }
  }
  return Dr;
}
var Nr = {}, zo = {}, qe = {}, Ae = {}, Wu;
function cv() {
  if (Wu) return Ae;
  Wu = 1;
  var e = Ae && Ae.__createBinding || (Object.create ? function(s, n, c, u) {
    u === void 0 && (u = c), Object.defineProperty(s, u, { enumerable: !0, get: function() {
      return n[c];
    } });
  } : function(s, n, c, u) {
    u === void 0 && (u = c), s[u] = n[c];
  }), t = Ae && Ae.__setModuleDefault || (Object.create ? function(s, n) {
    Object.defineProperty(s, "default", { enumerable: !0, value: n });
  } : function(s, n) {
    s.default = n;
  }), r = Ae && Ae.__importStar || function(s) {
    if (s && s.__esModule) return s;
    var n = {};
    if (s != null) for (var c in s) c !== "default" && Object.prototype.hasOwnProperty.call(s, c) && e(n, s, c);
    return t(n, s), n;
  };
  Object.defineProperty(Ae, "__esModule", { value: !0 }), Ae.AudioFileWriter = void 0;
  const o = r(Ot), i = /* @__PURE__ */ z();
  let a = class {
    constructor(n) {
      i.Contracts.throwIfNullOrUndefined(o.openSync, `
File System access not available, please use Push or PullAudioOutputStream`), this.privFd = o.openSync(n, "w");
    }
    set format(n) {
      i.Contracts.throwIfNotUndefined(this.privAudioFormat, "format is already set"), this.privAudioFormat = n;
      let c = 0;
      this.privAudioFormat.hasHeader && (c = this.privAudioFormat.header.byteLength), this.privFd !== void 0 && (this.privWriteStream = o.createWriteStream("", { fd: this.privFd, start: c, autoClose: !1 }));
    }
    write(n) {
      i.Contracts.throwIfNullOrUndefined(this.privAudioFormat, "must set format before writing."), this.privWriteStream !== void 0 && this.privWriteStream.write(new Uint8Array(n.slice(0)));
    }
    close() {
      this.privFd !== void 0 && (this.privWriteStream.on("finish", () => {
        this.privAudioFormat.hasHeader && (this.privAudioFormat.updateHeader(this.privWriteStream.bytesWritten), o.writeSync(this.privFd, new Int8Array(this.privAudioFormat.header), 0, this.privAudioFormat.header.byteLength, 0)), o.closeSync(this.privFd), this.privFd = void 0;
      }), this.privWriteStream.end());
    }
    id() {
      return this.privId;
    }
  };
  return Ae.AudioFileWriter = a, Ae;
}
var ve = {}, Hu;
function uv() {
  if (Hu) return ve;
  Hu = 1, Object.defineProperty(ve, "__esModule", { value: !0 }), ve.PullAudioInputStreamImpl = ve.PullAudioInputStream = ve.PushAudioInputStreamImpl = ve.PushAudioInputStream = ve.AudioInputStream = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ Dt(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ Nt();
  let a = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member AudioInputStream.createPushStream
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * written to the push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The audio input stream being created.
     */
    static createPushStream(p) {
      return s.create(p);
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for read()
     * and close() methods.
     * @member AudioInputStream.createPullStream
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object, derived from
     * PullAudioInputStreamCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be returned from
     * the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The audio input stream being created.
     */
    static createPullStream(p, h) {
      return c.create(p, h);
    }
  };
  ve.AudioInputStream = a;
  class s extends a {
    /**
     * Creates a memory backed PushAudioInputStream with the specified audio format.
     * @member PushAudioInputStream.create
     * @function
     * @public
     * @param {AudioStreamFormat} format - The audio data format in which audio will be written to the
     * push audio stream's write() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PushAudioInputStream} The push audio input stream being created.
     */
    static create(p) {
      return new n(p);
    }
  }
  ve.PushAudioInputStream = s;
  class n extends s {
    /**
     * Creates and initalizes an instance with the given values.
     * @constructor
     * @param {AudioStreamFormat} format - The audio stream format.
     */
    constructor(p) {
      super(), p === void 0 ? this.privFormat = i.AudioStreamFormatImpl.getDefaultInputFormat() : this.privFormat = p, this.privEvents = new t.EventSource(), this.privId = (0, r.createNoDashGuid)(), this.privStream = new t.ChunkedArrayBufferStream(this.privFormat.avgBytesPerSec / 10);
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PushAudioInputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(p) {
      this.privStream.writeStreamChunk({
        buffer: p,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PushAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    async attach(p) {
      this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, p)), await this.turnOn();
      const h = this.privStream;
      return this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, p)), {
        detach: async () => (this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p)), this.turnOff()),
        id: () => p,
        read: () => h.read()
      };
    }
    detach(p) {
      this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PushStream",
        samplerate: this.privFormat.samplesPerSec,
        type: e.type.Stream
      });
    }
    onEvent(p) {
      this.privEvents.onEvent(p), t.Events.instance.onEvent(p);
    }
    toBuffer(p) {
      const h = Buffer.alloc(p.byteLength), d = new Uint8Array(p);
      for (let f = 0; f < h.length; ++f)
        h[f] = d[f];
      return h;
    }
  }
  ve.PushAudioInputStreamImpl = n;
  class c extends a {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @member PullAudioInputStream.create
     * @function
     * @public
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     * @returns {PullAudioInputStream} The push audio input stream being created.
     */
    static create(p, h) {
      return new u(p, h);
    }
  }
  ve.PullAudioInputStream = c;
  class u extends c {
    /**
     * Creates a PullAudioInputStream that delegates to the specified callback interface for
     * read() and close() methods, using the default format (16 kHz 16bit mono PCM).
     * @constructor
     * @param {PullAudioInputStreamCallback} callback - The custom audio input object,
     * derived from PullAudioInputStreamCustomCallback
     * @param {AudioStreamFormat} format - The audio data format in which audio will be
     * returned from the callback's read() method (Required if format is not 16 kHz 16bit mono PCM).
     */
    constructor(p, h) {
      super(), h === void 0 ? this.privFormat = o.AudioStreamFormat.getDefaultInputFormat() : this.privFormat = h, this.privEvents = new t.EventSource(), this.privId = (0, r.createNoDashGuid)(), this.privCallback = p, this.privIsClosed = !1, this.privBufferSize = this.privFormat.avgBytesPerSec / 10;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return Promise.resolve(this.privFormat);
    }
    /**
     * Closes the stream.
     * @member PullAudioInputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privIsClosed = !0, this.privCallback.close();
    }
    id() {
      return this.privId;
    }
    turnOn() {
      this.onEvent(new t.AudioSourceInitializingEvent(this.privId)), this.onEvent(new t.AudioSourceReadyEvent(this.privId));
    }
    async attach(p) {
      return this.onEvent(new t.AudioStreamNodeAttachingEvent(this.privId, p)), await this.turnOn(), this.onEvent(new t.AudioStreamNodeAttachedEvent(this.privId, p)), {
        detach: () => (this.privCallback.close(), this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p)), this.turnOff()),
        id: () => p,
        read: () => {
          let h = 0, d;
          for (; h < this.privBufferSize; ) {
            const f = new ArrayBuffer(this.privBufferSize - h), g = this.privCallback.read(f);
            if (d === void 0 ? d = f : new Int8Array(d).set(new Int8Array(f), h), g === 0)
              break;
            h += g;
          }
          return Promise.resolve({
            buffer: d.slice(0, h),
            isEnd: this.privIsClosed || h === 0,
            timeReceived: Date.now()
          });
        }
      };
    }
    detach(p) {
      this.onEvent(new t.AudioStreamNodeDetachedEvent(this.privId, p));
    }
    turnOff() {
    }
    get events() {
      return this.privEvents;
    }
    get deviceInfo() {
      return Promise.resolve({
        bitspersample: this.privFormat.bitsPerSample,
        channelcount: this.privFormat.channels,
        connectivity: e.connectivity.Unknown,
        manufacturer: "Speech SDK",
        model: "PullStream",
        samplerate: this.privFormat.samplesPerSec,
        type: e.type.Stream
      });
    }
    onEvent(p) {
      this.privEvents.onEvent(p), t.Events.instance.onEvent(p);
    }
  }
  return ve.PullAudioInputStreamImpl = u, ve;
}
var ge = {}, xr = {}, Lo = {}, Ku;
function lv() {
  return Ku || (Ku = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeechSynthesisOutputFormat = void 0, function(t) {
      t[t.Raw8Khz8BitMonoMULaw = 0] = "Raw8Khz8BitMonoMULaw", t[t.Riff16Khz16KbpsMonoSiren = 1] = "Riff16Khz16KbpsMonoSiren", t[t.Audio16Khz16KbpsMonoSiren = 2] = "Audio16Khz16KbpsMonoSiren", t[t.Audio16Khz32KBitRateMonoMp3 = 3] = "Audio16Khz32KBitRateMonoMp3", t[t.Audio16Khz128KBitRateMonoMp3 = 4] = "Audio16Khz128KBitRateMonoMp3", t[t.Audio16Khz64KBitRateMonoMp3 = 5] = "Audio16Khz64KBitRateMonoMp3", t[t.Audio24Khz48KBitRateMonoMp3 = 6] = "Audio24Khz48KBitRateMonoMp3", t[t.Audio24Khz96KBitRateMonoMp3 = 7] = "Audio24Khz96KBitRateMonoMp3", t[t.Audio24Khz160KBitRateMonoMp3 = 8] = "Audio24Khz160KBitRateMonoMp3", t[t.Raw16Khz16BitMonoTrueSilk = 9] = "Raw16Khz16BitMonoTrueSilk", t[t.Riff16Khz16BitMonoPcm = 10] = "Riff16Khz16BitMonoPcm", t[t.Riff8Khz16BitMonoPcm = 11] = "Riff8Khz16BitMonoPcm", t[t.Riff24Khz16BitMonoPcm = 12] = "Riff24Khz16BitMonoPcm", t[t.Riff8Khz8BitMonoMULaw = 13] = "Riff8Khz8BitMonoMULaw", t[t.Raw16Khz16BitMonoPcm = 14] = "Raw16Khz16BitMonoPcm", t[t.Raw24Khz16BitMonoPcm = 15] = "Raw24Khz16BitMonoPcm", t[t.Raw8Khz16BitMonoPcm = 16] = "Raw8Khz16BitMonoPcm", t[t.Ogg16Khz16BitMonoOpus = 17] = "Ogg16Khz16BitMonoOpus", t[t.Ogg24Khz16BitMonoOpus = 18] = "Ogg24Khz16BitMonoOpus", t[t.Raw48Khz16BitMonoPcm = 19] = "Raw48Khz16BitMonoPcm", t[t.Riff48Khz16BitMonoPcm = 20] = "Riff48Khz16BitMonoPcm", t[t.Audio48Khz96KBitRateMonoMp3 = 21] = "Audio48Khz96KBitRateMonoMp3", t[t.Audio48Khz192KBitRateMonoMp3 = 22] = "Audio48Khz192KBitRateMonoMp3", t[t.Ogg48Khz16BitMonoOpus = 23] = "Ogg48Khz16BitMonoOpus", t[t.Webm16Khz16BitMonoOpus = 24] = "Webm16Khz16BitMonoOpus", t[t.Webm24Khz16BitMonoOpus = 25] = "Webm24Khz16BitMonoOpus", t[t.Raw24Khz16BitMonoTrueSilk = 26] = "Raw24Khz16BitMonoTrueSilk", t[t.Raw8Khz8BitMonoALaw = 27] = "Raw8Khz8BitMonoALaw", t[t.Riff8Khz8BitMonoALaw = 28] = "Riff8Khz8BitMonoALaw", t[t.Webm24Khz16Bit24KbpsMonoOpus = 29] = "Webm24Khz16Bit24KbpsMonoOpus", t[t.Audio16Khz16Bit32KbpsMonoOpus = 30] = "Audio16Khz16Bit32KbpsMonoOpus", t[t.Audio24Khz16Bit48KbpsMonoOpus = 31] = "Audio24Khz16Bit48KbpsMonoOpus", t[t.Audio24Khz16Bit24KbpsMonoOpus = 32] = "Audio24Khz16Bit24KbpsMonoOpus", t[t.Raw22050Hz16BitMonoPcm = 33] = "Raw22050Hz16BitMonoPcm", t[t.Riff22050Hz16BitMonoPcm = 34] = "Riff22050Hz16BitMonoPcm", t[t.Raw44100Hz16BitMonoPcm = 35] = "Raw44100Hz16BitMonoPcm", t[t.Riff44100Hz16BitMonoPcm = 36] = "Riff44100Hz16BitMonoPcm", t[t.AmrWb16000Hz = 37] = "AmrWb16000Hz", t[t.G72216Khz64Kbps = 38] = "G72216Khz64Kbps";
    }(e.SpeechSynthesisOutputFormat || (e.SpeechSynthesisOutputFormat = {}));
  }(Lo)), Lo;
}
var Ju;
function Ss() {
  if (Ju) return xr;
  Ju = 1, Object.defineProperty(xr, "__esModule", { value: !0 }), xr.AudioOutputFormatImpl = void 0;
  const e = /* @__PURE__ */ lv(), t = /* @__PURE__ */ Nt();
  class r extends t.AudioStreamFormatImpl {
    /**
     * Creates an instance with the given values.
     * @constructor
     * @param formatTag
     * @param {number} channels - Number of channels.
     * @param {number} samplesPerSec - Samples per second.
     * @param {number} avgBytesPerSec - Average bytes per second.
     * @param {number} blockAlign - Block alignment.
     * @param {number} bitsPerSample - Bits per sample.
     * @param {string} audioFormatString - Audio format string
     * @param {string} requestAudioFormatString - Audio format string sent to service.
     * @param {boolean} hasHeader - If the format has header or not.
     */
    constructor(i, a, s, n, c, u, l, p, h) {
      super(s, u, a, i), this.formatTag = i, this.avgBytesPerSec = n, this.blockAlign = c, this.priAudioFormatString = l, this.priRequestAudioFormatString = p, this.priHasHeader = h;
    }
    static fromSpeechSynthesisOutputFormat(i) {
      return i === void 0 ? r.getDefaultOutputFormat() : r.fromSpeechSynthesisOutputFormatString(r.SpeechSynthesisOutputFormatToString[i]);
    }
    static fromSpeechSynthesisOutputFormatString(i) {
      switch (i) {
        case "raw-8khz-8bit-mono-mulaw":
          return new r(t.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, i, i, !1);
        case "riff-16khz-16kbps-mono-siren":
          return new r(t.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, i, "audio-16khz-16kbps-mono-siren", !0);
        case "audio-16khz-16kbps-mono-siren":
          return new r(t.AudioFormatTag.Siren, 1, 16e3, 2e3, 40, 0, i, i, !1);
        case "audio-16khz-32kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 4096, 2, 16, i, i, !1);
        case "audio-16khz-128kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 16384, 2, 16, i, i, !1);
        case "audio-16khz-64kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 16e3, 8192, 2, 16, i, i, !1);
        case "audio-24khz-48kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 6144, 2, 16, i, i, !1);
        case "audio-24khz-96kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 12288, 2, 16, i, i, !1);
        case "audio-24khz-160kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 24e3, 20480, 2, 16, i, i, !1);
        case "raw-16khz-16bit-mono-truesilk":
          return new r(t.AudioFormatTag.SILKSkype, 1, 16e3, 32e3, 2, 16, i, i, !1);
        case "riff-8khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, i, "raw-8khz-16bit-mono-pcm", !0);
        case "riff-24khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, i, "raw-24khz-16bit-mono-pcm", !0);
        case "riff-8khz-8bit-mono-mulaw":
          return new r(t.AudioFormatTag.MuLaw, 1, 8e3, 8e3, 1, 8, i, "raw-8khz-8bit-mono-mulaw", !0);
        case "raw-16khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, i, "raw-16khz-16bit-mono-pcm", !1);
        case "raw-24khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 24e3, 48e3, 2, 16, i, "raw-24khz-16bit-mono-pcm", !1);
        case "raw-8khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 8e3, 16e3, 2, 16, i, "raw-8khz-16bit-mono-pcm", !1);
        case "ogg-16khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 16e3, 8192, 2, 16, i, i, !1);
        case "ogg-24khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 24e3, 8192, 2, 16, i, i, !1);
        case "raw-48khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, i, "raw-48khz-16bit-mono-pcm", !1);
        case "riff-48khz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 48e3, 96e3, 2, 16, i, "raw-48khz-16bit-mono-pcm", !0);
        case "audio-48khz-96kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 48e3, 12288, 2, 16, i, i, !1);
        case "audio-48khz-192kbitrate-mono-mp3":
          return new r(t.AudioFormatTag.MP3, 1, 48e3, 24576, 2, 16, i, i, !1);
        case "ogg-48khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.OGG_OPUS, 1, 48e3, 12e3, 2, 16, i, i, !1);
        case "webm-16khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 16e3, 4e3, 2, 16, i, i, !1);
        case "webm-24khz-16bit-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 24e3, 6e3, 2, 16, i, i, !1);
        case "webm-24khz-16bit-24kbps-mono-opus":
          return new r(t.AudioFormatTag.WEBM_OPUS, 1, 24e3, 3e3, 2, 16, i, i, !1);
        case "audio-16khz-16bit-32kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 16e3, 4e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-48kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 24e3, 6e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-24kbps-mono-opus":
          return new r(t.AudioFormatTag.OPUS, 1, 24e3, 3e3, 2, 16, i, i, !1);
        case "audio-24khz-16bit-mono-flac":
          return new r(t.AudioFormatTag.FLAC, 1, 24e3, 24e3, 2, 16, i, i, !1);
        case "audio-48khz-16bit-mono-flac":
          return new r(t.AudioFormatTag.FLAC, 1, 48e3, 3e4, 2, 16, i, i, !1);
        case "raw-24khz-16bit-mono-truesilk":
          return new r(t.AudioFormatTag.SILKSkype, 1, 24e3, 48e3, 2, 16, i, i, !1);
        case "raw-8khz-8bit-mono-alaw":
          return new r(t.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, i, i, !1);
        case "riff-8khz-8bit-mono-alaw":
          return new r(t.AudioFormatTag.ALaw, 1, 8e3, 8e3, 1, 8, i, "raw-8khz-8bit-mono-alaw", !0);
        case "raw-22050hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, i, i, !1);
        case "riff-22050hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 22050, 44100, 2, 16, i, "raw-22050hz-16bit-mono-pcm", !0);
        case "raw-44100hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, i, i, !1);
        case "riff-44100hz-16bit-mono-pcm":
          return new r(t.AudioFormatTag.PCM, 1, 44100, 88200, 2, 16, i, "raw-44100hz-16bit-mono-pcm", !0);
        case "amr-wb-16000h":
          return new r(t.AudioFormatTag.AMR_WB, 1, 16e3, 3052, 2, 16, i, i, !1);
        case "g722-16khz-64kbps":
          return new r(t.AudioFormatTag.G722, 1, 16e3, 8e3, 2, 16, i, i, !1);
        case "riff-16khz-16bit-mono-pcm":
        default:
          return new r(t.AudioFormatTag.PCM, 1, 16e3, 32e3, 2, 16, "riff-16khz-16bit-mono-pcm", "raw-16khz-16bit-mono-pcm", !0);
      }
    }
    static getDefaultOutputFormat() {
      return r.fromSpeechSynthesisOutputFormatString(typeof window < "u" ? "audio-24khz-48kbitrate-mono-mp3" : "riff-16khz-16bit-mono-pcm");
    }
    /**
     * Specifies if this audio output format has a header
     * @boolean AudioOutputFormatImpl.prototype.hasHeader
     * @function
     * @public
     */
    get hasHeader() {
      return this.priHasHeader;
    }
    /**
     * Specifies the header of this format
     * @ArrayBuffer AudioOutputFormatImpl.prototype.header
     * @function
     * @public
     */
    get header() {
      if (this.hasHeader)
        return this.privHeader;
    }
    /**
     * Updates the header based on the audio length
     * @member AudioOutputFormatImpl.updateHeader
     * @function
     * @public
     * @param {number} audioLength - the audio length
     */
    updateHeader(i) {
      if (this.priHasHeader) {
        const a = new DataView(this.privHeader);
        a.setUint32(4, i + this.privHeader.byteLength - 8, !0), a.setUint32(40, i, !0);
      }
    }
    /**
     * Specifies the audio format string to be sent to the service
     * @string AudioOutputFormatImpl.prototype.requestAudioFormatString
     * @function
     * @public
     */
    get requestAudioFormatString() {
      return this.priRequestAudioFormatString;
    }
    /**
     * Adds audio header
     * @param audio the raw audio without header
     * @returns the audio with header if applicable
     */
    addHeader(i) {
      if (!this.hasHeader)
        return i;
      this.updateHeader(i.byteLength);
      const a = new Uint8Array(i.byteLength + this.header.byteLength);
      return a.set(new Uint8Array(this.header), 0), a.set(new Uint8Array(i), this.header.byteLength), a.buffer;
    }
  }
  return xr.AudioOutputFormatImpl = r, r.SpeechSynthesisOutputFormatToString = {
    [e.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoMULaw]: "raw-8khz-8bit-mono-mulaw",
    [e.SpeechSynthesisOutputFormat.Riff16Khz16KbpsMonoSiren]: "riff-16khz-16kbps-mono-siren",
    [e.SpeechSynthesisOutputFormat.Audio16Khz16KbpsMonoSiren]: "audio-16khz-16kbps-mono-siren",
    [e.SpeechSynthesisOutputFormat.Audio16Khz32KBitRateMonoMp3]: "audio-16khz-32kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio16Khz128KBitRateMonoMp3]: "audio-16khz-128kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio16Khz64KBitRateMonoMp3]: "audio-16khz-64kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz48KBitRateMonoMp3]: "audio-24khz-48kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz96KBitRateMonoMp3]: "audio-24khz-96kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio24Khz160KBitRateMonoMp3]: "audio-24khz-160kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoTrueSilk]: "raw-16khz-16bit-mono-truesilk",
    [e.SpeechSynthesisOutputFormat.Riff16Khz16BitMonoPcm]: "riff-16khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff8Khz16BitMonoPcm]: "riff-8khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm]: "riff-24khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoMULaw]: "riff-8khz-8bit-mono-mulaw",
    [e.SpeechSynthesisOutputFormat.Raw16Khz16BitMonoPcm]: "raw-16khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoPcm]: "raw-24khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw8Khz16BitMonoPcm]: "raw-8khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Ogg16Khz16BitMonoOpus]: "ogg-16khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Ogg24Khz16BitMonoOpus]: "ogg-24khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw48Khz16BitMonoPcm]: "raw-48khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff48Khz16BitMonoPcm]: "riff-48khz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Audio48Khz96KBitRateMonoMp3]: "audio-48khz-96kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Audio48Khz192KBitRateMonoMp3]: "audio-48khz-192kbitrate-mono-mp3",
    [e.SpeechSynthesisOutputFormat.Ogg48Khz16BitMonoOpus]: "ogg-48khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm16Khz16BitMonoOpus]: "webm-16khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm24Khz16BitMonoOpus]: "webm-24khz-16bit-mono-opus",
    [e.SpeechSynthesisOutputFormat.Webm24Khz16Bit24KbpsMonoOpus]: "webm-24khz-16bit-24kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw24Khz16BitMonoTrueSilk]: "raw-24khz-16bit-mono-truesilk",
    [e.SpeechSynthesisOutputFormat.Raw8Khz8BitMonoALaw]: "raw-8khz-8bit-mono-alaw",
    [e.SpeechSynthesisOutputFormat.Riff8Khz8BitMonoALaw]: "riff-8khz-8bit-mono-alaw",
    [e.SpeechSynthesisOutputFormat.Audio16Khz16Bit32KbpsMonoOpus]: "audio-16khz-16bit-32kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Audio24Khz16Bit48KbpsMonoOpus]: "audio-24khz-16bit-48kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Audio24Khz16Bit24KbpsMonoOpus]: "audio-24khz-16bit-24kbps-mono-opus",
    [e.SpeechSynthesisOutputFormat.Raw22050Hz16BitMonoPcm]: "raw-22050hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff22050Hz16BitMonoPcm]: "riff-22050hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Raw44100Hz16BitMonoPcm]: "raw-44100hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.Riff44100Hz16BitMonoPcm]: "riff-44100hz-16bit-mono-pcm",
    [e.SpeechSynthesisOutputFormat.AmrWb16000Hz]: "amr-wb-16000hz",
    [e.SpeechSynthesisOutputFormat.G72216Khz64Kbps]: "g722-16khz-64kbps"
  }, xr;
}
var Gu;
function Wt() {
  if (Gu) return ge;
  Gu = 1, Object.defineProperty(ge, "__esModule", { value: !0 }), ge.PushAudioOutputStreamImpl = ge.PushAudioOutputStream = ge.PullAudioOutputStreamImpl = ge.PullAudioOutputStream = ge.AudioOutputStream = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ Ss();
  let o = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member AudioOutputStream.createPullStream
     * @function
     * @public
     * @returns {PullAudioOutputStream} The audio output stream being created.
     */
    static createPullStream() {
      return i.create();
    }
  };
  ge.AudioOutputStream = o;
  class i extends o {
    /**
     * Creates a memory backed PullAudioOutputStream with the specified audio format.
     * @member PullAudioOutputStream.create
     * @function
     * @public
     * @returns {PullAudioOutputStream} The push audio output stream being created.
     */
    static create() {
      return new a();
    }
  }
  ge.PullAudioOutputStream = i;
  class a extends i {
    /**
     * Creates and initializes an instance with the given values.
     * @constructor
     */
    constructor() {
      super(), this.privId = (0, e.createNoDashGuid)(), this.privStream = new e.Stream();
    }
    /**
     * Sets the format information to the stream. For internal use only.
     * @param {AudioStreamFormat} format - the format to be set.
     */
    set format(u) {
      u == null && (this.privFormat = r.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privFormat = u;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privFormat;
    }
    /**
     * Checks if the stream is closed
     * @member PullAudioOutputStreamImpl.prototype.isClosed
     * @property
     * @public
     */
    get isClosed() {
      return this.privStream.isClosed;
    }
    /**
     * Gets the id of the stream
     * @member PullAudioOutputStreamImpl.prototype.id
     * @property
     * @public
     */
    id() {
      return this.privId;
    }
    /**
     * Reads audio data from the internal buffer.
     * @member PullAudioOutputStreamImpl.prototype.read
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - An ArrayBuffer to store the read data.
     * @returns {Promise<number>} - Audio buffer length has been read.
     */
    async read(u) {
      const l = new Int8Array(u);
      let p = 0;
      if (this.privLastChunkView !== void 0) {
        if (this.privLastChunkView.length > u.byteLength)
          return l.set(this.privLastChunkView.slice(0, u.byteLength)), this.privLastChunkView = this.privLastChunkView.slice(u.byteLength), Promise.resolve(u.byteLength);
        l.set(this.privLastChunkView), p = this.privLastChunkView.length, this.privLastChunkView = void 0;
      }
      for (; p < u.byteLength && !this.privStream.isReadEnded; ) {
        const h = await this.privStream.read();
        if (h !== void 0 && !h.isEnd) {
          let d;
          h.buffer.byteLength > u.byteLength - p ? (d = h.buffer.slice(0, u.byteLength - p), this.privLastChunkView = new Int8Array(h.buffer.slice(u.byteLength - p))) : d = h.buffer, l.set(new Int8Array(d), p), p += d.byteLength;
        } else
          this.privStream.readEnded();
      }
      return p;
    }
    /**
     * Writes the audio data specified by making an internal copy of the data.
     * @member PullAudioOutputStreamImpl.prototype.write
     * @function
     * @public
     * @param {ArrayBuffer} dataBuffer - The audio buffer of which this function will make a copy.
     */
    write(u) {
      t.Contracts.throwIfNullOrUndefined(this.privStream, "must set format before writing"), this.privStream.writeStreamChunk({
        buffer: u,
        isEnd: !1,
        timeReceived: Date.now()
      });
    }
    /**
     * Closes the stream.
     * @member PullAudioOutputStreamImpl.prototype.close
     * @function
     * @public
     */
    close() {
      this.privStream.close();
    }
  }
  ge.PullAudioOutputStreamImpl = a;
  class s extends o {
    /**
     * Creates and initializes and instance.
     * @constructor
     */
    constructor() {
      super();
    }
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * write() and close() methods.
     * @member PushAudioOutputStream.create
     * @function
     * @public
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     * @returns {PushAudioOutputStream} The push audio output stream being created.
     */
    static create(u) {
      return new n(u);
    }
  }
  ge.PushAudioOutputStream = s;
  class n extends s {
    /**
     * Creates a PushAudioOutputStream that delegates to the specified callback interface for
     * read() and close() methods.
     * @constructor
     * @param {PushAudioOutputStreamCallback} callback - The custom audio output object,
     * derived from PushAudioOutputStreamCallback
     */
    constructor(u) {
      super(), this.privId = (0, e.createNoDashGuid)(), this.privCallback = u;
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set format(u) {
    }
    write(u) {
      this.privCallback.write && this.privCallback.write(u);
    }
    close() {
      this.privCallback.close && this.privCallback.close();
    }
    id() {
      return this.privId;
    }
  }
  return ge.PushAudioOutputStreamImpl = n, ge;
}
var Qu;
function dv() {
  if (Qu) return qe;
  Qu = 1, Object.defineProperty(qe, "__esModule", { value: !0 }), qe.AudioOutputConfigImpl = qe.AudioConfigImpl = qe.AudioConfig = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ cv(), i = /* @__PURE__ */ uv(), a = /* @__PURE__ */ Wt();
  let s = class pv {
    /**
     * Creates an AudioConfig object representing the default microphone on the system.
     * @member AudioConfig.fromDefaultMicrophoneInput
     * @function
     * @public
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromDefaultMicrophoneInput() {
      const l = new e.PcmRecorder(!0);
      return new n(new e.MicAudioSource(l));
    }
    /**
     * Creates an AudioConfig object representing a microphone with the specified device ID.
     * @member AudioConfig.fromMicrophoneInput
     * @function
     * @public
     * @param {string | undefined} deviceId - Specifies the device ID of the microphone to be used.
     * Default microphone is used the value is omitted.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromMicrophoneInput(l) {
      const p = new e.PcmRecorder(!0);
      return new n(new e.MicAudioSource(p, l));
    }
    /**
     * Creates an AudioConfig object representing the specified file.
     * @member AudioConfig.fromWavFileInput
     * @function
     * @public
     * @param {File} fileName - Specifies the audio input file. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromWavFileInput(l, p = "unnamedBuffer.wav") {
      return new n(new e.FileAudioSource(l, p));
    }
    /**
     * Creates an AudioConfig object representing the specified stream.
     * @member AudioConfig.fromStreamInput
     * @function
     * @public
     * @param {AudioInputStream | PullAudioInputStreamCallback | MediaStream} audioStream - Specifies the custom audio input
     * stream. Currently, only WAV / PCM is supported.
     * @returns {AudioConfig} The audio input configuration being created.
     */
    static fromStreamInput(l) {
      if (l instanceof r.PullAudioInputStreamCallback)
        return new n(new i.PullAudioInputStreamImpl(l));
      if (l instanceof r.AudioInputStream)
        return new n(l);
      if (typeof MediaStream < "u" && l instanceof MediaStream) {
        const p = new e.PcmRecorder(!1);
        return new n(new e.MicAudioSource(p, null, null, l));
      }
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing the default speaker.
     * @member AudioConfig.fromDefaultSpeakerOutput
     * @function
     * @public
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromDefaultSpeakerOutput() {
      return new c(new r.SpeakerAudioDestination());
    }
    /**
     * Creates an AudioConfig object representing the custom IPlayer object.
     * You can use the IPlayer object to control pause, resume, etc.
     * @member AudioConfig.fromSpeakerOutput
     * @function
     * @public
     * @param {IPlayer} player - the IPlayer object for playback.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.12.0
     */
    static fromSpeakerOutput(l) {
      if (l === void 0)
        return pv.fromDefaultSpeakerOutput();
      if (l instanceof r.SpeakerAudioDestination)
        return new c(l);
      throw new Error("Not Supported Type");
    }
    /**
     * Creates an AudioConfig object representing a specified output audio file
     * @member AudioConfig.fromAudioFileOutput
     * @function
     * @public
     * @param {PathLike} filename - the filename of the output audio file
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromAudioFileOutput(l) {
      return new c(new o.AudioFileWriter(l));
    }
    /**
     * Creates an AudioConfig object representing a specified audio output stream
     * @member AudioConfig.fromStreamOutput
     * @function
     * @public
     * @param {AudioOutputStream | PushAudioOutputStreamCallback} audioStream - Specifies the custom audio output
     * stream.
     * @returns {AudioConfig} The audio output configuration being created.
     * Added in version 1.11.0
     */
    static fromStreamOutput(l) {
      if (l instanceof r.PushAudioOutputStreamCallback)
        return new c(new a.PushAudioOutputStreamImpl(l));
      if (l instanceof r.PushAudioOutputStream)
        return new c(l);
      if (l instanceof r.PullAudioOutputStream)
        return new c(l);
      throw new Error("Not Supported Type");
    }
  };
  qe.AudioConfig = s;
  class n extends s {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioSource} source - An audio source.
     */
    constructor(l) {
      super(), this.privSource = l;
    }
    /**
     * Format information for the audio
     */
    get format() {
      return this.privSource.format;
    }
    /**
     * @member AudioConfigImpl.prototype.close
     * @function
     * @public
     */
    close(l, p) {
      this.privSource.turnOff().then(() => {
        l && l();
      }, (h) => {
        p && p(h);
      });
    }
    /**
     * @member AudioConfigImpl.prototype.id
     * @function
     * @public
     */
    id() {
      return this.privSource.id();
    }
    /**
     * @member AudioConfigImpl.prototype.turnOn
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOn() {
      return this.privSource.turnOn();
    }
    /**
     * @member AudioConfigImpl.prototype.attach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     * @returns {Promise<IAudioStreamNode>} A promise.
     */
    attach(l) {
      return this.privSource.attach(l);
    }
    /**
     * @member AudioConfigImpl.prototype.detach
     * @function
     * @public
     * @param {string} audioNodeId - The audio node id.
     */
    detach(l) {
      return this.privSource.detach(l);
    }
    /**
     * @member AudioConfigImpl.prototype.turnOff
     * @function
     * @public
     * @returns {Promise<void>} A promise.
     */
    turnOff() {
      return this.privSource.turnOff();
    }
    /**
     * @member AudioConfigImpl.prototype.events
     * @function
     * @public
     * @returns {EventSource<AudioSourceEvent>} An event source for audio events.
     */
    get events() {
      return this.privSource.events;
    }
    setProperty(l, p) {
      if (t.Contracts.throwIfNull(p, "value"), this.privSource.setProperty !== void 0)
        this.privSource.setProperty(l, p);
      else
        throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty(l, p) {
      if (this.privSource.getProperty !== void 0)
        return this.privSource.getProperty(l, p);
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
    get deviceInfo() {
      return this.privSource.deviceInfo;
    }
  }
  qe.AudioConfigImpl = n;
  class c extends s {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {IAudioDestination} destination - An audio destination.
     */
    constructor(l) {
      super(), this.privDestination = l;
    }
    set format(l) {
      this.privDestination.format = l;
    }
    write(l) {
      this.privDestination.write(l);
    }
    close() {
      this.privDestination.close();
    }
    id() {
      return this.privDestination.id();
    }
    setProperty() {
      throw new Error("This AudioConfig instance does not support setting properties.");
    }
    getProperty() {
      throw new Error("This AudioConfig instance does not support getting properties.");
    }
  }
  return qe.AudioOutputConfigImpl = c, qe;
}
var jo = {}, Yu;
function cR() {
  return Yu || (Yu = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationReason = void 0, function(t) {
      t[t.Error = 0] = "Error", t[t.EndOfStream = 1] = "EndOfStream";
    }(e.CancellationReason || (e.CancellationReason = {}));
  }(jo)), jo;
}
var zr = {}, Zu;
function uR() {
  if (Zu) return zr;
  Zu = 1, Object.defineProperty(zr, "__esModule", { value: !0 }), zr.PullAudioInputStreamCallback = void 0;
  let e = class {
  };
  return zr.PullAudioInputStreamCallback = e, zr;
}
var Lr = {}, Xu;
function lR() {
  if (Xu) return Lr;
  Xu = 1, Object.defineProperty(Lr, "__esModule", { value: !0 }), Lr.PushAudioOutputStreamCallback = void 0;
  let e = class {
  };
  return Lr.PushAudioOutputStreamCallback = e, Lr;
}
var jr = {}, el;
function pR() {
  if (el) return jr;
  el = 1, Object.defineProperty(jr, "__esModule", { value: !0 }), jr.KeywordRecognitionModel = void 0;
  const e = /* @__PURE__ */ z();
  let t = class {
    /**
     * Create and initializes a new instance.
     * @constructor
     */
    constructor() {
      this.privDisposed = !1;
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromFile
     * @function
     * @public
     * @param {string} fileName - A string that represents file name for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model
     * will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */
    static fromFile(o) {
      throw e.Contracts.throwIfFileDoesNotExist(o, "fileName"), new Error("Not yet implemented.");
    }
    /**
     * Creates a keyword recognition model using the specified filename.
     * @member KeywordRecognitionModel.fromStream
     * @function
     * @public
     * @param {string} file - A File that represents file for the keyword recognition model.
     * Note, the file can point to a zip file in which case the model will be extracted from the zip.
     * @returns {KeywordRecognitionModel} The keyword recognition model being created.
     */
    static fromStream(o) {
      throw e.Contracts.throwIfNull(o, "file"), new Error("Not yet implemented.");
    }
    /**
     * Dispose of associated resources.
     * @member KeywordRecognitionModel.prototype.close
     * @function
     * @public
     */
    close() {
      this.privDisposed || (this.privDisposed = !0);
    }
  };
  return jr.KeywordRecognitionModel = t, jr;
}
var qr = {}, tl;
function dR() {
  if (tl) return qr;
  tl = 1, Object.defineProperty(qr, "__esModule", { value: !0 }), qr.SessionEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionId - The session id.
     */
    constructor(r) {
      this.privSessionId = r;
    }
    /**
     * Represents the session identifier.
     * @member SessionEventArgs.prototype.sessionId
     * @function
     * @public
     * @returns {string} Represents the session identifier.
     */
    get sessionId() {
      return this.privSessionId;
    }
  };
  return qr.SessionEventArgs = e, qr;
}
var Fr = {}, rl;
function hR() {
  if (rl) return Fr;
  rl = 1, Object.defineProperty(Fr, "__esModule", { value: !0 }), Fr.RecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i) {
      super(i), this.privOffset = o;
    }
    /**
     * Represents the message offset
     * @member RecognitionEventArgs.prototype.offset
     * @function
     * @public
     */
    get offset() {
      return this.privOffset;
    }
  };
  return Fr.RecognitionEventArgs = t, Fr;
}
var qo = {}, nl;
function fR() {
  return nl || (nl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OutputFormat = void 0, function(t) {
      t[t.Simple = 0] = "Simple", t[t.Detailed = 1] = "Detailed";
    }(e.OutputFormat || (e.OutputFormat = {}));
  }(qo)), qo;
}
var Br = {}, il;
function vR() {
  if (il) return Br;
  il = 1, Object.defineProperty(Br, "__esModule", { value: !0 }), Br.IntentRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param result - The result of the intent recognition.
     * @param offset - The offset.
     * @param sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Represents the intent recognition result.
     * @member IntentRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {IntentRecognitionResult} Represents the intent recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Br.IntentRecognitionEventArgs = t, Br;
}
var Ur = {}, sl;
function gR() {
  if (sl) return Ur;
  sl = 1, Object.defineProperty(Ur, "__esModule", { value: !0 }), Ur.RecognitionResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, o, i, a, s, n, c, u, l, p) {
      this.privResultId = r, this.privReason = o, this.privText = i, this.privDuration = a, this.privOffset = s, this.privLanguage = n, this.privLanguageDetectionConfidence = c, this.privErrorDetails = u, this.privJson = l, this.privProperties = p;
    }
    /**
     * Specifies the result identifier.
     * @member RecognitionResult.prototype.resultId
     * @function
     * @public
     * @returns {string} Specifies the result identifier.
     */
    get resultId() {
      return this.privResultId;
    }
    /**
     * Specifies status of the result.
     * @member RecognitionResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} Specifies status of the result.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * Presents the recognized text in the result.
     * @member RecognitionResult.prototype.text
     * @function
     * @public
     * @returns {string} Presents the recognized text in the result.
     */
    get text() {
      return this.privText;
    }
    /**
     * Duration of recognized speech in 100 nano second increments.
     * @member RecognitionResult.prototype.duration
     * @function
     * @public
     * @returns {number} Duration of recognized speech in 100 nano second increments.
     */
    get duration() {
      return this.privDuration;
    }
    /**
     * Offset of recognized speech in 100 nano second increments.
     * @member RecognitionResult.prototype.offset
     * @function
     * @public
     * @returns {number} Offset of recognized speech in 100 nano second increments.
     */
    get offset() {
      return this.privOffset;
    }
    /**
     * Primary Language detected.
     * @member RecognitionResult.prototype.language
     * @function
     * @public
     * @returns {string} language detected.
     */
    get language() {
      return this.privLanguage;
    }
    /**
     * Primary Language detection confidence (Unknown, Low, Medium, High).
     * @member RecognitionResult.prototype.languageDetectionConfidence
     * @function
     * @public
     * @returns {string} detection confidence strength.
     */
    get languageDetectionConfidence() {
      return this.privLanguageDetectionConfidence;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member RecognitionResult.prototype.errorDetails
     * @function
     * @public
     * @returns {string} a brief description of an error.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * A string containing Json serialized recognition result as it was received from the service.
     * @member RecognitionResult.prototype.json
     * @function
     * @private
     * @returns {string} Json serialized representation of the result.
     */
    get json() {
      return this.privJson;
    }
    /**
     * The set of properties exposed in the result.
     * @member RecognitionResult.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The set of properties exposed in the result.
     */
    get properties() {
      return this.privProperties;
    }
  };
  return Ur.RecognitionResult = e, Ur;
}
var $r = {}, ol;
function mR() {
  if (ol) return $r;
  ol = 1, Object.defineProperty($r, "__esModule", { value: !0 }), $r.SpeechRecognitionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription, if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(o, i, a, s, n, c, u, p, h, d), this.privSpeakerId = l;
    }
    /**
     * speaker id from conversation transcription/id scenarios
     * @member SpeechRecognitionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return $r.SpeechRecognitionResult = t, $r;
}
var Vr = {}, al;
function yR() {
  if (al) return Vr;
  al = 1, Object.defineProperty(Vr, "__esModule", { value: !0 }), Vr.IntentRecognitionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param intentId - The intent id.
     * @param resultId - The result id.
     * @param reason - The reason.
     * @param text - The recognized text.
     * @param duration - The duration.
     * @param offset - The offset into the stream.
     * @param language - Primary Language detected, if provided.
     * @param languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param errorDetails - Error details, if provided.
     * @param json - Additional Json, if provided.
     * @param properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(i, a, s, n, c, u, l, void 0, p, h, d), this.privIntentId = o;
    }
    /**
     * A String that represents the intent identifier being recognized.
     * @member IntentRecognitionResult.prototype.intentId
     * @function
     * @public
     * @returns {string} A String that represents the intent identifier being recognized.
     */
    get intentId() {
      return this.privIntentId;
    }
  };
  return Vr.IntentRecognitionResult = t, Vr;
}
var dt = {}, cl;
function SR() {
  if (cl) return dt;
  cl = 1, Object.defineProperty(dt, "__esModule", { value: !0 }), dt.LanguageUnderstandingModelImpl = dt.LanguageUnderstandingModel = void 0;
  const e = /* @__PURE__ */ z();
  let t = class {
    /**
     * Creates and initializes a new instance
     * @constructor
     */
    constructor() {
    }
    /**
     * Creates an language understanding model using the specified endpoint.
     * @member LanguageUnderstandingModel.fromEndpoint
     * @function
     * @public
     * @param {URL} uri - A String that represents the endpoint of the language understanding model.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromEndpoint(i) {
      e.Contracts.throwIfNull(i, "uri"), e.Contracts.throwIfNullOrWhitespace(i.hostname, "uri");
      const a = new r(), s = i.host.indexOf(".");
      if (s === -1)
        throw new Error("Could not determine region from endpoint");
      a.region = i.host.substr(0, s);
      const n = i.pathname.lastIndexOf("/") + 1;
      if (n === -1)
        throw new Error("Could not determine appId from endpoint");
      if (a.appId = i.pathname.substr(n), a.subscriptionKey = i.searchParams.get("subscription-key"), a.subscriptionKey === void 0)
        throw new Error("Could not determine subscription key from endpoint");
      return a;
    }
    /**
     * Creates an language understanding model using the application id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromAppId
     * @function
     * @public
     * @param {string} appId - A String that represents the application id of Language Understanding service.
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromAppId(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "appId");
      const a = new r();
      return a.appId = i, a;
    }
    /**
     * Creates a language understanding model using hostname, subscription key and application
     * id of Language Understanding service.
     * @member LanguageUnderstandingModel.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - A String that represents the subscription key of
     * Language Understanding service.
     * @param {string} appId - A String that represents the application id of Language
     * Understanding service.
     * @param {LanguageUnderstandingModel} region - A String that represents the region
     * of the Language Understanding service (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {LanguageUnderstandingModel} The language understanding model being created.
     */
    static fromSubscription(i, a, s) {
      e.Contracts.throwIfNullOrWhitespace(i, "subscriptionKey"), e.Contracts.throwIfNullOrWhitespace(a, "appId"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const n = new r();
      return n.appId = a, n.region = s, n.subscriptionKey = i, n;
    }
  };
  dt.LanguageUnderstandingModel = t;
  class r extends t {
  }
  return dt.LanguageUnderstandingModelImpl = r, dt;
}
var Fe = {}, ul;
function CR() {
  if (ul) return Fe;
  ul = 1, Object.defineProperty(Fe, "__esModule", { value: !0 }), Fe.MeetingTranscriptionEventArgs = Fe.ConversationTranscriptionEventArgs = Fe.SpeechRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechRecognitionResult} result - The speech recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(a, s, n) {
      super(s, n), this.privResult = a;
    }
    /**
     * Specifies the recognition result.
     * @member SpeechRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  Fe.SpeechRecognitionEventArgs = t;
  class r extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranscriptionResult} result - The conversation transcription result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(a, s, n) {
      super(s, n), this.privResult = a;
    }
    /**
     * Specifies the transcription result.
     * @member ConversationTranscription1EventArgs.prototype.result
     * @function
     * @public
     * @returns {ConversationTranscriptionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  }
  Fe.ConversationTranscriptionEventArgs = r;
  class o extends t {
  }
  return Fe.MeetingTranscriptionEventArgs = o, Fe;
}
var Wr = {}, Hr = {}, ll;
function Cs() {
  if (ll) return Hr;
  ll = 1, Object.defineProperty(Hr, "__esModule", { value: !0 }), Hr.CancellationEventArgsBase = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a, s, n) {
      super(s, n), this.privReason = o, this.privErrorDetails = i, this.privErrorCode = a;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationEventArgsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful operation.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful operation, provides details of the occurred error.
     * @member CancellationEventArgsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return Hr.CancellationEventArgsBase = t, Hr;
}
var pl;
function RR() {
  if (pl) return Wr;
  pl = 1, Object.defineProperty(Wr, "__esModule", { value: !0 }), Wr.SpeechRecognitionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Cs();
  let t = class extends e.CancellationEventArgsBase {
  };
  return Wr.SpeechRecognitionCanceledEventArgs = t, Wr;
}
var Kr = {}, dl;
function PR() {
  if (dl) return Kr;
  dl = 1, Object.defineProperty(Kr, "__esModule", { value: !0 }), Kr.TranslationRecognitionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationRecognitionResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Kr.TranslationRecognitionEventArgs = t, Kr;
}
var Jr = {}, hl;
function wR() {
  if (hl) return Jr;
  hl = 1, Object.defineProperty(Jr, "__esModule", { value: !0 }), Jr.TranslationSynthesisEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {TranslationSynthesisResult} result - The translation synthesis result.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i) {
      super(i), this.privResult = o;
    }
    /**
     * Specifies the translation synthesis result.
     * @member TranslationSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationSynthesisResult} Specifies the translation synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Jr.TranslationSynthesisEventArgs = t, Jr;
}
var Gr = {}, fl;
function fv() {
  if (fl) return Gr;
  fl = 1, Object.defineProperty(Gr, "__esModule", { value: !0 }), Gr.TranslationRecognitionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class hv extends e.SpeechRecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {Translations} translations - The translations.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(i, a, s, n, c, u, l, void 0, p, h, d), this.privTranslations = o;
    }
    static fromSpeechRecognitionResult(o) {
      return new hv(void 0, o.resultId, o.reason, o.text, o.duration, o.offset, o.language, o.languageDetectionConfidence, o.errorDetails, o.json, o.properties);
    }
    /**
     * Presents the translation results. Each item in the dictionary represents
     * a translation result in one of target languages, where the key is the name
     * of the target language, in BCP-47 format, and the value is the translation
     * text in the specified language.
     * @member TranslationRecognitionResult.prototype.translations
     * @function
     * @public
     * @returns {Translations} the current translation map that holds all translations requested.
     */
    get translations() {
      return this.privTranslations;
    }
  };
  return Gr.TranslationRecognitionResult = t, Gr;
}
var Qr = {}, vl;
function bR() {
  if (vl) return Qr;
  vl = 1, Object.defineProperty(Qr, "__esModule", { value: !0 }), Qr.TranslationSynthesisResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ResultReason} reason - The synthesis reason.
     * @param {ArrayBuffer} audio - The audio data.
     */
    constructor(r, o) {
      this.privReason = r, this.privAudio = o;
    }
    /**
     * Translated text in the target language.
     * @member TranslationSynthesisResult.prototype.audio
     * @function
     * @public
     * @returns {ArrayBuffer} Translated audio in the target language.
     */
    get audio() {
      return this.privAudio;
    }
    /**
     * The synthesis status.
     * @member TranslationSynthesisResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} The synthesis status.
     */
    get reason() {
      return this.privReason;
    }
  };
  return Qr.TranslationSynthesisResult = e, Qr;
}
var Fo = {}, gl;
function ER() {
  return gl || (gl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ResultReason = void 0, function(t) {
      t[t.NoMatch = 0] = "NoMatch", t[t.Canceled = 1] = "Canceled", t[t.RecognizingSpeech = 2] = "RecognizingSpeech", t[t.RecognizedSpeech = 3] = "RecognizedSpeech", t[t.RecognizedKeyword = 4] = "RecognizedKeyword", t[t.RecognizingIntent = 5] = "RecognizingIntent", t[t.RecognizedIntent = 6] = "RecognizedIntent", t[t.TranslatingSpeech = 7] = "TranslatingSpeech", t[t.TranslatedSpeech = 8] = "TranslatedSpeech", t[t.SynthesizingAudio = 9] = "SynthesizingAudio", t[t.SynthesizingAudioCompleted = 10] = "SynthesizingAudioCompleted", t[t.SynthesizingAudioStarted = 11] = "SynthesizingAudioStarted", t[t.EnrollingVoiceProfile = 12] = "EnrollingVoiceProfile", t[t.EnrolledVoiceProfile = 13] = "EnrolledVoiceProfile", t[t.RecognizedSpeakers = 14] = "RecognizedSpeakers", t[t.RecognizedSpeaker = 15] = "RecognizedSpeaker", t[t.ResetVoiceProfile = 16] = "ResetVoiceProfile", t[t.DeletedVoiceProfile = 17] = "DeletedVoiceProfile", t[t.VoicesListRetrieved = 18] = "VoicesListRetrieved", t[t.TranslatingParticipantSpeech = 19] = "TranslatingParticipantSpeech", t[t.TranslatedParticipantSpeech = 20] = "TranslatedParticipantSpeech", t[t.TranslatedInstantMessage = 21] = "TranslatedInstantMessage", t[t.TranslatedParticipantInstantMessage = 22] = "TranslatedParticipantInstantMessage";
    }(e.ResultReason || (e.ResultReason = {}));
  }(Fo)), Fo;
}
var ht = {}, ml;
function IR() {
  if (ml) return ht;
  ml = 1, Object.defineProperty(ht, "__esModule", { value: !0 }), ht.SpeechConfigImpl = ht.SpeechConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I();
  let o = class {
    /**
     * Creates and initializes an instance.
     * @constructor
     */
    constructor() {
    }
    /**
     * Static instance of SpeechConfig returned by passing subscriptionKey and service region.
     * Note: Please use your LanguageUnderstanding subscription key in case you want to use the Intent recognizer.
     * @member SpeechConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} The speech factory
     */
    static fromSubscription(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "subscriptionKey"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c.setProperty(r.PropertyId.SpeechServiceConnection_IntentRegion, n), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c;
    }
    /**
     * Internal implementation of fromEndpoint() overloads. Accepts either a subscription key or a TokenCredential.
     * @private
     */
    static fromEndpoint(s, n) {
      t.Contracts.throwIfNull(s, "endpoint");
      const c = typeof n == "string" && n.trim().length > 0, u = typeof n == "object" && n !== null && typeof n.getToken == "function";
      if (n !== void 0 && !c && !u)
        throw new Error("Invalid 'auth' parameter: must be a non-empty key string or a valid TokenCredential object.");
      const l = typeof n == "object" ? new i(n) : new i();
      return l.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, s.href), typeof n == "string" && n.trim().length > 0 && l.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), l;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(s, n) {
      t.Contracts.throwIfNull(s, "hostName");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Host, s.protocol + "//" + s.hostname + (s.port === "" ? "" : ":" + s.port)), c.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), n !== void 0 && c.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), c;
    }
    /**
     * Creates an instance of the speech factory with specified initial authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key in case you want
     * to use the Intent recognizer. As configuration values are copied when creating a new recognizer,
     * the new token value will not apply to recognizers that have already been created. For recognizers
     * that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The initial authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromAuthorizationToken(s, n) {
      t.Contracts.throwIfNull(s, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c.setProperty(r.PropertyId.SpeechServiceConnection_IntentRegion, n), c.authorizationToken = s, c;
    }
    /**
     * Closes the configuration.
     * @member SpeechConfig.prototype.close
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    close() {
    }
  };
  ht.SpeechConfig = o;
  class i extends o {
    constructor(s) {
      super(), this.privProperties = new r.PropertyCollection(), this.speechRecognitionLanguage = "en-US", this.outputFormat = r.OutputFormat.Simple, this.privTokenCredential = s;
    }
    get properties() {
      return this.privProperties;
    }
    get endPoint() {
      return new URL(this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint));
    }
    get subscriptionKey() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Key);
    }
    get region() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_Region);
    }
    get authorizationToken() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    get speechRecognitionLanguage() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    set speechRecognitionLanguage(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, s);
    }
    get autoDetectSourceLanguages() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages);
    }
    set autoDetectSourceLanguages(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, s);
    }
    get outputFormat() {
      return r.OutputFormat[this.privProperties.getProperty(e.OutputFormatPropertyName, void 0)];
    }
    set outputFormat(s) {
      this.privProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[s]);
    }
    get endpointId() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId);
    }
    set endpointId(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_EndpointId, s);
    }
    get tokenCredential() {
      return this.privTokenCredential;
    }
    setProperty(s, n) {
      t.Contracts.throwIfNull(n, "value"), this.privProperties.setProperty(s, n);
    }
    getProperty(s, n) {
      return this.privProperties.getProperty(s, n);
    }
    setProxy(s, n, c, u) {
      this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyHostName], s), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPort], n), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    setServiceProperty(s, n) {
      const c = JSON.parse(this.privProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
      c[s] = n, this.privProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_ProfanityOption, r.ProfanityOption[s]);
    }
    enableAudioLogging() {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true"), this.privProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Detailed]);
    }
    enableDictation() {
      this.privProperties.setProperty(e.ForceDictationPropertyName, "true");
    }
    clone() {
      const s = new i(this.tokenCredential);
      return s.privProperties = this.privProperties.clone(), s;
    }
    get speechSynthesisLanguage() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, s);
    }
    get speechSynthesisVoiceName() {
      return this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, s);
    }
    get speechSynthesisOutputFormat() {
      return r.SpeechSynthesisOutputFormat[this.privProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(s) {
      this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, r.SpeechSynthesisOutputFormat[s]);
    }
  }
  return ht.SpeechConfigImpl = i, ht;
}
var ft = {}, yl;
function AR() {
  if (yl) return ft;
  yl = 1, Object.defineProperty(ft, "__esModule", { value: !0 }), ft.SpeechTranslationConfigImpl = ft.SpeechTranslationConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I();
  let o = class extends r.SpeechConfig {
    /**
     * Creates an instance of recognizer config.
     */
    constructor() {
      super();
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing a subscription key and service region.
     * @member SpeechTranslationConfig.fromSubscription
     * @function
     * @public
     * @param {string} subscriptionKey - The subscription key.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromSubscription(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "subscriptionKey"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Static instance of SpeechTranslationConfig returned by passing authorization token and service region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by setting the property authorizationToken with a new
     * valid token. Otherwise, all the recognizers created by this SpeechTranslationConfig instance
     * will encounter errors during recognition.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply
     * to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member SpeechTranslationConfig.fromAuthorizationToken
     * @function
     * @public
     * @param {string} authorizationToken - The authorization token.
     * @param {string} region - The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {SpeechTranslationConfig} The speech translation config.
     */
    static fromAuthorizationToken(s, n) {
      t.Contracts.throwIfNullOrWhitespace(s, "authorizationToken"), t.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new i();
      return c.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s), c.properties.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Creates an instance of the speech config with specified host and subscription key.
     * This method is intended only for users who use a non-default service host. Standard resource path will be assumed.
     * For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL),
     * and then set the AuthorizationToken property on the created SpeechConfig instance.
     * Note: Added in version 1.9.0.
     * @member SpeechConfig.fromHost
     * @function
     * @public
     * @param {URL} host - The service endpoint to connect to. Format is "protocol://host:port" where ":port" is optional.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization token must be set.
     * @returns {SpeechConfig} A speech factory instance.
     */
    static fromHost(s, n) {
      t.Contracts.throwIfNull(s, "hostName");
      const c = new i();
      return c.setProperty(r.PropertyId.SpeechServiceConnection_Host, s.protocol + "//" + s.hostname + (s.port === "" ? "" : ":" + s.port)), n !== void 0 && c.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), c;
    }
    /**
     * Internal implementation of fromEndpoint() overloads. Accepts either a subscription key or a TokenCredential.
     * @private
     */
    static fromEndpoint(s, n) {
      t.Contracts.throwIfNull(s, "endpoint");
      const c = typeof n == "string" && n.trim().length > 0, u = typeof n == "object" && n !== null && typeof n.getToken == "function";
      if (n !== void 0 && !c && !u)
        throw new Error("Invalid 'auth' parameter: must be a non-empty key string or a valid TokenCredential object.");
      const l = typeof n == "object" ? new i(n) : new i();
      return l.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, s.href), typeof n == "string" && n.trim().length > 0 && l.setProperty(r.PropertyId.SpeechServiceConnection_Key, n), l;
    }
  };
  ft.SpeechTranslationConfig = o;
  class i extends o {
    constructor(s) {
      super(), this.privSpeechProperties = new r.PropertyCollection(), this.outputFormat = r.OutputFormat.Simple, this.privTokenCredential = s;
    }
    /**
     * Gets/Sets the authorization token.
     * If this is set, subscription key is ignored.
     * User needs to make sure the provided authorization token is valid and not expired.
     * @member SpeechTranslationConfigImpl.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set authorizationToken(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    /**
     * Sets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The authorization token.
     */
    set speechRecognitionLanguage(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, s);
    }
    /**
     * Gets the speech recognition language.
     * @member SpeechTranslationConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @return {string} The speechRecognitionLanguage.
     */
    get speechRecognitionLanguage() {
      return this.privSpeechProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * @member SpeechTranslationConfigImpl.prototype.subscriptionKey
     * @function
     * @public
     */
    get subscriptionKey() {
      return this.privSpeechProperties.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_Key]);
    }
    /**
     * Gets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    get outputFormat() {
      return r.OutputFormat[this.privSpeechProperties.getProperty(e.OutputFormatPropertyName, void 0)];
    }
    /**
     * Gets/Sets the output format
     * @member SpeechTranslationConfigImpl.prototype.outputFormat
     * @function
     * @public
     */
    set outputFormat(s) {
      this.privSpeechProperties.setProperty(e.OutputFormatPropertyName, r.OutputFormat[s]);
    }
    /**
     * Gets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    get endpointId() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId);
    }
    /**
     * Gets/Sets the endpoint id.
     * @member SpeechTranslationConfigImpl.prototype.endpointId
     * @function
     * @public
     */
    set endpointId(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_EndpointId, s);
    }
    /**
     * Add a (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.addTargetLanguage
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    addTargetLanguage(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value");
      const n = this.targetLanguages;
      n.includes(s) || (n.push(s), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, n.join(",")));
    }
    /**
     * Gets the (text) target language to translate into.
     * @member SpeechTranslationConfigImpl.prototype.targetLanguages
     * @function
     * @public
     * @param {string} value - The language such as de-DE
     */
    get targetLanguages() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",") : [];
    }
    /**
     * Gets the voice name.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     */
    get voiceName() {
      return this.getProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_TranslationVoice]);
    }
    /**
     * Gets/Sets the voice of the translated language, enable voice synthesis output.
     * @member SpeechTranslationConfigImpl.prototype.voiceName
     * @function
     * @public
     * @param {string} value - The name of the voice.
     */
    set voiceName(s) {
      t.Contracts.throwIfNullOrWhitespace(s, "value"), this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, s);
    }
    /**
     * Provides the region.
     * @member SpeechTranslationConfigImpl.prototype.region
     * @function
     * @public
     * @returns {string} The region.
     */
    get region() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_Region);
    }
    get tokenCredential() {
      return this.privTokenCredential;
    }
    setProxy(s, n, c, u) {
      this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyHostName], s), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPort], n), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyUserName], c), this.setProperty(r.PropertyId[r.PropertyId.SpeechServiceConnection_ProxyPassword], u);
    }
    /**
     * Gets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {string} name - The name of the property.
     * @param {string} def - The default value of the property in case it is not set.
     * @returns {string} The value of the property.
     */
    getProperty(s, n) {
      return this.privSpeechProperties.getProperty(s, n);
    }
    /**
     * Gets/Sets an arbitrary property value.
     * @member SpeechTranslationConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {string | PropertyId} name - The name of the property to set.
     * @param {string} value - The value of the property.
     */
    setProperty(s, n) {
      this.privSpeechProperties.setProperty(s, n);
    }
    /**
     * Provides access to custom properties.
     * @member SpeechTranslationConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechProperties;
    }
    /**
     * Dispose of associated resources.
     * @member SpeechTranslationConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
    setServiceProperty(s, n) {
      const c = JSON.parse(this.privSpeechProperties.getProperty(e.ServicePropertiesPropertyName, "{}"));
      c[s] = n, this.privSpeechProperties.setProperty(e.ServicePropertiesPropertyName, JSON.stringify(c));
    }
    setProfanity(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceResponse_ProfanityOption, r.ProfanityOption[s]);
    }
    enableAudioLogging() {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_EnableAudioLogging, "true");
    }
    requestWordLevelTimestamps() {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "true");
    }
    enableDictation() {
      this.privSpeechProperties.setProperty(e.ForceDictationPropertyName, "true");
    }
    get speechSynthesisLanguage() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage);
    }
    set speechSynthesisLanguage(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthLanguage, s);
    }
    get speechSynthesisVoiceName() {
      return this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthVoice);
    }
    set speechSynthesisVoiceName(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthVoice, s);
    }
    get speechSynthesisOutputFormat() {
      return r.SpeechSynthesisOutputFormat[this.privSpeechProperties.getProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)];
    }
    set speechSynthesisOutputFormat(s) {
      this.privSpeechProperties.setProperty(r.PropertyId.SpeechServiceConnection_SynthOutputFormat, r.SpeechSynthesisOutputFormat[s]);
    }
  }
  return ft.SpeechTranslationConfigImpl = i, ft;
}
var Yr = {}, Sl;
function gv() {
  if (Sl) return Yr;
  Sl = 1, Object.defineProperty(Yr, "__esModule", { value: !0 }), Yr.PropertyCollection = void 0;
  const e = /* @__PURE__ */ I();
  let t = class vv {
    constructor() {
      this.privKeys = [], this.privValues = [];
    }
    /**
     * Returns the property value in type String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member PropertyCollection.prototype.getProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string | number | boolean} def - The default value which is returned if the parameter
     * is not available in the collection.
     * @returns {string} value of the parameter.
     */
    getProperty(o, i) {
      let a;
      typeof o == "string" ? a = o : a = e.PropertyId[o];
      for (let s = 0; s < this.privKeys.length; s++)
        if (this.privKeys[s] === a)
          return this.privValues[s];
      if (i !== void 0)
        return String(i);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member PropertyCollection.prototype.setProperty
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    setProperty(o, i) {
      let a;
      typeof o == "string" ? a = o : a = e.PropertyId[o];
      for (let s = 0; s < this.privKeys.length; s++)
        if (this.privKeys[s] === a) {
          this.privValues[s] = i;
          return;
        }
      this.privKeys.push(a), this.privValues.push(i);
    }
    /**
     * Clones the collection.
     * @member PropertyCollection.prototype.clone
     * @function
     * @public
     * @returns {PropertyCollection} A copy of the collection.
     */
    clone() {
      const o = new vv();
      for (let i = 0; i < this.privKeys.length; i++)
        o.privKeys.push(this.privKeys[i]), o.privValues.push(this.privValues[i]);
      return o;
    }
    /**
     * Merges this set of properties into another, no overwrites.
     * @member PropertyCollection.prototype.mergeTo
     * @function
     * @public
     * @param {PropertyCollection}  destinationCollection - The collection to merge into.
     */
    mergeTo(o) {
      this.privKeys.forEach((i) => {
        if (o.getProperty(i, void 0) === void 0) {
          const a = this.getProperty(i);
          o.setProperty(i, a);
        }
      });
    }
    /**
     * Get the keys in Property Collection.
     * @member PropertyCollection.prototype.keys
     * @function
     * @public
     * @returns {string []} Keys in the collection.
     */
    get keys() {
      return this.privKeys;
    }
  };
  return Yr.PropertyCollection = t, Yr;
}
var Bo = {}, Cl;
function cc() {
  return Cl || (Cl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PropertyId = void 0, function(t) {
      t[t.SpeechServiceConnection_Key = 0] = "SpeechServiceConnection_Key", t[t.SpeechServiceConnection_Endpoint = 1] = "SpeechServiceConnection_Endpoint", t[t.SpeechServiceConnection_Region = 2] = "SpeechServiceConnection_Region", t[t.SpeechServiceAuthorization_Token = 3] = "SpeechServiceAuthorization_Token", t[t.SpeechServiceAuthorization_Type = 4] = "SpeechServiceAuthorization_Type", t[t.SpeechServiceConnection_EndpointId = 5] = "SpeechServiceConnection_EndpointId", t[t.SpeechServiceConnection_TranslationToLanguages = 6] = "SpeechServiceConnection_TranslationToLanguages", t[t.SpeechServiceConnection_TranslationVoice = 7] = "SpeechServiceConnection_TranslationVoice", t[t.SpeechServiceConnection_TranslationFeatures = 8] = "SpeechServiceConnection_TranslationFeatures", t[t.SpeechServiceConnection_TranslationCategoryId = 9] = "SpeechServiceConnection_TranslationCategoryId", t[t.SpeechServiceConnection_IntentRegion = 10] = "SpeechServiceConnection_IntentRegion", t[t.SpeechServiceConnection_ProxyHostName = 11] = "SpeechServiceConnection_ProxyHostName", t[t.SpeechServiceConnection_ProxyPort = 12] = "SpeechServiceConnection_ProxyPort", t[t.SpeechServiceConnection_ProxyUserName = 13] = "SpeechServiceConnection_ProxyUserName", t[t.SpeechServiceConnection_ProxyPassword = 14] = "SpeechServiceConnection_ProxyPassword", t[t.SpeechServiceConnection_RecoMode = 15] = "SpeechServiceConnection_RecoMode", t[t.SpeechServiceConnection_RecoLanguage = 16] = "SpeechServiceConnection_RecoLanguage", t[t.Speech_SessionId = 17] = "Speech_SessionId", t[t.SpeechServiceConnection_SynthLanguage = 18] = "SpeechServiceConnection_SynthLanguage", t[t.SpeechServiceConnection_SynthVoice = 19] = "SpeechServiceConnection_SynthVoice", t[t.SpeechServiceConnection_SynthOutputFormat = 20] = "SpeechServiceConnection_SynthOutputFormat", t[t.SpeechServiceConnection_AutoDetectSourceLanguages = 21] = "SpeechServiceConnection_AutoDetectSourceLanguages", t[t.SpeechServiceResponse_RequestDetailedResultTrueFalse = 22] = "SpeechServiceResponse_RequestDetailedResultTrueFalse", t[t.SpeechServiceResponse_RequestProfanityFilterTrueFalse = 23] = "SpeechServiceResponse_RequestProfanityFilterTrueFalse", t[t.SpeechServiceResponse_JsonResult = 24] = "SpeechServiceResponse_JsonResult", t[t.SpeechServiceResponse_JsonErrorDetails = 25] = "SpeechServiceResponse_JsonErrorDetails", t[t.CancellationDetails_Reason = 26] = "CancellationDetails_Reason", t[t.CancellationDetails_ReasonText = 27] = "CancellationDetails_ReasonText", t[t.CancellationDetails_ReasonDetailedText = 28] = "CancellationDetails_ReasonDetailedText", t[t.LanguageUnderstandingServiceResponse_JsonResult = 29] = "LanguageUnderstandingServiceResponse_JsonResult", t[t.SpeechServiceConnection_Url = 30] = "SpeechServiceConnection_Url", t[t.SpeechServiceConnection_InitialSilenceTimeoutMs = 31] = "SpeechServiceConnection_InitialSilenceTimeoutMs", t[t.SpeechServiceConnection_EndSilenceTimeoutMs = 32] = "SpeechServiceConnection_EndSilenceTimeoutMs", t[t.Speech_SegmentationSilenceTimeoutMs = 33] = "Speech_SegmentationSilenceTimeoutMs", t[t.Speech_SegmentationMaximumTimeMs = 34] = "Speech_SegmentationMaximumTimeMs", t[t.Speech_SegmentationStrategy = 35] = "Speech_SegmentationStrategy", t[t.SpeechServiceConnection_EnableAudioLogging = 36] = "SpeechServiceConnection_EnableAudioLogging", t[t.SpeechServiceConnection_LanguageIdMode = 37] = "SpeechServiceConnection_LanguageIdMode", t[t.SpeechServiceConnection_RecognitionEndpointVersion = 38] = "SpeechServiceConnection_RecognitionEndpointVersion", t[t.SpeechServiceConnection_SpeakerIdMode = 39] = "SpeechServiceConnection_SpeakerIdMode", t[t.SpeechServiceResponse_ProfanityOption = 40] = "SpeechServiceResponse_ProfanityOption", t[t.SpeechServiceResponse_PostProcessingOption = 41] = "SpeechServiceResponse_PostProcessingOption", t[t.SpeechServiceResponse_RequestWordLevelTimestamps = 42] = "SpeechServiceResponse_RequestWordLevelTimestamps", t[t.SpeechServiceResponse_StablePartialResultThreshold = 43] = "SpeechServiceResponse_StablePartialResultThreshold", t[t.SpeechServiceResponse_OutputFormatOption = 44] = "SpeechServiceResponse_OutputFormatOption", t[t.SpeechServiceResponse_TranslationRequestStablePartialResult = 45] = "SpeechServiceResponse_TranslationRequestStablePartialResult", t[t.SpeechServiceResponse_RequestWordBoundary = 46] = "SpeechServiceResponse_RequestWordBoundary", t[t.SpeechServiceResponse_RequestPunctuationBoundary = 47] = "SpeechServiceResponse_RequestPunctuationBoundary", t[t.SpeechServiceResponse_RequestSentenceBoundary = 48] = "SpeechServiceResponse_RequestSentenceBoundary", t[t.SpeechServiceResponse_DiarizeIntermediateResults = 49] = "SpeechServiceResponse_DiarizeIntermediateResults", t[t.Conversation_ApplicationId = 50] = "Conversation_ApplicationId", t[t.Conversation_DialogType = 51] = "Conversation_DialogType", t[t.Conversation_Initial_Silence_Timeout = 52] = "Conversation_Initial_Silence_Timeout", t[t.Conversation_From_Id = 53] = "Conversation_From_Id", t[t.Conversation_Conversation_Id = 54] = "Conversation_Conversation_Id", t[t.Conversation_Custom_Voice_Deployment_Ids = 55] = "Conversation_Custom_Voice_Deployment_Ids", t[t.Conversation_Speech_Activity_Template = 56] = "Conversation_Speech_Activity_Template", t[t.Conversation_Request_Bot_Status_Messages = 57] = "Conversation_Request_Bot_Status_Messages", t[t.Conversation_Agent_Connection_Id = 58] = "Conversation_Agent_Connection_Id", t[t.SpeechServiceConnection_Host = 59] = "SpeechServiceConnection_Host", t[t.ConversationTranslator_Host = 60] = "ConversationTranslator_Host", t[t.ConversationTranslator_Name = 61] = "ConversationTranslator_Name", t[t.ConversationTranslator_CorrelationId = 62] = "ConversationTranslator_CorrelationId", t[t.ConversationTranslator_Token = 63] = "ConversationTranslator_Token", t[t.PronunciationAssessment_ReferenceText = 64] = "PronunciationAssessment_ReferenceText", t[t.PronunciationAssessment_GradingSystem = 65] = "PronunciationAssessment_GradingSystem", t[t.PronunciationAssessment_Granularity = 66] = "PronunciationAssessment_Granularity", t[t.PronunciationAssessment_EnableMiscue = 67] = "PronunciationAssessment_EnableMiscue", t[t.PronunciationAssessment_Json = 68] = "PronunciationAssessment_Json", t[t.PronunciationAssessment_Params = 69] = "PronunciationAssessment_Params", t[t.SpeakerRecognition_Api_Version = 70] = "SpeakerRecognition_Api_Version", t[t.WebWorkerLoadType = 71] = "WebWorkerLoadType", t[t.TalkingAvatarService_WebRTC_SDP = 72] = "TalkingAvatarService_WebRTC_SDP";
    }(e.PropertyId || (e.PropertyId = {}));
  }(Bo)), Bo;
}
var Zr = {}, Rl;
function TR() {
  if (Rl) return Zr;
  Rl = 1, Object.defineProperty(Zr, "__esModule", { value: !0 }), Zr.Recognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class mv {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {AudioConfig} audioInput - An optional audio input stream associated with the recognizer
     * @param {PropertyCollection} properties - A set of properties to set on the recognizer
     * @param {IConnectionFactory} connectionFactory - The factory class used to create a custom IConnection for the recognizer
     */
    constructor(s, n, c, u) {
      this.audioConfig = s !== void 0 ? s : o.AudioConfig.fromDefaultMicrophoneInput(), this.privDisposed = !1, this.privProperties = n.clone(), this.privConnectionFactory = c, this.tokenCredential = u, this.implCommonRecognizerSetup();
    }
    /**
     * Dispose of associated resources.
     * @member Recognizer.prototype.close
     * @function
     * @public
     */
    close(s, n) {
      r.Contracts.throwIfDisposed(this.privDisposed), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), s, n);
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privReco;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Recognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(s) {
      this.privDisposed || (this.privDisposed = !0, s && this.privReco && (await this.privReco.audioSource.turnOff(), await this.privReco.dispose()));
    }
    /**
     * This method returns the current state of the telemetry setting.
     * @member Recognizer.prototype.telemetryEnabled
     * @function
     * @public
     * @returns true if the telemetry is enabled, false otherwise.
     */
    static get telemetryEnabled() {
      return e.ServiceRecognizerBase.telemetryDataEnabled;
    }
    /**
     * This method globally enables or disables telemetry.
     * @member Recognizer.prototype.enableTelemetry
     * @function
     * @public
     * @param enabled - Global setting for telemetry collection.
     * If set to true, telemetry information like microphone errors,
     * recognition errors are collected and sent to Microsoft.
     * If set to false, no telemetry is sent to Microsoft.
     */
    static enableTelemetry(s) {
      e.ServiceRecognizerBase.telemetryDataEnabled = s;
    }
    // Does the generic recognizer setup that is common across all recognizer types.
    implCommonRecognizerSetup() {
      let s = typeof window < "u" ? "Browser" : "Node", n = "unknown", c = "unknown";
      typeof navigator < "u" && (s = s + "/" + navigator.platform, n = navigator.userAgent, c = navigator.appVersion);
      const u = this.createRecognizerConfig(new e.SpeechServiceConfig(new e.Context(new e.OS(s, n, c))));
      this.privReco = this.createServiceRecognizer(mv.getAuth(this.privProperties, this.tokenCredential), this.privConnectionFactory, this.audioConfig, u);
    }
    async recognizeOnceAsyncImpl(s) {
      r.Contracts.throwIfDisposed(this.privDisposed);
      const n = new t.Deferred();
      await this.implRecognizerStop(), await this.privReco.recognize(s, n.resolve, n.reject);
      const c = await n.promise;
      return await this.implRecognizerStop(), c;
    }
    async startContinuousRecognitionAsyncImpl(s) {
      r.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop(), await this.privReco.recognize(s, void 0, void 0);
    }
    async stopContinuousRecognitionAsyncImpl() {
      r.Contracts.throwIfDisposed(this.privDisposed), await this.implRecognizerStop();
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    static getAuth(s, n) {
      const c = s.getProperty(o.PropertyId.SpeechServiceConnection_Key, void 0);
      return c && c !== "" ? new e.CognitiveSubscriptionKeyAuthentication(c) : n ? new e.CognitiveTokenAuthentication(async () => {
        try {
          return (await n.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (u) {
          throw u;
        }
      }, async () => {
        try {
          return (await n.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (u) {
          throw u;
        }
      }) : new e.CognitiveTokenAuthentication(() => {
        const u = s.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      }, () => {
        const u = s.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(u);
      });
    }
  };
  return Zr.Recognizer = i, Zr;
}
var Xr = {}, Uo = {}, Pl;
function Re() {
  return Pl || (Pl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionMode = void 0, function(t) {
      t.Interactive = "Interactive", t.Dictation = "Dictation", t.Conversation = "Conversation", t.None = "None";
    }(e.RecognitionMode || (e.RecognitionMode = {}));
  }(Uo)), Uo;
}
var wl;
function _R() {
  if (wl) return Xr;
  wl = 1, Object.defineProperty(Xr, "__esModule", { value: !0 }), Xr.SpeechRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ Re(), r = /* @__PURE__ */ k(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ I();
  let a = class yv extends i.Recognizer {
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      o.Contracts.throwIfNull(u, "speechConfig"), o.Contracts.throwIfNullOrWhitespace(u.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new e.SpeechConnectionFactory(), n.tokenCredential), this.privDisposedRecognizer = !1;
    }
    /**
     * SpeechRecognizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(n, c, u) {
      const l = n;
      return c.properties.mergeTo(l.properties), new yv(n, u);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for speech recognition.
     * @member SpeechRecognizer.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeechRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      o.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * Gets the spoken language of recognition.
     * @member SpeechRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of recognition.
     * @member SpeechRecognizer.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of recognition.
     */
    get outputFormat() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(e.OutputFormatPropertyName, i.OutputFormat[i.OutputFormat.Simple]) === i.OutputFormat[i.OutputFormat.Simple] ? i.OutputFormat.Simple : i.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this SpeechRecognizer.
     * @member SpeechRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts speech recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition
     * like command or query. For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member SpeechRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the SpeechRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), n, c);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member SpeechRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(this.properties.getProperty(e.ForceDictationPropertyName, void 0) === void 0 ? t.RecognitionMode.Conversation : t.RecognitionMode.Dictation), n, c);
    }
    /**
     * Stops continuous speech recognition.
     * @member SpeechRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * Starts speech recognition with keyword spotting, until
     * stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model The keyword recognition model that
     * specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(n, c, u) {
      o.Contracts.throwIfNull(n, "model"), u && u("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the
     * Speech Devices SDK. This functionality is currently not included in the SDK itself.
     * @member SpeechRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(n) {
      n && n();
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member SpeechRecognizer.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new e.SpeechServiceRecognizer(n, c, p, l, this);
    }
  };
  return Xr.SpeechRecognizer = a, Xr;
}
var en = {}, bl;
function kR() {
  if (bl) return en;
  bl = 1, Object.defineProperty(en, "__esModule", { value: !0 }), en.IntentRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ Re(), r = /* @__PURE__ */ k(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ I();
  let a = class extends i.Recognizer {
    /**
     * Initializes an instance of the IntentRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(n, c) {
      o.Contracts.throwIfNullOrUndefined(n, "speechConfig");
      const u = n;
      o.Contracts.throwIfNullOrUndefined(u, "speechConfig"), super(c, u.properties, new e.IntentConnectionFactory()), this.privAddedIntents = [], this.privAddedLmIntents = {}, this.privDisposedIntentRecognizer = !1, this.privProperties = u.properties, o.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * Gets the spoken language of recognition.
     * @member IntentRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} the spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * Note: Please use a token derived from your LanguageUnderstanding subscription key for the Intent recognizer.
     * @member IntentRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(n) {
      this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * The collection of properties and their values defined for this IntentRecognizer.
     * @member IntentRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their
     * values defined for this IntentRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts intent recognition, and stops after the first utterance is recognized.
     * The task returns the recognition text and intent as result.
     * Note: RecognizeOnceAsync() returns when the first utterance has been recognized,
     * so it is suitable only for single shot recognition like command or query.
     * For long-running recognition, use StartContinuousRecognitionAsync() instead.
     * @member IntentRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the recognition has finished with an IntentRecognitionResult.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(n, c) {
      if (o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const u = this.buildSpeechContext();
        this.privReco.speechContext.getContext().intent = u.Intent, this.privReco.dynamicGrammar.addReferenceGrammar(u.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), n, c);
    }
    /**
     * Starts speech recognition, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * @member IntentRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(n, c) {
      if (Object.keys(this.privAddedLmIntents).length !== 0 || this.privUmbrellaIntent !== void 0) {
        const u = this.buildSpeechContext();
        this.privReco.speechContext.getContext().intent = u.Intent, this.privReco.dynamicGrammar.addReferenceGrammar(u.ReferenceGrammars), this.privReco.setIntents(this.privAddedLmIntents, this.privUmbrellaIntent);
      }
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), n, c);
    }
    /**
     * Stops continuous intent recognition.
     * @member IntentRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * Starts speech recognition with keyword spotting, until stopKeywordRecognitionAsync() is called.
     * User must subscribe to events to receive recognition results.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.startKeywordRecognitionAsync
     * @function
     * @public
     * @param {KeywordRecognitionModel} model - The keyword recognition model that specifies the keyword to be recognized.
     * @param cb - Callback invoked once the recognition has started.
     * @param err - Callback invoked in case of an error.
     */
    startKeywordRecognitionAsync(n, c, u) {
      o.Contracts.throwIfNull(n, "model"), u && u("Not yet implemented.");
    }
    /**
     * Stops continuous speech recognition.
     * Note: Key word spotting functionality is only available on the Speech Devices SDK.
     * This functionality is currently not included in the SDK itself.
     * @member IntentRecognizer.prototype.stopKeywordRecognitionAsync
     * @function
     * @public
     * @param cb - Callback invoked once the recognition has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopKeywordRecognitionAsync(n, c) {
      if (n)
        try {
          n();
        } catch (u) {
          c && c(u);
        }
    }
    /**
     * Adds a phrase that should be recognized as intent.
     * @member IntentRecognizer.prototype.addIntent
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent to be recognized.
     * @param {string} phrase - A String that specifies the phrase representing the intent.
     */
    addIntent(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), o.Contracts.throwIfNullOrWhitespace(c, "intentId"), o.Contracts.throwIfNullOrWhitespace(n, "simplePhrase"), this.privAddedIntents.push([c, n]);
    }
    /**
     * Adds an intent from Language Understanding service for recognition.
     * @member IntentRecognizer.prototype.addIntentWithLanguageModel
     * @function
     * @public
     * @param {string} intentId - A String that represents the identifier of the intent
     * to be recognized. Ignored if intentName is empty.
     * @param {string} model - The intent model from Language Understanding service.
     * @param {string} intentName - The intent name defined in the intent model. If it
     * is empty, all intent names defined in the model will be added.
     */
    addIntentWithLanguageModel(n, c, u) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), o.Contracts.throwIfNullOrWhitespace(n, "intentId"), o.Contracts.throwIfNull(c, "model");
      const l = c;
      o.Contracts.throwIfNullOrWhitespace(l.appId, "model.appId"), this.privAddedLmIntents[n] = new e.AddedLmIntent(l, u);
    }
    /**
     * @summary Adds all intents from the specified Language Understanding Model.
     * @member IntentRecognizer.prototype.addAllIntents
     * @function
     * @public
     * @function
     * @public
     * @param {LanguageUnderstandingModel} model - The language understanding model containing the intents.
     * @param {string} intentId - A custom id String to be returned in the IntentRecognitionResult's getIntentId() method.
     */
    addAllIntents(n, c) {
      o.Contracts.throwIfNull(n, "model");
      const u = n;
      o.Contracts.throwIfNullOrWhitespace(u.appId, "model.appId"), this.privUmbrellaIntent = new e.AddedLmIntent(u, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member IntentRecognizer.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedIntentRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new e.IntentServiceRecognizer(n, c, p, l, this);
    }
    async dispose(n) {
      this.privDisposedIntentRecognizer || n && (this.privDisposedIntentRecognizer = !0, await super.dispose(n));
    }
    buildSpeechContext() {
      let n, c, u;
      const l = [];
      this.privUmbrellaIntent !== void 0 && (n = this.privUmbrellaIntent.modelImpl.appId, c = this.privUmbrellaIntent.modelImpl.region, u = this.privUmbrellaIntent.modelImpl.subscriptionKey);
      for (const p of Object.keys(this.privAddedLmIntents)) {
        const h = this.privAddedLmIntents[p];
        if (n === void 0)
          n = h.modelImpl.appId;
        else if (n !== h.modelImpl.appId)
          throw new Error("Intents must all be from the same LUIS model");
        if (c === void 0)
          c = h.modelImpl.region;
        else if (c !== h.modelImpl.region)
          throw new Error("Intents must all be from the same LUIS model in a single region");
        if (u === void 0)
          u = h.modelImpl.subscriptionKey;
        else if (u !== h.modelImpl.subscriptionKey)
          throw new Error("Intents must all use the same subscription key");
        const d = "luis/" + n + "-PRODUCTION#" + p;
        l.push(d);
      }
      return {
        Intent: {
          id: n,
          key: u === void 0 ? this.privProperties.getProperty(i.PropertyId[i.PropertyId.SpeechServiceConnection_Key]) : u,
          provider: "LUIS"
        },
        ReferenceGrammars: this.privUmbrellaIntent === void 0 ? l : ["luis/" + n + "-PRODUCTION"]
      };
    }
  };
  return en.IntentRecognizer = a, en;
}
var $o = {}, El;
function OR() {
  return El || (El = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.VoiceProfileType = void 0, function(t) {
      t[t.TextIndependentIdentification = 0] = "TextIndependentIdentification", t[t.TextDependentVerification = 1] = "TextDependentVerification", t[t.TextIndependentVerification = 2] = "TextIndependentVerification";
    }(e.VoiceProfileType || (e.VoiceProfileType = {}));
  }($o)), $o;
}
var tn = {}, rn = {}, vt = {}, Il;
function Sv() {
  if (Il) return vt;
  Il = 1, Object.defineProperty(vt, "__esModule", { value: !0 }), vt.ConnectionMessageImpl = vt.ConnectionMessage = void 0;
  const e = /* @__PURE__ */ le(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ gv(), o = /* @__PURE__ */ cc();
  let i = class {
  };
  vt.ConnectionMessage = i;
  class a {
    constructor(n) {
      this.privConnectionMessage = n, this.privProperties = new r.PropertyCollection(), this.privConnectionMessage.headers[e.HeaderNames.ConnectionId] && this.privProperties.setProperty(o.PropertyId.Speech_SessionId, this.privConnectionMessage.headers[e.HeaderNames.ConnectionId]), Object.keys(this.privConnectionMessage.headers).forEach((c) => {
        this.privProperties.setProperty(c, this.privConnectionMessage.headers[c]);
      });
    }
    /**
     * The message path.
     */
    get path() {
      return this.privConnectionMessage.headers[Object.keys(this.privConnectionMessage.headers).find((n) => n.toLowerCase() === "path".toLowerCase())];
    }
    /**
     * Checks to see if the ConnectionMessage is a text message.
     * See also IsBinaryMessage().
     */
    get isTextMessage() {
      return this.privConnectionMessage.messageType === t.MessageType.Text;
    }
    /**
     * Checks to see if the ConnectionMessage is a binary message.
     * See also GetBinaryMessage().
     */
    get isBinaryMessage() {
      return this.privConnectionMessage.messageType === t.MessageType.Binary;
    }
    /**
     * Gets the text message payload. Typically the text message content-type is
     * application/json. To determine other content-types use
     * Properties.GetProperty("Content-Type").
     */
    get TextMessage() {
      return this.privConnectionMessage.textBody;
    }
    /**
     * Gets the binary message payload.
     */
    get binaryMessage() {
      return this.privConnectionMessage.binaryBody;
    }
    /**
     * A collection of properties and their values defined for this <see cref="ConnectionMessage"/>.
     * Message headers can be accessed via this collection (e.g. "Content-Type").
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Returns a string that represents the connection message.
     */
    toString() {
      return "";
    }
  }
  return vt.ConnectionMessageImpl = a, vt;
}
var Al;
function Cv() {
  if (Al) return rn;
  Al = 1, Object.defineProperty(rn, "__esModule", { value: !0 }), rn.Connection = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ Sv(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ I();
  let a = class $a {
    /**
     * Gets the Connection instance from the specified recognizer.
     * @param recognizer The recognizer associated with the connection.
     * @return The Connection instance of the recognizer.
     */
    static fromRecognizer(n) {
      const c = n.internalData, u = new $a();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Gets the Connection instance from the specified synthesizer.
     * @param synthesizer The synthesizer associated with the connection.
     * @return The Connection instance of the synthesizer.
     */
    static fromSynthesizer(n) {
      const c = n.internalData, u = new $a();
      return u.privInternalData = c, u.setupEvents(), u;
    }
    /**
     * Starts to set up connection to the service.
     * Users can optionally call openConnection() to manually set up a connection in advance before starting recognition on the
     * Recognizer associated with this Connection. After starting recognition, calling Open() will have no effect
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     */
    openConnection(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.connect(), n, c);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call closeConnection() to manually shutdown the connection of the associated Recognizer.
     *
     * If closeConnection() is called during recognition, recognition will fail and cancel with an error.
     */
    closeConnection(n, c) {
      if (this.privInternalData instanceof e.SynthesisAdapterBase)
        throw new Error("Disconnecting a synthesizer's connection is currently not supported");
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.disconnect(), n, c);
    }
    /**
     * Appends a parameter in a message to service.
     * Added in version 1.12.1.
     * @param path The path of the network message.
     * @param propertyName Name of the property
     * @param propertyValue Value of the property. This is a json string.
     */
    setMessageProperty(n, c, u) {
      if (o.Contracts.throwIfNullOrWhitespace(c, "propertyName"), this.privInternalData instanceof e.ServiceRecognizerBase) {
        if (n.toLowerCase() !== "speech.context")
          throw new Error("Only speech.context message property sets are currently supported for recognizer");
        {
          const l = this.privInternalData.speechContext.getContext();
          l[c] = u;
        }
      } else if (this.privInternalData instanceof e.SynthesisAdapterBase) {
        if (n.toLowerCase() !== "synthesis.context")
          throw new Error("Only synthesis.context message property sets are currently supported for synthesizer");
        this.privInternalData.synthesisContext.setSection(c, u);
      }
    }
    /**
     * Sends a message to the speech service.
     * Added in version 1.13.0.
     * @param path The WebSocket path of the message
     * @param payload The payload of the message. This is a json string or a ArrayBuffer.
     * @param success A callback to indicate success.
     * @param error A callback to indicate an error.
     */
    sendMessageAsync(n, c, u, l) {
      (0, t.marshalPromiseToCallbacks)(this.privInternalData.sendNetworkMessage(n, c), u, l);
    }
    /**
     * Dispose of associated resources.
     */
    close() {
    }
    setupEvents() {
      this.privEventListener = this.privInternalData.connectionEvents.attach((n) => {
        n.name === "ConnectionEstablishedEvent" ? this.connected && this.connected(new i.ConnectionEventArgs(n.connectionId)) : n.name === "ConnectionClosedEvent" ? this.disconnected && this.disconnected(new i.ConnectionEventArgs(n.connectionId)) : n.name === "ConnectionMessageSentEvent" ? this.messageSent && this.messageSent(new i.ConnectionMessageEventArgs(new r.ConnectionMessageImpl(n.message))) : n.name === "ConnectionMessageReceivedEvent" && this.messageReceived && this.messageReceived(new i.ConnectionMessageEventArgs(new r.ConnectionMessageImpl(n.message)));
      }), this.privServiceEventListener = this.privInternalData.serviceEvents.attach((n) => {
        this.receivedServiceMessage && this.receivedServiceMessage(new i.ServiceEventArgs(n.jsonString, n.name));
      });
    }
  };
  return rn.Connection = a, rn;
}
var Tl;
function MR() {
  if (Tl) return tn;
  Tl = 1, Object.defineProperty(tn, "__esModule", { value: !0 }), tn.TranslationRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ Re(), r = /* @__PURE__ */ k(), o = /* @__PURE__ */ Cv(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ I();
  let s = class Rv extends a.Recognizer {
    /**
     * Initializes an instance of the TranslationRecognizer.
     * @constructor
     * @param {SpeechTranslationConfig} speechConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     * @param {IConnectionFactory} connectionFactory - An optional connection factory to use to generate the endpoint URIs, headers to set, etc...
     */
    constructor(c, u, l) {
      const p = c;
      i.Contracts.throwIfNull(p, "speechConfig"), super(u, p.properties, l || new e.TranslationConnectionFactory(), c.tokenCredential), this.privDisposedTranslationRecognizer = !1, this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice), a.PropertyId[a.PropertyId.SpeechServiceConnection_TranslationVoice]), i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages), a.PropertyId[a.PropertyId.SpeechServiceConnection_TranslationToLanguages]), i.Contracts.throwIfNullOrWhitespace(this.properties.getProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage), a.PropertyId[a.PropertyId.SpeechServiceConnection_RecoLanguage]);
    }
    /**
     * TranslationRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(c, u, l) {
      const p = c;
      return u.properties.mergeTo(p.properties), u.properties.getProperty(a.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0) === e.AutoDetectSourceLanguagesOpenRangeOptionName && p.properties.setProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), new Rv(c, l);
    }
    /**
     * Gets the language name that was set when the recognizer was created.
     * @member TranslationRecognizer.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} Gets the language name that was set when the recognizer was created.
     */
    get speechRecognitionLanguage() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets target languages for translation that were set when the recognizer was created.
     * The language is specified in BCP-47 format. The translation will provide translated text for each of language.
     * @member TranslationRecognizer.prototype.targetLanguages
     * @function
     * @public
     * @returns {string[]} Gets target languages for translation that were set when the recognizer was created.
     */
    get targetLanguages() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(",");
    }
    /**
     * Gets the name of output voice.
     * @member TranslationRecognizer.prototype.voiceName
     * @function
     * @public
     * @returns {string} the name of output voice.
     */
    get voiceName() {
      return i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
    }
    /**
     * The collection of properties and their values defined for this TranslationRecognizer.
     * @member TranslationRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this TranslationRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(a.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member TranslationRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} value - Authorization token.
     */
    set authorizationToken(c) {
      this.properties.setProperty(a.PropertyId.SpeechServiceAuthorization_Token, c);
    }
    /**
     * Starts recognition and translation, and stops after the first utterance is recognized.
     * The task returns the translation text as result.
     * Note: recognizeOnceAsync returns when the first utterance has been recognized, so it is suitable only
     * for single shot recognition like command or query. For long-running recognition,
     * use startContinuousRecognitionAsync() instead.
     * @member TranslationRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the translation has completed.
     * @param err - Callback invoked in case of an error.
     */
    recognizeOnceAsync(c, u) {
      i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), (0, r.marshalPromiseToCallbacks)(this.recognizeOnceAsyncImpl(t.RecognitionMode.Interactive), c, u);
    }
    /**
     * Starts recognition and translation, until stopContinuousRecognitionAsync() is called.
     * User must subscribe to events to receive translation results.
     * @member TranslationRecognizer.prototype.startContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has started.
     * @param err - Callback invoked in case of an error.
     */
    startContinuousRecognitionAsync(c, u) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), c, u);
    }
    /**
     * Stops continuous recognition and translation.
     * @member TranslationRecognizer.prototype.stopContinuousRecognitionAsync
     * @function
     * @public
     * @param cb - Callback that received the translation has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopContinuousRecognitionAsync(c, u) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), c, u);
    }
    /**
     * dynamically remove a language from list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.removeTargetLanguage
     * @function
     * @param lang - language to be removed
     * @public
     */
    removeTargetLanguage(c) {
      if (i.Contracts.throwIfNullOrUndefined(c, "language to be removed"), this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0) {
        const u = this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), l = u.indexOf(c);
        l > -1 && (u.splice(l, 1), this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, u.join(",")), this.updateLanguages(u));
      }
    }
    /**
     * dynamically add a language to list of target language
     * (can be used while recognition is ongoing)
     * @member TranslationRecognizer.prototype.addTargetLanguage
     * @function
     * @param lang - language to be added
     * @public
     */
    addTargetLanguage(c) {
      i.Contracts.throwIfNullOrUndefined(c, "language to be added");
      let u = [];
      this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 ? (u = this.properties.getProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages).split(","), u.includes(c) || (u.push(c), this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, u.join(",")))) : (this.properties.setProperty(a.PropertyId.SpeechServiceConnection_TranslationToLanguages, c), u = [c]), this.updateLanguages(u);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member TranslationRecognizer.prototype.close
     * @function
     * @public
     */
    close(c, u) {
      i.Contracts.throwIfDisposed(this.privDisposedTranslationRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), c, u);
    }
    /**
     * handles ConnectionEstablishedEvent for conversation translation scenarios.
     * @member TranslationRecognizer.prototype.onConnection
     * @function
     * @public
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    onConnection() {
    }
    async dispose(c) {
      this.privDisposedTranslationRecognizer || (this.privDisposedTranslationRecognizer = !0, c && (await this.implRecognizerStop(), await super.dispose(c)));
    }
    createRecognizerConfig(c) {
      return new e.RecognizerConfig(c, this.privProperties);
    }
    createServiceRecognizer(c, u, l, p) {
      const h = l;
      return new e.TranslationServiceRecognizer(c, u, h, p, this);
    }
    updateLanguages(c) {
      const u = o.Connection.fromRecognizer(this);
      u && (u.setMessageProperty("speech.context", "translationcontext", { to: c }), u.sendMessageAsync("event", JSON.stringify({
        id: "translation",
        name: "updateLanguage",
        to: c
      })));
    }
  };
  return tn.TranslationRecognizer = s, tn;
}
var nn = {}, _l;
function DR() {
  if (_l) return nn;
  _l = 1, Object.defineProperty(nn, "__esModule", { value: !0 }), nn.Translations = void 0;
  const e = /* @__PURE__ */ I();
  let t = class {
    constructor() {
      this.privMap = new e.PropertyCollection();
    }
    /**
     * Get the languages in the object in a String array.
     * @member Translations.prototype.languages
     * @function
     * @public
     * @returns {string[]} languages in translations object.
     */
    get languages() {
      return this.privMap.keys;
    }
    /**
     * Returns the parameter value in type String. The parameter must have the same type as String.
     * Currently only String, int and bool are allowed.
     * If the name is not available, the specified defaultValue is returned.
     * @member Translations.prototype.get
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} def - The default value which is returned if the parameter is not available in the collection.
     * @returns {string} value of the parameter.
     */
    get(o, i) {
      return this.privMap.getProperty(o, i);
    }
    /**
     * Sets the String value of the parameter specified by name.
     * @member Translations.prototype.set
     * @function
     * @public
     * @param {string} key - The parameter name.
     * @param {string} value - The value of the parameter.
     */
    set(o, i) {
      this.privMap.setProperty(o, i);
    }
  };
  return nn.Translations = t, nn;
}
var Vo = {}, kl;
function NR() {
  return kl || (kl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NoMatchReason = void 0, function(t) {
      t[t.NotRecognized = 0] = "NotRecognized", t[t.InitialSilenceTimeout = 1] = "InitialSilenceTimeout", t[t.InitialBabbleTimeout = 2] = "InitialBabbleTimeout";
    }(e.NoMatchReason || (e.NoMatchReason = {}));
  }(Vo)), Vo;
}
var sn = {}, Ol;
function xR() {
  if (Ol) return sn;
  Ol = 1, Object.defineProperty(sn, "__esModule", { value: !0 }), sn.NoMatchDetails = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ I();
  let r = class Pv {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {NoMatchReason} reason - The no-match reason.
     */
    constructor(i) {
      this.privReason = i;
    }
    /**
     * Creates an instance of NoMatchDetails object for the NoMatch SpeechRecognitionResults.
     * @member NoMatchDetails.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult | IntentRecognitionResult | TranslationRecognitionResult}
     * result - The recognition result that was not recognized.
     * @returns {NoMatchDetails} The no match details object being created.
     */
    static fromResult(i) {
      const a = e.SimpleSpeechPhrase.fromJSON(i.json, 0);
      let s = t.NoMatchReason.NotRecognized;
      switch (a.RecognitionStatus) {
        case e.RecognitionStatus.BabbleTimeout:
          s = t.NoMatchReason.InitialBabbleTimeout;
          break;
        case e.RecognitionStatus.InitialSilenceTimeout:
          s = t.NoMatchReason.InitialSilenceTimeout;
          break;
        default:
          s = t.NoMatchReason.NotRecognized;
          break;
      }
      return new Pv(s);
    }
    /**
     * The reason the recognition was canceled.
     * @member NoMatchDetails.prototype.reason
     * @function
     * @public
     * @returns {NoMatchReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
  };
  return sn.NoMatchDetails = r, sn;
}
var on = {}, Ml;
function zR() {
  if (Ml) return on;
  Ml = 1, Object.defineProperty(on, "__esModule", { value: !0 }), on.TranslationRecognitionCanceledEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} sessionid - The session id.
     * @param {CancellationReason} cancellationReason - The cancellation reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {TranslationRecognitionResult} result - The result.
     */
    constructor(r, o, i, a, s) {
      this.privCancelReason = o, this.privErrorDetails = i, this.privResult = s, this.privSessionId = r, this.privErrorCode = a;
    }
    /**
     * Specifies the recognition result.
     * @member TranslationRecognitionCanceledEventArgs.prototype.result
     * @function
     * @public
     * @returns {TranslationRecognitionResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
    /**
     * Specifies the session identifier.
     * @member TranslationRecognitionCanceledEventArgs.prototype.sessionId
     * @function
     * @public
     * @returns {string} the session identifier.
     */
    get sessionId() {
      return this.privSessionId;
    }
    /**
     * The reason the recognition was canceled.
     * @member TranslationRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privCancelReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member TranslationRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return on.TranslationRecognitionCanceledEventArgs = e, on;
}
var an = {}, Dl;
function LR() {
  if (Dl) return an;
  Dl = 1, Object.defineProperty(an, "__esModule", { value: !0 }), an.IntentRecognitionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.IntentRecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} result - The result of the intent recognition.
     * @param {string} offset - The offset.
     * @param {IntentRecognitionResult} sessionId - The session id.
     */
    constructor(o, i, a, s, n, c) {
      super(s, n, c), this.privReason = o, this.privErrorDetails = i, this.privErrorCode = a;
    }
    /**
     * The reason the recognition was canceled.
     * @member IntentRecognitionCanceledEventArgs.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get errorCode() {
      return this.privErrorCode;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member IntentRecognitionCanceledEventArgs.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  return an.IntentRecognitionCanceledEventArgs = t, an;
}
var cn = {}, Nl;
function wv() {
  if (Nl) return cn;
  Nl = 1, Object.defineProperty(cn, "__esModule", { value: !0 }), cn.CancellationDetailsBase = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {CancellationReason} reason - The cancellation reason.
     * @param {string} errorDetails - The error details, if provided.
     */
    constructor(r, o, i) {
      this.privReason = r, this.privErrorDetails = o, this.privErrorCode = i;
    }
    /**
     * The reason the recognition was canceled.
     * @member CancellationDetailsBase.prototype.reason
     * @function
     * @public
     * @returns {CancellationReason} Specifies the reason canceled.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * In case of an unsuccessful recognition, provides details of the occurred error.
     * @member CancellationDetailsBase.prototype.errorDetails
     * @function
     * @public
     * @returns {string} A String that represents the error details.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * The error code in case of an unsuccessful recognition.
     * Added in version 1.1.0.
     * @return An error code that represents the error reason.
     */
    get ErrorCode() {
      return this.privErrorCode;
    }
  };
  return cn.CancellationDetailsBase = e, cn;
}
var un = {}, xl;
function jR() {
  if (xl) return un;
  xl = 1, Object.defineProperty(un, "__esModule", { value: !0 }), un.CancellationDetails = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ wv(), r = /* @__PURE__ */ I();
  let o = class bv extends t.CancellationDetailsBase {
    constructor(a, s, n) {
      super(a, s, n);
    }
    /**
     * Creates an instance of CancellationDetails object for the canceled RecognitionResult.
     * @member CancellationDetails.fromResult
     * @function
     * @public
     * @param {RecognitionResult | SpeechSynthesisResult} result - The result that was canceled.
     * @returns {CancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      let s = r.CancellationReason.Error, n = r.CancellationErrorCode.NoError;
      if (a instanceof r.RecognitionResult && a.json) {
        const c = e.SimpleSpeechPhrase.fromJSON(a.json, 0);
        s = e.EnumTranslation.implTranslateCancelResult(c.RecognitionStatus);
      }
      return a.properties && (n = r.CancellationErrorCode[a.properties.getProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new bv(s, a.errorDetails || e.EnumTranslation.implTranslateErrorDetails(n), n);
    }
  };
  return un.CancellationDetails = o, un;
}
var Wo = {}, zl;
function qR() {
  return zl || (zl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.CancellationErrorCode = void 0, function(t) {
      t[t.NoError = 0] = "NoError", t[t.AuthenticationFailure = 1] = "AuthenticationFailure", t[t.BadRequestParameters = 2] = "BadRequestParameters", t[t.TooManyRequests = 3] = "TooManyRequests", t[t.ConnectionFailure = 4] = "ConnectionFailure", t[t.ServiceTimeout = 5] = "ServiceTimeout", t[t.ServiceError = 6] = "ServiceError", t[t.RuntimeError = 7] = "RuntimeError", t[t.Forbidden = 8] = "Forbidden";
    }(e.CancellationErrorCode || (e.CancellationErrorCode = {}));
  }(Wo)), Wo;
}
var ln = {}, Ll;
function FR() {
  if (Ll) return ln;
  Ll = 1, Object.defineProperty(ln, "__esModule", { value: !0 }), ln.ConnectionEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
  };
  return ln.ConnectionEventArgs = t, ln;
}
var pn = {}, jl;
function BR() {
  if (jl) return pn;
  jl = 1, Object.defineProperty(pn, "__esModule", { value: !0 }), pn.ServiceEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} json - json payload of the USP message.
     */
    constructor(o, i, a) {
      super(a), this.privJsonResult = o, this.privEventName = i;
    }
    get jsonString() {
      return this.privJsonResult;
    }
    get eventName() {
      return this.privEventName;
    }
  };
  return pn.ServiceEventArgs = t, pn;
}
var dn = {}, ql;
function UR() {
  if (ql) return dn;
  ql = 1, Object.defineProperty(dn, "__esModule", { value: !0 }), dn.PhraseListGrammar = void 0;
  let e = class Ev {
    constructor(r) {
      this.privGrammerBuilder = r.dynamicGrammar;
    }
    /**
     * Creates a PhraseListGrammar from a given speech recognizer. Will accept any recognizer that derives from @class Recognizer.
     * @param recognizer The recognizer to add phrase lists to.
     */
    static fromRecognizer(r) {
      const o = r.internalData;
      return new Ev(o);
    }
    /**
     * Adds a single phrase to the current recognizer.
     * @param phrase Phrase to add.
     */
    addPhrase(r) {
      this.privGrammerBuilder.addPhrase(r);
    }
    /**
     * Adds multiple phrases to the current recognizer.
     * @param phrases Array of phrases to add.
     */
    addPhrases(r) {
      this.privGrammerBuilder.addPhrase(r);
    }
    /**
     * Clears all phrases added to the current recognizer.
     */
    clear() {
      this.privGrammerBuilder.clearPhrases();
    }
  };
  return dn.PhraseListGrammar = e, dn;
}
var gt = {}, Fl;
function uc() {
  if (Fl) return gt;
  Fl = 1, Object.defineProperty(gt, "__esModule", { value: !0 }), gt.DialogServiceConfigImpl = gt.DialogServiceConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class {
    /**
     * Creates an instance of DialogService config.
     * @constructor
     */
    constructor() {
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member DialogServiceConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    set applicationId(a) {
    }
    static get DialogTypes() {
      return {
        BotFramework: "bot_framework",
        CustomCommands: "custom_commands"
      };
    }
  };
  gt.DialogServiceConfig = r;
  class o extends r {
    /**
     * Creates an instance of dialogService config.
     */
    constructor() {
      super(), this.privSpeechConfig = new t.SpeechConfigImpl();
    }
    /**
     * Provides access to custom properties.
     * @member DialogServiceConfigImpl.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The properties.
     */
    get properties() {
      return this.privSpeechConfig.properties;
    }
    /**
     * Gets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     */
    get speechRecognitionLanguage() {
      return this.privSpeechConfig.speechRecognitionLanguage;
    }
    /**
     * Sets the speech recognition language.
     * @member DialogServiceConfigImpl.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @param {string} value - The language to set.
     */
    set speechRecognitionLanguage(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.privSpeechConfig.speechRecognitionLanguage = a;
    }
    get outputFormat() {
      return this.privSpeechConfig.outputFormat;
    }
    set outputFormat(a) {
      this.privSpeechConfig.outputFormat = a;
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.setProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to set.
     * @param {string} value - The value.
     */
    setProperty(a, s) {
      this.privSpeechConfig.setProperty(a, s);
    }
    /**
     * Sets a named property as value
     * @member DialogServiceConfigImpl.prototype.getProperty
     * @function
     * @public
     * @param {PropertyId | string} name - The property to get.
     * @param {string} def - The default value to return in case the property is not known.
     * @returns {string} The current value, or provided default, of the given property.
     */
    getProperty(a, s) {
      return this.privSpeechConfig.getProperty(a);
    }
    /**
     * Sets the proxy configuration.
     * Only relevant in Node.js environments.
     * Added in version 1.4.0.
     * @param proxyHostName The host name of the proxy server, without the protocol scheme (http://)
     * @param proxyPort The port number of the proxy server.
     * @param proxyUserName The user name of the proxy server.
     * @param proxyPassword The password of the proxy server.
     */
    setProxy(a, s, n, c) {
      this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyHostName, a), this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyPort, `${s}`), n && this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyUserName, n), c && this.setProperty(t.PropertyId.SpeechServiceConnection_ProxyPassword, c);
    }
    setServiceProperty(a, s, n) {
      this.privSpeechConfig.setServiceProperty(a, s);
    }
    /**
     * Dispose of associated resources.
     * @member DialogServiceConfigImpl.prototype.close
     * @function
     * @public
     */
    close() {
    }
  }
  return gt.DialogServiceConfigImpl = o, gt;
}
var hn = {}, Bl;
function $R() {
  if (Bl) return hn;
  Bl = 1, Object.defineProperty(hn, "__esModule", { value: !0 }), hn.BotFrameworkConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ uc(), r = /* @__PURE__ */ I();
  let o = class extends t.DialogServiceConfigImpl {
    /**
     * Creates an instance of BotFrameworkConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates a bot framework configuration instance with the provided subscription information.
     * @member BotFrameworkConfig.fromSubscription
     * @function
     * @public
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromSubscription(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "subscription"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, s), n && c.setProperty(r.PropertyId.Conversation_ApplicationId, n), c;
    }
    /**
     * Creates a bot framework configuration instance for the specified authorization token and region.
     * Note: The caller must ensure that an authorization token is valid. Before an authorization token expires, the
     * caller must refresh it by setting the authorizationToken property on the corresponding
     * DialogServiceConnector instance created with this config. The contents of configuration objects are copied
     * when connectors are created, so setting authorizationToken on a DialogServiceConnector will not update the
     * original configuration's authorization token. Create a new configuration instance or set the
     * SpeechServiceAuthorization_Token property to update an existing instance if it will be used to create
     * further DialogServiceConnectors.
     * @member BotFrameworkConfig.fromAuthorizationToken
     * @function
     * @public
     * @param authorizationToken The authorization token associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromAuthorizationToken(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(s, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), c.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, s), n && c.setProperty(r.PropertyId.Conversation_ApplicationId, n), c;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-default service host. The standard resource path will be
     * assumed. For services with a non-standard resource path or no path at all, use fromEndpoint instead.
     * Note: Query parameters are not allowed in the host URI and must be set by other APIs.
     * Note: To use an authorization token with fromHost, use fromHost(URL) and then set the AuthorizationToken
     * property on the created BotFrameworkConfig instance.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromHost
     * @function
     * @public
     * @param {URL | string} host - If a URL is provided, the fully-qualified host with protocol (e.g.
     * wss://your.host.com:1234) will be used. If a string is provided, it will be embedded in
     * wss://{host}.convai.speech.azure.us.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @param botId Optional. Identifier for using a specific bot within an Azure resource group. Equivalent to the
     * resource name.
     * @returns {BotFrameworkConfig} A new bot framework configuration instance.
     */
    static fromHost(a, s, n) {
      e.Contracts.throwIfNullOrUndefined(a, "host");
      const c = a instanceof URL ? a : new URL(`wss://${a}.convai.speech.azure.us`);
      e.Contracts.throwIfNullOrUndefined(c, "resolvedHost");
      const u = new t.DialogServiceConfigImpl();
      return u.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), u.setProperty(r.PropertyId.SpeechServiceConnection_Host, c.toString()), s !== void 0 && u.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), u;
    }
    /**
     * Creates an instance of a BotFrameworkConfig.
     * This method is intended only for users who use a non-standard service endpoint or parameters.
     * Note: The query parameters specified in the endpoint URL are not changed, even if they are set by any other APIs.
     * Note: To use authorization token with fromEndpoint, pass an empty string to the subscriptionKey in the
     * fromEndpoint method, and then set authorizationToken="token" on the created BotFrameworkConfig instance to
     * use the authorization token.
     * Note: Added in version 1.15.0.
     * @member BotFrameworkConfig.fromEndpoint
     * @function
     * @public
     * @param {URL} endpoint - The service endpoint to connect to.
     * @param {string} subscriptionKey - The subscription key. If a subscription key is not specified, an authorization
     * token must be set.
     * @returns {BotFrameworkConfig} - A new bot framework configuration instance using the provided endpoint.
     */
    static fromEndpoint(a, s) {
      e.Contracts.throwIfNull(a, "endpoint");
      const n = new t.DialogServiceConfigImpl();
      return n.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.BotFramework), n.setProperty(r.PropertyId.SpeechServiceConnection_Endpoint, a.toString()), s !== void 0 && n.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), n;
    }
  };
  return hn.BotFrameworkConfig = o, hn;
}
var fn = {}, Ul;
function VR() {
  if (Ul) return fn;
  Ul = 1, Object.defineProperty(fn, "__esModule", { value: !0 }), fn.CustomCommandsConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ uc(), r = /* @__PURE__ */ I();
  let o = class extends t.DialogServiceConfigImpl {
    /**
     * Creates an instance of CustomCommandsConfig.
     */
    constructor() {
      super();
    }
    /**
     * Creates an instance of the bot framework config with the specified subscription and region.
     * @member CustomCommandsConfig.fromSubscription
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param subscription Subscription key associated with the bot
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new bot framework config.
     */
    static fromSubscription(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "applicationId"), e.Contracts.throwIfNullOrWhitespace(s, "subscription"), e.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(r.PropertyId.Conversation_ApplicationId, a), c.setProperty(r.PropertyId.SpeechServiceConnection_Key, s), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Creates an instance of the bot framework config with the specified Speech Commands application id, authorization token and region.
     * Note: The caller needs to ensure that the authorization token is valid. Before the authorization token
     * expires, the caller needs to refresh it by calling this setter with a new valid token.
     * As configuration values are copied when creating a new recognizer, the new token value will not apply to recognizers that have already been created.
     * For recognizers that have been created before, you need to set authorization token of the corresponding recognizer
     * to refresh the token. Otherwise, the recognizers will encounter errors during recognition.
     * @member CustomCommandsConfig.fromAuthorizationToken
     * @function
     * @public
     * @param applicationId Speech Commands application id.
     * @param authorizationToken The authorization token associated with the application.
     * @param region The region name (see the <a href="https://aka.ms/csspeech/region">region page</a>).
     * @returns {CustomCommandsConfig} A new speech commands config.
     */
    static fromAuthorizationToken(a, s, n) {
      e.Contracts.throwIfNullOrWhitespace(a, "applicationId"), e.Contracts.throwIfNullOrWhitespace(s, "authorizationToken"), e.Contracts.throwIfNullOrWhitespace(n, "region");
      const c = new t.DialogServiceConfigImpl();
      return c.setProperty(r.PropertyId.Conversation_DialogType, t.DialogServiceConfig.DialogTypes.CustomCommands), c.setProperty(r.PropertyId.Conversation_ApplicationId, a), c.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, s), c.setProperty(r.PropertyId.SpeechServiceConnection_Region, n), c;
    }
    /**
     * Sets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to set.
     */
    set applicationId(a) {
      e.Contracts.throwIfNullOrWhitespace(a, "value"), this.setProperty(r.PropertyId.Conversation_ApplicationId, a);
    }
    /**
     * Gets the corresponding backend application identifier.
     * @member CustomCommandsConfig.prototype.Conversation_ApplicationId
     * @function
     * @public
     * @param {string} value - The application identifier to get.
     */
    get applicationId() {
      return this.getProperty(r.PropertyId.Conversation_ApplicationId);
    }
  };
  return fn.CustomCommandsConfig = o, fn;
}
var vn = {}, gn = {}, mn = {}, yn = {}, $l;
function et() {
  if ($l) return yn;
  $l = 1, Object.defineProperty(yn, "__esModule", { value: !0 }), yn.QueryParameterNames = void 0;
  let e = class {
  };
  return yn.QueryParameterNames = e, e.BotId = "botid", e.CustomSpeechDeploymentId = "cid", e.CustomVoiceDeploymentId = "deploymentId", e.EnableAudioLogging = "storeAudio", e.EnableLanguageId = "lidEnabled", e.EnableWordLevelTimestamps = "wordLevelTimestamps", e.EndSilenceTimeoutMs = "endSilenceTimeoutMs", e.SegmentationSilenceTimeoutMs = "segmentationSilenceTimeoutMs", e.SegmentationMaximumTimeMs = "segmentationMaximumTimeMs", e.SegmentationStrategy = "segmentationStrategy", e.Format = "format", e.InitialSilenceTimeoutMs = "initialSilenceTimeoutMs", e.Language = "language", e.Profanity = "profanity", e.RequestBotStatusMessages = "enableBotMessageStatus", e.StableIntermediateThreshold = "stableIntermediateThreshold", e.StableTranslation = "stableTranslation", e.TestHooks = "testhooks", e.Postprocessing = "postprocessing", e.CtsMeetingId = "meetingId", e.CtsDeviceId = "deviceId", e.CtsIsParticipant = "isParticipant", e.EnableAvatar = "enableTalkingAvatar", yn;
}
var Vl;
function ke() {
  if (Vl) return mn;
  Vl = 1, Object.defineProperty(mn, "__esModule", { value: !0 }), mn.ConnectionFactoryBase = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ et();
  let i = class {
    static getHostSuffix(s) {
      if (s) {
        if (s.toLowerCase().startsWith("china"))
          return ".azure.cn";
        if (s.toLowerCase().startsWith("usgov"))
          return ".azure.us";
      }
      return ".microsoft.com";
    }
    setCommonUrlParams(s, n, c) {
      (/* @__PURE__ */ new Map([
        [r.PropertyId.Speech_SegmentationSilenceTimeoutMs, o.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceConnection_EnableAudioLogging, o.QueryParameterNames.EnableAudioLogging],
        [r.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, o.QueryParameterNames.EndSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, o.QueryParameterNames.InitialSilenceTimeoutMs],
        [r.PropertyId.SpeechServiceResponse_PostProcessingOption, o.QueryParameterNames.Postprocessing],
        [r.PropertyId.SpeechServiceResponse_ProfanityOption, o.QueryParameterNames.Profanity],
        [r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, o.QueryParameterNames.EnableWordLevelTimestamps],
        [r.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, o.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((p, h) => {
        this.setUrlParameter(h, p, s, n, c);
      });
      const l = JSON.parse(s.parameters.getProperty(e.ServicePropertiesPropertyName, "{}"));
      Object.keys(l).forEach((p) => {
        n[p] = l[p];
      });
    }
    setUrlParameter(s, n, c, u, l) {
      const p = c.parameters.getProperty(s, void 0);
      p && (!l || l.search(n) === -1) && (u[n] = p.toLocaleLowerCase());
    }
    static async getRedirectUrlFromEndpoint(s) {
      let n;
      if (typeof window < "u" && typeof window.fetch < "u") {
        const c = new URL(s);
        c.protocol = "https:", c.port = "443", c.searchParams.append("GenerateRedirectResponse", "true");
        const l = c.toString();
        t.Events.instance.onEvent(new t.ConnectionRedirectEvent("", l, void 0, "ConnectionFactoryBase: redirectUrl request"));
        const p = await fetch(l);
        if (p.status !== 200)
          return s;
        n = await p.text();
      } else
        n = s;
      t.Events.instance.onEvent(new t.ConnectionRedirectEvent("", n, s, "ConnectionFactoryBase: redirectUrlString"));
      try {
        return new URL(n.trim()).toString();
      } catch {
        return s;
      }
    }
  };
  return mn.ConnectionFactoryBase = i, mn;
}
var Wl;
function WR() {
  if (Wl) return gn;
  Wl = 1, Object.defineProperty(gn, "__esModule", { value: !0 }), gn.DialogConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ ke(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ le(), s = /* @__PURE__ */ et();
  class n extends o.ConnectionFactoryBase {
    create(u, l, p) {
      const h = u.parameters.getProperty(r.PropertyId.Conversation_ApplicationId, ""), d = u.parameters.getProperty(r.PropertyId.Conversation_DialogType), f = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region), g = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), m = u.parameters.getProperty(r.PropertyId.Conversation_Request_Bot_Status_Messages, "true"), v = {};
      v[a.HeaderNames.ConnectionId] = p, v[s.QueryParameterNames.Format] = u.parameters.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase(), v[s.QueryParameterNames.Language] = g, v[s.QueryParameterNames.RequestBotStatusMessages] = m, h && (v[s.QueryParameterNames.BotId] = h, d === r.DialogServiceConfig.DialogTypes.CustomCommands && (v[a.HeaderNames.CustomCommandsAppId] = h));
      const y = d === r.DialogServiceConfig.DialogTypes.CustomCommands ? "commands/" : "", S = d === r.DialogServiceConfig.DialogTypes.CustomCommands ? "v1" : d === r.DialogServiceConfig.DialogTypes.BotFramework ? "v3" : "v0", C = {};
      l.token != null && l.token !== "" && (C[l.headerName] = l.token);
      let w = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, "");
      if (!w) {
        const A = o.ConnectionFactoryBase.getHostSuffix(f), E = u.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, `wss://${f}.${n.BaseUrl}${A}`);
        w = `${E.endsWith("/") ? E : E + "/"}${y}${n.ApiKey}/${S}`;
      }
      this.setCommonUrlParams(u, v, w);
      const b = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(w, v, C, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), b, p));
    }
  }
  return gn.DialogConnectionFactory = n, n.ApiKey = "api", n.BaseUrl = "convai.speech", gn;
}
var Hl;
function HR() {
  if (Hl) return vn;
  Hl = 1, Object.defineProperty(vn, "__esModule", { value: !0 }), vn.DialogServiceConnector = void 0;
  const e = /* @__PURE__ */ WR(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ Re(), o = /* @__PURE__ */ k(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ I(), s = /* @__PURE__ */ cc();
  let n = class extends a.Recognizer {
    /**
     * Initializes an instance of the DialogServiceConnector.
     * @constructor
     * @param {DialogServiceConfig} dialogConfig - Set of properties to configure this recognizer.
     * @param {AudioConfig} audioConfig - An optional audio config associated with the recognizer
     */
    constructor(u, l) {
      const p = u;
      i.Contracts.throwIfNull(u, "dialogConfig"), super(l, p.properties, new e.DialogConnectionFactory()), this.isTurnComplete = !0, this.privIsDisposed = !1, this.privProperties = p.properties.clone();
      const h = this.buildAgentConfig();
      this.privReco.agentConfig.set(h);
    }
    /**
     * Starts a connection to the service.
     * Users can optionally call connect() to manually set up a connection in advance, before starting interactions.
     *
     * Note: On return, the connection might not be ready yet. Please subscribe to the Connected event to
     * be notified when the connection is established.
     * @member DialogServiceConnector.prototype.connect
     * @function
     * @public
     */
    connect(u, l) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.connect(), u, l);
    }
    /**
     * Closes the connection the service.
     * Users can optionally call disconnect() to manually shutdown the connection of the associated DialogServiceConnector.
     *
     * If disconnect() is called during a recognition, recognition will fail and cancel with an error.
     */
    disconnect(u, l) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.disconnect(), u, l);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(s.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Sets the authorization token used to communicate with the service.
     * @member DialogServiceConnector.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(u) {
      i.Contracts.throwIfNullOrWhitespace(u, "token"), this.properties.setProperty(s.PropertyId.SpeechServiceAuthorization_Token, u);
    }
    /**
     * The collection of properties and their values defined for this DialogServiceConnector.
     * @member DialogServiceConnector.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this DialogServiceConnector.
     */
    get properties() {
      return this.privProperties;
    }
    /** Gets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be empty
     */
    get speechActivityTemplate() {
      return this.properties.getProperty(s.PropertyId.Conversation_Speech_Activity_Template);
    }
    /** Sets the template for the activity generated by service from speech.
     * Properties from the template will be stamped on the generated activity.
     * It can be null or empty.
     * Note: it has to be a valid Json object.
     */
    set speechActivityTemplate(u) {
      this.properties.setProperty(s.PropertyId.Conversation_Speech_Activity_Template, u);
    }
    /**
     * Starts recognition and stops after the first utterance is recognized.
     * @member DialogServiceConnector.prototype.listenOnceAsync
     * @function
     * @public
     * @param cb - Callback that received the result when the reco has completed.
     * @param err - Callback invoked in case of an error.
     */
    listenOnceAsync(u, l) {
      if (this.isTurnComplete) {
        i.Contracts.throwIfDisposed(this.privIsDisposed);
        const h = (async () => {
          await this.privReco.connect(), await this.implRecognizerStop(), this.isTurnComplete = !1;
          const d = new o.Deferred();
          await this.privReco.recognize(r.RecognitionMode.Conversation, d.resolve, d.reject);
          const f = await d.promise;
          return await this.implRecognizerStop(), f;
        })();
        h.catch(() => {
          this.dispose(!0).catch(() => {
          });
        }), (0, o.marshalPromiseToCallbacks)(h.finally(() => {
          this.isTurnComplete = !0;
        }), u, l);
      }
    }
    sendActivityAsync(u, l, p) {
      (0, o.marshalPromiseToCallbacks)(this.privReco.sendMessage(u), l, p);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member DialogServiceConnector.prototype.close
     * @function
     * @public
     */
    close(u, l) {
      i.Contracts.throwIfDisposed(this.privIsDisposed), (0, o.marshalPromiseToCallbacks)(this.dispose(!0), u, l);
    }
    async dispose(u) {
      this.privIsDisposed || u && (this.privIsDisposed = !0, await this.implRecognizerStop(), await super.dispose(u));
    }
    createRecognizerConfig(u) {
      return new t.RecognizerConfig(u, this.privProperties);
    }
    createServiceRecognizer(u, l, p, h) {
      const d = p;
      return new t.DialogServiceAdapter(u, l, d, h, this);
    }
    buildAgentConfig() {
      return {
        botInfo: {
          commType: this.properties.getProperty("Conversation_Communication_Type", "Default"),
          commandsCulture: void 0,
          connectionId: this.properties.getProperty(s.PropertyId.Conversation_Agent_Connection_Id),
          conversationId: this.properties.getProperty(s.PropertyId.Conversation_Conversation_Id, void 0),
          fromId: this.properties.getProperty(s.PropertyId.Conversation_From_Id, void 0),
          ttsAudioFormat: this.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)
        },
        version: 0.2
      };
    }
  };
  return vn.DialogServiceConnector = n, vn;
}
var Sn = {}, Kl;
function KR() {
  if (Kl) return Sn;
  Kl = 1, Object.defineProperty(Sn, "__esModule", { value: !0 }), Sn.ActivityReceivedEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {any} activity - The activity..
     */
    constructor(r, o) {
      this.privActivity = r, this.privAudioStream = o;
    }
    /**
     * Gets the received activity
     * @member ActivityReceivedEventArgs.prototype.activity
     * @function
     * @public
     * @returns {any} the received activity.
     */
    get activity() {
      return this.privActivity;
    }
    get audioStream() {
      return this.privAudioStream;
    }
  };
  return Sn.ActivityReceivedEventArgs = e, Sn;
}
var Cn = {}, Rn = {}, Jl;
function JR() {
  if (Jl) return Rn;
  Jl = 1, Object.defineProperty(Rn, "__esModule", { value: !0 }), Rn.TurnStatusResponsePayload = void 0;
  class e {
    constructor(r) {
      this.privMessageStatusResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new e(r);
    }
    get interactionId() {
      return this.privMessageStatusResponse.interactionId;
    }
    get conversationId() {
      return this.privMessageStatusResponse.conversationId;
    }
    get statusCode() {
      switch (this.privMessageStatusResponse.statusCode) {
        case "Success":
          return 200;
        case "Failed":
          return 400;
        case "TimedOut":
          return 429;
        default:
          return this.privMessageStatusResponse.statusCode;
      }
    }
  }
  return Rn.TurnStatusResponsePayload = e, Rn;
}
var Gl;
function GR() {
  if (Gl) return Cn;
  Gl = 1, Object.defineProperty(Cn, "__esModule", { value: !0 }), Cn.TurnStatusReceivedEventArgs = void 0;
  const e = /* @__PURE__ */ JR();
  let t = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} turnStatus - The JSON-encoded turn status message.
     */
    constructor(o) {
      this.privTurnStatus = e.TurnStatusResponsePayload.fromJSON(o);
    }
    /**
     * Gets the interaction identifier associated with this turn status event.
     * @member TurnStatusReceivedEventArgs.prototype.interactionId
     * @function
     * @public
     * @returns {any} the received interaction id.
     */
    get interactionId() {
      return this.privTurnStatus.interactionId;
    }
    /**
     * Gets the conversation identifier associated with this turn status event.
     * @member TurnStatusReceivedEventArgs.prototype.conversationId
     * @function
     * @public
     * @returns {any} the received conversation id.
     */
    get conversationId() {
      return this.privTurnStatus.conversationId;
    }
    /**
     * Gets the received turn status code.
     * @member TurnStatusReceivedEventArgs.prototype.statusCode
     * @function
     * @public
     * @returns {number} the received turn status.
     */
    get statusCode() {
      return this.privTurnStatus.statusCode;
    }
  };
  return Cn.TurnStatusReceivedEventArgs = t, Cn;
}
var Ho = {}, Ql;
function QR() {
  return Ql || (Ql = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ServicePropertyChannel = void 0, function(t) {
      t[t.UriQueryParameter = 0] = "UriQueryParameter";
    }(e.ServicePropertyChannel || (e.ServicePropertyChannel = {}));
  }(Ho)), Ho;
}
var Ko = {}, Yl;
function YR() {
  return Yl || (Yl = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ProfanityOption = void 0, function(t) {
      t[t.Masked = 0] = "Masked", t[t.Removed = 1] = "Removed", t[t.Raw = 2] = "Raw";
    }(e.ProfanityOption || (e.ProfanityOption = {}));
  }(Ko)), Ko;
}
var Pn = {}, Zl;
function ZR() {
  if (Zl) return Pn;
  Zl = 1, Object.defineProperty(Pn, "__esModule", { value: !0 }), Pn.BaseAudioPlayer = void 0;
  const e = /* @__PURE__ */ Ne(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ Nt();
  let o = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {AudioStreamFormat} audioFormat audio stream format recognized by the player.
     */
    constructor(a) {
      this.audioContext = null, this.gainNode = null, this.autoUpdateBufferTimer = 0, a === void 0 && (a = t.AudioStreamFormat.getDefaultInputFormat()), this.init(a);
    }
    /**
     * play Audio sample
     * @param newAudioData audio data to be played.
     */
    playAudioSample(a, s, n) {
      try {
        this.ensureInitializedContext();
        const c = this.formatAudioData(a), u = new Float32Array(this.samples.length + c.length);
        u.set(this.samples, 0), u.set(c, this.samples.length), this.samples = u, s && s();
      } catch (c) {
        n && n(c);
      }
    }
    /**
     * stops audio and clears the buffers
     */
    stopAudio(a, s) {
      this.audioContext !== null && (this.samples = new Float32Array(), clearInterval(this.autoUpdateBufferTimer), this.audioContext.close().then(() => {
        a && a();
      }, (n) => {
        s && s(n);
      }), this.audioContext = null);
    }
    init(a) {
      this.audioFormat = a, this.samples = new Float32Array();
    }
    ensureInitializedContext() {
      if (this.audioContext === null) {
        this.createAudioContext();
        const a = 200;
        this.autoUpdateBufferTimer = setInterval(() => {
          this.updateAudioBuffer();
        }, a);
      }
    }
    createAudioContext() {
      this.audioContext = r.AudioStreamFormatImpl.getAudioContext(), this.gainNode = this.audioContext.createGain(), this.gainNode.gain.value = 1, this.gainNode.connect(this.audioContext.destination), this.startTime = this.audioContext.currentTime;
    }
    formatAudioData(a) {
      switch (this.audioFormat.bitsPerSample) {
        case 8:
          return this.formatArrayBuffer(new Int8Array(a), 128);
        case 16:
          return this.formatArrayBuffer(new Int16Array(a), 32768);
        case 32:
          return this.formatArrayBuffer(new Int32Array(a), 2147483648);
        default:
          throw new e.InvalidOperationError("Only WAVE_FORMAT_PCM (8/16/32 bps) format supported at this time");
      }
    }
    formatArrayBuffer(a, s) {
      const n = new Float32Array(a.length);
      for (let c = 0; c < a.length; c++)
        n[c] = a[c] / s;
      return n;
    }
    updateAudioBuffer() {
      if (this.samples.length === 0)
        return;
      const a = this.audioFormat.channels, s = this.audioContext.createBufferSource(), n = this.samples.length / a, c = this.audioContext.createBuffer(a, n, this.audioFormat.samplesPerSec);
      for (let u = 0; u < a; u++) {
        let l = u;
        const p = c.getChannelData(u);
        for (let h = 0; h < this.samples.length; h++, l += a)
          p[h] = this.samples[l];
      }
      this.startTime < this.audioContext.currentTime && (this.startTime = this.audioContext.currentTime), s.buffer = c, s.connect(this.gainNode), s.start(this.startTime), this.startTime += c.duration, this.samples = new Float32Array();
    }
    async playAudio(a) {
      this.audioContext === null && this.createAudioContext();
      const s = this.audioContext.createBufferSource(), n = this.audioContext.destination;
      await this.audioContext.decodeAudioData(a, (c) => {
        s.buffer = c, s.connect(n), s.start(0);
      });
    }
  };
  return Pn.BaseAudioPlayer = o, Pn;
}
var wn = {}, Xl;
function XR() {
  if (Xl) return wn;
  Xl = 1, Object.defineProperty(wn, "__esModule", { value: !0 }), wn.ConnectionMessageEventArgs = void 0;
  let e = class {
    constructor(r) {
      this.privConnectionMessage = r;
    }
    /**
     * Gets the <see cref="ConnectionMessage"/> associated with this <see cref="ConnectionMessageEventArgs"/>.
     */
    get message() {
      return this.privConnectionMessage;
    }
    /**
     * Returns a string that represents the connection message event.
     */
    toString() {
      return "Message: " + this.privConnectionMessage.toString();
    }
  };
  return wn.ConnectionMessageEventArgs = e, wn;
}
var bn = {}, ep;
function eP() {
  if (ep) return bn;
  ep = 1, Object.defineProperty(bn, "__esModule", { value: !0 }), bn.VoiceProfile = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} profileId - profileId of this Voice Profile.
     * @param {VoiceProfileType} profileType - profileType of this Voice Profile.
     */
    constructor(r, o) {
      this.privId = r, this.privProfileType = o;
    }
    /**
     * profileId of this Voice Profile instance
     * @member VoiceProfile.prototype.profileId
     * @function
     * @public
     * @returns {string} profileId of this Voice Profile instance.
     */
    get profileId() {
      return this.privId;
    }
    /**
     * profileType of this Voice Profile instance
     * @member VoiceProfile.prototype.profileType
     * @function
     * @public
     * @returns {VoiceProfileType} profile type of this Voice Profile instance.
     */
    get profileType() {
      return this.privProfileType;
    }
  };
  return bn.VoiceProfile = e, bn;
}
var mt = {}, tp;
function tP() {
  if (tp) return mt;
  tp = 1, Object.defineProperty(mt, "__esModule", { value: !0 }), mt.VoiceProfileEnrollmentCancellationDetails = mt.VoiceProfileEnrollmentResult = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ I();
  let r = class Va {
    constructor(a, s, n) {
      this.privReason = a, this.privProperties = new t.PropertyCollection(), this.privReason !== t.ResultReason.Canceled ? s && (this.privDetails = JSON.parse(s), this.privDetails.enrollmentStatus.toLowerCase() === "enrolling" && (this.privReason = t.ResultReason.EnrollingVoiceProfile)) : (this.privErrorDetails = n, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[t.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get enrollmentsCount() {
      return this.privDetails.enrollmentsCount;
    }
    get enrollmentsLength() {
      return this.privDetails.enrollmentsLength;
    }
    get properties() {
      return this.privProperties;
    }
    get enrollmentResultDetails() {
      return this.privDetails;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
    static FromIdentificationProfileList(a) {
      const s = [];
      for (const n of a.value) {
        const c = n.enrollmentStatus.toLowerCase() === "enrolling" ? t.ResultReason.EnrollingVoiceProfile : n.enrollmentStatus.toLowerCase() === "enrolled" ? t.ResultReason.EnrolledVoiceProfile : t.ResultReason.Canceled, u = new Va(c, null, null);
        u.privDetails = this.getIdentificationDetails(n), s.push(u);
      }
      return s;
    }
    static FromVerificationProfileList(a) {
      const s = [];
      for (const n of a.value) {
        const c = n.enrollmentStatus.toLowerCase() === "enrolling" ? t.ResultReason.EnrollingVoiceProfile : n.enrollmentStatus.toLowerCase() === "enrolled" ? t.ResultReason.EnrolledVoiceProfile : t.ResultReason.Canceled, u = new Va(c, null, null);
        u.privDetails = this.getVerificationDetails(n), s.push(u);
      }
      return s;
    }
    static getIdentificationDetails(a) {
      return {
        audioLength: a.audioLength ? parseFloat(a.audioLength) : 0,
        audioSpeechLength: a.audioSpeechLength ? parseFloat(a.audioSpeechLength) : 0,
        enrollmentStatus: a.enrollmentStatus,
        enrollmentsCount: a.enrollmentsCount || 0,
        enrollmentsLength: a.enrollmentsLength ? parseFloat(a.enrollmentsLength) : 0,
        enrollmentsSpeechLength: a.enrollmentsSpeechLength ? parseFloat(a.enrollmentsSpeechLength) : 0,
        profileId: a.profileId || a.identificationProfileId,
        remainingEnrollmentsSpeechLength: a.remainingEnrollmentsSpeechLength ? parseFloat(a.remainingEnrollmentsSpeechLength) : 0
      };
    }
    static getVerificationDetails(a) {
      return {
        audioLength: a.audioLength ? parseFloat(a.audioLength) : 0,
        audioSpeechLength: a.audioSpeechLength ? parseFloat(a.audioSpeechLength) : 0,
        enrollmentStatus: a.enrollmentStatus,
        enrollmentsCount: a.enrollmentsCount,
        enrollmentsLength: a.enrollmentsLength ? parseFloat(a.enrollmentsLength) : 0,
        enrollmentsSpeechLength: a.enrollmentsSpeechLength ? parseFloat(a.enrollmentsSpeechLength) : 0,
        profileId: a.profileId || a.verificationProfileId,
        remainingEnrollmentsCount: a.remainingEnrollments || a.remainingEnrollmentsCount,
        remainingEnrollmentsSpeechLength: a.remainingEnrollmentsSpeechLength ? parseFloat(a.remainingEnrollmentsSpeechLength) : 0
      };
    }
  };
  mt.VoiceProfileEnrollmentResult = r;
  class o extends t.CancellationDetailsBase {
    constructor(a, s, n) {
      super(a, s, n);
    }
    /**
     * Creates an instance of VoiceProfileEnrollmentCancellationDetails object for the canceled VoiceProfileEnrollmentResult.
     * @member VoiceProfileEnrollmentCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileEnrollmentResult} result - The result that was canceled.
     * @returns {VoiceProfileEnrollmentCancellationDetails} The cancellation details object being created.
     */
    static fromResult(a) {
      const s = t.CancellationReason.Error;
      let n = t.CancellationErrorCode.NoError;
      return a.properties && (n = t.CancellationErrorCode[a.properties.getProperty(e.CancellationErrorCodePropertyName, t.CancellationErrorCode[t.CancellationErrorCode.NoError])]), new o(s, a.errorDetails, n);
    }
  }
  return mt.VoiceProfileEnrollmentCancellationDetails = o, mt;
}
var yt = {}, rp;
function rP() {
  if (rp) return yt;
  rp = 1, Object.defineProperty(yt, "__esModule", { value: !0 }), yt.VoiceProfileCancellationDetails = yt.VoiceProfileResult = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I();
  let o = class {
    constructor(s, n) {
      this.privReason = s, this.privProperties = new r.PropertyCollection(), s === r.ResultReason.Canceled && (t.Contracts.throwIfNullOrUndefined(n, "statusText"), this.privErrorDetails = n, this.privProperties.setProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.ServiceError]));
    }
    get reason() {
      return this.privReason;
    }
    get properties() {
      return this.privProperties;
    }
    get errorDetails() {
      return this.privErrorDetails;
    }
  };
  yt.VoiceProfileResult = o;
  class i extends r.CancellationDetailsBase {
    constructor(s, n, c) {
      super(s, n, c);
    }
    /**
     * Creates an instance of VoiceProfileCancellationDetails object for the canceled VoiceProfileResult.
     * @member VoiceProfileCancellationDetails.fromResult
     * @function
     * @public
     * @param {VoiceProfileResult} result - The result that was canceled.
     * @returns {VoiceProfileCancellationDetails} The cancellation details object being created.
     */
    static fromResult(s) {
      const n = r.CancellationReason.Error;
      let c = r.CancellationErrorCode.NoError;
      return s.properties && (c = r.CancellationErrorCode[s.properties.getProperty(e.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new i(n, s.errorDetails, c);
    }
  }
  return yt.VoiceProfileCancellationDetails = i, yt;
}
var En = {}, np;
function nP() {
  if (np) return En;
  np = 1, Object.defineProperty(En, "__esModule", { value: !0 }), En.VoiceProfilePhraseResult = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class extends t.VoiceProfileResult {
    constructor(i, a, s, n) {
      super(i, a), this.privPhrases = [], e.Contracts.throwIfNullOrUndefined(n, "phrase array"), this.privType = s, n && n[0] && (this.privPhrases = n);
    }
    get phrases() {
      return this.privPhrases;
    }
    get type() {
      return this.privType;
    }
  };
  return En.VoiceProfilePhraseResult = r, En;
}
var In = {}, ip;
function iP() {
  if (ip) return In;
  ip = 1, Object.defineProperty(In, "__esModule", { value: !0 }), In.VoiceProfileClient = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ dv(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class extends o.Recognizer {
    /**
     * VoiceProfileClient constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer (authentication key, region, &c)
     */
    constructor(s) {
      r.Contracts.throwIfNullOrUndefined(s, "speechConfig");
      const n = s;
      r.Contracts.throwIfNull(n, "speechConfig"), super(t.AudioConfig.fromStreamInput(o.AudioInputStream.createPushStream()), n.properties, new e.VoiceProfileConnectionFactory()), this.privProperties = n.properties.clone(), this.privVoiceAdapter = this.privReco, this.privDisposedVoiceAdapter = !1;
    }
    /**
     * The collection of properties and their values defined for this VoiceProfileClient.
     * @member VoiceProfileClient.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this VoiceProfileClient.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member VoiceProfileClient.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(s) {
      r.Contracts.throwIfNullOrWhitespace(s, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, s);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.createProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Type of Voice Profile to be created
     * @param {string} lang Language string (locale) for Voice Profile
     * @return {Promise<VoiceProfile>} - Promise of a VoiceProfile.
     */
    async createProfileAsync(s, n) {
      const c = await this.privVoiceAdapter.createProfile(s, n);
      return new o.VoiceProfile(c[0], s);
    }
    /**
     * Get current information of a voice profile
     * @member VoiceProfileClient.prototype.retrieveEnrollmentResultAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to retrieve info for
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async retrieveEnrollmentResultAsync(s) {
      return this.privVoiceAdapter.retrieveEnrollmentResult(s);
    }
    /**
     * Get all voice profiles on account with given voice profile type
     * @member VoiceProfileClient.prototype.getAllProfilesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType profile type (identification/verification) for which to list profiles
     * @return {Promise<VoiceProfileEnrollmentResult[]>} - Promise of an array of VoiceProfileEnrollmentResults.
     */
    async getAllProfilesAsync(s) {
      return this.privVoiceAdapter.getAllProfiles(s);
    }
    /**
     * Get valid authorization phrases for voice profile enrollment
     * @member VoiceProfileClient.prototype.getActivationPhrasesAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfileType} profileType Profile Type to get activation phrases for
     * @param {string} lang Language string (locale) for Voice Profile
     */
    async getActivationPhrasesAsync(s, n) {
      return this.privVoiceAdapter.getActivationPhrases(s, n);
    }
    /**
     * Create a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.enrollProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to create enrollment for
     * @param {AudioConfig} audioConfig source info from which to create enrollment
     * @return {Promise<VoiceProfileEnrollmentResult>} - Promise of a VoiceProfileEnrollmentResult.
     */
    async enrollProfileAsync(s, n) {
      const c = n;
      return r.Contracts.throwIfNullOrUndefined(c, "audioConfig"), this.audioConfig = n, this.privVoiceAdapter.SpeakerAudioSource = c, this.privVoiceAdapter.enrollProfile(s);
    }
    /**
     * Delete a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.deleteProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be deleted
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async deleteProfileAsync(s) {
      return this.privVoiceAdapter.deleteProfile(s);
    }
    /**
     * Remove all enrollments for a speaker recognition voice profile
     * @member VoiceProfileClient.prototype.resetProfileAsync
     * @function
     * @public
     * @async
     * @param {VoiceProfile} profile Voice Profile to be reset
     * @return {Promise<VoiceProfileResult>} - Promise of a VoiceProfileResult.
     */
    async resetProfileAsync(s) {
      return this.privVoiceAdapter.resetProfile(s);
    }
    /**
     * Clean up object and close underlying connection
     * @member VoiceProfileClient.prototype.close
     * @function
     * @async
     * @public
     */
    async close() {
      await this.dispose(!0);
    }
    createServiceRecognizer(s, n, c, u) {
      const l = c;
      return new e.VoiceServiceRecognizer(s, n, l, u, this);
    }
    async dispose(s) {
      this.privDisposedVoiceAdapter || (this.privDisposedVoiceAdapter = !0, s && await super.dispose(s));
    }
    createRecognizerConfig(s) {
      return new e.RecognizerConfig(s, this.properties);
    }
    getResult(s, n) {
      return new o.VoiceProfileResult(s.ok ? n : o.ResultReason.Canceled, s.statusText);
    }
  };
  return In.VoiceProfileClient = i, In;
}
var An = {}, sp;
function sP() {
  if (sp) return An;
  sp = 1, Object.defineProperty(An, "__esModule", { value: !0 }), An.SpeakerRecognizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I();
  let o = class extends r.Recognizer {
    /**
     * Initializes an instance of the SpeakerRecognizer.
     * @constructor
     * @param {SpeechConfig} speechConfig - The set of configuration properties.
     * @param {AudioConfig} audioConfig - An optional audio input config associated with the recognizer
     */
    constructor(a, s) {
      t.Contracts.throwIfNullOrUndefined(a, "speechConfig");
      const n = a;
      t.Contracts.throwIfNullOrUndefined(n, "speechConfig"), super(s, n.properties, new e.SpeakerRecognitionConnectionFactory()), this.privAudioConfigImpl = s, t.Contracts.throwIfNull(this.privAudioConfigImpl, "audioConfig"), this.privDisposedSpeakerRecognizer = !1, this.privProperties = n.properties;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member SpeakerRecognizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(a) {
      t.Contracts.throwIfNullOrWhitespace(a, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, a);
    }
    /**
     * The collection of properties and their values defined for this SpeakerRecognizer.
     * @member SpeakerRecognizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeakerRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Get recognition result for model using given audio
     * @member SpeakerRecognizer.prototype.recognizeOnceAsync
     * @function
     * @public
     * @async
     * @param {SpeakerIdentificationModel | SpeakerVerificationModel} model Model containing Voice Profiles to be identified
     * @param cb - Callback invoked once result is returned.
     * @param err - Callback invoked in case of an error.
     */
    async recognizeOnceAsync(a) {
      return t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), this.recognizeSpeakerOnceAsyncImpl(a);
    }
    /**
     * Included for compatibility
     * @member SpeakerRecognizer.prototype.close
     * @function
     * @public
     * @async
     */
    async close() {
      t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.dispose(!0);
    }
    async recognizeSpeakerOnceAsyncImpl(a) {
      t.Contracts.throwIfDisposed(this.privDisposedSpeakerRecognizer), await this.implRecognizerStop();
      const s = await this.privReco.recognizeSpeaker(a);
      return await this.implRecognizerStop(), s;
    }
    async implRecognizerStop() {
      this.privReco && await this.privReco.stopRecognizing();
    }
    createRecognizerConfig(a) {
      return new e.RecognizerConfig(a, this.privProperties);
    }
    createServiceRecognizer(a, s, n, c) {
      const u = n;
      return new e.SpeakerServiceRecognizer(a, s, u, c, this);
    }
    async dispose(a) {
      this.privDisposedSpeakerRecognizer || a && (this.privDisposedSpeakerRecognizer = !0, await super.dispose(a));
    }
  };
  return An.SpeakerRecognizer = o, An;
}
var Tn = {}, op;
function oP() {
  if (op) return Tn;
  op = 1, Object.defineProperty(Tn, "__esModule", { value: !0 }), Tn.SpeakerIdentificationModel = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class Iv {
    constructor(i) {
      if (this.privVoiceProfiles = [], this.privProfileIds = [], e.Contracts.throwIfNullOrUndefined(i, "VoiceProfiles"), i.length === 0)
        throw new Error("Empty Voice Profiles array");
      for (const a of i) {
        if (a.profileType !== t.VoiceProfileType.TextIndependentIdentification)
          throw new Error("Identification model can only be created from Identification profile: " + a.profileId);
        this.privVoiceProfiles.push(a), this.privProfileIds.push(a.profileId);
      }
    }
    static fromProfiles(i) {
      return new Iv(i);
    }
    get voiceProfileIds() {
      return this.privProfileIds.join(",");
    }
    get profileIds() {
      return this.privProfileIds;
    }
    get scenario() {
      return "TextIndependentIdentification";
    }
  };
  return Tn.SpeakerIdentificationModel = r, Tn;
}
var _n = {}, ap;
function aP() {
  if (ap) return _n;
  ap = 1, Object.defineProperty(_n, "__esModule", { value: !0 }), _n.SpeakerVerificationModel = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class Av {
    constructor(i) {
      if (e.Contracts.throwIfNullOrUndefined(i, "VoiceProfile"), i.profileType === t.VoiceProfileType.TextIndependentIdentification)
        throw new Error("Verification model cannot be created from Identification profile");
      this.privVoiceProfile = i;
    }
    static fromProfile(i) {
      return new Av(i);
    }
    get voiceProfile() {
      return this.privVoiceProfile;
    }
    get profileIds() {
      return [this.voiceProfile.profileId];
    }
    get scenario() {
      return this.voiceProfile.profileType === t.VoiceProfileType.TextDependentVerification ? "TextDependentVerification" : "TextIndependentVerification";
    }
  };
  return _n.SpeakerVerificationModel = r, _n;
}
var kn = {}, Jo = {}, cp;
function Tv() {
  return cp || (cp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LanguageIdMode = void 0, function(t) {
      t[t.AtStart = 0] = "AtStart", t[t.Continuous = 1] = "Continuous";
    }(e.LanguageIdMode || (e.LanguageIdMode = {}));
  }(Jo)), Jo;
}
var up;
function cP() {
  if (up) return kn;
  up = 1, Object.defineProperty(kn, "__esModule", { value: !0 }), kn.AutoDetectSourceLanguageConfig = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ Tv();
  let i = class Ms {
    constructor() {
      this.privProperties = new r.PropertyCollection(), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart"), this.privLanguageIdMode = o.LanguageIdMode.AtStart;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromOpenRange
     * @function
     * @public
     * Only [[SpeechSynthesizer]] supports source language auto detection from open range,
     * for [[Recognizer]], please use AutoDetectSourceLanguageConfig with specific source languages.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with open range.
     */
    static fromOpenRange() {
      const s = new Ms();
      return s.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, e.AutoDetectSourceLanguagesOpenRangeOptionName), s.properties.setProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, "en-US"), s;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromLanguages
     * @function
     * @public
     * @param {string[]} languages Comma-separated string of languages (eg. "en-US,fr-FR") to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given languages.
     */
    static fromLanguages(s) {
      t.Contracts.throwIfArrayEmptyOrWhitespace(s, "languages");
      const n = new Ms();
      return n.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, s.join()), n;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.fromSourceLanguageConfigs
     * @function
     * @public
     * @param {SourceLanguageConfig[]} configs SourceLanguageConfigs to populate properties of config.
     * @return {AutoDetectSourceLanguageConfig} Instance of AutoDetectSourceLanguageConfig
     * @summary Creates an instance of the AutoDetectSourceLanguageConfig with given SourceLanguageConfigs.
     */
    static fromSourceLanguageConfigs(s) {
      if (s.length < 1)
        throw new Error("Expected non-empty SourceLanguageConfig array.");
      const n = new Ms(), c = [];
      return s.forEach((u) => {
        if (c.push(u.language), u.endpointId !== void 0 && u.endpointId !== "") {
          const l = u.language + r.PropertyId.SpeechServiceConnection_EndpointId.toString();
          n.properties.setProperty(l, u.endpointId);
        }
      }), n.properties.setProperty(r.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, c.join()), n;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets an auto detected language config properties
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @member AutoDetectSourceLanguageConfig.prototype.mode
     * @function
     * @public
     * @param {LanguageIdMode} mode LID mode desired.
     * @summary Sets LID operation to desired mode
     */
    set mode(s) {
      s === o.LanguageIdMode.Continuous ? (this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "Continuous")) : (this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "1"), this.privProperties.setProperty(r.PropertyId.SpeechServiceConnection_LanguageIdMode, "AtStart")), this.privLanguageIdMode = s;
    }
  };
  return kn.AutoDetectSourceLanguageConfig = i, kn;
}
var On = {}, lp;
function uP() {
  if (lp) return On;
  lp = 1, Object.defineProperty(On, "__esModule", { value: !0 }), On.AutoDetectSourceLanguageResult = void 0;
  const e = /* @__PURE__ */ z();
  let t = class Wa {
    constructor(o, i) {
      e.Contracts.throwIfNullOrUndefined(o, "language"), e.Contracts.throwIfNullOrUndefined(i, "languageDetectionConfidence"), this.privLanguage = o, this.privLanguageDetectionConfidence = i;
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a SpeechRecognitionResult instance.
     * @member AutoDetectSourceLanguageResult.fromResult
     * @function
     * @public
     * @param {SpeechRecognitionResult} result - The recognition result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */
    static fromResult(o) {
      return new Wa(o.language, o.languageDetectionConfidence);
    }
    /**
     * Creates an instance of AutoDetectSourceLanguageResult object from a ConversationTranscriptionResult instance.
     * @member AutoDetectSourceLanguageResult.fromConversationTranscriptionResult
     * @function
     * @public
     * @param {ConversationTranscriptionResult} result - The transcription result.
     * @returns {AutoDetectSourceLanguageResult} AutoDetectSourceLanguageResult object being created.
     */
    static fromConversationTranscriptionResult(o) {
      return new Wa(o.language, o.languageDetectionConfidence);
    }
    get language() {
      return this.privLanguage;
    }
    get languageDetectionConfidence() {
      return this.privLanguageDetectionConfidence;
    }
  };
  return On.AutoDetectSourceLanguageResult = t, On;
}
var Mn = {}, pp;
function lP() {
  if (pp) return Mn;
  pp = 1, Object.defineProperty(Mn, "__esModule", { value: !0 }), Mn.SourceLanguageConfig = void 0;
  const e = /* @__PURE__ */ z();
  let t = class _v {
    constructor(o, i) {
      e.Contracts.throwIfNullOrUndefined(o, "language"), this.privLanguage = o, this.privEndpointId = i;
    }
    /**
     * @member SourceLanguageConfig.fromLanguage
     * @function
     * @public
     * @param {string} language language (eg. "en-US") value of config.
     * @param {string?} endpointId endpointId of model bound to given language of config.
     * @return {SourceLanguageConfig} Instance of SourceLanguageConfig
     * @summary Creates an instance of the SourceLanguageConfig with the given language and optional endpointId.
     * Added in version 1.13.0.
     */
    static fromLanguage(o, i) {
      return new _v(o, i);
    }
    get language() {
      return this.privLanguage;
    }
    get endpointId() {
      return this.privEndpointId;
    }
  };
  return Mn.SourceLanguageConfig = t, Mn;
}
var Go = {}, dp;
function pP() {
  return dp || (dp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeakerRecognitionCancellationDetails = e.SpeakerRecognitionResult = e.SpeakerRecognitionResultType = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ I();
    var o;
    (function(s) {
      s[s.Verify = 0] = "Verify", s[s.Identify = 1] = "Identify";
    })(o = e.SpeakerRecognitionResultType || (e.SpeakerRecognitionResultType = {}));
    class i {
      constructor(n, c = r.ResultReason.RecognizedSpeaker, u = r.CancellationErrorCode.NoError, l = "") {
        this.privProperties = new r.PropertyCollection();
        const p = n.scenario === "TextIndependentIdentification" ? o.Identify : o.Verify;
        this.privReason = c, this.privReason !== r.ResultReason.Canceled ? p === o.Identify ? (this.privProfileId = n.identificationResult.identifiedProfile.profileId, this.privScore = n.identificationResult.identifiedProfile.score, this.privReason = r.ResultReason.RecognizedSpeakers) : (this.privScore = n.verificationResult.score, n.verificationResult.recognitionResult.toLowerCase() !== "accept" && (this.privReason = r.ResultReason.NoMatch), n.verificationResult.profileId !== void 0 && n.verificationResult.profileId !== "" && (this.privProfileId = n.verificationResult.profileId)) : (this.privErrorDetails = l, this.privProperties.setProperty(t.CancellationErrorCodePropertyName, r.CancellationErrorCode[u])), this.privProperties.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, JSON.stringify(n));
      }
      get properties() {
        return this.privProperties;
      }
      get reason() {
        return this.privReason;
      }
      get profileId() {
        return this.privProfileId;
      }
      get errorDetails() {
        return this.privErrorDetails;
      }
      get score() {
        return this.privScore;
      }
    }
    e.SpeakerRecognitionResult = i;
    class a extends r.CancellationDetailsBase {
      constructor(n, c, u) {
        super(n, c, u);
      }
      /**
       * Creates an instance of SpeakerRecognitionCancellationDetails object for the canceled SpeakerRecognitionResult
       * @member SpeakerRecognitionCancellationDetails.fromResult
       * @function
       * @public
       * @param {SpeakerRecognitionResult} result - The result that was canceled.
       * @returns {SpeakerRecognitionCancellationDetails} The cancellation details object being created.
       */
      static fromResult(n) {
        const c = r.CancellationReason.Error;
        let u = r.CancellationErrorCode.NoError;
        return n.properties && (u = r.CancellationErrorCode[n.properties.getProperty(t.CancellationErrorCodePropertyName, r.CancellationErrorCode[r.CancellationErrorCode.NoError])]), new a(c, n.errorDetails, u);
      }
    }
    e.SpeakerRecognitionCancellationDetails = a;
  }(Go)), Go;
}
var Qo = {}, St = {}, hp;
function kv() {
  if (hp) return St;
  hp = 1, Object.defineProperty(St, "__esModule", { value: !0 }), St.ConversationImpl = St.Conversation = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class {
    constructor() {
    }
    /**
     * Create a conversation
     * @param speechConfig
     * @param cb
     * @param err
     */
    static createConversationAsync(n, c, u, l) {
      r.Contracts.throwIfNullOrUndefined(n, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), r.Contracts.throwIfNullOrUndefined(n.region, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), !n.subscriptionKey && !n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceAuthorization_Token]) && r.Contracts.throwIfNullOrUndefined(n.subscriptionKey, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      let p, h, d;
      return typeof c == "string" ? (p = new a(n, c), (0, t.marshalPromiseToCallbacks)((async () => {
      })(), u, l)) : (p = new a(n), h = c, d = u, p.createConversationAsync(() => {
        h && h();
      }, (f) => {
        d && d(f);
      })), p;
    }
  };
  St.Conversation = i;
  class a extends i {
    /**
     * Create a conversation impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(n, c) {
      if (super(), this.privErrors = e.ConversationConnectionConfig.restErrors, this.onConnected = (p) => {
        this.privIsConnected = !0;
        try {
          this.privConversationTranslator?.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, p);
        } catch {
        }
      }, this.onDisconnected = (p) => {
        try {
          this.privConversationTranslator?.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, p);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (p, h) => {
        try {
          this.privConversationTranslator?.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, h);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.getParticipant(h.id);
          if (d !== void 0) {
            switch (h.key) {
              case e.ConversationTranslatorCommandTypes.changeNickname:
                d.displayName = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setUseTTS:
                d.isUsingTts = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setProfanityFiltering:
                d.profanity = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setMute:
                d.isMuted = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                d.translateToLanguages = h.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(d), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, [this.toParticipant(d)], h.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (p, h) => {
        try {
          this.privParticipants.participants.forEach((d) => d.isMuted = d.isHost ? !1 : h.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, this.toParticipants(!1), h.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.addOrUpdateParticipant(h.participant);
          d !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, [this.toParticipant(d)], h.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.getParticipant(h.participant.id);
          d !== void 0 && (this.privParticipants.deleteParticipant(h.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.LeftConversation, [this.toParticipant(d)], h.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (p, h) => {
        try {
          switch (h.command) {
            case e.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (p, h) => {
        try {
          if (h.sessionToken !== void 0 && h.sessionToken !== null && (this.privRoom.token = h.sessionToken), this.privParticipants.participants = [...h.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), h.sessionId)), this.me.isHost) {
            const d = this.privConversationTranslator?.properties.getProperty(o.PropertyId.ConversationTranslator_Name);
            d !== void 0 && d.length > 0 && d !== this.me.displayName && this.changeNicknameAsync(d);
          }
        } catch {
        }
      }, this.onConversationExpiration = (p, h) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, h);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new o.PropertyCollection(), this.privManager = new e.ConversationManager(), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]) || n.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage], e.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]), c)
        this.privConversationId = c;
      else {
        n.targetLanguages.length === 0 && n.addTargetLanguage(this.privLanguage), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceResponse_ProfanityOption]) || n.setProfanity(o.ProfanityOption.Masked);
        let h = n.getProperty(o.PropertyId[o.PropertyId.ConversationTranslator_Name]);
        h == null && (h = "Host"), r.Contracts.throwIfNullOrTooLong(h, "nickname", 50), r.Contracts.throwIfNullOrTooShort(h, "nickname", 2), n.setProperty(o.PropertyId[o.PropertyId.ConversationTranslator_Name], h);
      }
      this.privConfig = n;
      const l = n;
      r.Contracts.throwIfNull(l, "speechConfig"), this.privProperties = l.properties.clone(), this.privIsConnected = !1, this.privParticipants = new e.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the conversation Id
    get conversationId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      return this.privParticipants.me?.isHost ? !1 : this.privParticipants.me?.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get conversationInfo() {
      const n = this.conversationId, c = this.participants.map((p) => ({
        id: p.id,
        preferredLanguage: p.preferredLanguage,
        voice: p.voice
      })), u = {};
      for (const p of e.ConversationConnectionConfig.transcriptionEventKeys) {
        const h = this.properties.getProperty(p, "");
        h !== "" && (u[p] = h);
      }
      return { id: n, participants: c, conversationProperties: u };
    }
    get canSend() {
      return this.privIsConnected && !this.privParticipants.me?.isMuted;
    }
    get canSendAsHost() {
      return this.privIsConnected && this.privParticipants.me?.isHost;
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "authorizationToken"), this.privToken = n;
    }
    set conversationTranslator(n) {
      this.privConversationTranslator = n;
    }
    onToken(n) {
      this.privConversationTranslator.onToken(n);
    }
    /**
     * Create a new conversation as Host
     * @param cb
     * @param err
     */
    createConversationAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new conversation as host.
     * @param cb
     * @param err
     */
    startConversationAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer = e.ConversationRecognizerFactory.fromConfig(this, this.privConfig), this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a conversation as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(n, c, u) {
      r.Contracts.throwIfNullOrUndefined(n, "Participant"), (0, t.marshalPromiseToCallbacks)(this.addParticipantImplAsync(n), c, u);
    }
    /**
     * Join a conversation as a participant.
     * @param conversation
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinConversationAsync(n, c, u, l, p) {
      try {
        r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), r.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, n, (h) => {
          r.Contracts.throwIfNullOrUndefined(h, this.privErrors.permissionDeniedConnect), this.privRoom = h, this.privConfig.authorizationToken = h.cognitiveSpeechAuthToken, l && l(h.cognitiveSpeechAuthToken);
        }, (h) => {
          this.handleError(h, p);
        });
      } catch (h) {
        this.handleError(h, p);
      }
    }
    /**
     * Deletes a conversation
     * @param cb
     * @param err
     */
    deleteConversationAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.deleteConversationImplAsync(), n, c);
    }
    async deleteConversationImplAsync() {
      r.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), r.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endConversationAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.endConversationImplAsync(), n, c);
    }
    endConversationImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockConversationAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the conversation
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !0), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(n, c, u) {
      try {
        if (r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && n.hasOwnProperty("id"))
          (0, t.marshalPromiseToCallbacks)(this.removeParticipantImplAsync(n), c, u);
        else {
          r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let l = "";
          typeof n == "string" ? l = n : n.hasOwnProperty("id") ? l = n.id : n.hasOwnProperty("userId") && (l = n.userId), r.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((h) => h.id === l) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(l), () => {
            this.handleCallback(c, u);
          }, (h) => {
            this.handleError(h, u);
          });
        }
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to unlock the conversation
     * @param cb
     * @param err
     */
    unlockConversationAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the conversation
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the conversation
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !1), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "message")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), n.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfArrayEmptyOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "languages")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(n) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await n.enforceAudioGating(), this.privTranscriberRecognizer = n, this.privTranscriberRecognizer.conversation = this;
    }
    getKeepAlive() {
      const n = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: n,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(n) {
      if (this.privParticipants.addOrUpdateParticipant(n) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.conversationInfo;
        return u.participants = [n], this.privTranscriberRecognizer.pushConversationEvent(u, "join");
      }
    }
    removeParticipantImplAsync(n) {
      this.privParticipants.deleteParticipant(n.id);
      const c = this.conversationInfo;
      return c.participants = [n], this.privTranscriberRecognizer.pushConversationEvent(c, "leave");
    }
    async close(n) {
      try {
        this.privIsConnected = !1, await this.privConversationRecognizer?.close(), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (c) {
        throw c;
      }
      n && this.dispose();
    }
    /** Helpers */
    handleCallback(n, c) {
      if (n) {
        try {
          n();
        } catch (u) {
          c && c(u);
        }
        n = void 0;
      }
    }
    handleError(n, c) {
      if (c)
        if (n instanceof Error) {
          const u = n;
          c(u.name + ": " + u.message);
        } else
          c(n);
    }
    /** Participant Helpers */
    toParticipants(n) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return n ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(n) {
      return new o.Participant(n.id, n.avatar, n.displayName, n.isHost, n.isMuted, n.isUsingTts, n.preferredLanguage, n.voice);
    }
    getMuteAllCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMuteCommand(n, c) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getEjectCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getChangeNicknameCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "nickname"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.changeNickname,
        nickname: n,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMessageCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), r.Contracts.throwIfNullOrWhitespace(n, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: n,
        type: e.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return St.ConversationImpl = a, St;
}
var Dn = {}, fp;
function dP() {
  if (fp) return Dn;
  fp = 1, Object.defineProperty(Dn, "__esModule", { value: !0 }), Dn.ConversationCommon = void 0;
  let e = class {
    constructor(r) {
      this.privAudioConfig = r;
    }
    handleCallback(r, o) {
      if (r) {
        try {
          r();
        } catch (i) {
          o && o(i);
        }
        r = void 0;
      }
    }
    handleError(r, o) {
      if (o)
        if (r instanceof Error) {
          const i = r;
          o(i.name + ": " + i.message);
        } else
          o(r);
    }
  };
  return Dn.ConversationCommon = e, Dn;
}
var Nn = {}, vp;
function hP() {
  if (vp) return Nn;
  vp = 1, Object.defineProperty(Nn, "__esModule", { value: !0 }), Nn.ConversationExpirationEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    constructor(o, i) {
      super(i), this.privExpirationTime = o;
    }
    /** How much longer until the conversation expires (in minutes). */
    get expirationTime() {
      return this.privExpirationTime;
    }
  };
  return Nn.ConversationExpirationEventArgs = t, Nn;
}
var xn = {}, gp;
function fP() {
  if (gp) return xn;
  gp = 1, Object.defineProperty(xn, "__esModule", { value: !0 }), xn.ConversationParticipantsChangedEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SessionEventArgs {
    constructor(o, i, a) {
      super(a), this.privReason = o, this.privParticipant = i;
    }
    get reason() {
      return this.privReason;
    }
    get participants() {
      return this.privParticipant;
    }
  };
  return xn.ConversationParticipantsChangedEventArgs = t, xn;
}
var zn = {}, mp;
function vP() {
  if (mp) return zn;
  mp = 1, Object.defineProperty(zn, "__esModule", { value: !0 }), zn.ConversationTranslationCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Cs();
  let t = class extends e.CancellationEventArgsBase {
  };
  return zn.ConversationTranslationCanceledEventArgs = t, zn;
}
var Ln = {}, yp;
function gP() {
  if (yp) return Ln;
  yp = 1, Object.defineProperty(Ln, "__esModule", { value: !0 }), Ln.ConversationTranslationEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionEventArgs {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {ConversationTranslationResult} result - The translation recognition result.
     * @param {number} offset - The offset.
     * @param {string} sessionId - The session id.
     */
    constructor(o, i, a) {
      super(i, a), this.privResult = o;
    }
    /**
     * Specifies the recognition result.
     * @returns {ConversationTranslationResult} the recognition result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Ln.ConversationTranslationEventArgs = t, Ln;
}
var jn = {}, Sp;
function mP() {
  if (Sp) return jn;
  Sp = 1, Object.defineProperty(jn, "__esModule", { value: !0 }), jn.ConversationTranslationResult = void 0;
  const e = /* @__PURE__ */ fv();
  let t = class extends e.TranslationRecognitionResult {
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(i, s, n, c, u, l, void 0, void 0, p, h, d), this.privId = o, this.privOrigLang = a;
    }
    /**
     * The unique identifier for the participant this result is for.
     */
    get participantId() {
      return this.privId;
    }
    /**
     * The original language this result was in.
     */
    get originalLang() {
      return this.privOrigLang;
    }
  };
  return jn.ConversationTranslationResult = t, jn;
}
var Yo = {}, qn = {}, Fn = {}, Cp;
function Ov() {
  if (Cp) return Fn;
  Cp = 1, Object.defineProperty(Fn, "__esModule", { value: !0 }), Fn.StringUtils = void 0;
  let e = class {
    /**
     * Formats a string by replacing the named {keys} in the string with the values contained in the replacement dictionary.
     * @param format The format string that contains the parts to replace surrounded by {}. For example: "wss://{region}.cts.speech.microsoft.com".
     * If your string needs to contain a { or } you can use the {{ and }} escape sequences respectively.
     * @param replacements The dictionary of replacements. If a replacement is not found, it is replaced with an empty string
     * @returns The formatted string. If you pass in a null or undefined format string, an empty string will be returned
     */
    static formatString(r, o) {
      if (!r)
        return "";
      if (!o)
        return r;
      let i = "", a = "";
      const s = (u) => {
        i += u;
      }, n = (u) => {
        a += u;
      };
      let c = s;
      for (let u = 0; u < r.length; u++) {
        const l = r[u], p = u + 1 < r.length ? r[u + 1] : "";
        switch (l) {
          case "{":
            p === "{" ? (c("{"), u++) : c = n;
            break;
          case "}":
            p === "}" ? (c("}"), u++) : (o.hasOwnProperty(a) && (i += o[a]), c = s, a = "");
            break;
          default:
            c(l);
            break;
        }
      }
      return i;
    }
  };
  return Fn.StringUtils = e, Fn;
}
var Rp;
function yP() {
  if (Rp) return qn;
  Rp = 1, Object.defineProperty(qn, "__esModule", { value: !0 }), qn.ConversationTranslatorConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ Ov(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ le(), a = /* @__PURE__ */ et(), s = /* @__PURE__ */ ke(), n = /* @__PURE__ */ _();
  let c = class Mv extends s.ConnectionFactoryBase {
    constructor(l) {
      super(), r.Contracts.throwIfNullOrUndefined(l, "convGetter"), this.privConvGetter = l;
    }
    create(l, p, h) {
      const d = l.parameters.getProperty("ConversationTranslator_MultiChannelAudio", "").toUpperCase() === "TRUE", f = this.privConvGetter().room, g = f.cognitiveSpeechRegion || l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Region, ""), m = {
        hostSuffix: s.ConnectionFactoryBase.getHostSuffix(g),
        path: Mv.CTS_VIRT_MIC_PATH,
        region: encodeURIComponent(g)
      };
      m[a.QueryParameterNames.Language] = encodeURIComponent(l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_RecoLanguage, "")), m[a.QueryParameterNames.CtsMeetingId] = encodeURIComponent(f.roomId), m[a.QueryParameterNames.CtsDeviceId] = encodeURIComponent(f.participantId), m[a.QueryParameterNames.CtsIsParticipant] = f.isHost ? "" : "&" + a.QueryParameterNames.CtsIsParticipant;
      let v = "";
      const y = {}, S = {};
      if (d) {
        v = l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Endpoint), v || (v = "wss://" + l.parameters.getProperty(o.PropertyId.SpeechServiceConnection_Host, "transcribe.{region}.cts.speech{hostSuffix}") + "{path}"), v = t.StringUtils.formatString(v, m);
        const w = new URL(v);
        w.searchParams.forEach((A, E) => {
          y[E] = A;
        }), new n.TranscriberConnectionFactory().setQueryParams(y, l, v), y[a.QueryParameterNames.CtsMeetingId] = m[a.QueryParameterNames.CtsMeetingId], y[a.QueryParameterNames.CtsDeviceId] = m[a.QueryParameterNames.CtsDeviceId], f.isHost || (y[a.QueryParameterNames.CtsIsParticipant] = ""), a.QueryParameterNames.Format in y || (y[a.QueryParameterNames.Format] = "simple"), w.searchParams.forEach((A, E) => {
          w.searchParams.set(E, y[E]), delete y[E];
        }), v = w.toString();
      } else {
        const w = new n.TranslationConnectionFactory();
        v = w.getEndpointUrl(l, !0), v = t.StringUtils.formatString(v, m), w.setQueryParams(y, l, v);
      }
      S[i.HeaderNames.ConnectionId] = h, S[e.RestConfigBase.configParams.token] = f.token, p.token && (S[p.headerName] = p.token);
      const C = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "").toUpperCase() === "TRUE";
      return Promise.resolve(new e.WebsocketConnection(v, y, S, new n.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), C, h));
    }
  };
  return qn.ConversationTranslatorConnectionFactory = c, c.CTS_VIRT_MIC_PATH = "/speech/recognition/dynamicaudio", qn;
}
var Pp;
function SP() {
  return Pp || (Pp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConversationTranslator = e.SpeechState = void 0;
    const t = /* @__PURE__ */ _(), r = /* @__PURE__ */ yP(), o = /* @__PURE__ */ k(), i = /* @__PURE__ */ z(), a = /* @__PURE__ */ I(), s = /* @__PURE__ */ kv(), n = /* @__PURE__ */ lc();
    var c;
    (function(p) {
      p[p.Inactive = 0] = "Inactive", p[p.Connecting = 1] = "Connecting", p[p.Connected = 2] = "Connected";
    })(c = e.SpeechState || (e.SpeechState = {}));
    class u extends a.TranslationRecognizer {
      constructor(h, d, f, g) {
        super(h, d, new r.ConversationTranslatorConnectionFactory(g)), this.privSpeechState = c.Inactive, f && (this.privTranslator = f, this.sessionStarted = () => {
          this.privSpeechState = c.Connected;
        }, this.sessionStopped = () => {
          this.privSpeechState = c.Inactive;
        }, this.recognizing = (m, v) => {
          this.privTranslator.recognizing && this.privTranslator.recognizing(this.privTranslator, v);
        }, this.recognized = async (m, v) => {
          v.result?.errorDetails ? (await this.cancelSpeech(), this.fireCancelEvent(v.result.errorDetails)) : this.privTranslator.recognized && this.privTranslator.recognized(this.privTranslator, v);
        }, this.canceled = async () => {
          if (this.privSpeechState !== c.Inactive)
            try {
              await this.cancelSpeech();
            } catch {
              this.privSpeechState = c.Inactive;
            }
        });
      }
      get state() {
        return this.privSpeechState;
      }
      set state(h) {
        this.privSpeechState = h;
      }
      set authentication(h) {
        this.privReco.authentication = h;
      }
      onConnection() {
        this.privSpeechState = c.Connected;
      }
      async onCancelSpeech() {
        this.privSpeechState = c.Inactive, await this.cancelSpeech();
      }
      /**
       * Fire a cancel event
       * @param error
       */
      fireCancelEvent(h) {
        try {
          if (this.privTranslator.canceled) {
            const d = new n.ConversationTranslationCanceledEventArgs(a.CancellationReason.Error, h, a.CancellationErrorCode.RuntimeError);
            this.privTranslator.canceled(this.privTranslator, d);
          }
        } catch {
        }
      }
      async cancelSpeech() {
        try {
          this.stopContinuousRecognitionAsync(), await this.privReco?.disconnect(), this.privSpeechState = c.Inactive;
        } catch {
        }
      }
    }
    class l extends n.ConversationCommon {
      constructor(h) {
        super(h), this.privErrors = t.ConversationConnectionConfig.restErrors, this.privIsDisposed = !1, this.privIsSpeaking = !1, this.privPlaceholderKey = "abcdefghijklmnopqrstuvwxyz012345", this.privPlaceholderRegion = "westus", this.privProperties = new a.PropertyCollection();
      }
      get properties() {
        return this.privProperties;
      }
      get speechRecognitionLanguage() {
        return this.privSpeechRecognitionLanguage;
      }
      get participants() {
        return this.privConversation?.participants;
      }
      get canSpeak() {
        return !(!this.privConversation.isConnected || !this.privCTRecognizer || this.privIsSpeaking || this.privCTRecognizer.state === c.Connected || this.privCTRecognizer.state === c.Connecting || this.privConversation.isMutedByHost);
      }
      onToken(h) {
        this.privCTRecognizer.authentication = h;
      }
      setServiceProperty(h, d) {
        const f = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
        f[h] = d, this.privProperties.setProperty(t.ServicePropertiesPropertyName, JSON.stringify(f));
      }
      joinConversationAsync(h, d, f, g, m) {
        try {
          if (typeof h == "string") {
            i.Contracts.throwIfNullOrUndefined(h, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), i.Contracts.throwIfNullOrWhitespace(d, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privConversation && this.handleError(new Error(this.privErrors.permissionDeniedStart), m);
            let v = f;
            (v == null || v === "") && (v = t.ConversationConnectionConfig.defaultLanguageCode), this.privSpeechTranslationConfig = a.SpeechTranslationConfig.fromSubscription(this.privPlaceholderKey, this.privPlaceholderRegion), this.privSpeechTranslationConfig.setProfanity(a.ProfanityOption.Masked), this.privSpeechTranslationConfig.addTargetLanguage(v), this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_RecoLanguage], v), this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.ConversationTranslator_Name], d);
            const y = [
              a.PropertyId.SpeechServiceConnection_Host,
              a.PropertyId.ConversationTranslator_Host,
              a.PropertyId.SpeechServiceConnection_Endpoint,
              a.PropertyId.SpeechServiceConnection_ProxyHostName,
              a.PropertyId.SpeechServiceConnection_ProxyPassword,
              a.PropertyId.SpeechServiceConnection_ProxyPort,
              a.PropertyId.SpeechServiceConnection_ProxyUserName,
              "ConversationTranslator_MultiChannelAudio",
              "ConversationTranslator_Region"
            ];
            for (const C of y) {
              const w = this.privProperties.getProperty(C);
              if (w) {
                const b = typeof C == "string" ? C : a.PropertyId[C];
                this.privSpeechTranslationConfig.setProperty(b, w);
              }
            }
            const S = JSON.parse(this.privProperties.getProperty(t.ServicePropertiesPropertyName, "{}"));
            for (const C of Object.keys(S))
              this.privSpeechTranslationConfig.setServiceProperty(C, S[C], a.ServicePropertyChannel.UriQueryParameter);
            this.privConversation = new s.ConversationImpl(this.privSpeechTranslationConfig), this.privConversation.conversationTranslator = this, this.privConversation.joinConversationAsync(h, d, v, (C) => {
              C || this.handleError(new Error(this.privErrors.permissionDeniedConnect), m), this.privSpeechTranslationConfig.authorizationToken = C, this.privConversation.room.isHost = !1, this.privConversation.startConversationAsync(() => {
                this.handleCallback(g, m);
              }, (w) => {
                this.handleError(w, m);
              });
            }, (C) => {
              this.handleError(C, m);
            });
          } else typeof h == "object" ? (i.Contracts.throwIfNullOrUndefined(h, this.privErrors.invalidArgs.replace("{arg}", "conversation id")), i.Contracts.throwIfNullOrWhitespace(d, this.privErrors.invalidArgs.replace("{arg}", "nickname")), this.privProperties.setProperty(a.PropertyId.ConversationTranslator_Name, d), this.privConversation = h, this.privConversation.conversationTranslator = this, this.privConversation.room.isHost = !0, i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedConnect), i.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privSpeechTranslationConfig = h.config, this.handleCallback(f, g)) : this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "invalid conversation type")), g);
        } catch (v) {
          this.handleError(v, typeof f == "string" ? m : g);
        }
      }
      /**
       * Leave the conversation
       * @param cb
       * @param err
       */
      leaveConversationAsync(h, d) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          await this.cancelSpeech(), await this.privConversation.endConversationImplAsync(), await this.privConversation.deleteConversationImplAsync(), this.dispose();
        })(), h, d);
      }
      /**
       * Send a text message
       * @param message
       * @param cb
       * @param err
       */
      sendTextMessageAsync(h, d, f) {
        try {
          i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), i.Contracts.throwIfNullOrWhitespace(h, this.privErrors.invalidArgs.replace("{arg}", h)), this.privConversation.sendTextMessageAsync(h, d, f);
        } catch (g) {
          this.handleError(g, f);
        }
      }
      /**
       * Start speaking
       * @param cb
       * @param err
       */
      startTranscribingAsync(h, d) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          try {
            i.Contracts.throwIfNullOrUndefined(this.privConversation, this.privErrors.permissionDeniedSend), i.Contracts.throwIfNullOrUndefined(this.privConversation.room.token, this.privErrors.permissionDeniedConnect), this.privCTRecognizer === void 0 && await this.connectTranslatorRecognizer(), i.Contracts.throwIfNullOrUndefined(this.privCTRecognizer, this.privErrors.permissionDeniedSend), this.canSpeak || this.handleError(new Error(this.privErrors.permissionDeniedSend), d), await this.startContinuousRecognition(), this.privIsSpeaking = !0;
          } catch (f) {
            throw this.privIsSpeaking = !1, await this.cancelSpeech(), f;
          }
        })(), h, d);
      }
      /**
       * Stop speaking
       * @param cb
       * @param err
       */
      stopTranscribingAsync(h, d) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          try {
            if (!this.privIsSpeaking) {
              await this.cancelSpeech();
              return;
            }
            this.privIsSpeaking = !1, await new Promise((f, g) => {
              this.privCTRecognizer.stopContinuousRecognitionAsync(f, g);
            });
          } catch {
            await this.cancelSpeech();
          }
        })(), h, d);
      }
      isDisposed() {
        return this.privIsDisposed;
      }
      dispose(h, d, f) {
        (0, o.marshalPromiseToCallbacks)((async () => {
          this.isDisposed && !this.privIsSpeaking || (await this.cancelSpeech(), this.privIsDisposed = !0, this.privSpeechTranslationConfig.close(), this.privSpeechRecognitionLanguage = void 0, this.privProperties = void 0, this.privAudioConfig = void 0, this.privSpeechTranslationConfig = void 0, this.privConversation.dispose(), this.privConversation = void 0);
        })(), d, f);
      }
      /**
       * Cancel the speech websocket
       */
      async cancelSpeech() {
        try {
          this.privIsSpeaking = !1, await this.privCTRecognizer?.onCancelSpeech(), this.privCTRecognizer = void 0;
        } catch {
        }
      }
      /**
       * Connect to the speech translation recognizer.
       * Currently there is no language validation performed before sending the SpeechLanguage code to the service.
       * If it's an invalid language the raw error will be: 'Error during WebSocket handshake: Unexpected response code: 400'
       * e.g. pass in 'fr' instead of 'fr-FR', or a text-only language 'cy'
       */
      async connectTranslatorRecognizer() {
        try {
          this.privAudioConfig === void 0 && (this.privAudioConfig = a.AudioConfig.fromDefaultMicrophoneInput()), this.privSpeechTranslationConfig.getProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_Key]) === this.privPlaceholderKey && this.privSpeechTranslationConfig.setProperty(a.PropertyId[a.PropertyId.SpeechServiceConnection_Key], "");
          const h = () => this.privConversation;
          this.privCTRecognizer = new u(this.privSpeechTranslationConfig, this.privAudioConfig, this, h);
        } catch (h) {
          throw await this.cancelSpeech(), h;
        }
      }
      /**
       * Handle the start speaking request
       */
      startContinuousRecognition() {
        return new Promise((h, d) => {
          this.privCTRecognizer.startContinuousRecognitionAsync(h, d);
        });
      }
    }
    e.ConversationTranslator = l;
  }(Yo)), Yo;
}
var Bn = {}, wp;
function CP() {
  if (wp) return Bn;
  wp = 1, Object.defineProperty(Bn, "__esModule", { value: !0 }), Bn.ConversationTranscriber = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ Re(), r = /* @__PURE__ */ k(), o = /* @__PURE__ */ z(), i = /* @__PURE__ */ I();
  let a = class Dv extends i.Recognizer {
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      o.Contracts.throwIfNull(u, "speechConfig"), o.Contracts.throwIfNullOrWhitespace(u.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage), i.PropertyId[i.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new e.ConversationTranscriberConnectionFactory(), n.tokenCredential), this.privProperties.setProperty(i.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2"), this.privDisposedRecognizer = !1;
    }
    /**
     * ConversationTranscriber constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this recognizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    static FromConfig(n, c, u) {
      const l = n;
      return c.properties.mergeTo(l.properties), new Dv(n, u);
    }
    /**
     * Gets the endpoint id of a customized speech model that is used for transcription.
     * @member ConversationTranscriber.prototype.endpointId
     * @function
     * @public
     * @returns {string} the endpoint id of a customized speech model that is used for speech recognition.
     */
    get endpointId() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_EndpointId, "00000000-0000-0000-0000-000000000000");
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(i.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member ConversationTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      o.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(i.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * Gets the spoken language of transcription.
     * @member ConversationTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of transcription.
     */
    get speechRecognitionLanguage() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * Gets the output format of transcription.
     * @member ConversationTranscriber.prototype.outputFormat
     * @function
     * @public
     * @returns {OutputFormat} The output format of transcription.
     */
    get outputFormat() {
      return o.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(e.OutputFormatPropertyName, i.OutputFormat[i.OutputFormat.Simple]) === i.OutputFormat[i.OutputFormat.Simple] ? i.OutputFormat.Simple : i.OutputFormat.Detailed;
    }
    /**
     * The collection of properties and their values defined for this conversation transcriber.
     * @member ConversationTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechRecognizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Starts conversation transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member ConversationTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(t.RecognitionMode.Conversation), n, c);
    }
    /**
     * Stops conversation transcription.
     * @member ConversationTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has stopped.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(n, c) {
      (0, r.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member ConversationTranscriber.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      o.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, r.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member SpeechRecognizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new e.RecognizerConfig(n, this.privProperties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return l.isSpeakerDiarizationEnabled = !0, new e.ConversationTranscriptionServiceRecognizer(n, c, p, l, this);
    }
  };
  return Bn.ConversationTranscriber = a, Bn;
}
var Ct = {}, bp;
function RP() {
  if (bp) return Ct;
  bp = 1, Object.defineProperty(Ct, "__esModule", { value: !0 }), Ct.Participant = Ct.User = void 0;
  const e = /* @__PURE__ */ I();
  class t {
    constructor(i) {
      this.privUserId = i;
    }
    get userId() {
      return this.privUserId;
    }
  }
  Ct.User = t;
  class r {
    constructor(i, a, s, n, c, u, l, p) {
      this.privId = i, this.privAvatar = a, this.privDisplayName = s, this.privIsHost = n, this.privIsMuted = c, this.privIsUsingTts = u, this.privPreferredLanguage = l, this.privVoice = p, this.privProperties = new e.PropertyCollection();
    }
    get avatar() {
      return this.privAvatar;
    }
    get displayName() {
      return this.privDisplayName;
    }
    get id() {
      return this.privId;
    }
    get preferredLanguage() {
      return this.privPreferredLanguage;
    }
    get isHost() {
      return this.privIsHost;
    }
    get isMuted() {
      return this.privIsMuted;
    }
    get isUsingTts() {
      return this.privIsUsingTts;
    }
    get voice() {
      return this.privVoice;
    }
    get properties() {
      return this.privProperties;
    }
    static From(i, a, s) {
      return new r(i, "", i, !1, !1, !1, a, s);
    }
  }
  return Ct.Participant = r, Ct;
}
var Zo = {}, Ep;
function PP() {
  return Ep || (Ep = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ParticipantChangedReason = void 0, function(t) {
      t[t.JoinedConversation = 0] = "JoinedConversation", t[t.LeftConversation = 1] = "LeftConversation", t[t.Updated = 2] = "Updated";
    }(e.ParticipantChangedReason || (e.ParticipantChangedReason = {}));
  }(Zo)), Zo;
}
var Rt = {}, Ip;
function wP() {
  if (Ip) return Rt;
  Ip = 1, Object.defineProperty(Rt, "__esModule", { value: !0 }), Rt.MeetingImpl = Rt.Meeting = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class {
    constructor() {
    }
    /**
     * Create a meeting
     * @param speechConfig
     * @param meetingId
     * @param cb
     * @param err
     */
    static createMeetingAsync(n, c, u, l) {
      if (r.Contracts.throwIfNullOrUndefined(n, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "config")), r.Contracts.throwIfNullOrUndefined(n.region, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Region")), r.Contracts.throwIfNull(c, "meetingId"), c.length === 0)
        throw new Error("meetingId cannot be empty");
      !n.subscriptionKey && !n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceAuthorization_Token]) && r.Contracts.throwIfNullOrUndefined(n.subscriptionKey, e.ConversationConnectionConfig.restErrors.invalidArgs.replace("{arg}", "SpeechServiceConnection_Key"));
      const p = new a(n, c);
      return (0, t.marshalPromiseToCallbacks)((async () => {
      })(), u, l), p;
    }
  };
  Rt.Meeting = i;
  class a extends i {
    /**
     * Create a Meeting impl
     * @param speechConfig
     * @param {string} id - optional conversationId
     */
    constructor(n, c) {
      super(), this.privErrors = e.ConversationConnectionConfig.restErrors, this.onConnected = (p) => {
        this.privIsConnected = !0;
        try {
          this.privConversationTranslator?.sessionStarted && this.privConversationTranslator.sessionStarted(this.privConversationTranslator, p);
        } catch {
        }
      }, this.onDisconnected = (p) => {
        try {
          this.privConversationTranslator?.sessionStopped && this.privConversationTranslator.sessionStopped(this.privConversationTranslator, p);
        } catch {
        } finally {
          this.close(!1);
        }
      }, this.onCanceled = (p, h) => {
        try {
          this.privConversationTranslator?.canceled && this.privConversationTranslator.canceled(this.privConversationTranslator, h);
        } catch {
        }
      }, this.onParticipantUpdateCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.getParticipant(h.id);
          if (d !== void 0) {
            switch (h.key) {
              case e.ConversationTranslatorCommandTypes.changeNickname:
                d.displayName = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setUseTTS:
                d.isUsingTts = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setProfanityFiltering:
                d.profanity = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setMute:
                d.isMuted = h.value;
                break;
              case e.ConversationTranslatorCommandTypes.setTranslateToLanguages:
                d.translateToLanguages = h.value;
                break;
            }
            this.privParticipants.addOrUpdateParticipant(d), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, [this.toParticipant(d)], h.sessionId));
          }
        } catch {
        }
      }, this.onLockRoomCommandReceived = () => {
      }, this.onMuteAllCommandReceived = (p, h) => {
        try {
          this.privParticipants.participants.forEach((d) => d.isMuted = d.isHost ? !1 : h.isMuted), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.Updated, this.toParticipants(!1), h.sessionId));
        } catch {
        }
      }, this.onParticipantJoinCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.addOrUpdateParticipant(h.participant);
          d !== void 0 && this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, [this.toParticipant(d)], h.sessionId));
        } catch {
        }
      }, this.onParticipantLeaveCommandReceived = (p, h) => {
        try {
          const d = this.privParticipants.getParticipant(h.participant.id);
          d !== void 0 && (this.privParticipants.deleteParticipant(h.participant.id), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.LeftConversation, [this.toParticipant(d)], h.sessionId)));
        } catch {
        }
      }, this.onTranslationReceived = (p, h) => {
        try {
          switch (h.command) {
            case e.ConversationTranslatorMessageTypes.final:
              this.privConversationTranslator && this.privConversationTranslator.transcribed(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.partial:
              this.privConversationTranslator && this.privConversationTranslator.transcribing(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
            case e.ConversationTranslatorMessageTypes.instantMessage:
              this.privConversationTranslator && this.privConversationTranslator.textMessageReceived(this.privConversationTranslator, new o.ConversationTranslationEventArgs(h.payload, void 0, h.sessionId));
              break;
          }
        } catch {
        }
      }, this.onParticipantsListReceived = (p, h) => {
        try {
          if (h.sessionToken !== void 0 && h.sessionToken !== null && (this.privRoom.token = h.sessionToken), this.privParticipants.participants = [...h.participants], this.privParticipants.me !== void 0 && (this.privIsReady = !0), this.privConversationTranslator && this.privConversationTranslator.participantsChanged(this.privConversationTranslator, new o.ConversationParticipantsChangedEventArgs(o.ParticipantChangedReason.JoinedConversation, this.toParticipants(!0), h.sessionId)), this.me.isHost) {
            const d = this.privConversationTranslator?.properties.getProperty(o.PropertyId.ConversationTranslator_Name);
            d !== void 0 && d.length > 0 && d !== this.me.displayName && this.changeNicknameAsync(d);
          }
        } catch {
        }
      }, this.onConversationExpiration = (p, h) => {
        try {
          this.privConversationTranslator && this.privConversationTranslator.conversationExpiration(this.privConversationTranslator, h);
        } catch {
        }
      }, this.privIsConnected = !1, this.privIsDisposed = !1, this.privConversationId = "", this.privProperties = new o.PropertyCollection(), this.privManager = new e.ConversationManager(), n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]) || n.setProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage], e.ConversationConnectionConfig.defaultLanguageCode), this.privLanguage = n.getProperty(o.PropertyId[o.PropertyId.SpeechServiceConnection_RecoLanguage]), this.privConversationId = c, this.privConfig = n;
      const l = n;
      r.Contracts.throwIfNull(l, "speechConfig"), this.privProperties = l.properties.clone(), this.privIsConnected = !1, this.privParticipants = new e.InternalParticipants(), this.privIsReady = !1, this.privTextMessageMaxLength = 1e3;
    }
    // get the internal data about a conversation
    get room() {
      return this.privRoom;
    }
    // get the wrapper for connecting to the websockets
    get connection() {
      return this.privConversationRecognizer;
    }
    // get the config
    get config() {
      return this.privConfig;
    }
    // get the meeting Id
    get meetingId() {
      return this.privRoom ? this.privRoom.roomId : this.privConversationId;
    }
    // get the properties
    get properties() {
      return this.privProperties;
    }
    // get the speech language
    get speechRecognitionLanguage() {
      return this.privLanguage;
    }
    get isMutedByHost() {
      return this.privParticipants.me?.isHost ? !1 : this.privParticipants.me?.isMuted;
    }
    get isConnected() {
      return this.privIsConnected && this.privIsReady;
    }
    get participants() {
      return this.toParticipants(!0);
    }
    get me() {
      return this.toParticipant(this.privParticipants.me);
    }
    get host() {
      return this.toParticipant(this.privParticipants.host);
    }
    get transcriberRecognizer() {
      return this.privTranscriberRecognizer;
    }
    get meetingInfo() {
      const n = this.meetingId, c = this.participants.map((p) => ({
        id: p.id,
        preferredLanguage: p.preferredLanguage,
        voice: p.voice
      })), u = {};
      for (const p of e.ConversationConnectionConfig.transcriptionEventKeys) {
        const h = this.properties.getProperty(p, "");
        h !== "" && (u[p] = h);
      }
      return { id: n, participants: c, meetingProperties: u };
    }
    get canSend() {
      return this.privIsConnected && !this.privParticipants.me?.isMuted;
    }
    get canSendAsHost() {
      return this.privIsConnected && this.privParticipants.me?.isHost;
    }
    // get / set the speech auth token
    // eslint-disable-next-line @typescript-eslint/member-ordering
    get authorizationToken() {
      return this.privToken;
    }
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "authorizationToken"), this.privToken = n;
    }
    /**
     * Create a new meeting as Host
     * @param cb
     * @param err
     */
    createMeetingAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), this.privManager.createOrJoin(this.privProperties, void 0, (u) => {
          u || this.handleError(new Error(this.privErrors.permissionDeniedConnect), c), this.privRoom = u, this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Starts a new meeting as host.
     * @param cb
     * @param err
     */
    startMeetingAsync(n, c) {
      try {
        this.privConversationRecognizer && this.handleError(new Error(this.privErrors.permissionDeniedStart), c), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedConnect), this.privParticipants.meId = this.privRoom.participantId, this.privConversationRecognizer.connected = this.onConnected, this.privConversationRecognizer.disconnected = this.onDisconnected, this.privConversationRecognizer.canceled = this.onCanceled, this.privConversationRecognizer.participantUpdateCommandReceived = this.onParticipantUpdateCommandReceived, this.privConversationRecognizer.lockRoomCommandReceived = this.onLockRoomCommandReceived, this.privConversationRecognizer.muteAllCommandReceived = this.onMuteAllCommandReceived, this.privConversationRecognizer.participantJoinCommandReceived = this.onParticipantJoinCommandReceived, this.privConversationRecognizer.participantLeaveCommandReceived = this.onParticipantLeaveCommandReceived, this.privConversationRecognizer.translationReceived = this.onTranslationReceived, this.privConversationRecognizer.participantsListReceived = this.onParticipantsListReceived, this.privConversationRecognizer.conversationExpiration = this.onConversationExpiration, this.privConversationRecognizer.connect(this.privRoom.token, () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Join a meeting as a participant.
     * @param { IParticipant } participant - participant to add
     * @param cb
     * @param err
     */
    addParticipantAsync(n, c, u) {
      r.Contracts.throwIfNullOrUndefined(n, "Participant"), (0, t.marshalPromiseToCallbacks)(this.addParticipantImplAsync(n), c, u);
    }
    /**
     * Join a meeting as a participant.
     * @param meeting
     * @param nickname
     * @param lang
     * @param cb
     * @param err
     */
    joinMeetingAsync(n, c, u, l, p) {
      try {
        r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "conversationId")), r.Contracts.throwIfNullOrWhitespace(c, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrWhitespace(u, this.privErrors.invalidArgs.replace("{arg}", "language")), this.privManager.createOrJoin(this.privProperties, n, (h) => {
          r.Contracts.throwIfNullOrUndefined(h, this.privErrors.permissionDeniedConnect), this.privRoom = h, this.privConfig.authorizationToken = h.cognitiveSpeechAuthToken, l && l(h.cognitiveSpeechAuthToken);
        }, (h) => {
          this.handleError(h, p);
        });
      } catch (h) {
        this.handleError(h, p);
      }
    }
    /**
     * Deletes a meeting
     * @param cb
     * @param err
     */
    deleteMeetingAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.deleteMeetingImplAsync(), n, c);
    }
    async deleteMeetingImplAsync() {
      r.Contracts.throwIfNullOrUndefined(this.privProperties, this.privErrors.permissionDeniedConnect), r.Contracts.throwIfNullOrWhitespace(this.privRoom.token, this.privErrors.permissionDeniedConnect), await this.privManager.leave(this.privProperties, this.privRoom.token), this.dispose();
    }
    /**
     * Issues a request to close the client websockets
     * @param cb
     * @param err
     */
    endMeetingAsync(n, c) {
      (0, t.marshalPromiseToCallbacks)(this.endMeetingImplAsync(), n, c);
    }
    endMeetingImplAsync() {
      return this.close(!0);
    }
    /**
     * Issues a request to lock the conversation
     * @param cb
     * @param err
     */
    lockMeetingAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "lock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute the meeting
     * @param cb
     * @param err
     */
    muteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privConversationRecognizer, this.privErrors.permissionDeniedSend), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "mute")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!0), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to mute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    muteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !0), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to remove a participant from the conversation
     * @param userId
     * @param cb
     * @param err
     */
    removeParticipantAsync(n, c, u) {
      try {
        if (r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTranscriberRecognizer && n.hasOwnProperty("id"))
          (0, t.marshalPromiseToCallbacks)(this.removeParticipantImplAsync(n), c, u);
        else {
          r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "remove")), u);
          let l = "";
          typeof n == "string" ? l = n : n.hasOwnProperty("id") ? l = n.id : n.hasOwnProperty("userId") && (l = n.userId), r.Contracts.throwIfNullOrWhitespace(l, this.privErrors.invalidArgs.replace("{arg}", "userId")), this.participants.findIndex((h) => h.id === l) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getEjectCommand(l), () => {
            this.handleCallback(c, u);
          }, (h) => {
            this.handleError(h, u);
          });
        }
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Issues a request to unlock the meeting
     * @param cb
     * @param err
     */
    unlockMeetingAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unlock")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getLockCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute all participants in the meeting
     * @param cb
     * @param err
     */
    unmuteAllParticipantsAsync(n, c) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSendAsHost || this.handleError(new Error(this.privErrors.permissionDeniedConversation.replace("{command}", "unmute all")), c), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteAllCommand(!1), () => {
          this.handleCallback(n, c);
        }, (u) => {
          this.handleError(u, c);
        });
      } catch (u) {
        this.handleError(u, c);
      }
    }
    /**
     * Issues a request to unmute a participant in the meeting
     * @param userId
     * @param cb
     * @param err
     */
    unmuteParticipantAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "userId")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), !this.me.isHost && this.me.id !== n && this.handleError(new Error(this.privErrors.permissionDeniedParticipant.replace("{command}", "mute")), u), this.privParticipants.getParticipantIndex(n) === -1 && this.handleError(new Error(this.privErrors.invalidParticipantRequest), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMuteCommand(n, !1), () => {
          this.handleCallback(c, u);
        }, (p) => {
          this.handleError(p, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Send a text message
     * @param message
     * @param cb
     * @param err
     */
    sendTextMessageAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "message")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), n.length > this.privTextMessageMaxLength && this.handleError(new Error(this.privErrors.invalidArgs.replace("{arg}", "message length")), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getMessageCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Set translated to languages
     * @param {string[]} languages - languages to translate to
     * @param cb
     * @param err
     */
    setTranslatedLanguagesAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfArrayEmptyOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "languages")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getSetTranslateToLanguagesCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    /**
     * Change nickname
     * @param {string} nickname - new nickname for the room
     * @param cb
     * @param err
     */
    changeNicknameAsync(n, c, u) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfDisposed(this.privConversationRecognizer.isDisposed()), r.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "nickname")), r.Contracts.throwIfNullOrUndefined(this.privRoom, this.privErrors.permissionDeniedSend), this.canSend || this.handleError(new Error(this.privErrors.permissionDeniedSend), u), this.privConversationRecognizer && this.privConversationRecognizer.sendRequest(this.getChangeNicknameCommand(n), () => {
          this.handleCallback(c, u);
        }, (l) => {
          this.handleError(l, u);
        });
      } catch (l) {
        this.handleError(l, u);
      }
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    dispose() {
      this.isDisposed || (this.privIsDisposed = !0, this.config && this.config.close(), this.privConfig = void 0, this.privLanguage = void 0, this.privProperties = void 0, this.privRoom = void 0, this.privToken = void 0, this.privManager = void 0, this.privIsConnected = !1, this.privIsReady = !1, this.privParticipants = void 0);
    }
    async connectTranscriberRecognizer(n) {
      this.privTranscriberRecognizer && await this.privTranscriberRecognizer.close(), await n.enforceAudioGating(), this.privTranscriberRecognizer = n, this.privTranscriberRecognizer.meeting = this;
    }
    getKeepAlive() {
      const n = this.me ? this.me.displayName : "default_nickname";
      return JSON.stringify({
        id: "0",
        nickname: n,
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.keepAlive
      });
    }
    /* eslint-enable @typescript-eslint/typedef */
    addParticipantImplAsync(n) {
      if (this.privParticipants.addOrUpdateParticipant(n) !== void 0 && this.privTranscriberRecognizer) {
        const u = this.meetingInfo;
        return u.participants = [n], this.privTranscriberRecognizer.pushMeetingEvent(u, "join");
      }
    }
    removeParticipantImplAsync(n) {
      this.privParticipants.deleteParticipant(n.id);
      const c = this.meetingInfo;
      return c.participants = [n], this.privTranscriberRecognizer.pushMeetingEvent(c, "leave");
    }
    async close(n) {
      try {
        this.privIsConnected = !1, await this.privConversationRecognizer?.close(), this.privConversationRecognizer = void 0, this.privConversationTranslator && this.privConversationTranslator.dispose();
      } catch (c) {
        throw c;
      }
      n && this.dispose();
    }
    /** Helpers */
    handleCallback(n, c) {
      if (n) {
        try {
          n();
        } catch (u) {
          c && c(u);
        }
        n = void 0;
      }
    }
    handleError(n, c) {
      if (c)
        if (n instanceof Error) {
          const u = n;
          c(u.name + ": " + u.message);
        } else
          c(n);
    }
    /** Participant Helpers */
    toParticipants(n) {
      const c = this.privParticipants.participants.map((u) => this.toParticipant(u));
      return n ? c : c.filter((u) => u.isHost === !1);
    }
    toParticipant(n) {
      return new o.Participant(n.id, n.avatar, n.displayName, n.isHost, n.isMuted, n.isUsingTts, n.preferredLanguage, n.voice);
    }
    getMuteAllCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingd"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMuteAll,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMuteCommand(n, c) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "conversationId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setMute,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: c
      });
    }
    getLockCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setLockState,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getEjectCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(n, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.ejectParticipant,
        // eslint-disable-next-line object-shorthand
        participantId: n,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand
      });
    }
    getSetTranslateToLanguagesCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.setTranslateToLanguages,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getChangeNicknameCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(n, "nickname"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), JSON.stringify({
        command: e.ConversationTranslatorCommandTypes.changeNickname,
        nickname: n,
        participantId: this.privRoom.participantId,
        roomid: this.privRoom.roomId,
        type: e.ConversationTranslatorMessageTypes.participantCommand,
        value: n
      });
    }
    getMessageCommand(n) {
      return r.Contracts.throwIfNullOrWhitespace(this.privRoom.roomId, "meetingId"), r.Contracts.throwIfNullOrWhitespace(this.privRoom.participantId, "participantId"), r.Contracts.throwIfNullOrWhitespace(n, "message"), JSON.stringify({
        participantId: this.privRoom.participantId,
        roomId: this.privRoom.roomId,
        text: n,
        type: e.ConversationTranslatorMessageTypes.instantMessage
      });
    }
  }
  return Rt.MeetingImpl = a, Rt;
}
var Un = {}, Ap;
function bP() {
  if (Ap) return Un;
  Ap = 1, Object.defineProperty(Un, "__esModule", { value: !0 }), Un.MeetingTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Cs();
  class t extends e.CancellationEventArgsBase {
  }
  return Un.MeetingTranscriptionCanceledEventArgs = t, Un;
}
var $n = {}, Tp;
function EP() {
  if (Tp) return $n;
  Tp = 1, Object.defineProperty($n, "__esModule", { value: !0 }), $n.MeetingTranscriber = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ lc();
  let a = class {
    /**
     * MeetingTranscriber constructor.
     * @constructor
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the recognizer
     */
    constructor(n) {
      this.privAudioConfig = n, this.privProperties = new o.PropertyCollection(), this.privRecognizer = void 0, this.privDisposedRecognizer = !1;
    }
    /**
     * Gets the spoken language of recognition.
     * @member MeetingTranscriber.prototype.speechRecognitionLanguage
     * @function
     * @public
     * @returns {string} The spoken language of recognition.
     */
    get speechRecognitionLanguage() {
      return r.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(o.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    /**
     * The collection of properties and their values defined for this MeetingTranscriber.
     * @member MeetingTranscriber.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this MeetingTranscriber.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * @Internal
     * Internal data member to support fromRecognizer* pattern methods on other classes.
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privRecognizer.internalData;
    }
    /**
     * @Deprecated
     * @Obsolete
     * Please use the Connection.fromRecognizer pattern to obtain a connection object
     */
    get connection() {
      return o.Connection.fromRecognizer(this.privRecognizer);
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member MeetingTranscriber.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * @param {Meeting} meeting - meeting to be recognized
     */
    joinMeetingAsync(n, c, u) {
      const l = n;
      r.Contracts.throwIfNullOrUndefined(i.MeetingImpl, "Meeting"), this.privRecognizer = new e.TranscriberRecognizer(n.config, this.privAudioConfig), r.Contracts.throwIfNullOrUndefined(this.privRecognizer, "Recognizer"), this.privRecognizer.connectMeetingCallbacks(this), (0, t.marshalPromiseToCallbacks)(l.connectTranscriberRecognizer(this.privRecognizer), c, u);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.startTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    startTranscribingAsync(n, c) {
      this.privRecognizer.startContinuousRecognitionAsync(n, c);
    }
    /**
     * Starts meeting transcription, until stopTranscribingAsync() is called.
     * User must subscribe to events to receive transcription results.
     * @member MeetingTranscriber.prototype.stopTranscribingAsync
     * @function
     * @public
     * @param cb - Callback invoked once the transcription has started.
     * @param err - Callback invoked in case of an error.
     */
    stopTranscribingAsync(n, c) {
      this.privRecognizer.stopContinuousRecognitionAsync(n, c);
    }
    /**
     * Leave the current meeting. After this is called, you will no longer receive any events.
     */
    leaveMeetingAsync(n, c) {
      this.privRecognizer.disconnectCallbacks(), (0, t.marshalPromiseToCallbacks)((async () => {
      })(), n, c);
    }
    /**
     * closes all external resources held by an instance of this class.
     * @member MeetingTranscriber.prototype.close
     * @function
     * @public
     */
    close(n, c) {
      r.Contracts.throwIfDisposed(this.privDisposedRecognizer), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), n, c);
    }
    /**
     * Disposes any resources held by the object.
     * @member MeetingTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (this.privRecognizer && (await this.privRecognizer.close(), this.privRecognizer = void 0), n && (this.privDisposedRecognizer = !0));
    }
  };
  return $n.MeetingTranscriber = a, $n;
}
var Vn = {}, _p;
function IP() {
  if (_p) return Vn;
  _p = 1, Object.defineProperty(Vn, "__esModule", { value: !0 }), Vn.ConversationTranscriptionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.RecognitionResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @public
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} text - The recognized text.
     * @param {number} duration - The duration.
     * @param {number} offset - The offset into the stream.
     * @param {string} language - Primary Language detected, if provided.
     * @param {string} languageDetectionConfidence - Primary Language confidence ("Unknown," "Low," "Medium," "High"...), if provided.
     * @param {string} speakerId - speaker id for conversation transcription.
     * @param {string} errorDetails - Error details, if provided.
     * @param {string} json - Additional Json, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n, c, u, l, p, h, d) {
      super(o, i, a, s, n, c, u, p, h, d), this.privSpeakerId = l;
    }
    /**
     * speaker id
     * @member ConversationTranscriptionResult.prototype.speakerId
     * @function
     * @public
     * @returns {string} id of speaker in given result
     */
    get speakerId() {
      return this.privSpeakerId;
    }
  };
  return Vn.ConversationTranscriptionResult = t, Vn;
}
var kp;
function lc() {
  return kp || (kp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConversationTranscriptionResult = e.MeetingTranscriber = e.MeetingTranscriptionCanceledEventArgs = e.MeetingImpl = e.Meeting = e.ParticipantChangedReason = e.User = e.Participant = e.ConversationTranscriber = e.ConversationTranslator = e.ConversationTranslationResult = e.ConversationTranslationEventArgs = e.ConversationTranslationCanceledEventArgs = e.ConversationParticipantsChangedEventArgs = e.ConversationExpirationEventArgs = e.ConversationCommon = e.ConversationImpl = e.Conversation = void 0;
    var t = /* @__PURE__ */ kv();
    Object.defineProperty(e, "Conversation", { enumerable: !0, get: function() {
      return t.Conversation;
    } }), Object.defineProperty(e, "ConversationImpl", { enumerable: !0, get: function() {
      return t.ConversationImpl;
    } });
    var r = /* @__PURE__ */ dP();
    Object.defineProperty(e, "ConversationCommon", { enumerable: !0, get: function() {
      return r.ConversationCommon;
    } });
    var o = /* @__PURE__ */ hP();
    Object.defineProperty(e, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return o.ConversationExpirationEventArgs;
    } });
    var i = /* @__PURE__ */ fP();
    Object.defineProperty(e, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return i.ConversationParticipantsChangedEventArgs;
    } });
    var a = /* @__PURE__ */ vP();
    Object.defineProperty(e, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return a.ConversationTranslationCanceledEventArgs;
    } });
    var s = /* @__PURE__ */ gP();
    Object.defineProperty(e, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return s.ConversationTranslationEventArgs;
    } });
    var n = /* @__PURE__ */ mP();
    Object.defineProperty(e, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return n.ConversationTranslationResult;
    } });
    var c = /* @__PURE__ */ SP();
    Object.defineProperty(e, "ConversationTranslator", { enumerable: !0, get: function() {
      return c.ConversationTranslator;
    } });
    var u = /* @__PURE__ */ CP();
    Object.defineProperty(e, "ConversationTranscriber", { enumerable: !0, get: function() {
      return u.ConversationTranscriber;
    } });
    var l = /* @__PURE__ */ RP();
    Object.defineProperty(e, "Participant", { enumerable: !0, get: function() {
      return l.Participant;
    } }), Object.defineProperty(e, "User", { enumerable: !0, get: function() {
      return l.User;
    } });
    var p = /* @__PURE__ */ PP();
    Object.defineProperty(e, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return p.ParticipantChangedReason;
    } });
    var h = /* @__PURE__ */ wP();
    Object.defineProperty(e, "Meeting", { enumerable: !0, get: function() {
      return h.Meeting;
    } }), Object.defineProperty(e, "MeetingImpl", { enumerable: !0, get: function() {
      return h.MeetingImpl;
    } });
    var d = /* @__PURE__ */ bP();
    Object.defineProperty(e, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return d.MeetingTranscriptionCanceledEventArgs;
    } });
    var f = /* @__PURE__ */ EP();
    Object.defineProperty(e, "MeetingTranscriber", { enumerable: !0, get: function() {
      return f.MeetingTranscriber;
    } });
    var g = /* @__PURE__ */ IP();
    Object.defineProperty(e, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return g.ConversationTranscriptionResult;
    } });
  }(Qo)), Qo;
}
var Pt = {}, Op;
function pc() {
  if (Op) return Pt;
  Op = 1, Object.defineProperty(Pt, "__esModule", { value: !0 }), Pt.SynthesisRequest = Pt.Synthesizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I();
  let i = class Nv {
    /**
     * Creates and initializes an instance of a Recognizer
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config to initialize the synthesizer.
     */
    constructor(n) {
      const c = n;
      r.Contracts.throwIfNull(c, "speechConfig"), this.privProperties = c.properties.clone(), this.privDisposed = !1, this.privSynthesizing = !1, this.synthesisRequestQueue = new t.Queue(), this.tokenCredential = n.tokenCredential;
    }
    /**
     * Gets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @returns {string} Authorization token.
     */
    get authorizationToken() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token);
    }
    /**
     * Gets/Sets the authorization token used to communicate with the service.
     * @member Synthesizer.prototype.authorizationToken
     * @function
     * @public
     * @param {string} token - Authorization token.
     */
    set authorizationToken(n) {
      r.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(o.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    /**
     * The collection of properties and their values defined for this Synthesizer.
     * @member Synthesizer.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The collection of properties and their values defined for this SpeechSynthesizer.
     */
    get properties() {
      return this.privProperties;
    }
    /**
     * Indicates if auto detect source language is enabled
     * @member Synthesizer.prototype.autoDetectSourceLanguage
     * @function
     * @public
     * @returns {boolean} if auto detect source language is enabled
     */
    get autoDetectSourceLanguage() {
      return this.properties.getProperty(o.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages) === e.AutoDetectSourceLanguagesOpenRangeOptionName;
    }
    buildSsml(n) {
      const c = {
        "af-ZA": "af-ZA-AdriNeural",
        "am-ET": "am-ET-AmehaNeural",
        "ar-AE": "ar-AE-FatimaNeural",
        "ar-BH": "ar-BH-AliNeural",
        "ar-DZ": "ar-DZ-AminaNeural",
        "ar-EG": "ar-EG-SalmaNeural",
        "ar-IQ": "ar-IQ-BasselNeural",
        "ar-JO": "ar-JO-SanaNeural",
        "ar-KW": "ar-KW-FahedNeural",
        "ar-LY": "ar-LY-ImanNeural",
        "ar-MA": "ar-MA-JamalNeural",
        "ar-QA": "ar-QA-AmalNeural",
        "ar-SA": "ar-SA-HamedNeural",
        "ar-SY": "ar-SY-AmanyNeural",
        "ar-TN": "ar-TN-HediNeural",
        "ar-YE": "ar-YE-MaryamNeural",
        "bg-BG": "bg-BG-BorislavNeural",
        "bn-BD": "bn-BD-NabanitaNeural",
        "bn-IN": "bn-IN-BashkarNeural",
        "ca-ES": "ca-ES-JoanaNeural",
        "cs-CZ": "cs-CZ-AntoninNeural",
        "cy-GB": "cy-GB-AledNeural",
        "da-DK": "da-DK-ChristelNeural",
        "de-AT": "de-AT-IngridNeural",
        "de-CH": "de-CH-JanNeural",
        "de-DE": "de-DE-KatjaNeural",
        "el-GR": "el-GR-AthinaNeural",
        "en-AU": "en-AU-NatashaNeural",
        "en-CA": "en-CA-ClaraNeural",
        "en-GB": "en-GB-LibbyNeural",
        "en-HK": "en-HK-SamNeural",
        "en-IE": "en-IE-ConnorNeural",
        "en-IN": "en-IN-NeerjaNeural",
        "en-KE": "en-KE-AsiliaNeural",
        "en-NG": "en-NG-AbeoNeural",
        "en-NZ": "en-NZ-MitchellNeural",
        "en-PH": "en-PH-JamesNeural",
        "en-SG": "en-SG-LunaNeural",
        "en-TZ": "en-TZ-ElimuNeural",
        "en-US": "en-US-AvaMultilingualNeural",
        "en-ZA": "en-ZA-LeahNeural",
        "es-AR": "es-AR-ElenaNeural",
        "es-BO": "es-BO-MarceloNeural",
        "es-CL": "es-CL-CatalinaNeural",
        "es-CO": "es-CO-GonzaloNeural",
        "es-CR": "es-CR-JuanNeural",
        "es-CU": "es-CU-BelkysNeural",
        "es-DO": "es-DO-EmilioNeural",
        "es-EC": "es-EC-AndreaNeural",
        "es-ES": "es-ES-AlvaroNeural",
        "es-GQ": "es-GQ-JavierNeural",
        "es-GT": "es-GT-AndresNeural",
        "es-HN": "es-HN-CarlosNeural",
        "es-MX": "es-MX-DaliaNeural",
        "es-NI": "es-NI-FedericoNeural",
        "es-PA": "es-PA-MargaritaNeural",
        "es-PE": "es-PE-AlexNeural",
        "es-PR": "es-PR-KarinaNeural",
        "es-PY": "es-PY-MarioNeural",
        "es-SV": "es-SV-LorenaNeural",
        "es-US": "es-US-AlonsoNeural",
        "es-UY": "es-UY-MateoNeural",
        "es-VE": "es-VE-PaolaNeural",
        "et-EE": "et-EE-AnuNeural",
        "fa-IR": "fa-IR-DilaraNeural",
        "fi-FI": "fi-FI-SelmaNeural",
        "fil-PH": "fil-PH-AngeloNeural",
        "fr-BE": "fr-BE-CharlineNeural",
        "fr-CA": "fr-CA-SylvieNeural",
        "fr-CH": "fr-CH-ArianeNeural",
        "fr-FR": "fr-FR-DeniseNeural",
        "ga-IE": "ga-IE-ColmNeural",
        "gl-ES": "gl-ES-RoiNeural",
        "gu-IN": "gu-IN-DhwaniNeural",
        "he-IL": "he-IL-AvriNeural",
        "hi-IN": "hi-IN-MadhurNeural",
        "hr-HR": "hr-HR-GabrijelaNeural",
        "hu-HU": "hu-HU-NoemiNeural",
        "id-ID": "id-ID-ArdiNeural",
        "is-IS": "is-IS-GudrunNeural",
        "it-IT": "it-IT-IsabellaNeural",
        "ja-JP": "ja-JP-NanamiNeural",
        "jv-ID": "jv-ID-DimasNeural",
        "kk-KZ": "kk-KZ-AigulNeural",
        "km-KH": "km-KH-PisethNeural",
        "kn-IN": "kn-IN-GaganNeural",
        "ko-KR": "ko-KR-SunHiNeural",
        "lo-LA": "lo-LA-ChanthavongNeural",
        "lt-LT": "lt-LT-LeonasNeural",
        "lv-LV": "lv-LV-EveritaNeural",
        "mk-MK": "mk-MK-AleksandarNeural",
        "ml-IN": "ml-IN-MidhunNeural",
        "mr-IN": "mr-IN-AarohiNeural",
        "ms-MY": "ms-MY-OsmanNeural",
        "mt-MT": "mt-MT-GraceNeural",
        "my-MM": "my-MM-NilarNeural",
        "nb-NO": "nb-NO-PernilleNeural",
        "nl-BE": "nl-BE-ArnaudNeural",
        "nl-NL": "nl-NL-ColetteNeural",
        "pl-PL": "pl-PL-AgnieszkaNeural",
        "ps-AF": "ps-AF-GulNawazNeural",
        "pt-BR": "pt-BR-FranciscaNeural",
        "pt-PT": "pt-PT-DuarteNeural",
        "ro-RO": "ro-RO-AlinaNeural",
        "ru-RU": "ru-RU-SvetlanaNeural",
        "si-LK": "si-LK-SameeraNeural",
        "sk-SK": "sk-SK-LukasNeural",
        "sl-SI": "sl-SI-PetraNeural",
        "so-SO": "so-SO-MuuseNeural",
        "sr-RS": "sr-RS-NicholasNeural",
        "su-ID": "su-ID-JajangNeural",
        "sv-SE": "sv-SE-SofieNeural",
        "sw-KE": "sw-KE-RafikiNeural",
        "sw-TZ": "sw-TZ-DaudiNeural",
        "ta-IN": "ta-IN-PallaviNeural",
        "ta-LK": "ta-LK-KumarNeural",
        "ta-SG": "ta-SG-AnbuNeural",
        "te-IN": "te-IN-MohanNeural",
        "th-TH": "th-TH-PremwadeeNeural",
        "tr-TR": "tr-TR-AhmetNeural",
        "uk-UA": "uk-UA-OstapNeural",
        "ur-IN": "ur-IN-GulNeural",
        "ur-PK": "ur-PK-AsadNeural",
        "uz-UZ": "uz-UZ-MadinaNeural",
        "vi-VN": "vi-VN-HoaiMyNeural",
        "zh-CN": "zh-CN-XiaoxiaoNeural",
        "zh-HK": "zh-HK-HiuMaanNeural",
        "zh-TW": "zh-TW-HsiaoChenNeural",
        "zu-ZA": "zu-ZA-ThandoNeural"
      };
      let u = this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthLanguage, "en-US"), l = this.properties.getProperty(o.PropertyId.SpeechServiceConnection_SynthVoice, ""), p = Nv.XMLEncode(n);
      return this.autoDetectSourceLanguage ? u = "en-US" : l = l || c[u], l && (p = `<voice name='${l}'>${p}</voice>`), p = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xmlns:mstts='http://www.w3.org/2001/mstts' xmlns:emo='http://www.w3.org/2009/10/emotionml' xml:lang='${u}'>${p}</speak>`, p;
    }
    /**
     * This method performs cleanup of resources.
     * The Boolean parameter disposing indicates whether the method is called
     * from Dispose (if disposing is true) or from the finalizer (if disposing is false).
     * Derived classes should override this method to dispose resource if needed.
     * @member Synthesizer.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - Flag to request disposal.
     */
    async dispose(n) {
      this.privDisposed || (n && this.privAdapter && await this.privAdapter.dispose(), this.privDisposed = !0);
    }
    async adapterSpeak() {
      if (!this.privDisposed && !this.privSynthesizing) {
        this.privSynthesizing = !0;
        const n = await this.synthesisRequestQueue.dequeue();
        return this.privAdapter.Speak(n.text, n.isSSML, n.requestId, n.cb, n.err, n.dataStream);
      }
    }
    createSynthesizerConfig(n) {
      return new e.SynthesizerConfig(n, this.privProperties);
    }
    // Does the generic synthesizer setup that is common across all synthesizer types.
    implCommonSynthesizeSetup() {
      let n = typeof window < "u" ? "Browser" : "Node", c = "unknown", u = "unknown";
      typeof navigator < "u" && (n = n + "/" + navigator.platform, c = navigator.userAgent, u = navigator.appVersion);
      const l = this.createSynthesizerConfig(new e.SpeechServiceConfig(new e.Context(new e.OS(n, c, u)))), p = this.privProperties.getProperty(o.PropertyId.SpeechServiceConnection_Key, void 0), h = p && p !== "" ? new e.CognitiveSubscriptionKeyAuthentication(p) : this.tokenCredential ? new e.CognitiveTokenAuthentication(async () => {
        try {
          return (await this.tokenCredential.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (d) {
          throw d;
        }
      }, async () => {
        try {
          return (await this.tokenCredential.getToken("https://cognitiveservices.azure.com/.default"))?.token ?? "";
        } catch (d) {
          throw d;
        }
      }) : new e.CognitiveTokenAuthentication(() => {
        const d = this.privProperties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(d);
      }, () => {
        const d = this.privProperties.getProperty(o.PropertyId.SpeechServiceAuthorization_Token, void 0);
        return Promise.resolve(d);
      });
      this.privAdapter = this.createSynthesisAdapter(h, this.privConnectionFactory, l), this.privRestAdapter = this.createRestSynthesisAdapter(h, l);
    }
    static XMLEncode(n) {
      return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
    }
  };
  Pt.Synthesizer = i;
  class a {
    constructor(n, c, u, l, p, h) {
      this.requestId = n, this.text = c, this.isSSML = u, this.cb = l, this.err = p, this.dataStream = h;
    }
  }
  return Pt.SynthesisRequest = a, Pt;
}
var Wn = {}, Mp;
function AP() {
  if (Mp) return Wn;
  Mp = 1, Object.defineProperty(Wn, "__esModule", { value: !0 }), Wn.SpeechSynthesizer = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ cv(), o = /* @__PURE__ */ Ss(), i = /* @__PURE__ */ Wt(), a = /* @__PURE__ */ z(), s = /* @__PURE__ */ I(), n = /* @__PURE__ */ pc();
  let c = class xv extends s.Synthesizer {
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - An set of initial properties for this synthesizer.
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer.
     */
    constructor(l, p) {
      super(l), p !== null && (p === void 0 ? this.audioConfig = typeof window > "u" ? void 0 : s.AudioConfig.fromDefaultSpeakerOutput() : this.audioConfig = p), this.privConnectionFactory = new e.SpeechSynthesisConnectionFactory(), this.implCommonSynthesizeSetup();
    }
    /**
     * SpeechSynthesizer constructor.
     * @constructor
     * @param {SpeechConfig} speechConfig - an set of initial properties for this synthesizer
     * @param {AutoDetectSourceLanguageConfig} autoDetectSourceLanguageConfig - An source language detection configuration associated with the synthesizer
     * @param {AudioConfig} audioConfig - An optional audio configuration associated with the synthesizer
     */
    static FromConfig(l, p, h) {
      const d = l;
      return p.properties.mergeTo(d.properties), new xv(l, h);
    }
    /**
     * Executes speech synthesis on plain text.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param text - Text to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakTextAsync(l, p, h, d) {
      this.speakImpl(l, !1, p, h, d);
    }
    /**
     * Executes speech synthesis on SSML.
     * The task returns the synthesis result.
     * @member SpeechSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param ssml - SSML to be synthesized.
     * @param cb - Callback that received the SpeechSynthesisResult.
     * @param err - Callback invoked in case of an error.
     * @param stream - AudioOutputStream to receive the synthesized audio.
     */
    speakSsmlAsync(l, p, h, d) {
      this.speakImpl(l, !0, p, h, d);
    }
    /**
     * Get list of synthesis voices available.
     * The task returns the synthesis voice result.
     * @member SpeechSynthesizer.prototype.getVoicesAsync
     * @function
     * @async
     * @public
     * @param locale - Locale of voices in BCP-47 format; if left empty, get all available voices.
     * @return {Promise<SynthesisVoicesResult>} - Promise of a SynthesisVoicesResult.
     */
    async getVoicesAsync(l = "") {
      return this.getVoices(l);
    }
    /**
     * Dispose of associated resources.
     * @member SpeechSynthesizer.prototype.close
     * @function
     * @public
     */
    close(l, p) {
      a.Contracts.throwIfDisposed(this.privDisposed), (0, t.marshalPromiseToCallbacks)(this.dispose(!0), l, p);
    }
    /**
     * @Internal
     * Do not use externally, object returned will change without warning or notice.
     */
    get internalData() {
      return this.privAdapter;
    }
    //
    // ################################################################################################################
    // IMPLEMENTATION.
    // ################################################################################################################
    //
    // Creates the synthesis adapter
    createSynthesisAdapter(l, p, h) {
      return new e.SpeechSynthesisAdapter(l, p, h, this, this.audioConfig);
    }
    createRestSynthesisAdapter(l, p) {
      return new e.SynthesisRestAdapter(p, l);
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(s.SpeechSynthesisOutputFormat[this.properties.getProperty(s.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0)]);
    }
    speakImpl(l, p, h, d, f) {
      try {
        a.Contracts.throwIfDisposed(this.privDisposed);
        const g = (0, t.createNoDashGuid)();
        let m;
        f instanceof s.PushAudioOutputStreamCallback ? m = new i.PushAudioOutputStreamImpl(f) : f instanceof s.PullAudioOutputStream ? m = f : f !== void 0 ? m = new r.AudioFileWriter(f) : m = void 0, this.synthesisRequestQueue.enqueue(new n.SynthesisRequest(g, l, p, (v) => {
          if (this.privSynthesizing = !1, h)
            try {
              h(v);
            } catch (y) {
              d && d(y);
            }
          h = void 0, this.adapterSpeak().catch(() => {
          });
        }, (v) => {
          d && d(v);
        }, m)), this.adapterSpeak().catch(() => {
        });
      } catch (g) {
        if (d)
          if (g instanceof Error) {
            const m = g;
            d(m.name + ": " + m.message);
          } else
            d(g);
        this.dispose(!0).catch(() => {
        });
      }
    }
    async getVoices(l) {
      const p = (0, t.createNoDashGuid)(), h = await this.privRestAdapter.getVoicesList(p);
      if (h.ok && Array.isArray(h.json)) {
        let d = h.json;
        return l && l.length > 0 && (d = d.filter((f) => !!f.Locale && f.Locale.toLowerCase() === l.toLowerCase())), new s.SynthesisVoicesResult(p, d, void 0);
      } else
        return new s.SynthesisVoicesResult(p, void 0, `Error: ${h.status}: ${h.statusText}`);
    }
  };
  return Wn.SpeechSynthesizer = c, Wn;
}
var Hn = {}, Dp;
function TP() {
  if (Dp) return Hn;
  Dp = 1, Object.defineProperty(Hn, "__esModule", { value: !0 }), Hn.SynthesisResult = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(r, o, i, a) {
      this.privResultId = r, this.privReason = o, this.privErrorDetails = i, this.privProperties = a;
    }
    /**
     * Specifies the result identifier.
     * @member SynthesisResult.prototype.resultId
     * @function
     * @public
     * @returns {string} Specifies the result identifier.
     */
    get resultId() {
      return this.privResultId;
    }
    /**
     * Specifies status of the result.
     * @member SynthesisResult.prototype.reason
     * @function
     * @public
     * @returns {ResultReason} Specifies status of the result.
     */
    get reason() {
      return this.privReason;
    }
    /**
     * In case of an unsuccessful synthesis, provides details of the occurred error.
     * @member SynthesisResult.prototype.errorDetails
     * @function
     * @public
     * @returns {string} a brief description of an error.
     */
    get errorDetails() {
      return this.privErrorDetails;
    }
    /**
     * The set of properties exposed in the result.
     * @member SynthesisResult.prototype.properties
     * @function
     * @public
     * @returns {PropertyCollection} The set of properties exposed in the result.
     */
    get properties() {
      return this.privProperties;
    }
  };
  return Hn.SynthesisResult = e, Hn;
}
var Kn = {}, Np;
function _P() {
  if (Np) return Kn;
  Np = 1, Object.defineProperty(Kn, "__esModule", { value: !0 }), Kn.SpeechSynthesisResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {ArrayBuffer} audioData - The synthesized audio binary.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     * @param {number} audioDuration - The audio duration.
     */
    constructor(o, i, a, s, n, c) {
      super(o, i, s, n), this.privAudioData = a, this.privAudioDuration = c;
    }
    /**
     * The synthesized audio data
     * @member SpeechSynthesisResult.prototype.audioData
     * @function
     * @public
     * @returns {ArrayBuffer} The synthesized audio data.
     */
    get audioData() {
      return this.privAudioData;
    }
    /**
     * The time duration of synthesized audio, in ticks (100 nanoseconds).
     * @member SpeechSynthesisResult.prototype.audioDuration
     * @function
     * @public
     * @returns {number} The time duration of synthesized audio.
     */
    get audioDuration() {
      return this.privAudioDuration;
    }
  };
  return Kn.SpeechSynthesisResult = t, Kn;
}
var Jn = {}, xp;
function kP() {
  if (xp) return Jn;
  xp = 1, Object.defineProperty(Jn, "__esModule", { value: !0 }), Jn.SpeechSynthesisEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechSynthesisResult} result - The speech synthesis result.
     */
    constructor(r) {
      this.privResult = r;
    }
    /**
     * Specifies the synthesis result.
     * @member SpeechSynthesisEventArgs.prototype.result
     * @function
     * @public
     * @returns {SpeechSynthesisResult} the synthesis result.
     */
    get result() {
      return this.privResult;
    }
  };
  return Jn.SpeechSynthesisEventArgs = e, Jn;
}
var Gn = {}, zp;
function OP() {
  if (zp) return Gn;
  zp = 1, Object.defineProperty(Gn, "__esModule", { value: !0 }), Gn.SpeechSynthesisWordBoundaryEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} duration - The audio duration.
     * @param {string} text - The text.
     * @param {number} wordLength - The length of the word.
     * @param {number} textOffset - The text offset.
     * @param {SpeechSynthesisBoundaryType} boundaryType - The boundary type
     */
    constructor(r, o, i, a, s, n) {
      this.privAudioOffset = r, this.privDuration = o, this.privText = i, this.privWordLength = a, this.privTextOffset = s, this.privBoundaryType = n;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the duration, in ticks (100 nanoseconds).
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.duration
     * @function
     * @public
     * @returns {number} Duration in 100 nanosecond increments.
     */
    get duration() {
      return this.privDuration;
    }
    /**
     * Specifies the text of the word boundary event.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.text
     * @function
     * @public
     * @returns {string} the text.
     */
    get text() {
      return this.privText;
    }
    /**
     * Specifies the word length
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.wordLength
     * @function
     * @public
     * @returns {number} the word length
     */
    get wordLength() {
      return this.privWordLength;
    }
    /**
     * Specifies the text offset.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.textOffset
     * @function
     * @public
     * @returns {number} the text offset.
     */
    get textOffset() {
      return this.privTextOffset;
    }
    /**
     * Specifies the boundary type.
     * @member SpeechSynthesisWordBoundaryEventArgs.prototype.boundaryType
     * @function
     * @public
     * @returns {SpeechSynthesisBoundaryType} the boundary type.
     */
    get boundaryType() {
      return this.privBoundaryType;
    }
  };
  return Gn.SpeechSynthesisWordBoundaryEventArgs = e, Gn;
}
var Qn = {}, Lp;
function MP() {
  if (Lp) return Qn;
  Lp = 1, Object.defineProperty(Qn, "__esModule", { value: !0 }), Qn.SpeechSynthesisBookmarkEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {string} text - The bookmark text.
     */
    constructor(r, o) {
      this.privAudioOffset = r, this.privText = o;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisBookmarkEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the bookmark.
     * @member SpeechSynthesisBookmarkEventArgs.prototype.text
     * @function
     * @public
     * @returns {string} the bookmark text.
     */
    get text() {
      return this.privText;
    }
  };
  return Qn.SpeechSynthesisBookmarkEventArgs = e, Qn;
}
var Yn = {}, jp;
function DP() {
  if (jp) return Yn;
  jp = 1, Object.defineProperty(Yn, "__esModule", { value: !0 }), Yn.SpeechSynthesisVisemeEventArgs = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {number} audioOffset - The audio offset.
     * @param {number} visemeId - The viseme ID.
     * @param {string} animation - The animation, could be in svg or other format.
     */
    constructor(r, o, i) {
      this.privAudioOffset = r, this.privVisemeId = o, this.privAnimation = i;
    }
    /**
     * Specifies the audio offset.
     * @member SpeechSynthesisVisemeEventArgs.prototype.audioOffset
     * @function
     * @public
     * @returns {number} the audio offset.
     */
    get audioOffset() {
      return this.privAudioOffset;
    }
    /**
     * Specifies the viseme ID.
     * @member SpeechSynthesisVisemeEventArgs.prototype.visemeId
     * @function
     * @public
     * @returns {number} the viseme ID.
     */
    get visemeId() {
      return this.privVisemeId;
    }
    /**
     * Specifies the animation.
     * @member SpeechSynthesisVisemeEventArgs.prototype.animation
     * @function
     * @public
     * @returns {string} the animation, could be in svg or other format.
     */
    get animation() {
      return this.privAnimation;
    }
  };
  return Yn.SpeechSynthesisVisemeEventArgs = e, Yn;
}
var Xo = {}, qp;
function NP() {
  return qp || (qp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SpeechSynthesisBoundaryType = void 0, function(t) {
      t.Word = "WordBoundary", t.Punctuation = "PunctuationBoundary", t.Sentence = "SentenceBoundary";
    }(e.SpeechSynthesisBoundaryType || (e.SpeechSynthesisBoundaryType = {}));
  }(Xo)), Xo;
}
var Zn = {}, Fp;
function xP() {
  if (Fp) return Zn;
  Fp = 1, Object.defineProperty(Zn, "__esModule", { value: !0 }), Zn.SynthesisVoicesResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param requestId - result id for request.
     * @param json - json payload from endpoint.
     */
    constructor(o, i, a) {
      if (Array.isArray(i)) {
        super(o, e.ResultReason.VoicesListRetrieved, void 0, new e.PropertyCollection()), this.privVoices = [];
        for (const s of i)
          this.privVoices.push(new e.VoiceInfo(s));
      } else
        super(o, e.ResultReason.Canceled, a || "Error information unavailable", new e.PropertyCollection());
    }
    /**
     * The list of voices
     * @member SynthesisVoicesResult.prototype.voices
     * @function
     * @public
     * @returns {VoiceInfo[]} List of synthesized voices.
     */
    get voices() {
      return this.privVoices;
    }
  };
  return Zn.SynthesisVoicesResult = t, Zn;
}
var ea = {}, Bp;
function zP() {
  return Bp || (Bp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.VoiceInfo = e.SynthesisVoiceType = e.SynthesisVoiceGender = void 0;
    var t;
    (function(s) {
      s[s.Unknown = 0] = "Unknown", s[s.Female = 1] = "Female", s[s.Male = 2] = "Male", s[s.Neutral = 3] = "Neutral";
    })(t = e.SynthesisVoiceGender || (e.SynthesisVoiceGender = {}));
    var r;
    (function(s) {
      s[s.Unknown = 0] = "Unknown", s[s.OnlineNeural = 1] = "OnlineNeural", s[s.OnlineStandard = 2] = "OnlineStandard", s[s.OfflineNeural = 3] = "OfflineNeural", s[s.OfflineStandard = 4] = "OfflineStandard", s[s.OnlineNeuralHD = 5] = "OnlineNeuralHD";
    })(r = e.SynthesisVoiceType || (e.SynthesisVoiceType = {}));
    const o = {
      [t[t.Neutral]]: t.Neutral,
      [t[t.Male]]: t.Male,
      [t[t.Female]]: t.Female
    }, i = {
      Neural: r.OnlineNeural,
      NeuralHD: r.OnlineNeuralHD
    };
    class a {
      constructor(n) {
        if (this.privStyleList = [], n) {
          if (this.privName = n.Name, this.privLocale = n.Locale, this.privShortName = n.ShortName, this.privLocaleName = n.LocaleName, this.privDisplayName = n.DisplayName, this.privLocalName = n.LocalName, this.privVoiceType = i[n.VoiceType] || r.Unknown, this.privGender = o[n.Gender] || t.Unknown, n.StyleList && Array.isArray(n.StyleList))
            for (const c of n.StyleList)
              this.privStyleList.push(c);
          this.privSampleRateHertz = n.SampleRateHertz, this.privStatus = n.Status, n.ExtendedPropertyMap && (this.privExtendedPropertyMap = n.ExtendedPropertyMap), this.privWordsPerMinute = n.WordsPerMinute, Array.isArray(n.SecondaryLocaleList) && (this.privSecondaryLocaleList = [...n.SecondaryLocaleList]), Array.isArray(n.RolePlayList) && (this.privRolePlayList = [...n.RolePlayList]), n.VoiceTag && (this.privVoiceTag = n.VoiceTag);
        }
      }
      get name() {
        return this.privName;
      }
      get locale() {
        return this.privLocale;
      }
      get shortName() {
        return this.privShortName;
      }
      get displayName() {
        return this.privDisplayName;
      }
      get localName() {
        return this.privLocalName;
      }
      get localeName() {
        return this.privLocaleName;
      }
      get gender() {
        return this.privGender;
      }
      get voiceType() {
        return this.privVoiceType;
      }
      get styleList() {
        return this.privStyleList;
      }
      get sampleRateHertz() {
        return this.privSampleRateHertz;
      }
      get status() {
        return this.privStatus;
      }
      get extendedPropertyMap() {
        return this.privExtendedPropertyMap;
      }
      get wordsPerMinute() {
        return this.privWordsPerMinute;
      }
      get secondaryLocaleList() {
        return this.privSecondaryLocaleList;
      }
      get rolePlayList() {
        return this.privRolePlayList;
      }
      get voiceTag() {
        return this.privVoiceTag;
      }
    }
    e.VoiceInfo = a;
  }(ea)), ea;
}
var Xn = {}, Up;
function LP() {
  if (Up) return Xn;
  Up = 1, Object.defineProperty(Xn, "__esModule", { value: !0 }), Xn.SpeakerAudioDestination = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ Wt(), r = /* @__PURE__ */ Nt(), o = 60 * 30, i = {
    [r.AudioFormatTag.PCM]: "audio/wav",
    [r.AudioFormatTag.MuLaw]: "audio/x-wav",
    [r.AudioFormatTag.MP3]: "audio/mpeg",
    [r.AudioFormatTag.OGG_OPUS]: "audio/ogg",
    [r.AudioFormatTag.WEBM_OPUS]: "audio/webm; codecs=opus",
    [r.AudioFormatTag.ALaw]: "audio/x-wav",
    [r.AudioFormatTag.FLAC]: "audio/flac",
    [r.AudioFormatTag.AMR_WB]: "audio/amr-wb",
    [r.AudioFormatTag.G722]: "audio/G722"
  };
  let a = class {
    constructor(n) {
      this.privPlaybackStarted = !1, this.privAppendingToBuffer = !1, this.privMediaSourceOpened = !1, this.privBytesReceived = 0, this.privId = n || (0, e.createNoDashGuid)(), this.privIsPaused = !1, this.privIsClosed = !1;
    }
    id() {
      return this.privId;
    }
    write(n, c, u) {
      this.privAudioBuffer !== void 0 ? (this.privAudioBuffer.push(n), this.updateSourceBuffer().then(() => {
        c && c();
      }, (l) => {
        u && u(l);
      })) : this.privAudioOutputStream !== void 0 && (this.privAudioOutputStream.write(n), this.privBytesReceived += n.byteLength);
    }
    close(n, c) {
      if (this.privIsClosed = !0, this.privSourceBuffer !== void 0)
        this.handleSourceBufferUpdateEnd().then(() => {
          n && n();
        }, (u) => {
          c && c(u);
        });
      else if (this.privAudioOutputStream !== void 0 && typeof window < "u")
        if ((this.privFormat.formatTag === r.AudioFormatTag.PCM || this.privFormat.formatTag === r.AudioFormatTag.MuLaw || this.privFormat.formatTag === r.AudioFormatTag.ALaw) && this.privFormat.hasHeader === !1)
          console.warn("Play back is not supported for raw PCM, mulaw or alaw format without header."), this.onAudioEnd && this.onAudioEnd(this);
        else {
          let u = new ArrayBuffer(this.privBytesReceived);
          this.privAudioOutputStream.read(u).then(() => {
            u = this.privFormat.addHeader(u);
            const l = new Blob([u], { type: i[this.privFormat.formatTag] });
            this.privAudio.src = window.URL.createObjectURL(l), this.notifyPlayback().then(() => {
              n && n();
            }, (p) => {
              c && c(p);
            });
          }, (l) => {
            c && c(l);
          });
        }
      else
        this.onAudioEnd && this.onAudioEnd(this);
    }
    set format(n) {
      if (typeof AudioContext < "u" || typeof window < "u" && typeof window.webkitAudioContext < "u") {
        this.privFormat = n;
        const c = i[this.privFormat.formatTag];
        c === void 0 ? console.warn(`Unknown mimeType for format ${r.AudioFormatTag[this.privFormat.formatTag]}; playback is not supported.`) : typeof MediaSource < "u" && MediaSource.isTypeSupported(c) ? (this.privAudio = new Audio(), this.privAudioBuffer = [], this.privMediaSource = new MediaSource(), this.privAudio.src = URL.createObjectURL(this.privMediaSource), this.privAudio.load(), this.privMediaSource.onsourceopen = () => {
          this.privMediaSourceOpened = !0, this.privMediaSource.duration = o, this.privSourceBuffer = this.privMediaSource.addSourceBuffer(c), this.privSourceBuffer.onupdate = () => {
            this.updateSourceBuffer().catch((u) => {
              e.Events.instance.onEvent(new e.BackgroundEvent(u));
            });
          }, this.privSourceBuffer.onupdateend = () => {
            this.handleSourceBufferUpdateEnd().catch((u) => {
              e.Events.instance.onEvent(new e.BackgroundEvent(u));
            });
          }, this.privSourceBuffer.onupdatestart = () => {
            this.privAppendingToBuffer = !1;
          };
        }, this.updateSourceBuffer().catch((u) => {
          e.Events.instance.onEvent(new e.BackgroundEvent(u));
        })) : (console.warn(`Format ${r.AudioFormatTag[this.privFormat.formatTag]} could not be played by MSE, streaming playback is not enabled.`), this.privAudioOutputStream = new t.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privFormat, this.privAudio = new Audio());
      }
    }
    get volume() {
      return this.privAudio?.volume ?? -1;
    }
    set volume(n) {
      this.privAudio && (this.privAudio.volume = n);
    }
    mute() {
      this.privAudio && (this.privAudio.muted = !0);
    }
    unmute() {
      this.privAudio && (this.privAudio.muted = !1);
    }
    get isClosed() {
      return this.privIsClosed;
    }
    get currentTime() {
      return this.privAudio !== void 0 ? this.privAudio.currentTime : -1;
    }
    pause() {
      !this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.pause(), this.privIsPaused = !0);
    }
    resume(n, c) {
      this.privIsPaused && this.privAudio !== void 0 && (this.privAudio.play().then(() => {
        n && n();
      }, (u) => {
        c && c(u);
      }), this.privIsPaused = !1);
    }
    get internalAudio() {
      return this.privAudio;
    }
    async updateSourceBuffer() {
      if (this.privAudioBuffer !== void 0 && this.privAudioBuffer.length > 0 && this.sourceBufferAvailable()) {
        this.privAppendingToBuffer = !0;
        const n = this.privAudioBuffer.shift();
        try {
          this.privSourceBuffer.appendBuffer(n);
        } catch {
          this.privAudioBuffer.unshift(n), console.log("buffer filled, pausing addition of binaries until space is made");
          return;
        }
        await this.notifyPlayback();
      } else this.canEndStream() && await this.handleSourceBufferUpdateEnd();
    }
    async handleSourceBufferUpdateEnd() {
      this.canEndStream() && this.sourceBufferAvailable() && (this.privMediaSource.endOfStream(), await this.notifyPlayback());
    }
    async notifyPlayback() {
      !this.privPlaybackStarted && this.privAudio !== void 0 && (this.privPlaybackStarted = !0, this.onAudioStart && this.onAudioStart(this), this.privAudio.onended = () => {
        this.onAudioEnd && this.onAudioEnd(this);
      }, this.privIsPaused || await this.privAudio.play());
    }
    canEndStream() {
      return this.isClosed && this.privSourceBuffer !== void 0 && this.privAudioBuffer.length === 0 && this.privMediaSourceOpened && !this.privAppendingToBuffer && this.privMediaSource.readyState === "open";
    }
    sourceBufferAvailable() {
      return this.privSourceBuffer !== void 0 && !this.privSourceBuffer.updating;
    }
  };
  return Xn.SpeakerAudioDestination = a, Xn;
}
var ei = {}, $p;
function jP() {
  if ($p) return ei;
  $p = 1, Object.defineProperty(ei, "__esModule", { value: !0 }), ei.ConversationTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Cs();
  let t = class extends e.CancellationEventArgsBase {
  };
  return ei.ConversationTranscriptionCanceledEventArgs = t, ei;
}
var ti = {}, Vp;
function qP() {
  if (Vp) return ti;
  Vp = 1, Object.defineProperty(ti, "__esModule", { value: !0 }), ti.MeetingTranscriptionCanceledEventArgs = void 0;
  const e = /* @__PURE__ */ Cs();
  let t = class extends e.CancellationEventArgsBase {
  };
  return ti.MeetingTranscriptionCanceledEventArgs = t, ti;
}
var ta = {}, Wp;
function FP() {
  return Wp || (Wp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PronunciationAssessmentGradingSystem = void 0, function(t) {
      t[t.FivePoint = 1] = "FivePoint", t[t.HundredMark = 2] = "HundredMark";
    }(e.PronunciationAssessmentGradingSystem || (e.PronunciationAssessmentGradingSystem = {}));
  }(ta)), ta;
}
var ra = {}, Hp;
function BP() {
  return Hp || (Hp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PronunciationAssessmentGranularity = void 0, function(t) {
      t[t.Phoneme = 1] = "Phoneme", t[t.Word = 2] = "Word", t[t.FullText = 3] = "FullText";
    }(e.PronunciationAssessmentGranularity || (e.PronunciationAssessmentGranularity = {}));
  }(ra)), ra;
}
var ri = {}, Kp;
function UP() {
  if (Kp) return ri;
  Kp = 1, Object.defineProperty(ri, "__esModule", { value: !0 }), ri.PronunciationAssessmentConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class zv {
    /**
     * PronunciationAssessmentConfig constructor.
     * @constructor
     * @param {string} referenceText
     * @param gradingSystem
     * @param granularity
     * @param enableMiscue
     */
    constructor(i, a = t.PronunciationAssessmentGradingSystem.FivePoint, s = t.PronunciationAssessmentGranularity.Phoneme, n = !1) {
      e.Contracts.throwIfNullOrUndefined(i, "referenceText"), this.privProperties = new t.PropertyCollection(), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_ReferenceText, i), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_GradingSystem, t.PronunciationAssessmentGradingSystem[a]), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_Granularity, t.PronunciationAssessmentGranularity[s]), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, String(n));
    }
    /**
     * @member PronunciationAssessmentConfig.fromJSON
     * @function
     * @public
     * @param {string} json The json string containing the pronunciation assessment parameters.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentConfig from json.
     * This method is designed to support the pronunciation assessment parameters still in preview.
     * Under normal circumstances, use the constructor instead.
     */
    static fromJSON(i) {
      e.Contracts.throwIfNullOrUndefined(i, "json");
      const a = new zv("");
      return a.privProperties = new t.PropertyCollection(), a.properties.setProperty(t.PropertyId.PronunciationAssessment_Json, i), a;
    }
    toJSON() {
      return this.updateJson(), this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Params);
    }
    applyTo(i) {
      this.updateJson();
      const a = i.internalData;
      a.expectContentAssessmentResponse = !!this.privContentAssessmentTopic, a.speechContext.setPronunciationAssessmentParams(this.properties.getProperty(t.PropertyId.PronunciationAssessment_Params), this.privContentAssessmentTopic, a.isSpeakerDiarizationEnabled);
    }
    /**
     * Gets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @returns {string} Reference text.
     */
    get referenceText() {
      return this.properties.getProperty(t.PropertyId.PronunciationAssessment_ReferenceText);
    }
    /**
     * Gets/Sets the reference text.
     * @member PronunciationAssessmentConfig.prototype.referenceText
     * @function
     * @public
     * @param {string} referenceText - Reference text.
     */
    set referenceText(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "referenceText"), this.properties.setProperty(t.PropertyId.PronunciationAssessment_ReferenceText, i);
    }
    /**
     * Sets the phoneme alphabet.
     * The valid values are "SAPI" (default) and "IPA".
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.phonemeAlphabet
     * @function
     * @public
     * @param {string} phonemeAlphabet - Phoneme alphabet.
     */
    set phonemeAlphabet(i) {
      e.Contracts.throwIfNullOrWhitespace(i, "phonemeAlphabet"), this.privPhonemeAlphabet = i;
    }
    /**
     * Sets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @param {boolean} enableMiscue - enable miscue.
     */
    set enableMiscue(i) {
      const a = i ? "true" : "false";
      this.properties.setProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, a);
    }
    /**
     * Gets the boolean enableMiscue property.
     * Added in version 1.26.0
     * @member PronunciationAssessmentConfig.prototype.enableMiscue
     * @function
     * @public
     * @return {boolean} enableMiscue - enable miscue.
     */
    get enableMiscue() {
      return this.properties.getProperty(t.PropertyId.PronunciationAssessment_EnableMiscue, "false").toLowerCase() === "true";
    }
    /**
     * Sets the nbest phoneme count
     * Added in version 1.20.0
     * @member PronunciationAssessmentConfig.prototype.nbestPhonemeCount
     * @function
     * @public
     * @param {number} nbestPhonemeCount - NBest phoneme count.
     */
    set nbestPhonemeCount(i) {
      this.privNBestPhonemeCount = i;
    }
    /**
     * Enables the prosody assessment.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableProsodyAssessment
     * @function
     * @public
     * @param {boolean} enableProsodyAssessment - enable prosody assessment.
     */
    set enableProsodyAssessment(i) {
      this.privEnableProsodyAssessment = i;
    }
    /**
     * Enables content assessment and sets the topic.
     * Added in version 1.34.0
     * @member PronunciationAssessmentConfig.prototype.enableContentAssessmentWithTopic
     * @function
     * @public
     * @param {string} topic - Topic for content assessment.
     */
    enableContentAssessmentWithTopic(i) {
      this.privContentAssessmentTopic = i;
    }
    /**
     * @member PronunciationAssessmentConfig.prototype.properties
     * @function
     * @public
     * @return {PropertyCollection} Properties of the config.
     * @summary Gets a pronunciation assessment config properties
     */
    get properties() {
      return this.privProperties;
    }
    updateJson() {
      const i = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Json, "{}"), a = JSON.parse(i), s = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_ReferenceText);
      s && (a.referenceText = s);
      const n = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_GradingSystem);
      n && (a.gradingSystem = n);
      const c = this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_Granularity);
      c && (a.granularity = c), this.privPhonemeAlphabet && (a.phonemeAlphabet = this.privPhonemeAlphabet), this.privNBestPhonemeCount && (a.nbestPhonemeCount = this.privNBestPhonemeCount), a.enableProsodyAssessment = this.privEnableProsodyAssessment, a.dimension = "Comprehensive", this.privProperties.getProperty(t.PropertyId.PronunciationAssessment_EnableMiscue) && (a.enableMiscue = this.enableMiscue), this.privProperties.setProperty(t.PropertyId.PronunciationAssessment_Params, JSON.stringify(a));
    }
  };
  return ri.PronunciationAssessmentConfig = r, ri;
}
var wt = {}, Jp;
function $P() {
  if (Jp) return wt;
  Jp = 1, Object.defineProperty(wt, "__esModule", { value: !0 }), wt.PronunciationAssessmentResult = wt.ContentAssessmentResult = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  class r {
    /**
     * @Internal
     * Do not use externally.
     */
    constructor(a) {
      this.privPronJson = a;
    }
    /**
     * Correctness in using grammar and variety of sentence patterns.
     * Grammatical errors are jointly evaluated by lexical accuracy,
     * grammatical accuracy and diversity of sentence structures.
     * @member ContentAssessmentResult.prototype.grammarScore
     * @function
     * @public
     * @returns {number} Grammar score.
     */
    get grammarScore() {
      return this.privPronJson.ContentAssessment.GrammarScore;
    }
    /**
     * Proficiency in lexical usage. It evaluates the speaker's effective usage
     * of words and their appropriateness within the given context to express
     * ideas accurately, as well as level of lexical complexity.
     * @member ContentAssessmentResult.prototype.vocabularyScore
     * @function
     * @public
     * @returns {number} Vocabulary score.
     */
    get vocabularyScore() {
      return this.privPronJson.ContentAssessment.VocabularyScore;
    }
    /**
     * Level of understanding and engagement with the topic, which provides
     * insights into the speaker’s ability to express their thoughts and ideas
     * effectively and the ability to engage with the topic.
     * @member ContentAssessmentResult.prototype.topicScore
     * @function
     * @public
     * @returns {number} Topic score.
     */
    get topicScore() {
      return this.privPronJson.ContentAssessment.TopicScore;
    }
  }
  wt.ContentAssessmentResult = r;
  let o = class Lv {
    constructor(a) {
      const s = JSON.parse(a);
      e.Contracts.throwIfNullOrUndefined(s.NBest[0], "NBest"), this.privPronJson = s.NBest[0];
    }
    /**
     * @member PronunciationAssessmentResult.fromResult
     * @function
     * @public
     * @param {RecognitionResult} result The recognition result.
     * @return {PronunciationAssessmentConfig} Instance of PronunciationAssessmentConfig
     * @summary Creates an instance of the PronunciationAssessmentResult from recognition result.
     */
    static fromResult(a) {
      e.Contracts.throwIfNullOrUndefined(a, "result");
      const s = a.properties.getProperty(t.PropertyId.SpeechServiceResponse_JsonResult);
      return e.Contracts.throwIfNullOrUndefined(s, "json"), new Lv(s);
    }
    /**
     * Gets the detail result of pronunciation assessment.
     * @member PronunciationAssessmentConfig.prototype.detailResult
     * @function
     * @public
     * @returns {DetailResult} detail result.
     */
    get detailResult() {
      return this.privPronJson;
    }
    /**
     * The score indicating the pronunciation accuracy of the given speech, which indicates
     * how closely the phonemes match a native speaker's pronunciation.
     * @member PronunciationAssessmentResult.prototype.accuracyScore
     * @function
     * @public
     * @returns {number} Accuracy score.
     */
    get accuracyScore() {
      return this.detailResult.PronunciationAssessment?.AccuracyScore;
    }
    /**
     * The overall score indicating the pronunciation quality of the given speech.
     * This is calculated from AccuracyScore, FluencyScore and CompletenessScore with weight.
     * @member PronunciationAssessmentResult.prototype.pronunciationScore
     * @function
     * @public
     * @returns {number} Pronunciation score.
     */
    get pronunciationScore() {
      return this.detailResult.PronunciationAssessment?.PronScore;
    }
    /**
     * The score indicating the completeness of the given speech by calculating the ratio of pronounced words towards entire input.
     * @member PronunciationAssessmentResult.prototype.completenessScore
     * @function
     * @public
     * @returns {number} Completeness score.
     */
    get completenessScore() {
      return this.detailResult.PronunciationAssessment?.CompletenessScore;
    }
    /**
     * The score indicating the fluency of the given speech.
     * @member PronunciationAssessmentResult.prototype.fluencyScore
     * @function
     * @public
     * @returns {number} Fluency score.
     */
    get fluencyScore() {
      return this.detailResult.PronunciationAssessment?.FluencyScore;
    }
    /**
     * The prosody score, which indicates how nature of the given speech, including stress, intonation, speaking speed and rhythm.
     * @member PronunciationAssessmentResult.prototype.prosodyScore
     * @function
     * @public
     * @returns {number} Prosody score.
     */
    get prosodyScore() {
      return this.detailResult.PronunciationAssessment?.ProsodyScore;
    }
    /**
     * The concent assessment result.
     * Only available when content assessment is enabled.
     * @member PronunciationAssessmentResult.prototype.contentAssessmentResult
     * @function
     * @public
     * @returns {ContentAssessmentResult} Content assessment result.
     */
    get contentAssessmentResult() {
      if (this.detailResult.ContentAssessment !== void 0)
        return new r(this.detailResult);
    }
  };
  return wt.PronunciationAssessmentResult = o, wt;
}
var ni = {}, Gp;
function VP() {
  if (Gp) return ni;
  Gp = 1, Object.defineProperty(ni, "__esModule", { value: !0 }), ni.AvatarConfig = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ I();
  let r = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} character - The avatar character.
     * @param {string} style - The avatar style.
     * @param {AvatarVideoFormat} videoFormat - The talking avatar output video format.
     */
    constructor(i, a, s) {
      this.privCustomized = !1, this.privUseBuiltInVoice = !1, e.Contracts.throwIfNullOrWhitespace(i, "character"), this.character = i, this.style = a, s === void 0 && (s = new t.AvatarVideoFormat()), this.videoFormat = s;
    }
    /**
     * Indicates if the talking avatar is customized.
     */
    get customized() {
      return this.privCustomized;
    }
    /**
     * Sets if the talking avatar is customized.
     */
    set customized(i) {
      this.privCustomized = i;
    }
    /**
     * Indicates whether to use built-in voice for custom avatar.
     */
    get useBuiltInVoice() {
      return this.privUseBuiltInVoice;
    }
    /**
     * Sets whether to use built-in voice for custom avatar.
     */
    set useBuiltInVoice(i) {
      this.privUseBuiltInVoice = i;
    }
    /**
     * Gets the background color.
     */
    get backgroundColor() {
      return this.privBackgroundColor;
    }
    /**
     * Sets the background color.
     */
    set backgroundColor(i) {
      this.privBackgroundColor = i;
    }
    /**
     * Gets the background image.
     */
    get backgroundImage() {
      return this.privBackgroundImage;
    }
    /**
     * Sets the background image.
     * @param {URL} value - The background image.
     */
    set backgroundImage(i) {
      this.privBackgroundImage = i;
    }
    /**
     * Gets the remote ICE servers.
     * @remarks This method is designed to be used internally in the SDK.
     * @returns {RTCIceServer[]} The remote ICE servers.
     */
    get remoteIceServers() {
      return this.privRemoteIceServers;
    }
    /**
     * Sets the remote ICE servers.
     * @remarks Normally, the ICE servers are gathered from the PeerConnection,
     * set this property to override the ICE servers. E.g., the ICE servers are
     * different in client and server side.
     * @param {RTCIceServer[]} value - The remote ICE servers.
     */
    set remoteIceServers(i) {
      this.privRemoteIceServers = i;
    }
  };
  return ni.AvatarConfig = r, ni;
}
var na = {}, Qp;
function WP() {
  return Qp || (Qp = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AvatarEventArgs = e.AvatarEventTypes = void 0, function(r) {
      r.SwitchedToSpeaking = "SwitchedToSpeaking", r.SwitchedToIdle = "SwitchedToIdle", r.SessionClosed = "SessionClosed";
    }(e.AvatarEventTypes || (e.AvatarEventTypes = {}));
    class t {
      /**
       * Creates and initializes an instance of this class.
       * @constructor
       * @param {number} audioOffset - The audio offset.
       * @param {string} description - The description of the event.
       */
      constructor(o, i) {
        this.privOffset = o, this.privDescription = i;
      }
      /**
       * The type of the event.
       * @public
       * @returns {AvatarEventTypes} The type of the event.
       */
      get type() {
        return this.privType;
      }
      /**
       * The time offset associated with this event.
       * @public
       * @returns {number} The time offset associated with this event.
       */
      get offset() {
        return this.privOffset;
      }
      /**
       * The description of the event.
       * @public
       * @returns {string} The description of the event.
       */
      get description() {
        return this.privDescription;
      }
    }
    e.AvatarEventArgs = t;
  }(na)), na;
}
var ii = {}, si = {}, Yp;
function jv() {
  if (Yp) return si;
  Yp = 1, Object.defineProperty(si, "__esModule", { value: !0 }), si.SpeechSynthesisConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ le(), a = /* @__PURE__ */ et();
  let s = class {
    constructor() {
      this.synthesisUri = "/tts/cognitiveservices/websocket/v1";
    }
    async create(c, u, l) {
      let p = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, void 0), d = r.ConnectionFactoryBase.getHostSuffix(h), f = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), g = f === void 0 ? "tts" : "voice", m = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + h + "." + g + ".speech" + d), v = {}, y = {};
      if (u.token !== void 0 && u.token !== "" && (y[u.headerName] = u.token), y[i.HeaderNames.ConnectionId] = l, f !== void 0 && f !== "" && (!p || p.search(a.QueryParameterNames.CustomVoiceDeploymentId) === -1) && (v[a.QueryParameterNames.CustomVoiceDeploymentId] = f), c.avatarEnabled && (!p || p.search(a.QueryParameterNames.EnableAvatar) === -1) && (v[a.QueryParameterNames.EnableAvatar] = "true"), p) {
        const C = new URL(p), w = C.pathname;
        (w === "" || w === "/") && (C.pathname = this.synthesisUri, p = await r.ConnectionFactoryBase.getRedirectUrlFromEndpoint(C.toString()));
      }
      p || (p = m + this.synthesisUri), c.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, p);
      const S = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new e.WebsocketConnection(p, v, y, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromParameters(c.parameters), S, l);
    }
  };
  return si.SpeechSynthesisConnectionFactory = s, si;
}
var Zp;
function HP() {
  if (Zp) return ii;
  Zp = 1, Object.defineProperty(ii, "__esModule", { value: !0 }), ii.AvatarSynthesizer = void 0;
  const e = /* @__PURE__ */ jv(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ k(), o = /* @__PURE__ */ Ss(), i = /* @__PURE__ */ I(), a = /* @__PURE__ */ z(), s = /* @__PURE__ */ pc();
  let n = class extends i.Synthesizer {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {SpeechConfig} speechConfig - The speech config.
     * @param {AvatarConfig} avatarConfig - The talking avatar config.
     */
    constructor(u, l) {
      super(u), a.Contracts.throwIfNullOrUndefined(l, "avatarConfig"), this.privConnectionFactory = new e.SpeechSynthesisConnectionFactory(), this.privAvatarConfig = l, this.implCommonSynthesizeSetup();
    }
    implCommonSynthesizeSetup() {
      super.implCommonSynthesizeSetup(), this.privAdapter.audioOutputFormat = o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormat(i.SpeechSynthesisOutputFormat.Riff24Khz16BitMonoPcm);
    }
    /**
     * Starts the talking avatar session and establishes the WebRTC connection.
     * @member AvatarSynthesizer.prototype.startAvatarAsync
     * @function
     * @public
     * @param {AvatarWebRTCConnectionInfo} peerConnection - The peer connection.
     * @returns {Promise<SynthesisResult>} The promise of the connection result.
     */
    async startAvatarAsync(u) {
      a.Contracts.throwIfNullOrUndefined(u, "peerConnection"), this.privIceServers = u.getConfiguration().iceServers, a.Contracts.throwIfNullOrUndefined(this.privIceServers, "Ice servers must be set.");
      const l = new r.Deferred();
      u.onicegatheringstatechange = () => {
        r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering state: " + u.iceGatheringState, r.EventType.Debug)), u.iceGatheringState === "complete" && (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering complete.", r.EventType.Info)), l.resolve());
      }, u.onicecandidate = (g) => {
        g.candidate ? r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice candidate: " + g.candidate.candidate, r.EventType.Debug)) : (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice candidate: complete", r.EventType.Debug)), l.resolve());
      }, setTimeout(() => {
        u.iceGatheringState !== "complete" && (r.Events.instance.onEvent(new r.PlatformEvent("peer connection: ice gathering timeout.", r.EventType.Warning)), l.resolve());
      }, 2e3);
      const p = await u.createOffer();
      await u.setLocalDescription(p), await l.promise, r.Events.instance.onEvent(new r.PlatformEvent("peer connection: got local SDP.", r.EventType.Info)), this.privProperties.setProperty(i.PropertyId.TalkingAvatarService_WebRTC_SDP, JSON.stringify(u.localDescription));
      const h = await this.speak("", !1);
      if (h.reason !== i.ResultReason.SynthesizingAudioCompleted)
        return new i.SynthesisResult(h.resultId, h.reason, h.errorDetails, h.properties);
      const d = atob(h.properties.getProperty(i.PropertyId.TalkingAvatarService_WebRTC_SDP)), f = new RTCSessionDescription(JSON.parse(d));
      return await u.setRemoteDescription(f), new i.SynthesisResult(h.resultId, h.reason, void 0, h.properties);
    }
    /**
     * Speaks plain text asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakTextAsync
     * @function
     * @public
     * @param {string} text - The plain text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakTextAsync(u) {
      const l = await this.speak(u, !1);
      return new i.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
    }
    /**
     * Speaks SSML asynchronously. The rendered audio and video will be sent via the WebRTC connection.
     * @member AvatarSynthesizer.prototype.speakSsmlAsync
     * @function
     * @public
     * @param {string} ssml - The SSML text to speak.
     * @returns {Promise<SynthesisResult>} The promise of the synthesis result.
     */
    async speakSsmlAsync(u) {
      const l = await this.speak(u, !0);
      return new i.SynthesisResult(l.resultId, l.reason, l.errorDetails, l.properties);
    }
    /**
     * Speaks text asynchronously. The avatar will switch to idle state.
     * @member AvatarSynthesizer.prototype.stopSpeakingAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopSpeakingAsync() {
      for (; this.synthesisRequestQueue.length() > 0; )
        (await this.synthesisRequestQueue.dequeue()).err("Synthesis is canceled by user.");
      return this.privAdapter.stopSpeaking();
    }
    /**
     * Stops the talking avatar session and closes the WebRTC connection.
     * For now, this is the same as close().
     * You need to create a new AvatarSynthesizer instance to start a new session.
     * @member AvatarSynthesizer.prototype.stopAvatarAsync
     * @function
     * @public
     * @returns {Promise<void>} The promise of the void result.
     */
    async stopAvatarAsync() {
      return a.Contracts.throwIfDisposed(this.privDisposed), this.dispose(!0);
    }
    /**
     * Dispose of associated resources.
     * @member AvatarSynthesizer.prototype.close
     * @function
     * @public
     */
    async close() {
      if (!this.privDisposed)
        return this.dispose(!0);
    }
    /**
     * Gets the ICE servers. Internal use only.
     */
    get iceServers() {
      return this.privIceServers;
    }
    // Creates the synthesis adapter
    createSynthesisAdapter(u, l, p) {
      return new t.AvatarSynthesisAdapter(u, l, p, this, this.privAvatarConfig);
    }
    createRestSynthesisAdapter(u, l) {
    }
    createSynthesizerConfig(u) {
      const l = super.createSynthesizerConfig(u);
      return l.avatarEnabled = !0, l;
    }
    async speak(u, l) {
      const p = (0, r.createNoDashGuid)(), h = new r.Deferred();
      return this.synthesisRequestQueue.enqueue(new s.SynthesisRequest(p, u, l, (d) => {
        h.resolve(d), this.privSynthesizing = !1, this.adapterSpeak();
      }, (d) => {
        h.reject(d), this.privSynthesizing = !1;
      })), this.adapterSpeak(), h.promise;
    }
  };
  return ii.AvatarSynthesizer = n, ii;
}
var bt = {}, Xp;
function KP() {
  if (Xp) return bt;
  Xp = 1, Object.defineProperty(bt, "__esModule", { value: !0 }), bt.AvatarVideoFormat = bt.Coordinate = void 0;
  class e {
    constructor(o, i) {
      this.x = o, this.y = i;
    }
  }
  bt.Coordinate = e;
  let t = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {string} codec - The video codec.
     * @param {number} bitrate - The video bitrate.
     * @param {number} width - The video width.
     * @param {number} height - The video height.
     */
    constructor(o = "H264", i = 2e6, a = 1920, s = 1080) {
      this.codec = o, this.bitrate = i, this.width = a, this.height = s;
    }
    /**
     * Sets the video crop range.
     */
    setCropRange(o, i) {
      this.cropRange = {
        bottomRight: i,
        topLeft: o
      };
    }
  };
  return bt.AvatarVideoFormat = t, bt;
}
var oi = {}, ed;
function JP() {
  if (ed) return oi;
  ed = 1, Object.defineProperty(oi, "__esModule", { value: !0 }), oi.AvatarWebRTCConnectionResult = void 0;
  const e = /* @__PURE__ */ I();
  let t = class extends e.SynthesisResult {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param {RTCSessionDescriptionInit} SDPAnswer - The SDP answer of WebRTC connection.
     * @param {string} resultId - The result id.
     * @param {ResultReason} reason - The reason.
     * @param {string} errorDetails - Error details, if provided.
     * @param {PropertyCollection} properties - Additional properties, if provided.
     */
    constructor(o, i, a, s, n) {
      super(i, a, s, n), this.privSDPAnswer = o;
    }
    /**
     * Specifies SDP (Session Description Protocol) answer of WebRTC connection.
     * @member AvatarWebRTCConnectionResult.prototype.SDPAnswer
     * @function
     * @public
     * @returns {RTCSessionDescriptionInit} Specifies the SDP answer of WebRTC connection.
     */
    get SDPAnswer() {
      return this.privSDPAnswer;
    }
  };
  return oi.AvatarWebRTCConnectionResult = t, oi;
}
var ai = {}, td;
function GP() {
  if (td) return ai;
  td = 1, Object.defineProperty(ai, "__esModule", { value: !0 }), ai.Diagnostics = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ k();
  let r = class {
    static SetLoggingLevel(i) {
      this.privListener = new e.ConsoleLoggingListener(i), t.Events.instance.attachConsoleListener(this.privListener);
    }
    static StartConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !0);
    }
    static StopConsoleOutput() {
      this.privListener && (this.privListener.enableConsoleOutput = !1);
    }
    static SetLogOutputPath(i) {
      if (typeof window > "u")
        this.privListener && (this.privListener.logPath = i);
      else
        throw new Error("File system logging not available in browser.");
    }
    static set onLogOutput(i) {
      this.privListener && (this.privListener.logCallback = i);
    }
  };
  return ai.Diagnostics = r, r.privListener = void 0, ai;
}
var rd;
function I() {
  return rd || (rd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ConnectionEventArgs = e.CancellationErrorCode = e.CancellationDetails = e.CancellationDetailsBase = e.IntentRecognitionCanceledEventArgs = e.TranslationRecognitionCanceledEventArgs = e.NoMatchDetails = e.NoMatchReason = e.Translations = e.TranslationRecognizer = e.VoiceProfileType = e.IntentRecognizer = e.SpeechRecognizer = e.Recognizer = e.PropertyId = e.PropertyCollection = e.SpeechTranslationConfigImpl = e.SpeechTranslationConfig = e.SpeechConfigImpl = e.SpeechConfig = e.ResultReason = e.TranslationSynthesisResult = e.TranslationRecognitionResult = e.TranslationSynthesisEventArgs = e.TranslationRecognitionEventArgs = e.SpeechRecognitionCanceledEventArgs = e.MeetingTranscriptionEventArgs = e.ConversationTranscriptionEventArgs = e.SpeechRecognitionEventArgs = e.LanguageUnderstandingModel = e.IntentRecognitionResult = e.SpeechRecognitionResult = e.RecognitionResult = e.IntentRecognitionEventArgs = e.OutputFormat = e.RecognitionEventArgs = e.SessionEventArgs = e.KeywordRecognitionModel = e.PushAudioOutputStreamCallback = e.PullAudioInputStreamCallback = e.CancellationReason = e.PushAudioOutputStream = e.PullAudioOutputStream = e.AudioOutputStream = e.PushAudioInputStream = e.PullAudioInputStream = e.AudioInputStream = e.AudioFormatTag = e.AudioStreamFormat = e.AudioConfig = void 0, e.SpeechSynthesisEventArgs = e.SpeechSynthesisResult = e.SynthesisResult = e.SpeechSynthesizer = e.SpeechSynthesisOutputFormat = e.Synthesizer = e.User = e.ParticipantChangedReason = e.Participant = e.MeetingTranscriber = e.Meeting = e.ConversationTranscriptionResult = e.ConversationTranscriber = e.ConversationTranslator = e.ConversationTranslationResult = e.ConversationTranslationEventArgs = e.ConversationTranslationCanceledEventArgs = e.ConversationParticipantsChangedEventArgs = e.ConversationExpirationEventArgs = e.Conversation = e.SpeakerRecognitionCancellationDetails = e.SpeakerRecognitionResultType = e.SpeakerRecognitionResult = e.SourceLanguageConfig = e.AutoDetectSourceLanguageResult = e.AutoDetectSourceLanguageConfig = e.SpeakerVerificationModel = e.SpeakerIdentificationModel = e.SpeakerRecognizer = e.VoiceProfileClient = e.VoiceProfilePhraseResult = e.VoiceProfileCancellationDetails = e.VoiceProfileResult = e.VoiceProfileEnrollmentCancellationDetails = e.VoiceProfileEnrollmentResult = e.VoiceProfile = e.ConnectionMessage = e.ConnectionMessageEventArgs = e.BaseAudioPlayer = e.ProfanityOption = e.ServicePropertyChannel = e.TurnStatusReceivedEventArgs = e.ActivityReceivedEventArgs = e.DialogServiceConnector = e.CustomCommandsConfig = e.BotFrameworkConfig = e.DialogServiceConfig = e.PhraseListGrammar = e.Connection = e.ServiceEventArgs = void 0, e.LogLevel = e.Diagnostics = e.AvatarWebRTCConnectionResult = e.Coordinate = e.AvatarVideoFormat = e.AvatarSynthesizer = e.AvatarEventArgs = e.AvatarConfig = e.LanguageIdMode = e.PronunciationAssessmentResult = e.PronunciationAssessmentConfig = e.PronunciationAssessmentGranularity = e.PronunciationAssessmentGradingSystem = e.MeetingTranscriptionCanceledEventArgs = e.ConversationTranscriptionCanceledEventArgs = e.SpeakerAudioDestination = e.VoiceInfo = e.SynthesisVoiceType = e.SynthesisVoiceGender = e.SynthesisVoicesResult = e.SpeechSynthesisBoundaryType = e.SpeechSynthesisVisemeEventArgs = e.SpeechSynthesisBookmarkEventArgs = e.SpeechSynthesisWordBoundaryEventArgs = void 0;
    var t = /* @__PURE__ */ dv();
    Object.defineProperty(e, "AudioConfig", { enumerable: !0, get: function() {
      return t.AudioConfig;
    } });
    var r = /* @__PURE__ */ Nt();
    Object.defineProperty(e, "AudioStreamFormat", { enumerable: !0, get: function() {
      return r.AudioStreamFormat;
    } }), Object.defineProperty(e, "AudioFormatTag", { enumerable: !0, get: function() {
      return r.AudioFormatTag;
    } });
    var o = /* @__PURE__ */ uv();
    Object.defineProperty(e, "AudioInputStream", { enumerable: !0, get: function() {
      return o.AudioInputStream;
    } }), Object.defineProperty(e, "PullAudioInputStream", { enumerable: !0, get: function() {
      return o.PullAudioInputStream;
    } }), Object.defineProperty(e, "PushAudioInputStream", { enumerable: !0, get: function() {
      return o.PushAudioInputStream;
    } });
    var i = /* @__PURE__ */ Wt();
    Object.defineProperty(e, "AudioOutputStream", { enumerable: !0, get: function() {
      return i.AudioOutputStream;
    } }), Object.defineProperty(e, "PullAudioOutputStream", { enumerable: !0, get: function() {
      return i.PullAudioOutputStream;
    } }), Object.defineProperty(e, "PushAudioOutputStream", { enumerable: !0, get: function() {
      return i.PushAudioOutputStream;
    } });
    var a = /* @__PURE__ */ cR();
    Object.defineProperty(e, "CancellationReason", { enumerable: !0, get: function() {
      return a.CancellationReason;
    } });
    var s = /* @__PURE__ */ uR();
    Object.defineProperty(e, "PullAudioInputStreamCallback", { enumerable: !0, get: function() {
      return s.PullAudioInputStreamCallback;
    } });
    var n = /* @__PURE__ */ lR();
    Object.defineProperty(e, "PushAudioOutputStreamCallback", { enumerable: !0, get: function() {
      return n.PushAudioOutputStreamCallback;
    } });
    var c = /* @__PURE__ */ pR();
    Object.defineProperty(e, "KeywordRecognitionModel", { enumerable: !0, get: function() {
      return c.KeywordRecognitionModel;
    } });
    var u = /* @__PURE__ */ dR();
    Object.defineProperty(e, "SessionEventArgs", { enumerable: !0, get: function() {
      return u.SessionEventArgs;
    } });
    var l = /* @__PURE__ */ hR();
    Object.defineProperty(e, "RecognitionEventArgs", { enumerable: !0, get: function() {
      return l.RecognitionEventArgs;
    } });
    var p = /* @__PURE__ */ fR();
    Object.defineProperty(e, "OutputFormat", { enumerable: !0, get: function() {
      return p.OutputFormat;
    } });
    var h = /* @__PURE__ */ vR();
    Object.defineProperty(e, "IntentRecognitionEventArgs", { enumerable: !0, get: function() {
      return h.IntentRecognitionEventArgs;
    } });
    var d = /* @__PURE__ */ gR();
    Object.defineProperty(e, "RecognitionResult", { enumerable: !0, get: function() {
      return d.RecognitionResult;
    } });
    var f = /* @__PURE__ */ mR();
    Object.defineProperty(e, "SpeechRecognitionResult", { enumerable: !0, get: function() {
      return f.SpeechRecognitionResult;
    } });
    var g = /* @__PURE__ */ yR();
    Object.defineProperty(e, "IntentRecognitionResult", { enumerable: !0, get: function() {
      return g.IntentRecognitionResult;
    } });
    var m = /* @__PURE__ */ SR();
    Object.defineProperty(e, "LanguageUnderstandingModel", { enumerable: !0, get: function() {
      return m.LanguageUnderstandingModel;
    } });
    var v = /* @__PURE__ */ CR();
    Object.defineProperty(e, "SpeechRecognitionEventArgs", { enumerable: !0, get: function() {
      return v.SpeechRecognitionEventArgs;
    } }), Object.defineProperty(e, "ConversationTranscriptionEventArgs", { enumerable: !0, get: function() {
      return v.ConversationTranscriptionEventArgs;
    } }), Object.defineProperty(e, "MeetingTranscriptionEventArgs", { enumerable: !0, get: function() {
      return v.MeetingTranscriptionEventArgs;
    } });
    var y = /* @__PURE__ */ RR();
    Object.defineProperty(e, "SpeechRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return y.SpeechRecognitionCanceledEventArgs;
    } });
    var S = /* @__PURE__ */ PR();
    Object.defineProperty(e, "TranslationRecognitionEventArgs", { enumerable: !0, get: function() {
      return S.TranslationRecognitionEventArgs;
    } });
    var C = /* @__PURE__ */ wR();
    Object.defineProperty(e, "TranslationSynthesisEventArgs", { enumerable: !0, get: function() {
      return C.TranslationSynthesisEventArgs;
    } });
    var w = /* @__PURE__ */ fv();
    Object.defineProperty(e, "TranslationRecognitionResult", { enumerable: !0, get: function() {
      return w.TranslationRecognitionResult;
    } });
    var b = /* @__PURE__ */ bR();
    Object.defineProperty(e, "TranslationSynthesisResult", { enumerable: !0, get: function() {
      return b.TranslationSynthesisResult;
    } });
    var A = /* @__PURE__ */ ER();
    Object.defineProperty(e, "ResultReason", { enumerable: !0, get: function() {
      return A.ResultReason;
    } });
    var E = /* @__PURE__ */ IR();
    Object.defineProperty(e, "SpeechConfig", { enumerable: !0, get: function() {
      return E.SpeechConfig;
    } }), Object.defineProperty(e, "SpeechConfigImpl", { enumerable: !0, get: function() {
      return E.SpeechConfigImpl;
    } });
    var M = /* @__PURE__ */ AR();
    Object.defineProperty(e, "SpeechTranslationConfig", { enumerable: !0, get: function() {
      return M.SpeechTranslationConfig;
    } }), Object.defineProperty(e, "SpeechTranslationConfigImpl", { enumerable: !0, get: function() {
      return M.SpeechTranslationConfigImpl;
    } });
    var R = /* @__PURE__ */ gv();
    Object.defineProperty(e, "PropertyCollection", { enumerable: !0, get: function() {
      return R.PropertyCollection;
    } });
    var j = /* @__PURE__ */ cc();
    Object.defineProperty(e, "PropertyId", { enumerable: !0, get: function() {
      return j.PropertyId;
    } });
    var T = /* @__PURE__ */ TR();
    Object.defineProperty(e, "Recognizer", { enumerable: !0, get: function() {
      return T.Recognizer;
    } });
    var D = /* @__PURE__ */ _R();
    Object.defineProperty(e, "SpeechRecognizer", { enumerable: !0, get: function() {
      return D.SpeechRecognizer;
    } });
    var q = /* @__PURE__ */ kR();
    Object.defineProperty(e, "IntentRecognizer", { enumerable: !0, get: function() {
      return q.IntentRecognizer;
    } });
    var pe = /* @__PURE__ */ OR();
    Object.defineProperty(e, "VoiceProfileType", { enumerable: !0, get: function() {
      return pe.VoiceProfileType;
    } });
    var W = /* @__PURE__ */ MR();
    Object.defineProperty(e, "TranslationRecognizer", { enumerable: !0, get: function() {
      return W.TranslationRecognizer;
    } });
    var G = /* @__PURE__ */ DR();
    Object.defineProperty(e, "Translations", { enumerable: !0, get: function() {
      return G.Translations;
    } });
    var re = /* @__PURE__ */ NR();
    Object.defineProperty(e, "NoMatchReason", { enumerable: !0, get: function() {
      return re.NoMatchReason;
    } });
    var oe = /* @__PURE__ */ xR();
    Object.defineProperty(e, "NoMatchDetails", { enumerable: !0, get: function() {
      return oe.NoMatchDetails;
    } });
    var me = /* @__PURE__ */ zR();
    Object.defineProperty(e, "TranslationRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return me.TranslationRecognitionCanceledEventArgs;
    } });
    var V = /* @__PURE__ */ LR();
    Object.defineProperty(e, "IntentRecognitionCanceledEventArgs", { enumerable: !0, get: function() {
      return V.IntentRecognitionCanceledEventArgs;
    } });
    var te = /* @__PURE__ */ wv();
    Object.defineProperty(e, "CancellationDetailsBase", { enumerable: !0, get: function() {
      return te.CancellationDetailsBase;
    } });
    var Pe = /* @__PURE__ */ jR();
    Object.defineProperty(e, "CancellationDetails", { enumerable: !0, get: function() {
      return Pe.CancellationDetails;
    } });
    var ye = /* @__PURE__ */ qR();
    Object.defineProperty(e, "CancellationErrorCode", { enumerable: !0, get: function() {
      return ye.CancellationErrorCode;
    } });
    var Kt = /* @__PURE__ */ FR();
    Object.defineProperty(e, "ConnectionEventArgs", { enumerable: !0, get: function() {
      return Kt.ConnectionEventArgs;
    } });
    var xe = /* @__PURE__ */ BR();
    Object.defineProperty(e, "ServiceEventArgs", { enumerable: !0, get: function() {
      return xe.ServiceEventArgs;
    } });
    var ze = /* @__PURE__ */ Cv();
    Object.defineProperty(e, "Connection", { enumerable: !0, get: function() {
      return ze.Connection;
    } });
    var xt = /* @__PURE__ */ UR();
    Object.defineProperty(e, "PhraseListGrammar", { enumerable: !0, get: function() {
      return xt.PhraseListGrammar;
    } });
    var we = /* @__PURE__ */ uc();
    Object.defineProperty(e, "DialogServiceConfig", { enumerable: !0, get: function() {
      return we.DialogServiceConfig;
    } });
    var Jt = /* @__PURE__ */ $R();
    Object.defineProperty(e, "BotFrameworkConfig", { enumerable: !0, get: function() {
      return Jt.BotFrameworkConfig;
    } });
    var tt = /* @__PURE__ */ VR();
    Object.defineProperty(e, "CustomCommandsConfig", { enumerable: !0, get: function() {
      return tt.CustomCommandsConfig;
    } });
    var rt = /* @__PURE__ */ HR();
    Object.defineProperty(e, "DialogServiceConnector", { enumerable: !0, get: function() {
      return rt.DialogServiceConnector;
    } });
    var He = /* @__PURE__ */ KR();
    Object.defineProperty(e, "ActivityReceivedEventArgs", { enumerable: !0, get: function() {
      return He.ActivityReceivedEventArgs;
    } });
    var nt = /* @__PURE__ */ GR();
    Object.defineProperty(e, "TurnStatusReceivedEventArgs", { enumerable: !0, get: function() {
      return nt.TurnStatusReceivedEventArgs;
    } });
    var de = /* @__PURE__ */ QR();
    Object.defineProperty(e, "ServicePropertyChannel", { enumerable: !0, get: function() {
      return de.ServicePropertyChannel;
    } });
    var Rs = /* @__PURE__ */ YR();
    Object.defineProperty(e, "ProfanityOption", { enumerable: !0, get: function() {
      return Rs.ProfanityOption;
    } });
    var Ps = /* @__PURE__ */ ZR();
    Object.defineProperty(e, "BaseAudioPlayer", { enumerable: !0, get: function() {
      return Ps.BaseAudioPlayer;
    } });
    var ws = /* @__PURE__ */ XR();
    Object.defineProperty(e, "ConnectionMessageEventArgs", { enumerable: !0, get: function() {
      return ws.ConnectionMessageEventArgs;
    } });
    var zt = /* @__PURE__ */ Sv();
    Object.defineProperty(e, "ConnectionMessage", { enumerable: !0, get: function() {
      return zt.ConnectionMessage;
    } });
    var Oe = /* @__PURE__ */ eP();
    Object.defineProperty(e, "VoiceProfile", { enumerable: !0, get: function() {
      return Oe.VoiceProfile;
    } });
    var Ke = /* @__PURE__ */ tP();
    Object.defineProperty(e, "VoiceProfileEnrollmentResult", { enumerable: !0, get: function() {
      return Ke.VoiceProfileEnrollmentResult;
    } }), Object.defineProperty(e, "VoiceProfileEnrollmentCancellationDetails", { enumerable: !0, get: function() {
      return Ke.VoiceProfileEnrollmentCancellationDetails;
    } });
    var ae = /* @__PURE__ */ rP();
    Object.defineProperty(e, "VoiceProfileResult", { enumerable: !0, get: function() {
      return ae.VoiceProfileResult;
    } }), Object.defineProperty(e, "VoiceProfileCancellationDetails", { enumerable: !0, get: function() {
      return ae.VoiceProfileCancellationDetails;
    } });
    var Gt = /* @__PURE__ */ nP();
    Object.defineProperty(e, "VoiceProfilePhraseResult", { enumerable: !0, get: function() {
      return Gt.VoiceProfilePhraseResult;
    } });
    var F = /* @__PURE__ */ iP();
    Object.defineProperty(e, "VoiceProfileClient", { enumerable: !0, get: function() {
      return F.VoiceProfileClient;
    } });
    var X = /* @__PURE__ */ sP();
    Object.defineProperty(e, "SpeakerRecognizer", { enumerable: !0, get: function() {
      return X.SpeakerRecognizer;
    } });
    var Lt = /* @__PURE__ */ oP();
    Object.defineProperty(e, "SpeakerIdentificationModel", { enumerable: !0, get: function() {
      return Lt.SpeakerIdentificationModel;
    } });
    var bs = /* @__PURE__ */ aP();
    Object.defineProperty(e, "SpeakerVerificationModel", { enumerable: !0, get: function() {
      return bs.SpeakerVerificationModel;
    } });
    var Xs = /* @__PURE__ */ cP();
    Object.defineProperty(e, "AutoDetectSourceLanguageConfig", { enumerable: !0, get: function() {
      return Xs.AutoDetectSourceLanguageConfig;
    } });
    var Es = /* @__PURE__ */ uP();
    Object.defineProperty(e, "AutoDetectSourceLanguageResult", { enumerable: !0, get: function() {
      return Es.AutoDetectSourceLanguageResult;
    } });
    var Is = /* @__PURE__ */ lP();
    Object.defineProperty(e, "SourceLanguageConfig", { enumerable: !0, get: function() {
      return Is.SourceLanguageConfig;
    } });
    var Je = /* @__PURE__ */ pP();
    Object.defineProperty(e, "SpeakerRecognitionResult", { enumerable: !0, get: function() {
      return Je.SpeakerRecognitionResult;
    } }), Object.defineProperty(e, "SpeakerRecognitionResultType", { enumerable: !0, get: function() {
      return Je.SpeakerRecognitionResultType;
    } }), Object.defineProperty(e, "SpeakerRecognitionCancellationDetails", { enumerable: !0, get: function() {
      return Je.SpeakerRecognitionCancellationDetails;
    } });
    var ne = /* @__PURE__ */ lc();
    Object.defineProperty(e, "Conversation", { enumerable: !0, get: function() {
      return ne.Conversation;
    } }), Object.defineProperty(e, "ConversationExpirationEventArgs", { enumerable: !0, get: function() {
      return ne.ConversationExpirationEventArgs;
    } }), Object.defineProperty(e, "ConversationParticipantsChangedEventArgs", { enumerable: !0, get: function() {
      return ne.ConversationParticipantsChangedEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationCanceledEventArgs", { enumerable: !0, get: function() {
      return ne.ConversationTranslationCanceledEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationEventArgs", { enumerable: !0, get: function() {
      return ne.ConversationTranslationEventArgs;
    } }), Object.defineProperty(e, "ConversationTranslationResult", { enumerable: !0, get: function() {
      return ne.ConversationTranslationResult;
    } }), Object.defineProperty(e, "ConversationTranslator", { enumerable: !0, get: function() {
      return ne.ConversationTranslator;
    } }), Object.defineProperty(e, "ConversationTranscriber", { enumerable: !0, get: function() {
      return ne.ConversationTranscriber;
    } }), Object.defineProperty(e, "ConversationTranscriptionResult", { enumerable: !0, get: function() {
      return ne.ConversationTranscriptionResult;
    } }), Object.defineProperty(e, "Meeting", { enumerable: !0, get: function() {
      return ne.Meeting;
    } }), Object.defineProperty(e, "MeetingTranscriber", { enumerable: !0, get: function() {
      return ne.MeetingTranscriber;
    } }), Object.defineProperty(e, "Participant", { enumerable: !0, get: function() {
      return ne.Participant;
    } }), Object.defineProperty(e, "ParticipantChangedReason", { enumerable: !0, get: function() {
      return ne.ParticipantChangedReason;
    } }), Object.defineProperty(e, "User", { enumerable: !0, get: function() {
      return ne.User;
    } });
    var eo = /* @__PURE__ */ pc();
    Object.defineProperty(e, "Synthesizer", { enumerable: !0, get: function() {
      return eo.Synthesizer;
    } });
    var K = /* @__PURE__ */ lv();
    Object.defineProperty(e, "SpeechSynthesisOutputFormat", { enumerable: !0, get: function() {
      return K.SpeechSynthesisOutputFormat;
    } });
    var ie = /* @__PURE__ */ AP();
    Object.defineProperty(e, "SpeechSynthesizer", { enumerable: !0, get: function() {
      return ie.SpeechSynthesizer;
    } });
    var U = /* @__PURE__ */ TP();
    Object.defineProperty(e, "SynthesisResult", { enumerable: !0, get: function() {
      return U.SynthesisResult;
    } });
    var be = /* @__PURE__ */ _P();
    Object.defineProperty(e, "SpeechSynthesisResult", { enumerable: !0, get: function() {
      return be.SpeechSynthesisResult;
    } });
    var it = /* @__PURE__ */ kP();
    Object.defineProperty(e, "SpeechSynthesisEventArgs", { enumerable: !0, get: function() {
      return it.SpeechSynthesisEventArgs;
    } });
    var J = /* @__PURE__ */ OP();
    Object.defineProperty(e, "SpeechSynthesisWordBoundaryEventArgs", { enumerable: !0, get: function() {
      return J.SpeechSynthesisWordBoundaryEventArgs;
    } });
    var Ee = /* @__PURE__ */ MP();
    Object.defineProperty(e, "SpeechSynthesisBookmarkEventArgs", { enumerable: !0, get: function() {
      return Ee.SpeechSynthesisBookmarkEventArgs;
    } });
    var Se = /* @__PURE__ */ DP();
    Object.defineProperty(e, "SpeechSynthesisVisemeEventArgs", { enumerable: !0, get: function() {
      return Se.SpeechSynthesisVisemeEventArgs;
    } });
    var Qt = /* @__PURE__ */ NP();
    Object.defineProperty(e, "SpeechSynthesisBoundaryType", { enumerable: !0, get: function() {
      return Qt.SpeechSynthesisBoundaryType;
    } });
    var to = /* @__PURE__ */ xP();
    Object.defineProperty(e, "SynthesisVoicesResult", { enumerable: !0, get: function() {
      return to.SynthesisVoicesResult;
    } });
    var Yt = /* @__PURE__ */ zP();
    Object.defineProperty(e, "SynthesisVoiceGender", { enumerable: !0, get: function() {
      return Yt.SynthesisVoiceGender;
    } }), Object.defineProperty(e, "SynthesisVoiceType", { enumerable: !0, get: function() {
      return Yt.SynthesisVoiceType;
    } }), Object.defineProperty(e, "VoiceInfo", { enumerable: !0, get: function() {
      return Yt.VoiceInfo;
    } });
    var ro = /* @__PURE__ */ LP();
    Object.defineProperty(e, "SpeakerAudioDestination", { enumerable: !0, get: function() {
      return ro.SpeakerAudioDestination;
    } });
    var no = /* @__PURE__ */ jP();
    Object.defineProperty(e, "ConversationTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return no.ConversationTranscriptionCanceledEventArgs;
    } });
    var io = /* @__PURE__ */ qP();
    Object.defineProperty(e, "MeetingTranscriptionCanceledEventArgs", { enumerable: !0, get: function() {
      return io.MeetingTranscriptionCanceledEventArgs;
    } });
    var so = /* @__PURE__ */ FP();
    Object.defineProperty(e, "PronunciationAssessmentGradingSystem", { enumerable: !0, get: function() {
      return so.PronunciationAssessmentGradingSystem;
    } });
    var oo = /* @__PURE__ */ BP();
    Object.defineProperty(e, "PronunciationAssessmentGranularity", { enumerable: !0, get: function() {
      return oo.PronunciationAssessmentGranularity;
    } });
    var ao = /* @__PURE__ */ UP();
    Object.defineProperty(e, "PronunciationAssessmentConfig", { enumerable: !0, get: function() {
      return ao.PronunciationAssessmentConfig;
    } });
    var mg = /* @__PURE__ */ $P();
    Object.defineProperty(e, "PronunciationAssessmentResult", { enumerable: !0, get: function() {
      return mg.PronunciationAssessmentResult;
    } });
    var yg = /* @__PURE__ */ Tv();
    Object.defineProperty(e, "LanguageIdMode", { enumerable: !0, get: function() {
      return yg.LanguageIdMode;
    } });
    var Sg = /* @__PURE__ */ VP();
    Object.defineProperty(e, "AvatarConfig", { enumerable: !0, get: function() {
      return Sg.AvatarConfig;
    } });
    var Cg = /* @__PURE__ */ WP();
    Object.defineProperty(e, "AvatarEventArgs", { enumerable: !0, get: function() {
      return Cg.AvatarEventArgs;
    } });
    var Rg = /* @__PURE__ */ HP();
    Object.defineProperty(e, "AvatarSynthesizer", { enumerable: !0, get: function() {
      return Rg.AvatarSynthesizer;
    } });
    var vc = /* @__PURE__ */ KP();
    Object.defineProperty(e, "AvatarVideoFormat", { enumerable: !0, get: function() {
      return vc.AvatarVideoFormat;
    } }), Object.defineProperty(e, "Coordinate", { enumerable: !0, get: function() {
      return vc.Coordinate;
    } });
    var Pg = /* @__PURE__ */ JP();
    Object.defineProperty(e, "AvatarWebRTCConnectionResult", { enumerable: !0, get: function() {
      return Pg.AvatarWebRTCConnectionResult;
    } });
    var wg = /* @__PURE__ */ GP();
    Object.defineProperty(e, "Diagnostics", { enumerable: !0, get: function() {
      return wg.Diagnostics;
    } });
    var bg = /* @__PURE__ */ ov();
    Object.defineProperty(e, "LogLevel", { enumerable: !0, get: function() {
      return bg.LogLevel;
    } });
  }(zo)), zo;
}
var nd;
function QP() {
  if (nd) return Nr;
  nd = 1, Object.defineProperty(Nr, "__esModule", { value: !0 }), Nr.ProxyInfo = void 0;
  const e = /* @__PURE__ */ I();
  let t = class qv {
    constructor(o, i, a, s) {
      this.privProxyHostName = o, this.privProxyPort = i, this.privProxyUserName = a, this.privProxyPassword = s;
    }
    static fromParameters(o) {
      return new qv(o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyHostName), parseInt(o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyPort), 10), o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyUserName), o.getProperty(e.PropertyId.SpeechServiceConnection_ProxyPassword));
    }
    static fromRecognizerConfig(o) {
      return this.fromParameters(o.parameters);
    }
    get HostName() {
      return this.privProxyHostName;
    }
    get Port() {
      return this.privProxyPort;
    }
    get UserName() {
      return this.privProxyUserName;
    }
    get Password() {
      return this.privProxyPassword;
    }
  };
  return Nr.ProxyInfo = t, Nr;
}
var ci = {}, ia, id;
function YP() {
  if (id) return ia;
  id = 1;
  const e = /* @__PURE__ */ new Set(["json", "buffer", "string"]);
  return ia = (t) => (...r) => {
    const o = /* @__PURE__ */ new Set();
    let i, a, s, n = "";
    return r.forEach((c) => {
      if (typeof c == "string")
        if (c.toUpperCase() === c)
          if (i) {
            const u = `Can't set method to ${c}, already set to ${i}.`;
            throw new Error(u);
          } else
            i = c;
        else if (c.startsWith("http:") || c.startsWith("https:"))
          n = c;
        else if (e.has(c))
          a = c;
        else
          throw new Error(`Unknown encoding, ${c}`);
      else if (typeof c == "number")
        o.add(c);
      else if (typeof c == "object")
        if (Array.isArray(c) || c instanceof Set)
          c.forEach((u) => o.add(u));
        else {
          if (s)
            throw new Error("Cannot set headers twice.");
          s = c;
        }
      else
        throw new Error(`Unknown type: ${typeof c}`);
    }), i || (i = "GET"), o.size === 0 && o.add(200), t(o, i, a, s, n);
  }, ia;
}
var sa, sd;
function ZP() {
  if (sd) return sa;
  sd = 1;
  const e = YP();
  class t extends Error {
    constructor(i, ...a) {
      super(...a), Error.captureStackTrace && Error.captureStackTrace(this, t), this.name = "StatusError", this.message = i.statusMessage, this.statusCode = i.status, this.res = i, this.json = i.json.bind(i), this.text = i.text.bind(i), this.arrayBuffer = i.arrayBuffer.bind(i);
      let s;
      Object.defineProperty(this, "responseBody", { get: () => (s || (s = this.arrayBuffer()), s) }), this.headers = {};
      for (const [c, u] of i.headers.entries())
        this.headers[c.toLowerCase()] = u;
    }
  }
  return sa = e((o, i, a, s, n) => async (c, u, l = {}) => {
    c = n + (c || "");
    let p = new URL(c);
    if (s || (s = {}), p.username && (s.Authorization = "Basic " + btoa(p.username + ":" + p.password), p = new URL(p.protocol + "//" + p.host + p.pathname + p.search)), p.protocol !== "https:" && p.protocol !== "http:")
      throw new Error(`Unknown protocol, ${p.protocol}`);
    if (u && !(u instanceof ArrayBuffer || ArrayBuffer.isView(u) || typeof u == "string"))
      if (typeof u == "object")
        u = JSON.stringify(u), s["Content-Type"] = "application/json";
      else
        throw new Error("Unknown body type.");
    l = new Headers({ ...s || {}, ...l });
    const h = await fetch(p, { method: i, headers: l, body: u });
    if (h.statusCode = h.status, !o.has(h.status))
      throw new t(h);
    return a === "json" ? h.json() : a === "buffer" ? h.arrayBuffer() : a === "string" ? h.text() : h;
  }), sa;
}
var od;
function XP() {
  return od || (od = 1, function(e) {
    var t = ci && ci.__importDefault || function(s) {
      return s && s.__esModule ? s : { default: s };
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RestMessageAdapter = e.RestRequestType = void 0;
    const r = t(ZP()), o = /* @__PURE__ */ k();
    var i;
    (function(s) {
      s.Get = "GET", s.Post = "POST", s.Delete = "DELETE", s.File = "file";
    })(i = e.RestRequestType || (e.RestRequestType = {}));
    let a = class {
      constructor(n) {
        if (!n)
          throw new o.ArgumentNullError("configParams");
        this.privHeaders = n.headers, this.privIgnoreCache = n.ignoreCache;
      }
      static extractHeaderValue(n, c) {
        let u = "";
        try {
          const l = c.trim().split(/[\r\n]+/), p = {};
          l.forEach((h) => {
            const d = h.split(": "), f = d.shift().toLowerCase(), g = d.join(": ");
            p[f] = g;
          }), u = p[n.toLowerCase()];
        } catch {
        }
        return u;
      }
      set options(n) {
        this.privHeaders = n.headers, this.privIgnoreCache = n.ignoreCache;
      }
      setHeaders(n, c) {
        this.privHeaders[n] = c;
      }
      request(n, c, u = {}, l = null) {
        const p = new o.Deferred(), h = n === i.File ? "POST" : n, d = (g, m = {}) => {
          const v = g;
          return {
            data: JSON.stringify(m),
            headers: JSON.stringify(g.headers),
            json: m,
            ok: g.statusCode >= 200 && g.statusCode < 300,
            status: g.statusCode,
            statusText: m.error ? m.error.message : v.statusText ? v.statusText : v.statusMessage
          };
        }, f = (g) => {
          const m = (0, r.default)(c, h, this.privHeaders, 200, 201, 202, 204, 400, 401, 402, 403, 404), v = this.queryParams(u) === "" ? "" : `?${this.queryParams(u)}`;
          m(v, g).then(async (y) => {
            if (n === i.Delete || y.statusCode === 204)
              p.resolve(d(y));
            else
              try {
                const S = await y.json();
                p.resolve(d(y, S));
              } catch {
                p.resolve(d(y));
              }
          }).catch((y) => {
            p.reject(y);
          });
        };
        return this.privIgnoreCache && (this.privHeaders["Cache-Control"] = "no-cache"), n === i.Post && l && (this.privHeaders["content-type"] = "application/json", this.privHeaders["Content-Type"] = "application/json"), f(l), p.promise;
      }
      queryParams(n = {}) {
        return Object.keys(n).map((c) => encodeURIComponent(c) + "=" + encodeURIComponent(n[c])).join("&");
      }
    };
    e.RestMessageAdapter = a;
  }(ci)), ci;
}
var ui = {}, ad;
function Fv() {
  if (ad) return ui;
  ad = 1, Object.defineProperty(ui, "__esModule", { value: !0 }), ui.RestConfigBase = void 0;
  let e = class Ds {
    static get requestOptions() {
      return Ds.privDefaultRequestOptions;
    }
    static get configParams() {
      return Ds.privDefaultParams;
    }
    static get restErrors() {
      return Ds.privRestErrors;
    }
  };
  return ui.RestConfigBase = e, e.privDefaultRequestOptions = {
    headers: {
      Accept: "application/json"
    },
    ignoreCache: !1,
    timeout: 1e4
  }, e.privRestErrors = {
    authInvalidSubscriptionKey: "You must specify either an authentication token to use, or a Cognitive Speech subscription key.",
    authInvalidSubscriptionRegion: "You must specify the Cognitive Speech region to use.",
    invalidArgs: "Required input not found: {arg}.",
    invalidCreateJoinConversationResponse: "Creating/Joining conversation failed with HTTP {status}.",
    invalidParticipantRequest: "The requested participant was not found.",
    permissionDeniedConnect: "Required credentials not found.",
    permissionDeniedConversation: "Invalid operation: only the host can {command} the conversation.",
    permissionDeniedParticipant: "Invalid operation: only the host can {command} a participant.",
    permissionDeniedSend: "Invalid operation: the conversation is not in a connected state.",
    permissionDeniedStart: "Invalid operation: there is already an active conversation."
  }, e.privDefaultParams = {
    apiVersion: "api-version",
    authorization: "Authorization",
    clientAppId: "X-ClientAppId",
    contentTypeKey: "Content-Type",
    correlationId: "X-CorrelationId",
    languageCode: "language",
    nickname: "nickname",
    profanity: "profanity",
    requestId: "X-RequestId",
    roomId: "roomid",
    sessionToken: "token",
    subscriptionKey: "Ocp-Apim-Subscription-Key",
    subscriptionRegion: "Ocp-Apim-Subscription-Region",
    token: "X-CapitoToken"
  }, ui;
}
var cd;
function ee() {
  return cd || (cd = 1, function(e) {
    var t = pt && pt.__createBinding || (Object.create ? function(o, i, a, s) {
      s === void 0 && (s = a), Object.defineProperty(o, s, { enumerable: !0, get: function() {
        return i[a];
      } });
    } : function(o, i, a, s) {
      s === void 0 && (s = a), o[s] = i[a];
    }), r = pt && pt.__exportStar || function(o, i) {
      for (var a in o) a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, o, a);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), r(/* @__PURE__ */ tR(), e), r(/* @__PURE__ */ rR(), e), r(/* @__PURE__ */ nR(), e), r(/* @__PURE__ */ iR(), e), r(/* @__PURE__ */ sR(), e), r(/* @__PURE__ */ oR(), e), r(/* @__PURE__ */ av(), e), r(/* @__PURE__ */ aR(), e), r(/* @__PURE__ */ QP(), e), r(/* @__PURE__ */ XP(), e), r(/* @__PURE__ */ Fv(), e);
  }(pt)), pt;
}
var ud;
function ew() {
  if (ud) return Tr;
  ud = 1, Object.defineProperty(Tr, "__esModule", { value: !0 }), Tr.IntentConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ le();
  let a = class extends r.ConnectionFactoryBase {
    create(n, c, u) {
      let l = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint);
      if (!l) {
        const f = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_IntentRegion), g = r.ConnectionFactoryBase.getHostSuffix(f);
        l = n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + f + ".sr.speech" + g) + "/speech/recognition/interactive/cognitiveservices/v1";
      }
      const p = {
        format: "simple",
        language: n.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(n, p, l);
      const h = {};
      c.token !== void 0 && c.token !== "" && (h[c.headerName] = c.token), h[i.HeaderNames.ConnectionId] = u, n.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, l);
      const d = n.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(l, p, h, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(n), d, u));
    }
    getSpeechRegionFromIntentRegion(n) {
      switch (n) {
        case "West US":
        case "US West":
        case "westus":
          return "uswest";
        case "West US 2":
        case "US West 2":
        case "westus2":
          return "uswest2";
        case "South Central US":
        case "US South Central":
        case "southcentralus":
          return "ussouthcentral";
        case "West Central US":
        case "US West Central":
        case "westcentralus":
          return "uswestcentral";
        case "East US":
        case "US East":
        case "eastus":
          return "useast";
        case "East US 2":
        case "US East 2":
        case "eastus2":
          return "useast2";
        case "West Europe":
        case "Europe West":
        case "westeurope":
          return "europewest";
        case "North Europe":
        case "Europe North":
        case "northeurope":
          return "europenorth";
        case "Brazil South":
        case "South Brazil":
        case "southbrazil":
          return "brazilsouth";
        case "Australia East":
        case "East Australia":
        case "eastaustralia":
          return "australiaeast";
        case "Southeast Asia":
        case "Asia Southeast":
        case "southeastasia":
          return "asiasoutheast";
        case "East Asia":
        case "Asia East":
        case "eastasia":
          return "asiaeast";
        default:
          return n;
      }
    }
  };
  return Tr.IntentConnectionFactory = a, Tr;
}
var Et = {}, ld;
function tw() {
  if (ld) return Et;
  ld = 1, Object.defineProperty(Et, "__esModule", { value: !0 }), Et.VoiceProfileConnectionFactory = Et.SpeakerRecognitionConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ le();
  class a extends r.ConnectionFactoryBase {
    create(u, l, p, h) {
      let d = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint);
      if (!d) {
        const v = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region), y = r.ConnectionFactoryBase.getHostSuffix(v), S = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, `wss://${v}.spr-frontend.speech${y}`), C = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_SpeakerIdMode, "TextIndependentIdentification");
        d = `${S}/speaker/ws/${this.scenarioToPath(C)}/${p}`;
      }
      const f = {
        format: "simple",
        language: u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage)
      };
      this.setCommonUrlParams(u, f, d);
      const g = {};
      l.token !== void 0 && l.token !== "" && (g[l.headerName] = l.token), g[i.HeaderNames.ConnectionId] = h, g[i.HeaderNames.SpIDAuthKey] = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Key), u.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, d);
      const m = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(d, f, g, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), m, h));
    }
    scenarioToPath(u) {
      switch (u) {
        case "TextIndependentVerification":
        case "2":
          return "verification/text-independent";
        case "TextDependentVerification":
        case "1":
          return "verification/text-dependent";
        default:
          return "identification/text-independent";
      }
    }
  }
  let s = class extends a {
    create(u, l, p) {
      return super.create(u, l, "recognition", p);
    }
  };
  Et.SpeakerRecognitionConnectionFactory = s;
  class n extends a {
    create(u, l, p) {
      return super.create(u, l, "profile", p);
    }
  }
  return Et.VoiceProfileConnectionFactory = n, Et;
}
var oa = {}, pd;
function dc() {
  return pd || (pd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionEndedEvent = e.RecognitionCompletionStatus = e.RecognitionStartedEvent = e.ConnectingToServiceEvent = e.ListeningStartedEvent = e.RecognitionTriggeredEvent = e.SpeechRecognitionEvent = void 0;
    const t = /* @__PURE__ */ k();
    class r extends t.PlatformEvent {
      constructor(l, p, h, d = t.EventType.Info) {
        super(l, d), this.privRequestId = p, this.privSessionId = h;
      }
      get requestId() {
        return this.privRequestId;
      }
      get sessionId() {
        return this.privSessionId;
      }
    }
    e.SpeechRecognitionEvent = r;
    class o extends r {
      constructor(l, p, h, d) {
        super("RecognitionTriggeredEvent", l, p), this.privAudioSourceId = h, this.privAudioNodeId = d;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
    }
    e.RecognitionTriggeredEvent = o;
    class i extends r {
      constructor(l, p, h, d) {
        super("ListeningStartedEvent", l, p), this.privAudioSourceId = h, this.privAudioNodeId = d;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
    }
    e.ListeningStartedEvent = i;
    class a extends r {
      constructor(l, p, h) {
        super("ConnectingToServiceEvent", l, h), this.privAuthFetchEventid = p;
      }
      get authFetchEventid() {
        return this.privAuthFetchEventid;
      }
    }
    e.ConnectingToServiceEvent = a;
    class s extends r {
      constructor(l, p, h, d, f) {
        super("RecognitionStartedEvent", l, f), this.privAudioSourceId = p, this.privAudioNodeId = h, this.privAuthFetchEventId = d;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
      get authFetchEventId() {
        return this.privAuthFetchEventId;
      }
    }
    e.RecognitionStartedEvent = s;
    var n;
    (function(u) {
      u[u.Success = 0] = "Success", u[u.AudioSourceError = 1] = "AudioSourceError", u[u.AudioSourceTimeout = 2] = "AudioSourceTimeout", u[u.AuthTokenFetchError = 3] = "AuthTokenFetchError", u[u.AuthTokenFetchTimeout = 4] = "AuthTokenFetchTimeout", u[u.UnAuthorized = 5] = "UnAuthorized", u[u.ConnectTimeout = 6] = "ConnectTimeout", u[u.ConnectError = 7] = "ConnectError", u[u.ClientRecognitionActivityTimeout = 8] = "ClientRecognitionActivityTimeout", u[u.UnknownError = 9] = "UnknownError";
    })(n = e.RecognitionCompletionStatus || (e.RecognitionCompletionStatus = {}));
    class c extends r {
      constructor(l, p, h, d, f, g, m, v) {
        super("RecognitionEndedEvent", l, f, m === n.Success ? t.EventType.Info : t.EventType.Error), this.privAudioSourceId = p, this.privAudioNodeId = h, this.privAuthFetchEventId = d, this.privStatus = m, this.privError = v, this.privServiceTag = g;
      }
      get audioSourceId() {
        return this.privAudioSourceId;
      }
      get audioNodeId() {
        return this.privAudioNodeId;
      }
      get authFetchEventId() {
        return this.privAuthFetchEventId;
      }
      get serviceTag() {
        return this.privServiceTag;
      }
      get status() {
        return this.privStatus;
      }
      get error() {
        return this.privError;
      }
    }
    e.RecognitionEndedEvent = c;
  }(oa)), oa;
}
var li = {}, pi = {}, dd;
function Ht() {
  if (dd) return pi;
  dd = 1, Object.defineProperty(pi, "__esModule", { value: !0 }), pi.SpeechConnectionMessage = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ le();
  class r extends e.ConnectionMessage {
    constructor(i, a, s, n, c, u, l, p) {
      if (!a)
        throw new e.ArgumentNullError("path");
      if (!s)
        throw new e.ArgumentNullError("requestId");
      const h = {};
      if (h[t.HeaderNames.Path] = a, h[t.HeaderNames.RequestId] = s, h[t.HeaderNames.RequestTimestamp] = (/* @__PURE__ */ new Date()).toISOString(), n && (h[t.HeaderNames.ContentType] = n), u && (h[t.HeaderNames.RequestStreamId] = u), l)
        for (const d in l)
          d && (h[d] = l[d]);
      p ? super(i, c, h, p) : super(i, c, h), this.privPath = a, this.privRequestId = s, this.privContentType = n, this.privStreamId = u, this.privAdditionalHeaders = l;
    }
    get path() {
      return this.privPath;
    }
    get requestId() {
      return this.privRequestId;
    }
    get contentType() {
      return this.privContentType;
    }
    get streamId() {
      return this.privStreamId;
    }
    get additionalHeaders() {
      return this.privAdditionalHeaders;
    }
    static fromConnectionMessage(i) {
      let a = null, s = null, n = null, c = null;
      const u = {};
      if (i.headers)
        for (const l in i.headers)
          l && (l.toLowerCase() === t.HeaderNames.Path.toLowerCase() ? a = i.headers[l] : l.toLowerCase() === t.HeaderNames.RequestId.toLowerCase() ? s = i.headers[l] : l.toLowerCase() === t.HeaderNames.ContentType.toLowerCase() ? n = i.headers[l] : l.toLowerCase() === t.HeaderNames.RequestStreamId.toLowerCase() ? c = i.headers[l] : u[l] = i.headers[l]);
      return new r(i.messageType, a, s, n, i.body, c, u, i.id);
    }
  }
  return pi.SpeechConnectionMessage = r, pi;
}
var aa = {}, hd;
function rw() {
  return hd || (hd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SegmentationMode = void 0, function(t) {
      t.Normal = "Normal", t.Disabled = "Disabled", t.Custom = "Custom", t.Semantic = "Semantic";
    }(e.SegmentationMode || (e.SegmentationMode = {}));
  }(aa)), aa;
}
var ca = {}, fd;
function nw() {
  return fd || (fd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.None = "None", t.Synthesize = "Synthesize";
    }(e.NextAction || (e.NextAction = {}));
  }(ca)), ca;
}
var ua = {}, vd;
function iw() {
  return vd || (vd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.Mode = void 0, function(t) {
      t.None = "None", t.Always = "Always";
    }(e.Mode || (e.Mode = {}));
  }(ua)), ua;
}
var la = {}, gd;
function sw() {
  return gd || (gd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.LanguageIdDetectionPriority = e.LanguageIdDetectionMode = void 0, function(t) {
      t.DetectAtAudioStart = "DetectAtAudioStart", t.DetectContinuous = "DetectContinuous", t.DetectSegments = "DetectSegments";
    }(e.LanguageIdDetectionMode || (e.LanguageIdDetectionMode = {})), function(t) {
      t.Auto = "Auto", t.PrioritizeLatency = "PrioritizeLatency", t.PrioritizeAccuracy = "PrioritizeAccuracy";
    }(e.LanguageIdDetectionPriority || (e.LanguageIdDetectionPriority = {}));
  }(la)), la;
}
var pa = {}, md;
function ow() {
  return md || (md = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.Recognize = "Recognize", t.None = "None";
    }(e.NextAction || (e.NextAction = {}));
  }(pa)), pa;
}
var da = {}, yd;
function aw() {
  return yd || (yd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OnUnknownAction = void 0, function(t) {
      t.RecognizeWithDefaultLanguage = "RecognizeWithDefaultLanguage", t.None = "None";
    }(e.OnUnknownAction || (e.OnUnknownAction = {}));
  }(da)), da;
}
var ha = {}, Sd;
function cw() {
  return Sd || (Sd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.ResultType = void 0, function(t) {
      t.Auto = "Auto", t.StableFragment = "StableFragment", t.Hypothesis = "Hypothesis", t.None = "None";
    }(e.ResultType || (e.ResultType = {}));
  }(ha)), ha;
}
var fa = {}, Cd;
function uw() {
  return Cd || (Cd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.PhraseResultOutputType = void 0, function(t) {
      t.Always = "Always", t.None = "None";
    }(e.PhraseResultOutputType || (e.PhraseResultOutputType = {}));
  }(fa)), fa;
}
var va = {}, Rd;
function lw() {
  return Rd || (Rd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.NextAction = void 0, function(t) {
      t.None = "None", t.Translate = "Translate";
    }(e.NextAction || (e.NextAction = {}));
  }(va)), va;
}
var Pd;
function pw() {
  if (Pd) return li;
  Pd = 1, Object.defineProperty(li, "__esModule", { value: !0 }), li.ServiceRecognizerBase = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Ht(), a = /* @__PURE__ */ rw(), s = /* @__PURE__ */ Re(), n = /* @__PURE__ */ nw(), c = /* @__PURE__ */ iw(), u = /* @__PURE__ */ sw(), l = /* @__PURE__ */ ow(), p = /* @__PURE__ */ aw(), h = /* @__PURE__ */ cw(), d = /* @__PURE__ */ uw(), f = /* @__PURE__ */ lw();
  let g = class cs {
    constructor(v, y, S, C, w) {
      if (this.privConnectionConfigurationPromise = void 0, this.privConnectionPromise = void 0, this.privSetTimeout = setTimeout, this.privIsLiveAudio = !1, this.privAverageBytesPerMs = 0, this.privEnableSpeakerId = !1, this.privExpectContentAssessmentResponse = !1, this.recognizeOverride = void 0, this.recognizeSpeaker = void 0, this.disconnectOverride = void 0, this.receiveMessageOverride = void 0, this.sendPrePayloadJSONOverride = void 0, this.postConnectImplOverride = void 0, this.configConnectionOverride = void 0, this.handleSpeechPhraseMessage = void 0, this.handleSpeechHypothesisMessage = void 0, !v)
        throw new t.ArgumentNullError("authentication");
      if (!y)
        throw new t.ArgumentNullError("connectionFactory");
      if (!S)
        throw new t.ArgumentNullError("audioSource");
      if (!C)
        throw new t.ArgumentNullError("recognizerConfig");
      this.privEnableSpeakerId = C.isSpeakerDiarizationEnabled, this.privMustReportEndOfStream = !1, this.privAuthentication = v, this.privConnectionFactory = y, this.privAudioSource = S, this.privRecognizerConfig = C, this.privIsDisposed = !1, this.privRecognizer = w, this.privRequestSession = new o.RequestSession(this.privAudioSource.id()), this.privConnectionEvents = new t.EventSource(), this.privServiceEvents = new t.EventSource(), this.privDynamicGrammar = new o.DynamicGrammarBuilder(), this.privSpeechContext = new o.SpeechContext(this.privDynamicGrammar), this.privAgentConfig = new o.AgentConfig(), this.privRecognizerConfig.parameters.getProperty(r.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? this.privSetTimeout = t.Timeout.setTimeout : (typeof window < "u" && (this.privSetTimeout = window.setTimeout.bind(window)), typeof globalThis < "u" && (this.privSetTimeout = globalThis.setTimeout.bind(globalThis))), this.connectionEvents.attach((A) => {
        if (A.name === "ConnectionClosedEvent") {
          const E = A;
          (E.statusCode === 1003 || E.statusCode === 1007 || E.statusCode === 1002 || E.statusCode === 4e3 || this.privRequestSession.numConnectionAttempts > this.privRecognizerConfig.maxRetryCount) && this.cancelRecognitionLocal(r.CancellationReason.Error, E.statusCode === 1007 ? r.CancellationErrorCode.BadRequestParameters : r.CancellationErrorCode.ConnectionFailure, `${E.reason} websocket error code: ${E.statusCode}`);
        }
      }), this.privEnableSpeakerId && (this.privDiarizationSessionId = (0, t.createNoDashGuid)());
    }
    setTranslationJson() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0);
      if (v !== void 0) {
        const y = v.split(","), S = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0), C = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationCategoryId, void 0), w = S !== void 0 ? n.NextAction.Synthesize : n.NextAction.None;
        if (this.privSpeechContext.getContext().translation = {
          onPassthrough: { action: w },
          onSuccess: { action: w },
          output: {
            includePassThroughResults: !0,
            interimResults: { mode: c.Mode.Always }
          },
          targetLanguages: y
        }, C !== void 0 && (this.privSpeechContext.getContext().translation.category = C), S !== void 0) {
          const A = {};
          for (const E of y)
            A[E] = S;
          this.privSpeechContext.getContext().synthesis = {
            defaultVoices: A
          };
        }
        const b = this.privSpeechContext.getContext().phraseDetection || {};
        b.onSuccess = { action: f.NextAction.Translate }, b.onInterim = { action: f.NextAction.Translate }, this.privSpeechContext.getContext().phraseDetection = b;
      }
    }
    setSpeechSegmentationTimeoutJson() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationSilenceTimeoutMs, void 0), y = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationMaximumTimeMs, void 0), S = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.Speech_SegmentationStrategy, void 0), C = {
        mode: a.SegmentationMode.Normal
      };
      let w = !1;
      if (S !== void 0) {
        w = !0;
        let b = a.SegmentationMode.Normal;
        switch (S.toLowerCase()) {
          case "default":
            break;
          case "time":
            b = a.SegmentationMode.Custom;
            break;
          case "semantic":
            b = a.SegmentationMode.Semantic;
            break;
        }
        C.mode = b;
      }
      if (v !== void 0) {
        w = !0;
        const b = parseInt(v, 10);
        C.mode = a.SegmentationMode.Custom, C.segmentationSilenceTimeoutMs = b;
      }
      if (y !== void 0) {
        w = !0;
        const b = parseInt(y, 10);
        C.mode = a.SegmentationMode.Custom, C.segmentationForcedTimeoutMs = b;
      }
      if (w) {
        const b = this.privSpeechContext.getContext().phraseDetection || {};
        switch (b.mode = this.recognitionMode, this.recognitionMode) {
          case s.RecognitionMode.Conversation:
            b.conversation = b.conversation ?? { segmentation: {} }, b.conversation.segmentation = C;
            break;
          case s.RecognitionMode.Interactive:
            b.interactive = b.interactive ?? { segmentation: {} }, b.interactive.segmentation = C;
            break;
          case s.RecognitionMode.Dictation:
            b.dictation = b.dictation ?? {}, b.dictation.segmentation = C;
            break;
        }
        this.privSpeechContext.getContext().phraseDetection = b;
      }
    }
    setLanguageIdJson() {
      const v = this.privSpeechContext.getContext().phraseDetection || {};
      if (this.privRecognizerConfig.autoDetectSourceLanguages !== void 0) {
        const y = this.privRecognizerConfig.autoDetectSourceLanguages.split(",");
        y.length === 1 && y[0] === o.AutoDetectSourceLanguagesOpenRangeOptionName && (y[0] = "UND");
        let S;
        this.privRecognizerConfig.languageIdMode === "Continuous" ? S = u.LanguageIdDetectionMode.DetectContinuous : S = u.LanguageIdDetectionMode.DetectAtAudioStart, this.privSpeechContext.getContext().languageId = {
          languages: y,
          mode: S,
          onSuccess: { action: l.NextAction.Recognize },
          onUnknown: { action: p.OnUnknownAction.None },
          priority: u.LanguageIdDetectionPriority.PrioritizeLatency
        }, this.privSpeechContext.getContext().phraseOutput = {
          interimResults: {
            resultType: h.ResultType.Auto
          },
          phraseResults: {
            resultType: d.PhraseResultOutputType.Always
          }
        };
        const C = this.privRecognizerConfig.sourceLanguageModels;
        C !== void 0 && (v.customModels = C, v.onInterim = { action: f.NextAction.None }, v.onSuccess = { action: f.NextAction.None });
      }
      this.privSpeechContext.getContext().phraseDetection = v;
    }
    setOutputDetailLevelJson() {
      this.privEnableSpeakerId && (this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true" ? this.privSpeechContext.setWordLevelTimings() : this.privRecognizerConfig.parameters.getProperty(o.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase() === r.OutputFormat[r.OutputFormat.Detailed].toLocaleLowerCase() && this.privSpeechContext.setDetailedOutputFormat());
    }
    get isSpeakerDiarizationEnabled() {
      return this.privEnableSpeakerId;
    }
    get audioSource() {
      return this.privAudioSource;
    }
    get speechContext() {
      return this.privSpeechContext;
    }
    get dynamicGrammar() {
      return this.privDynamicGrammar;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    set conversationTranslatorToken(v) {
      this.privRecognizerConfig.parameters.setProperty(r.PropertyId.ConversationTranslator_Token, v);
    }
    set voiceProfileType(v) {
      this.privRecognizerConfig.parameters.setProperty(r.PropertyId.SpeechServiceConnection_SpeakerIdMode, v);
    }
    set authentication(v) {
      this.privAuthentication = v;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(v) {
      if (this.privIsDisposed = !0, this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose(v);
        } catch {
          return;
        }
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    get recognitionMode() {
      return this.privRecognizerConfig.recognitionMode;
    }
    async recognize(v, y, S) {
      if (this.recognizeOverride !== void 0) {
        await this.recognizeOverride(v, y, S);
        return;
      }
      if (this.privConnectionConfigurationPromise = void 0, this.privRecognizerConfig.recognitionMode = v, this.privRecognizerConfig.recognitionEndpointVersion === "2") {
        const E = this.privSpeechContext.getContext().phraseDetection || {};
        E.mode = v, this.privSpeechContext.getContext().phraseDetection = E;
      }
      this.setLanguageIdJson(), this.setTranslationJson(), this.privRecognizerConfig.autoDetectSourceLanguages !== void 0 && this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0) !== void 0 && this.setupTranslationWithLanguageId(), this.setSpeechSegmentationTimeoutJson(), this.setOutputDetailLevelJson(), this.privSuccessCallback = y, this.privErrorCallback = S, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privAudioSource.events);
      const C = this.connectImpl();
      let w;
      try {
        const E = await this.audioSource.attach(this.privRequestSession.audioNodeId), M = await this.audioSource.format, R = await this.audioSource.deviceInfo;
        this.privIsLiveAudio = R.type && R.type === o.type.Microphones, w = new e.ReplayableAudioNode(E, M.avgBytesPerSec), await this.privRequestSession.onAudioSourceAttachCompleted(w, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: R };
      } catch (E) {
        throw await this.privRequestSession.onStopRecognizing(), E;
      }
      try {
        await C;
      } catch (E) {
        await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, E);
        return;
      }
      const b = new r.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, b), this.receiveMessage(), this.sendAudio(w).catch(async (E) => {
        await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, E);
      });
    }
    async stopRecognizing() {
      if (this.privRequestSession.isRecognizing)
        try {
          await this.audioSource.turnOff(), await this.sendFinalAudio(), await this.privRequestSession.onStopRecognizing(), await this.privRequestSession.turnCompletionPromise;
        } finally {
          await this.privRequestSession.dispose();
        }
    }
    async connect() {
      return await this.connectImpl(), Promise.resolve();
    }
    connectAsync(v, y) {
      this.connectImpl().then(() => {
        try {
          v && v();
        } catch (S) {
          y && y(S);
        }
      }, (S) => {
        try {
          y && y(S);
        } catch {
        }
      });
    }
    async disconnect() {
      if (await this.cancelRecognitionLocal(r.CancellationReason.Error, r.CancellationErrorCode.NoError, "Disconnecting"), this.disconnectOverride !== void 0 && await this.disconnectOverride(), this.privConnectionPromise !== void 0)
        try {
          await (await this.privConnectionPromise).dispose();
        } catch {
        }
      this.privConnectionPromise = void 0;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    sendMessage(v) {
    }
    async sendNetworkMessage(v, y) {
      const S = typeof y == "string" ? t.MessageType.Text : t.MessageType.Binary, C = typeof y == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new i.SpeechConnectionMessage(S, v, this.privRequestSession.requestId, C, y));
    }
    set activityTemplate(v) {
      this.privActivityTemplate = v;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set expectContentAssessmentResponse(v) {
      this.privExpectContentAssessmentResponse = v;
    }
    async sendTelemetryData() {
      const v = this.privRequestSession.getTelemetry();
      if (cs.telemetryDataEnabled !== !0 || this.privIsDisposed || v === null)
        return;
      if (cs.telemetryData)
        try {
          cs.telemetryData(v);
        } catch {
        }
      await (await this.fetchConnection()).send(new i.SpeechConnectionMessage(t.MessageType.Text, "telemetry", this.privRequestSession.requestId, "application/json", v));
    }
    // Cancels recognition.
    async cancelRecognitionLocal(v, y, S) {
      this.privRequestSession.isRecognizing && (await this.privRequestSession.onStopRecognizing(), this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, v, y, S));
    }
    async receiveMessage() {
      try {
        if (this.privIsDisposed)
          return;
        let v = await this.fetchConnection();
        const y = await v.read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (!y)
          return this.receiveMessage();
        this.privServiceHasSentMessage = !0;
        const S = i.SpeechConnectionMessage.fromConnectionMessage(y);
        if (S.requestId.toLowerCase() === this.privRequestSession.requestId.toLowerCase())
          switch (S.path.toLowerCase()) {
            case "turn.start":
              this.privMustReportEndOfStream = !0, this.privRequestSession.onServiceTurnStartResponse();
              break;
            case "speech.startdetected":
              const C = o.SpeechDetected.fromJSON(S.textBody, this.privRequestSession.currentTurnAudioOffset), w = new r.RecognitionEventArgs(C.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, w);
              break;
            case "speech.enddetected":
              let b;
              S.textBody.length > 0 ? b = S.textBody : b = "{ Offset: 0 }";
              const A = o.SpeechDetected.fromJSON(b, this.privRequestSession.currentTurnAudioOffset), E = new r.RecognitionEventArgs(A.Offset + this.privRequestSession.currentTurnAudioOffset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, E);
              break;
            case "turn.end":
              await this.sendTelemetryData(), this.privRequestSession.isSpeechEnded && this.privMustReportEndOfStream && (this.privMustReportEndOfStream = !1, await this.cancelRecognitionLocal(r.CancellationReason.EndOfStream, r.CancellationErrorCode.NoError, void 0));
              const M = new r.SessionEventArgs(this.privRequestSession.sessionId);
              if (await this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition), !this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) {
                this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, M);
                return;
              } else
                v = await this.fetchConnection(), await this.sendPrePayloadJSON(v);
              break;
            default:
              await this.processTypeSpecificMessages(S) || this.privServiceEvents && this.serviceEvents.onEvent(new t.ServiceEvent(S.path.toLowerCase(), S.textBody));
          }
        return this.receiveMessage();
      } catch {
        return null;
      }
    }
    updateSpeakerDiarizationAudioOffset() {
      const v = this.privRequestSession.recognitionBytesSent, y = this.privAverageBytesPerMs !== 0 ? v / this.privAverageBytesPerMs : 0;
      this.privSpeechContext.setSpeakerDiarizationAudioOffsetMs(y);
    }
    sendSpeechContext(v, y) {
      this.privEnableSpeakerId && this.updateSpeakerDiarizationAudioOffset();
      const S = this.speechContext.toJSON();
      if (y && this.privRequestSession.onSpeechContext(), S)
        return v.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speech.context", this.privRequestSession.requestId, "application/json", S));
    }
    setupTranslationWithLanguageId() {
      const v = this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages, void 0), y = this.privRecognizerConfig.autoDetectSourceLanguages !== void 0;
      if (v !== void 0 && y) {
        this.privSpeechContext.getContext().phraseOutput = {
          interimResults: {
            resultType: h.ResultType.None
          },
          phraseResults: {
            resultType: d.PhraseResultOutputType.None
          }
        };
        const S = this.privSpeechContext.getContext().translation;
        if (S) {
          const C = this.privRecognizerConfig.sourceLanguageModels;
          if (C !== void 0 && C.length > 0) {
            const b = this.privSpeechContext.getContext().phraseDetection || {};
            b.customModels = C, this.privSpeechContext.getContext().phraseDetection = b;
          }
          this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0) !== void 0 && (S.onSuccess = { action: n.NextAction.Synthesize }, S.onPassthrough = { action: n.NextAction.Synthesize });
        }
      }
    }
    noOp() {
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendPrePayloadJSON(v, y = !0) {
      if (this.sendPrePayloadJSONOverride !== void 0)
        return this.sendPrePayloadJSONOverride(v);
      await this.sendSpeechContext(v, y), await this.sendWaveHeader(v);
    }
    async sendWaveHeader(v) {
      const y = await this.audioSource.format;
      return v.send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, "audio/x-wav", y.header));
    }
    // Establishes a websocket connection to the end point.
    connectImpl() {
      return this.privConnectionPromise !== void 0 ? this.privConnectionPromise.then((v) => v.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = void 0, this.privServiceHasSentMessage = !1, this.connectImpl())) : (this.privConnectionPromise = this.retryableConnect(), this.privConnectionPromise.catch(() => {
      }), this.postConnectImplOverride !== void 0 ? this.postConnectImplOverride(this.privConnectionPromise) : this.privConnectionPromise);
    }
    sendSpeechServiceConfig(v, y, S) {
      if (y.onSpeechContext(), cs.telemetryDataEnabled !== !0) {
        const w = {
          context: {
            system: JSON.parse(S).context.system
          }
        };
        S = JSON.stringify(w);
      }
      if (this.privRecognizerConfig.parameters.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() === "true") {
        const C = JSON.parse(S);
        C.context.DisableReferenceChannel = "True", C.context.MicSpec = "1_0_0", S = JSON.stringify(C);
      }
      if (S)
        return v.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speech.config", y.requestId, "application/json", S));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((v) => v.state() === t.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.privServiceHasSentMessage = !1, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    async sendAudio(v) {
      const y = await this.audioSource.format;
      this.privAverageBytesPerMs = y.avgBytesPerSec / 1e3;
      let S = Date.now();
      const C = this.privRecognizerConfig.parameters.getProperty("SPEECH-TransmitLengthBeforThrottleMs", "5000"), w = y.avgBytesPerSec / 1e3 * parseInt(C, 10), b = this.privRequestSession.recogNumber, A = async () => {
        if (!this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === b) {
          const E = await this.fetchConnection(), M = await v.read();
          if (this.privRequestSession.isSpeechEnded)
            return;
          let R, j;
          if (!M || M.isEnd ? (R = null, j = 0) : (R = M.buffer, this.privRequestSession.onAudioSent(R.byteLength), w >= this.privRequestSession.bytesSent ? j = 0 : j = Math.max(0, S - Date.now())), j !== 0 && await this.delay(j), R !== null && (S = Date.now() + R.byteLength * 1e3 / (y.avgBytesPerSec * 2)), !this.privIsDisposed && !this.privRequestSession.isSpeechEnded && this.privRequestSession.isRecognizing && this.privRequestSession.recogNumber === b)
            if (E.send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, null, R)).catch(() => {
              this.privRequestSession.onServiceTurnEndResponse(this.privRecognizerConfig.isContinuousRecognition).catch(() => {
              });
            }), M?.isEnd)
              this.privIsLiveAudio || this.privRequestSession.onSpeechEnded();
            else
              return A();
        }
      };
      return A();
    }
    async retryableConnect() {
      let v = !1;
      this.privAuthFetchEventId = (0, t.createNoDashGuid)();
      const y = this.privRequestSession.sessionId;
      this.privConnectionId = y !== void 0 ? y : (0, t.createNoDashGuid)(), this.privRequestSession.onPreConnectionStart(this.privAuthFetchEventId, this.privConnectionId);
      let S = 0, C = "";
      for (; this.privRequestSession.numConnectionAttempts <= this.privRecognizerConfig.maxRetryCount; ) {
        this.privRequestSession.onRetryConnection();
        const b = await (v ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId));
        await this.privRequestSession.onAuthCompleted(!1);
        const A = await this.privConnectionFactory.create(this.privRecognizerConfig, b, this.privConnectionId);
        this.privRequestSession.listenForServiceTelemetry(A.events), A.events.attach((M) => {
          this.connectionEvents.onEvent(M);
        });
        const E = await A.open();
        if (E.statusCode === 200)
          return await this.privRequestSession.onConnectionEstablishCompleted(E.statusCode), Promise.resolve(A);
        E.statusCode === 1006 && (v = !0), S = E.statusCode, C = E.reason;
      }
      return await this.privRequestSession.onConnectionEstablishCompleted(S, C), Promise.reject(`Unable to contact server. StatusCode: ${S}, ${this.privRecognizerConfig.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint)} Reason: ${C}`);
    }
    delay(v) {
      return new Promise((y) => this.privSetTimeout(y, v));
    }
    writeBufferToConsole(v) {
      let y = "Buffer Size: ";
      if (v === null)
        y += "null";
      else {
        const S = new Uint8Array(v);
        y += `${v.byteLength}\r
`;
        for (let C = 0; C < v.byteLength; C++)
          y += S[C].toString(16).padStart(2, "0") + " ", (C + 1) % 16 === 0 && (console.info(y), y = "");
      }
      console.info(y);
    }
    async sendFinalAudio() {
      await (await this.fetchConnection()).send(new i.SpeechConnectionMessage(t.MessageType.Binary, "audio", this.privRequestSession.requestId, null, null));
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const v = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(v) : (await this.sendSpeechServiceConfig(v, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendPrePayloadJSON(v, !1), v);
    }
  };
  return li.ServiceRecognizerBase = g, g.telemetryDataEnabled = !0, li;
}
var di = {}, wd;
function dw() {
  if (wd) return di;
  wd = 1, Object.defineProperty(di, "__esModule", { value: !0 }), di.ConversationServiceRecognizer = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class extends t.ServiceRecognizerBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, n, c), this.handleSpeechPhraseMessage = async (u) => this.handleSpeechPhrase(u), this.handleSpeechHypothesisMessage = (u) => this.handleSpeechHypothesis(u);
    }
    processTypeSpecificMessages(i) {
    }
    handleRecognizedCallback(i, a, s) {
    }
    handleRecognizingCallback(i, a, s) {
    }
    async processSpeechMessages(i) {
      let a = !1;
      switch (i.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          this.handleSpeechHypothesisMessage && this.handleSpeechHypothesisMessage(i.textBody), a = !0;
          break;
        case "speech.phrase":
          this.handleSpeechPhraseMessage && await this.handleSpeechPhraseMessage(i.textBody), a = !0;
          break;
      }
      return a;
    }
    cancelRecognition(i, a, s, n, c) {
    }
    async handleSpeechPhrase(i) {
      const a = t.SimpleSpeechPhrase.fromJSON(i, this.privRequestSession.currentTurnAudioOffset), s = t.EnumTranslation.implTranslateRecognitionResult(a.RecognitionStatus);
      let n;
      const c = new e.PropertyCollection();
      if (c.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, i), this.privRequestSession.onPhraseRecognized(a.Offset + a.Duration), e.ResultReason.Canceled === s) {
        const u = t.EnumTranslation.implTranslateCancelResult(a.RecognitionStatus), l = t.EnumTranslation.implTranslateCancelErrorCode(a.RecognitionStatus);
        await this.cancelRecognitionLocal(u, l, t.EnumTranslation.implTranslateErrorDetails(l));
      } else if (a.RecognitionStatus !== t.RecognitionStatus.EndOfDictation) {
        if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
          n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, s, a.DisplayText, a.Duration, a.Offset, a.Language, a.LanguageDetectionConfidence, a.SpeakerId, void 0, a.asJson(), c);
        else {
          const u = t.DetailedSpeechPhrase.fromJSON(i, this.privRequestSession.currentTurnAudioOffset);
          n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, s, u.Text, u.Duration, u.Offset, u.Language, u.LanguageDetectionConfidence, u.SpeakerId, void 0, u.asJson(), c);
        }
        this.handleRecognizedCallback(n, n.offset, this.privRequestSession.sessionId);
      }
    }
    handleSpeechHypothesis(i) {
      const a = t.SpeechHypothesis.fromJSON(i, this.privRequestSession.currentTurnAudioOffset), s = new e.PropertyCollection();
      s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, i);
      const n = new e.SpeechRecognitionResult(this.privRequestSession.requestId, e.ResultReason.RecognizingSpeech, a.Text, a.Duration, a.Offset, a.Language, a.LanguageDetectionConfidence, a.SpeakerId, void 0, a.asJson(), s);
      this.privRequestSession.onHypothesis(a.Offset), this.handleRecognizingCallback(n, a.Duration, this.privRequestSession.sessionId);
    }
  };
  return di.ConversationServiceRecognizer = r, di;
}
var ga = {}, bd;
function hw() {
  return bd || (bd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognizerConfig = e.SpeechResultFormat = void 0;
    const t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Re();
    (function(a) {
      a[a.Simple = 0] = "Simple", a[a.Detailed = 1] = "Detailed";
    })(e.SpeechResultFormat || (e.SpeechResultFormat = {}));
    class i {
      constructor(s, n) {
        this.privSpeechServiceConfig = s || new r.SpeechServiceConfig(new r.Context(null)), this.privParameters = n, this.privMaxRetryCount = parseInt(n.getProperty("SPEECH-Error-MaxRetryCount", "4"), 10), this.privLanguageIdMode = n.getProperty(t.PropertyId.SpeechServiceConnection_LanguageIdMode, void 0), this.privEnableSpeakerId = !1;
      }
      get parameters() {
        return this.privParameters;
      }
      get recognitionMode() {
        return this.privRecognitionMode;
      }
      set recognitionMode(s) {
        this.privRecognitionMode = s, this.privRecognitionActivityTimeout = s === o.RecognitionMode.Interactive ? 8e3 : 25e3, this.privSpeechServiceConfig.Recognition = o.RecognitionMode[s];
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
      get recognitionActivityTimeout() {
        return this.privRecognitionActivityTimeout;
      }
      get isContinuousRecognition() {
        return this.privRecognitionMode !== o.RecognitionMode.Interactive;
      }
      get languageIdMode() {
        return this.privLanguageIdMode;
      }
      get autoDetectSourceLanguages() {
        return this.parameters.getProperty(t.PropertyId.SpeechServiceConnection_AutoDetectSourceLanguages, void 0);
      }
      get recognitionEndpointVersion() {
        return this.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, "2");
      }
      set recognitionEndpointVersion(s) {
        this.parameters.setProperty(t.PropertyId.SpeechServiceConnection_RecognitionEndpointVersion, s);
      }
      get sourceLanguageModels() {
        const s = [];
        let n = !1;
        if (this.autoDetectSourceLanguages !== void 0)
          for (const c of this.autoDetectSourceLanguages.split(",")) {
            const u = c + t.PropertyId.SpeechServiceConnection_EndpointId.toString(), l = this.parameters.getProperty(u, void 0);
            l !== void 0 ? (s.push({ language: c, endpoint: l }), n = !0) : s.push({ language: c, endpoint: "" });
          }
        return n ? s : void 0;
      }
      get maxRetryCount() {
        return this.privMaxRetryCount;
      }
      get isSpeakerDiarizationEnabled() {
        return this.privEnableSpeakerId;
      }
      set isSpeakerDiarizationEnabled(s) {
        this.privEnableSpeakerId = s;
      }
    }
    e.RecognizerConfig = i;
  }(ga)), ga;
}
var ma = {}, Ed;
function fw() {
  return Ed || (Ed = 1, Object.defineProperty(ma, "__esModule", { value: !0 })), ma;
}
var hi = {}, Id;
function vw() {
  if (Id) return hi;
  Id = 1, Object.defineProperty(hi, "__esModule", { value: !0 }), hi.WebsocketMessageFormatter = void 0;
  const e = /* @__PURE__ */ k(), t = `\r
`;
  let r = class {
    toConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = i.textContent;
          let n = {}, c = null;
          if (s) {
            const u = s.split(`\r
\r
`);
            u && u.length > 0 && (n = this.parseHeaders(u[0]), u.length > 1 && (c = u[1]));
          }
          a.resolve(new e.ConnectionMessage(i.messageType, c, n, i.id));
        } else if (i.messageType === e.MessageType.Binary) {
          const s = i.binaryContent;
          let n = {}, c = null;
          if (!s || s.byteLength < 2)
            throw new Error("Invalid binary message format. Header length missing.");
          const u = new DataView(s), l = u.getInt16(0);
          if (s.byteLength < l + 2)
            throw new Error("Invalid binary message format. Header content missing.");
          let p = "";
          for (let h = 0; h < l; h++)
            p += String.fromCharCode(u.getInt8(h + 2));
          n = this.parseHeaders(p), s.byteLength > l + 2 && (c = s.slice(2 + l)), a.resolve(new e.ConnectionMessage(i.messageType, c, n, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. Error: ${s}`);
      }
      return a.promise;
    }
    fromConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = `${this.makeHeaders(i)}${t}${i.textBody ? i.textBody : ""}`;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Text, s, i.id));
        } else if (i.messageType === e.MessageType.Binary) {
          const s = this.makeHeaders(i), n = i.binaryBody, c = this.stringToArrayBuffer(s), u = new Int8Array(c), l = u.byteLength, p = new Int8Array(2 + l + (n ? n.byteLength : 0));
          if (p[0] = l >> 8 & 255, p[1] = l & 255, p.set(u, 2), n) {
            const d = new Int8Array(n);
            p.set(d, 2 + l);
          }
          const h = p.buffer;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Binary, h, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. ${s}`);
      }
      return a.promise;
    }
    makeHeaders(i) {
      let a = "";
      if (i.headers)
        for (const s in i.headers)
          s && (a += `${s}: ${i.headers[s]}${t}`);
      return a;
    }
    parseHeaders(i) {
      const a = {};
      if (i) {
        const s = i.match(/[^\r\n]+/g);
        if (a) {
          for (const n of s)
            if (n) {
              const c = n.indexOf(":"), u = c > 0 ? n.substr(0, c).trim().toLowerCase() : n, l = c > 0 && n.length > c + 1 ? n.substr(c + 1).trim() : "";
              a[u] = l;
            }
        }
      }
      return a;
    }
    stringToArrayBuffer(i) {
      const a = new ArrayBuffer(i.length), s = new DataView(a);
      for (let n = 0; n < i.length; n++)
        s.setUint8(n, i.charCodeAt(n));
      return a;
    }
  };
  return hi.WebsocketMessageFormatter = r, hi;
}
var fi = {}, Ad;
function gw() {
  if (Ad) return fi;
  Ad = 1, Object.defineProperty(fi, "__esModule", { value: !0 }), fi.SpeechConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ ke(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ le(), s = /* @__PURE__ */ et(), n = /* @__PURE__ */ Re();
  let c = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.interactiveRelativeUri = "/speech/recognition/interactive/cognitiveservices/v1", this.conversationRelativeUri = "/speech/recognition/conversation/cognitiveservices/v1", this.dictationRelativeUri = "/speech/recognition/dictation/cognitiveservices/v1", this.universalUri = "/stt/speech/universal/v";
    }
    async create(l, p, h) {
      let d = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region, void 0), g = o.ConnectionFactoryBase.getHostSuffix(f), m = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://" + f + ".stt.speech" + g), v = {}, y = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_EndpointId, void 0), S = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (y ? (!d || d.search(s.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (v[s.QueryParameterNames.CustomSpeechDeploymentId] = y) : S && (!d || d.search(s.QueryParameterNames.Language) === -1) && (v[s.QueryParameterNames.Language] = S), (!d || d.search(s.QueryParameterNames.Format) === -1) && (v[s.QueryParameterNames.Format] = l.parameters.getProperty(t.OutputFormatPropertyName, r.OutputFormat[r.OutputFormat.Simple]).toLowerCase()), l.autoDetectSourceLanguages !== void 0 && (v[s.QueryParameterNames.EnableLanguageId] = "true"), this.setCommonUrlParams(l, v, d), d) {
        const E = new URL(d), M = E.pathname;
        (M === "" || M === "/") && (E.pathname = this.universalUri + l.recognitionEndpointVersion, d = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(E.toString()));
      }
      if (!d)
        switch (l.recognitionMode) {
          case n.RecognitionMode.Conversation:
            l.parameters.getProperty(t.ForceDictationPropertyName, "false") === "true" ? d = m + this.dictationRelativeUri : l.recognitionEndpointVersion !== void 0 && parseInt(l.recognitionEndpointVersion, 10) > 1 ? d = `${m}${this.universalUri}${l.recognitionEndpointVersion}` : d = m + this.conversationRelativeUri;
            break;
          case n.RecognitionMode.Dictation:
            d = m + this.dictationRelativeUri;
            break;
          default:
            l.recognitionEndpointVersion !== void 0 && parseInt(l.recognitionEndpointVersion, 10) > 1 ? d = `${m}${this.universalUri}${l.recognitionEndpointVersion}` : d = m + this.interactiveRelativeUri;
            break;
        }
      const C = {};
      p.token !== void 0 && p.token !== "" && (C[p.headerName] = p.token), C[a.HeaderNames.ConnectionId] = h, C.connectionId = h;
      const w = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", b = new e.WebsocketConnection(d, v, C, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), w, h), A = b.uri;
      return l.parameters.setProperty(r.PropertyId.SpeechServiceConnection_Url, A), b;
    }
  };
  return fi.SpeechConnectionFactory = c, fi;
}
var vi = {}, Td;
function mw() {
  if (Td) return vi;
  Td = 1, Object.defineProperty(vi, "__esModule", { value: !0 }), vi.ConversationTranscriberConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ ke(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ le(), s = /* @__PURE__ */ et();
  let n = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/stt/speech/universal/v2";
    }
    async create(u, l, p) {
      let h = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const d = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, void 0), f = o.ConnectionFactoryBase.getHostSuffix(d), g = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, "wss://" + d + ".stt.speech" + f), m = {}, v = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), y = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      if (v ? (!h || h.search(s.QueryParameterNames.CustomSpeechDeploymentId) === -1) && (m[s.QueryParameterNames.CustomSpeechDeploymentId] = v) : y && (!h || h.search(s.QueryParameterNames.Language) === -1) && (m[s.QueryParameterNames.Language] = y), u.autoDetectSourceLanguages !== void 0 && (m[s.QueryParameterNames.EnableLanguageId] = "true"), this.setV2UrlParams(u, m, h), h) {
        const A = new URL(h), E = A.pathname;
        (E === "" || E === "/") && (A.pathname = this.universalUri, h = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(A.toString()));
      }
      h || (h = `${g}${this.universalUri}`);
      const S = {};
      l.token !== void 0 && l.token !== "" && (S[l.headerName] = l.token), S[a.HeaderNames.ConnectionId] = p;
      const C = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true", w = new e.WebsocketConnection(h, m, S, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), C, p), b = w.uri;
      return u.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, b), w;
    }
    setV2UrlParams(u, l, p) {
      (/* @__PURE__ */ new Map([
        [t.PropertyId.Speech_SegmentationSilenceTimeoutMs, s.QueryParameterNames.SegmentationSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceConnection_EnableAudioLogging, s.QueryParameterNames.EnableAudioLogging],
        [t.PropertyId.SpeechServiceConnection_EndSilenceTimeoutMs, s.QueryParameterNames.EndSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceConnection_InitialSilenceTimeoutMs, s.QueryParameterNames.InitialSilenceTimeoutMs],
        [t.PropertyId.SpeechServiceResponse_PostProcessingOption, s.QueryParameterNames.Postprocessing],
        [t.PropertyId.SpeechServiceResponse_ProfanityOption, s.QueryParameterNames.Profanity],
        [t.PropertyId.SpeechServiceResponse_StablePartialResultThreshold, s.QueryParameterNames.StableIntermediateThreshold]
      ])).forEach((f, g) => {
        this.setUrlParameter(g, f, u, l, p);
      });
      const d = JSON.parse(u.parameters.getProperty(r.ServicePropertiesPropertyName, "{}"));
      Object.keys(d).forEach((f) => {
        l[f] = d[f];
      });
    }
  };
  return vi.ConversationTranscriberConnectionFactory = n, vi;
}
var gi = {}, _d;
function yw() {
  if (_d) return gi;
  _d = 1, Object.defineProperty(gi, "__esModule", { value: !0 }), gi.TranscriberConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ le(), a = /* @__PURE__ */ et();
  let s = class extends r.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.multiaudioRelativeUri = "/speech/recognition/multiaudio";
    }
    create(c, u, l) {
      let p = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      const h = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, "centralus"), d = r.ConnectionFactoryBase.getHostSuffix(h), f = "wss://transcribe." + h + ".cts.speech" + d + this.multiaudioRelativeUri, g = c.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, f), m = {};
      this.setQueryParams(m, c, p), p || (p = g);
      const v = {};
      u.token !== void 0 && u.token !== "" && (v[u.headerName] = u.token), v[i.HeaderNames.ConnectionId] = l, c.parameters.setProperty(t.PropertyId.SpeechServiceConnection_Url, p);
      const y = c.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(p, m, v, new o.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(c), y, l));
    }
    setQueryParams(c, u, l) {
      const p = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_EndpointId, void 0), h = u.parameters.getProperty(t.PropertyId.SpeechServiceConnection_RecoLanguage, void 0);
      p && !(a.QueryParameterNames.CustomSpeechDeploymentId in c) && (c[a.QueryParameterNames.CustomSpeechDeploymentId] = p), h && !(a.QueryParameterNames.Language in c) && (c[a.QueryParameterNames.Language] = h);
      const d = u.parameters.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps, "false").toLowerCase() === "true", f = u.parameters.getProperty(o.OutputFormatPropertyName, t.OutputFormat[t.OutputFormat.Simple]) !== t.OutputFormat[t.OutputFormat.Simple];
      (d || f) && (c[a.QueryParameterNames.Format] = t.OutputFormat[t.OutputFormat.Detailed].toLowerCase()), this.setCommonUrlParams(u, c, l);
    }
  };
  return gi.TranscriberConnectionFactory = s, gi;
}
var mi = {}, kd;
function Sw() {
  if (kd) return mi;
  kd = 1, Object.defineProperty(mi, "__esModule", { value: !0 }), mi.TranslationConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ Ov(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ ke(), i = /* @__PURE__ */ _(), a = /* @__PURE__ */ le(), s = /* @__PURE__ */ et(), n = /* @__PURE__ */ Re();
  let c = class extends o.ConnectionFactoryBase {
    constructor() {
      super(...arguments), this.universalUri = "/stt/speech/universal/v2", this.translationV1Uri = "/speech/translation/cognitiveservices/v1";
    }
    async create(l, p, h) {
      let d = this.getEndpointUrl(l);
      const f = {};
      if (this.setQueryParams(f, l, d), d) {
        const y = new URL(d), S = y.pathname;
        (S === "" || S === "/") && (y.pathname = this.universalUri, d = await o.ConnectionFactoryBase.getRedirectUrlFromEndpoint(y.toString()));
      }
      const g = {};
      p.token !== void 0 && p.token !== "" && (g[p.headerName] = p.token), g[a.HeaderNames.ConnectionId] = h, l.parameters.setProperty(r.PropertyId.SpeechServiceConnection_Url, d);
      const m = l.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return new e.WebsocketConnection(d, f, g, new i.WebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(l), m, h);
    }
    getEndpointUrl(l, p) {
      const h = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Region), d = o.ConnectionFactoryBase.getHostSuffix(h);
      let f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      return f ? p === !0 ? f : t.StringUtils.formatString(f, { region: h }) : (l.parameters.getProperty("SPEECH-ForceV1Endpoint", "false") === "true" ? f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://{region}.s2s.speech" + d) + this.translationV1Uri : f = l.parameters.getProperty(r.PropertyId.SpeechServiceConnection_Host, "wss://{region}.stt.speech" + d) + this.universalUri, p === !0 ? f : t.StringUtils.formatString(f, { region: h }));
    }
    setQueryParams(l, p, h) {
      l.from = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage), l.to = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationToLanguages), l.scenario = p.recognitionMode === n.RecognitionMode.Interactive ? "interactive" : p.recognitionMode === n.RecognitionMode.Conversation ? "conversation" : "", this.setCommonUrlParams(p, l, h), this.setUrlParameter(r.PropertyId.SpeechServiceResponse_TranslationRequestStablePartialResult, s.QueryParameterNames.StableTranslation, p, l, h);
      const d = p.parameters.getProperty(r.PropertyId.SpeechServiceConnection_TranslationVoice, void 0);
      d !== void 0 && (l.voice = d, l.features = "requireVoice");
    }
  };
  return mi.TranslationConnectionFactory = c, mi;
}
var yi = {}, Od;
function Cw() {
  if (Od) return yi;
  Od = 1, Object.defineProperty(yi, "__esModule", { value: !0 }), yi.EnumTranslation = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class {
    static implTranslateRecognitionResult(i, a = !1) {
      let s = e.ResultReason.Canceled;
      switch (i) {
        case t.RecognitionStatus.Success:
          s = e.ResultReason.RecognizedSpeech;
          break;
        case t.RecognitionStatus.EndOfDictation:
          s = a ? e.ResultReason.RecognizedSpeech : e.ResultReason.NoMatch;
          break;
        case t.RecognitionStatus.NoMatch:
        case t.RecognitionStatus.InitialSilenceTimeout:
        case t.RecognitionStatus.BabbleTimeout:
          s = e.ResultReason.NoMatch;
          break;
        case t.RecognitionStatus.Error:
        case t.RecognitionStatus.BadRequest:
        case t.RecognitionStatus.Forbidden:
        default:
          s = e.ResultReason.Canceled;
          break;
      }
      return s;
    }
    static implTranslateCancelResult(i) {
      let a = e.CancellationReason.EndOfStream;
      switch (i) {
        case t.RecognitionStatus.Success:
        case t.RecognitionStatus.EndOfDictation:
        case t.RecognitionStatus.NoMatch:
          a = e.CancellationReason.EndOfStream;
          break;
        case t.RecognitionStatus.InitialSilenceTimeout:
        case t.RecognitionStatus.BabbleTimeout:
        case t.RecognitionStatus.Error:
        case t.RecognitionStatus.BadRequest:
        case t.RecognitionStatus.Forbidden:
        default:
          a = e.CancellationReason.Error;
          break;
      }
      return a;
    }
    static implTranslateCancelErrorCode(i) {
      let a = e.CancellationErrorCode.NoError;
      switch (i) {
        case t.RecognitionStatus.Error:
          a = e.CancellationErrorCode.ServiceError;
          break;
        case t.RecognitionStatus.TooManyRequests:
          a = e.CancellationErrorCode.TooManyRequests;
          break;
        case t.RecognitionStatus.BadRequest:
          a = e.CancellationErrorCode.BadRequestParameters;
          break;
        case t.RecognitionStatus.Forbidden:
          a = e.CancellationErrorCode.Forbidden;
          break;
        default:
          a = e.CancellationErrorCode.NoError;
          break;
      }
      return a;
    }
    static implTranslateErrorDetails(i) {
      let a = "The speech service encountered an internal error and could not continue.";
      switch (i) {
        case e.CancellationErrorCode.Forbidden:
          a = "The recognizer is using a free subscription that ran out of quota.";
          break;
        case e.CancellationErrorCode.BadRequestParameters:
          a = "Invalid parameter or unsupported audio format in the request.";
          break;
        case e.CancellationErrorCode.TooManyRequests:
          a = "The number of parallel requests exceeded the number of allowed concurrent transcriptions.";
          break;
      }
      return a;
    }
  };
  return yi.EnumTranslation = r, yi;
}
var ya = {}, Md;
function Rw() {
  return Md || (Md = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.RecognitionStatus = e.SynthesisStatus = void 0, function(t) {
      t[t.Success = 0] = "Success", t[t.SynthesisEnd = 1] = "SynthesisEnd", t[t.Error = 2] = "Error";
    }(e.SynthesisStatus || (e.SynthesisStatus = {})), function(t) {
      t[t.Success = 0] = "Success", t[t.NoMatch = 1] = "NoMatch", t[t.InitialSilenceTimeout = 2] = "InitialSilenceTimeout", t[t.BabbleTimeout = 3] = "BabbleTimeout", t[t.Error = 4] = "Error", t[t.EndOfDictation = 5] = "EndOfDictation", t[t.TooManyRequests = 6] = "TooManyRequests", t[t.BadRequest = 7] = "BadRequest", t[t.Forbidden = 8] = "Forbidden";
    }(e.RecognitionStatus || (e.RecognitionStatus = {}));
  }(ya)), ya;
}
var Si = {}, Dd;
function Pw() {
  if (Dd) return Si;
  Dd = 1, Object.defineProperty(Si, "__esModule", { value: !0 }), Si.TranslationSynthesisEnd = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Bv {
    constructor(o) {
      this.privSynthesisEnd = JSON.parse(o), this.privSynthesisEnd.SynthesisStatus && (this.privSynthesisEnd.SynthesisStatus = e.SynthesisStatus[this.privSynthesisEnd.SynthesisStatus]), this.privSynthesisEnd.Status && (this.privSynthesisEnd.SynthesisStatus = e.SynthesisStatus[this.privSynthesisEnd.Status]);
    }
    static fromJSON(o) {
      return new Bv(o);
    }
    get SynthesisStatus() {
      return this.privSynthesisEnd.SynthesisStatus;
    }
    get FailureReason() {
      return this.privSynthesisEnd.FailureReason;
    }
  };
  return Si.TranslationSynthesisEnd = t, Si;
}
var Ci = {}, Nd;
function ww() {
  if (Nd) return Ci;
  Nd = 1, Object.defineProperty(Ci, "__esModule", { value: !0 }), Ci.TranslationHypothesis = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ oc();
  let r = class Ha {
    constructor(i, a) {
      this.privTranslationHypothesis = i, this.privTranslationHypothesis.Offset += a, this.privTranslationHypothesis.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationHypothesis.Translation.TranslationStatus);
    }
    static fromJSON(i, a) {
      return new Ha(JSON.parse(i), a);
    }
    static fromTranslationResponse(i, a) {
      e.Contracts.throwIfNullOrUndefined(i, "translationHypothesis");
      const s = i.SpeechHypothesis;
      return i.SpeechHypothesis = void 0, s.Translation = i, new Ha(s, a);
    }
    get Duration() {
      return this.privTranslationHypothesis.Duration;
    }
    get Offset() {
      return this.privTranslationHypothesis.Offset;
    }
    get Text() {
      return this.privTranslationHypothesis.Text;
    }
    get Translation() {
      return this.privTranslationHypothesis.Translation;
    }
    get Language() {
      return this.privTranslationHypothesis.PrimaryLanguage?.Language;
    }
    asJson() {
      const i = { ...this.privTranslationHypothesis };
      return i.Translation !== void 0 ? JSON.stringify({
        ...i,
        TranslationStatus: t.TranslationStatus[i.Translation.TranslationStatus]
      }) : JSON.stringify(i);
    }
    mapTranslationStatus(i) {
      if (typeof i == "string")
        return t.TranslationStatus[i];
      if (typeof i == "number")
        return i;
    }
  };
  return Ci.TranslationHypothesis = r, Ci;
}
var Ri = {}, xd;
function bw() {
  if (xd) return Ri;
  xd = 1, Object.defineProperty(Ri, "__esModule", { value: !0 }), Ri.TranslationPhrase = void 0;
  const e = /* @__PURE__ */ z(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ oc();
  let o = class Ka {
    constructor(a, s) {
      this.privTranslationPhrase = a, this.privTranslationPhrase.Offset += s, this.privTranslationPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privTranslationPhrase.RecognitionStatus), this.privTranslationPhrase.Translation !== void 0 && (this.privTranslationPhrase.Translation.TranslationStatus = this.mapTranslationStatus(this.privTranslationPhrase.Translation.TranslationStatus));
    }
    static fromJSON(a, s) {
      return new Ka(JSON.parse(a), s);
    }
    static fromTranslationResponse(a, s) {
      e.Contracts.throwIfNullOrUndefined(a, "translationResponse");
      const n = a.SpeechPhrase;
      return a.SpeechPhrase = void 0, n.Translation = a, n.Text = n.DisplayText, new Ka(n, s);
    }
    get RecognitionStatus() {
      return this.privTranslationPhrase.RecognitionStatus;
    }
    get Offset() {
      return this.privTranslationPhrase.Offset;
    }
    get Duration() {
      return this.privTranslationPhrase.Duration;
    }
    get Text() {
      return this.privTranslationPhrase.Text;
    }
    get Language() {
      return this.privTranslationPhrase.PrimaryLanguage?.Language;
    }
    get Confidence() {
      return this.privTranslationPhrase.PrimaryLanguage?.Confidence;
    }
    get Translation() {
      return this.privTranslationPhrase.Translation;
    }
    asJson() {
      const a = { ...this.privTranslationPhrase }, s = {
        ...a,
        RecognitionStatus: t.RecognitionStatus[a.RecognitionStatus]
      };
      return a.Translation && (s.Translation = {
        ...a.Translation,
        TranslationStatus: r.TranslationStatus[a.Translation.TranslationStatus]
      }), JSON.stringify(s);
    }
    mapRecognitionStatus(a) {
      if (typeof a == "string")
        return t.RecognitionStatus[a];
      if (typeof a == "number")
        return a;
    }
    mapTranslationStatus(a) {
      if (typeof a == "string")
        return r.TranslationStatus[a];
      if (typeof a == "number")
        return a;
    }
  };
  return Ri.TranslationPhrase = o, Ri;
}
var Pi = {}, zd;
function Ew() {
  if (zd) return Pi;
  zd = 1, Object.defineProperty(Pi, "__esModule", { value: !0 }), Pi.TranslationServiceRecognizer = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _();
  let o = class extends r.ConversationServiceRecognizer {
    constructor(a, s, n, c, u) {
      super(a, s, n, c, u), this.privTranslationRecognizer = u, this.connectionEvents.attach((l) => {
        l.name === "ConnectionEstablishedEvent" && this.privTranslationRecognizer.onConnection();
      });
    }
    async processTypeSpecificMessages(a) {
      const s = new t.PropertyCollection();
      let n = await this.processSpeechMessages(a);
      if (n)
        return !0;
      const c = async (l) => {
        if (s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, l.asJson()), this.privRequestSession.onPhraseRecognized(l.Offset + l.Duration), l.RecognitionStatus === r.RecognitionStatus.Success) {
          const p = this.fireEventForResult(l, s);
          if (this.privTranslationRecognizer.recognized)
            try {
              this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, p);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(p.result);
            } catch (h) {
              this.privErrorCallback && this.privErrorCallback(h);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
        } else {
          const p = r.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus), h = new t.TranslationRecognitionResult(void 0, this.privRequestSession.requestId, p, l.Text, l.Duration, l.Offset, l.Language, l.Confidence, void 0, l.asJson(), s);
          if (p === t.ResultReason.Canceled) {
            const d = r.EnumTranslation.implTranslateCancelResult(l.RecognitionStatus), f = r.EnumTranslation.implTranslateCancelErrorCode(l.RecognitionStatus);
            await this.cancelRecognitionLocal(d, f, r.EnumTranslation.implTranslateErrorDetails(f));
          } else if (l.RecognitionStatus !== r.RecognitionStatus.EndOfDictation) {
            const d = new t.TranslationRecognitionEventArgs(h, h.offset, this.privRequestSession.sessionId);
            if (this.privTranslationRecognizer.recognized)
              try {
                this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, d);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(h);
              } catch (f) {
                this.privErrorCallback && this.privErrorCallback(f);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          n = !0;
        }
      }, u = (l) => {
        s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, l.asJson());
        const p = this.fireEventForResult(l, s);
        if (this.privRequestSession.onHypothesis(p.offset), this.privTranslationRecognizer.recognizing)
          try {
            this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, p);
          } catch {
          }
        n = !0;
      };
      switch (a.messageType === e.MessageType.Text && s.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, a.textBody), a.path.toLowerCase()) {
        case "translation.hypothesis":
          u(r.TranslationHypothesis.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.response":
          const l = JSON.parse(a.textBody);
          if (l.SpeechPhrase)
            await c(r.TranslationPhrase.fromTranslationResponse(l, this.privRequestSession.currentTurnAudioOffset));
          else {
            const h = JSON.parse(a.textBody);
            h.SpeechHypothesis && u(r.TranslationHypothesis.fromTranslationResponse(h, this.privRequestSession.currentTurnAudioOffset));
          }
          break;
        case "translation.phrase":
          await c(r.TranslationPhrase.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset));
          break;
        case "translation.synthesis":
        case "audio":
          this.sendSynthesisAudio(a.binaryBody, this.privRequestSession.sessionId), n = !0;
          break;
        case "audio.end":
        case "translation.synthesis.end":
          const p = r.TranslationSynthesisEnd.fromJSON(a.textBody);
          switch (p.SynthesisStatus) {
            case r.SynthesisStatus.Error:
              if (this.privTranslationRecognizer.synthesizing) {
                const h = new t.TranslationSynthesisResult(t.ResultReason.Canceled, void 0), d = new t.TranslationSynthesisEventArgs(h, this.privRequestSession.sessionId);
                try {
                  this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, d);
                } catch {
                }
              }
              if (this.privTranslationRecognizer.canceled) {
                const h = new t.TranslationRecognitionCanceledEventArgs(this.privRequestSession.sessionId, t.CancellationReason.Error, p.FailureReason, t.CancellationErrorCode.ServiceError, null);
                try {
                  this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, h);
                } catch {
                }
              }
              break;
            case r.SynthesisStatus.Success:
              this.sendSynthesisAudio(void 0, this.privRequestSession.sessionId);
              break;
          }
          n = !0;
          break;
      }
      return n;
    }
    // Cancels recognition.
    cancelRecognition(a, s, n, c, u) {
      const l = new t.PropertyCollection();
      if (l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]), this.privTranslationRecognizer.canceled) {
        const p = new t.TranslationRecognitionCanceledEventArgs(a, n, u, c, void 0);
        try {
          this.privTranslationRecognizer.canceled(this.privTranslationRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.TranslationRecognitionResult(
          void 0,
          // Translations
          s,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Druation
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          l
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    handleRecognizingCallback(a, s, n) {
      try {
        const c = new t.TranslationRecognitionEventArgs(t.TranslationRecognitionResult.fromSpeechRecognitionResult(a), s, n);
        this.privTranslationRecognizer.recognizing(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    handleRecognizedCallback(a, s, n) {
      try {
        const c = new t.TranslationRecognitionEventArgs(t.TranslationRecognitionResult.fromSpeechRecognitionResult(a), s, n);
        this.privTranslationRecognizer.recognized(this.privTranslationRecognizer, c);
      } catch {
      }
    }
    fireEventForResult(a, s) {
      let n;
      if (a.Translation.Translations !== void 0) {
        n = new t.Translations();
        for (const d of a.Translation.Translations)
          n.set(d.Language, d.Text || d.DisplayText);
      }
      let c, u;
      a instanceof r.TranslationPhrase ? (a.Translation && a.Translation.TranslationStatus === e.TranslationStatus.Success ? c = t.ResultReason.TranslatedSpeech : c = t.ResultReason.RecognizedSpeech, u = a.Confidence) : c = t.ResultReason.TranslatingSpeech;
      const l = a.Language, p = new t.TranslationRecognitionResult(n, this.privRequestSession.requestId, c, a.Text, a.Duration, a.Offset, l, u, a.Translation.FailureReason, a.asJson(), s);
      return new t.TranslationRecognitionEventArgs(p, a.Offset, this.privRequestSession.sessionId);
    }
    sendSynthesisAudio(a, s) {
      const n = a === void 0 ? t.ResultReason.SynthesizingAudioCompleted : t.ResultReason.SynthesizingAudio, c = new t.TranslationSynthesisResult(n, a), u = new t.TranslationSynthesisEventArgs(c, s);
      if (this.privTranslationRecognizer.synthesizing)
        try {
          this.privTranslationRecognizer.synthesizing(this.privTranslationRecognizer, u);
        } catch {
        }
    }
  };
  return Pi.TranslationServiceRecognizer = o, Pi;
}
var wi = {}, Ld;
function Iw() {
  if (Ld) return wi;
  Ld = 1, Object.defineProperty(wi, "__esModule", { value: !0 }), wi.SpeechDetected = void 0;
  let e = class Uv {
    constructor(r, o) {
      this.privSpeechStartDetected = JSON.parse(r), this.privSpeechStartDetected.Offset += o;
    }
    static fromJSON(r, o) {
      return new Uv(r, o);
    }
    get Offset() {
      return this.privSpeechStartDetected.Offset;
    }
  };
  return wi.SpeechDetected = e, wi;
}
var bi = {}, jd;
function Aw() {
  if (jd) return bi;
  jd = 1, Object.defineProperty(bi, "__esModule", { value: !0 }), bi.SpeechHypothesis = void 0;
  let e = class $v {
    constructor(r, o) {
      this.privSpeechHypothesis = JSON.parse(r), this.updateOffset(o);
    }
    static fromJSON(r, o) {
      return new $v(r, o);
    }
    updateOffset(r) {
      this.privSpeechHypothesis.Offset += r;
    }
    asJson() {
      return JSON.stringify(this.privSpeechHypothesis);
    }
    get Text() {
      return this.privSpeechHypothesis.Text;
    }
    get Offset() {
      return this.privSpeechHypothesis.Offset;
    }
    get Duration() {
      return this.privSpeechHypothesis.Duration;
    }
    get Language() {
      return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSpeechHypothesis.PrimaryLanguage === void 0 ? void 0 : this.privSpeechHypothesis.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSpeechHypothesis.SpeakerId;
    }
  };
  return bi.SpeechHypothesis = e, bi;
}
var Ei = {}, qd;
function Tw() {
  if (qd) return Ei;
  qd = 1, Object.defineProperty(Ei, "__esModule", { value: !0 }), Ei.SpeechKeyword = void 0;
  let e = class Vv {
    constructor(r, o) {
      this.privSpeechKeyword = JSON.parse(r), this.privSpeechKeyword.Offset += o;
    }
    static fromJSON(r, o) {
      return new Vv(r, o);
    }
    get Status() {
      return this.privSpeechKeyword.Status;
    }
    get Text() {
      return this.privSpeechKeyword.Text;
    }
    get Offset() {
      return this.privSpeechKeyword.Offset;
    }
    get Duration() {
      return this.privSpeechKeyword.Duration;
    }
    asJson() {
      return JSON.stringify(this.privSpeechKeyword);
    }
  };
  return Ei.SpeechKeyword = e, Ei;
}
var Ii = {}, Fd;
function _w() {
  if (Fd) return Ii;
  Fd = 1, Object.defineProperty(Ii, "__esModule", { value: !0 }), Ii.SpeechServiceRecognizer = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class extends t.ServiceRecognizerBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, n, c), this.privSpeechRecognizer = c;
    }
    async processTypeSpecificMessages(i) {
      let a;
      const s = new e.PropertyCollection();
      let n = !1;
      switch (i.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const c = t.SpeechHypothesis.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
          s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, c.asJson()), a = new e.SpeechRecognitionResult(
            this.privRequestSession.requestId,
            e.ResultReason.RecognizingSpeech,
            c.Text,
            c.Duration,
            c.Offset,
            c.Language,
            c.LanguageDetectionConfidence,
            void 0,
            // Speaker Id
            void 0,
            c.asJson(),
            s
          ), this.privRequestSession.onHypothesis(c.Offset);
          const u = new e.SpeechRecognitionEventArgs(a, c.Offset, this.privRequestSession.sessionId);
          if (this.privSpeechRecognizer.recognizing)
            try {
              this.privSpeechRecognizer.recognizing(this.privSpeechRecognizer, u);
            } catch {
            }
          n = !0;
          break;
        case "speech.phrase":
          const l = t.SimpleSpeechPhrase.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
          s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, l.asJson());
          const p = t.EnumTranslation.implTranslateRecognitionResult(l.RecognitionStatus, this.privExpectContentAssessmentResponse);
          if (this.privRequestSession.onPhraseRecognized(l.Offset + l.Duration), e.ResultReason.Canceled === p) {
            const h = t.EnumTranslation.implTranslateCancelResult(l.RecognitionStatus), d = t.EnumTranslation.implTranslateCancelErrorCode(l.RecognitionStatus);
            await this.cancelRecognitionLocal(h, d, t.EnumTranslation.implTranslateErrorDetails(d));
          } else {
            if (l.RecognitionStatus === t.RecognitionStatus.EndOfDictation)
              break;
            if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
              a = new e.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                p,
                l.DisplayText,
                l.Duration,
                l.Offset,
                l.Language,
                l.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                l.asJson(),
                s
              );
            else {
              const d = t.DetailedSpeechPhrase.fromJSON(i.textBody, this.privRequestSession.currentTurnAudioOffset);
              s.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, d.asJson()), a = new e.SpeechRecognitionResult(
                this.privRequestSession.requestId,
                p,
                d.RecognitionStatus === t.RecognitionStatus.Success ? d.NBest[0].Display : "",
                d.Duration,
                d.Offset,
                d.Language,
                d.LanguageDetectionConfidence,
                void 0,
                // Speaker Id
                void 0,
                d.asJson(),
                s
              );
            }
            const h = new e.SpeechRecognitionEventArgs(a, a.offset, this.privRequestSession.sessionId);
            if (this.privSpeechRecognizer.recognized)
              try {
                this.privSpeechRecognizer.recognized(this.privSpeechRecognizer, h);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(a);
              } catch (d) {
                this.privErrorCallback && this.privErrorCallback(d);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          }
          n = !0;
          break;
      }
      return n;
    }
    // Cancels recognition.
    cancelRecognition(i, a, s, n, c) {
      const u = new e.PropertyCollection();
      if (u.setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[n]), this.privSpeechRecognizer.canceled) {
        const l = new e.SpeechRecognitionCanceledEventArgs(s, c, n, void 0, i);
        try {
          this.privSpeechRecognizer.canceled(this.privSpeechRecognizer, l);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const l = new e.SpeechRecognitionResult(
          a,
          e.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          c,
          void 0,
          // Json
          u
        );
        try {
          this.privSuccessCallback(l), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Ii.SpeechServiceRecognizer = r, Ii;
}
var Ai = {}, Sa = {}, Bd;
function kw() {
  return Bd || (Bd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.IdentityProvider = e.SpeakerDiarizationMode = void 0, function(t) {
      t.None = "None", t.Identity = "Identity", t.Anonymous = "Anonymous";
    }(e.SpeakerDiarizationMode || (e.SpeakerDiarizationMode = {})), function(t) {
      t.CallCenter = "CallCenter";
    }(e.IdentityProvider || (e.IdentityProvider = {}));
  }(Sa)), Sa;
}
var Ud;
function Ow() {
  if (Ud) return Ai;
  Ud = 1, Object.defineProperty(Ai, "__esModule", { value: !0 }), Ai.ConversationTranscriptionServiceRecognizer = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _(), r = /* @__PURE__ */ kw(), o = /* @__PURE__ */ Re();
  let i = class extends t.ServiceRecognizerBase {
    constructor(s, n, c, u, l) {
      super(s, n, c, u, l), this.privConversationTranscriber = l, this.setSpeakerDiarizationJson();
    }
    setSpeakerDiarizationJson() {
      if (this.privEnableSpeakerId) {
        const s = this.privSpeechContext.getContext().phraseDetection || {};
        s.mode = o.RecognitionMode.Conversation;
        const n = {};
        n.mode = r.SpeakerDiarizationMode.Anonymous, n.audioSessionId = this.privDiarizationSessionId, n.audioOffsetMs = 0, n.diarizeIntermediates = this.privRecognizerConfig.parameters.getProperty(e.PropertyId.SpeechServiceResponse_DiarizeIntermediateResults, "false") === "true", s.speakerDiarization = n, this.privSpeechContext.getContext().phraseDetection = s;
      }
    }
    async processTypeSpecificMessages(s) {
      let n;
      const c = new e.PropertyCollection();
      c.setProperty(e.PropertyId.SpeechServiceResponse_JsonResult, s.textBody);
      let u = !1;
      switch (s.path.toLowerCase()) {
        case "speech.hypothesis":
        case "speech.fragment":
          const l = t.SpeechHypothesis.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
          n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, e.ResultReason.RecognizingSpeech, l.Text, l.Duration, l.Offset, l.Language, l.LanguageDetectionConfidence, l.SpeakerId, void 0, l.asJson(), c), this.privRequestSession.onHypothesis(l.Offset);
          const p = new e.ConversationTranscriptionEventArgs(n, l.Duration, this.privRequestSession.sessionId);
          if (this.privConversationTranscriber.transcribing)
            try {
              this.privConversationTranscriber.transcribing(this.privConversationTranscriber, p);
            } catch {
            }
          u = !0;
          break;
        case "speech.phrase":
          const h = t.SimpleSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset), d = t.EnumTranslation.implTranslateRecognitionResult(h.RecognitionStatus);
          if (this.privRequestSession.onPhraseRecognized(h.Offset + h.Duration), e.ResultReason.Canceled === d) {
            const f = t.EnumTranslation.implTranslateCancelResult(h.RecognitionStatus), g = t.EnumTranslation.implTranslateCancelErrorCode(h.RecognitionStatus);
            await this.cancelRecognitionLocal(f, g, t.EnumTranslation.implTranslateErrorDetails(g));
          } else if (!(this.privRequestSession.isSpeechEnded && d === e.ResultReason.NoMatch && h.RecognitionStatus !== t.RecognitionStatus.InitialSilenceTimeout)) {
            if (this.privRecognizerConfig.parameters.getProperty(t.OutputFormatPropertyName) === e.OutputFormat[e.OutputFormat.Simple])
              n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, d, h.DisplayText, h.Duration, h.Offset, h.Language, h.LanguageDetectionConfidence, h.SpeakerId, void 0, h.asJson(), c);
            else {
              const g = t.DetailedSpeechPhrase.fromJSON(s.textBody, this.privRequestSession.currentTurnAudioOffset);
              n = new e.ConversationTranscriptionResult(this.privRequestSession.requestId, d, g.RecognitionStatus === t.RecognitionStatus.Success ? g.NBest[0].Display : void 0, g.Duration, g.Offset, g.Language, g.LanguageDetectionConfidence, h.SpeakerId, void 0, g.asJson(), c);
            }
            const f = new e.ConversationTranscriptionEventArgs(n, n.offset, this.privRequestSession.sessionId);
            if (this.privConversationTranscriber.transcribed)
              try {
                this.privConversationTranscriber.transcribed(this.privConversationTranscriber, f);
              } catch {
              }
          }
          u = !0;
          break;
      }
      return u;
    }
    // Cancels recognition.
    cancelRecognition(s, n, c, u, l) {
      if (new e.PropertyCollection().setProperty(t.CancellationErrorCodePropertyName, e.CancellationErrorCode[u]), this.privConversationTranscriber.canceled) {
        const h = new e.ConversationTranscriptionCanceledEventArgs(c, l, u, void 0, s);
        try {
          this.privConversationTranscriber.canceled(this.privConversationTranscriber, h);
        } catch {
        }
      }
    }
  };
  return Ai.ConversationTranscriptionServiceRecognizer = i, Ai;
}
var Ti = {}, $d;
function Mw() {
  if ($d) return Ti;
  $d = 1, Object.defineProperty(Ti, "__esModule", { value: !0 }), Ti.TranscriptionServiceRecognizer = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Ht();
  let i = class extends r.ConversationServiceRecognizer {
    constructor(s, n, c, u, l) {
      super(s, n, c, u, l), this.privTranscriberRecognizer = l, this.sendPrePayloadJSONOverride = (p) => this.sendTranscriptionStartJSON(p), this.privRecognizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceResponse_RequestWordLevelTimestamps) === "true" && this.privSpeechContext.setWordLevelTimings();
    }
    async sendSpeechEventAsync(s, n) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createSpeechEventPayload(s, n));
      }
    }
    async sendMeetingSpeechEventAsync(s, n) {
      if (this.privRequestSession.isRecognizing) {
        const c = await this.fetchConnection();
        await this.sendSpeechEvent(c, this.createMeetingSpeechEventPayload(s, n));
      }
    }
    processTypeSpecificMessages(s) {
      return this.processSpeechMessages(s);
    }
    handleRecognizedCallback(s, n, c) {
      try {
        const u = new t.SpeechRecognitionEventArgs(s, n, c);
        if (this.privTranscriberRecognizer.recognized(this.privTranscriberRecognizer, u), this.privSuccessCallback) {
          try {
            this.privSuccessCallback(s);
          } catch (l) {
            this.privErrorCallback && this.privErrorCallback(l);
          }
          this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
        }
      } catch {
      }
    }
    handleRecognizingCallback(s, n, c) {
      try {
        const u = new t.SpeechRecognitionEventArgs(s, n, c);
        this.privTranscriberRecognizer.recognizing(this.privTranscriberRecognizer, u);
      } catch {
      }
    }
    // Cancels recognition.
    cancelRecognition(s, n, c, u, l) {
      const p = new t.PropertyCollection();
      if (p.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[u]), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        if (this.privTranscriberRecognizer.canceled) {
          const h = new t.MeetingTranscriptionCanceledEventArgs(c, l, u, void 0, s);
          try {
            this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, h);
          } catch {
          }
        }
      } else if (this.privTranscriberRecognizer.canceled) {
        const h = new t.ConversationTranscriptionCanceledEventArgs(c, l, u, void 0, s);
        try {
          this.privTranscriberRecognizer.canceled(this.privTranscriberRecognizer, h);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const h = new t.SpeechRecognitionResult(
          n,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // Language Detection Confidence
          void 0,
          // Speaker Id
          l,
          void 0,
          // Json
          p
        );
        try {
          this.privSuccessCallback(h), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
    // Encapsulated for derived service recognizers that need to send additional JSON
    async sendTranscriptionStartJSON(s) {
      if (await this.sendSpeechContext(s, !0), this.privTranscriberRecognizer.IsMeetingRecognizer()) {
        const n = this.privTranscriberRecognizer.getMeetingInfo(), c = this.createMeetingSpeechEventPayload(n, "start");
        await this.sendSpeechEvent(s, c);
      } else {
        const n = this.privTranscriberRecognizer.getConversationInfo(), c = this.createSpeechEventPayload(n, "start");
        await this.sendSpeechEvent(s, c);
      }
      await this.sendWaveHeader(s);
    }
    sendSpeechEvent(s, n) {
      const c = JSON.stringify(n);
      if (c)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "speech.event", this.privRequestSession.requestId, "application/json", c));
    }
    createSpeechEventPayload(s, n) {
      const c = { id: "meeting", name: n, meeting: s.conversationProperties };
      return c.meeting.id = s.id, c.meeting.attendees = s.participants, c;
    }
    createMeetingSpeechEventPayload(s, n) {
      const c = { id: "meeting", name: n, meeting: s.meetingProperties };
      return c.meeting.id = s.id, c.meeting.attendees = s.participants, c;
    }
  };
  return Ti.TranscriptionServiceRecognizer = i, Ti;
}
var _i = {}, Vd;
function Dw() {
  if (Vd) return _i;
  Vd = 1, Object.defineProperty(_i, "__esModule", { value: !0 }), _i.DetailedSpeechPhrase = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Wv {
    constructor(o, i) {
      this.privDetailedSpeechPhrase = JSON.parse(o), this.privDetailedSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privDetailedSpeechPhrase.RecognitionStatus), this.updateOffsets(i);
    }
    static fromJSON(o, i) {
      return new Wv(o, i);
    }
    updateOffsets(o) {
      if (this.privDetailedSpeechPhrase.Offset += o, this.privDetailedSpeechPhrase.NBest)
        for (const i of this.privDetailedSpeechPhrase.NBest) {
          if (i.Words)
            for (const a of i.Words)
              a.Offset += o;
          if (i.DisplayWords)
            for (const a of i.DisplayWords)
              a.Offset += o;
        }
    }
    asJson() {
      const o = { ...this.privDetailedSpeechPhrase };
      return JSON.stringify({
        ...o,
        RecognitionStatus: e.RecognitionStatus[o.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privDetailedSpeechPhrase.RecognitionStatus;
    }
    get NBest() {
      return this.privDetailedSpeechPhrase.NBest;
    }
    get Duration() {
      return this.privDetailedSpeechPhrase.Duration;
    }
    get Offset() {
      return this.privDetailedSpeechPhrase.Offset;
    }
    get Language() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privDetailedSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privDetailedSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get Text() {
      return this.privDetailedSpeechPhrase.NBest && this.privDetailedSpeechPhrase.NBest[0] ? this.privDetailedSpeechPhrase.NBest[0].Display || this.privDetailedSpeechPhrase.NBest[0].DisplayText : this.privDetailedSpeechPhrase.DisplayText;
    }
    get SpeakerId() {
      return this.privDetailedSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(o) {
      if (typeof o == "string")
        return e.RecognitionStatus[o];
      if (typeof o == "number")
        return o;
    }
  };
  return _i.DetailedSpeechPhrase = t, _i;
}
var ki = {}, Wd;
function Nw() {
  if (Wd) return ki;
  Wd = 1, Object.defineProperty(ki, "__esModule", { value: !0 }), ki.SimpleSpeechPhrase = void 0;
  const e = /* @__PURE__ */ _();
  let t = class Hv {
    constructor(o, i = 0) {
      this.privSimpleSpeechPhrase = JSON.parse(o), this.privSimpleSpeechPhrase.RecognitionStatus = this.mapRecognitionStatus(this.privSimpleSpeechPhrase.RecognitionStatus), this.updateOffset(i);
    }
    static fromJSON(o, i) {
      return new Hv(o, i);
    }
    updateOffset(o) {
      this.privSimpleSpeechPhrase.Offset += o;
    }
    asJson() {
      const o = { ...this.privSimpleSpeechPhrase };
      return JSON.stringify({
        ...o,
        RecognitionStatus: e.RecognitionStatus[o.RecognitionStatus]
      });
    }
    get RecognitionStatus() {
      return this.privSimpleSpeechPhrase.RecognitionStatus;
    }
    get DisplayText() {
      return this.privSimpleSpeechPhrase.DisplayText;
    }
    get Offset() {
      return this.privSimpleSpeechPhrase.Offset;
    }
    get Duration() {
      return this.privSimpleSpeechPhrase.Duration;
    }
    get Language() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Language;
    }
    get LanguageDetectionConfidence() {
      return this.privSimpleSpeechPhrase.PrimaryLanguage === void 0 ? void 0 : this.privSimpleSpeechPhrase.PrimaryLanguage.Confidence;
    }
    get SpeakerId() {
      return this.privSimpleSpeechPhrase.SpeakerId;
    }
    mapRecognitionStatus(o) {
      if (typeof o == "string")
        return e.RecognitionStatus[o];
      if (typeof o == "number")
        return o;
    }
  };
  return ki.SimpleSpeechPhrase = t, ki;
}
var Oi = {}, Hd;
function xw() {
  if (Hd) return Oi;
  Hd = 1, Object.defineProperty(Oi, "__esModule", { value: !0 }), Oi.AddedLmIntent = void 0;
  let e = class {
    /**
     * Creates and initializes an instance of this class.
     * @constructor
     * @param modelImpl - The model.
     * @param intentName - The intent name.
     */
    constructor(r, o) {
      this.modelImpl = r, this.intentName = o;
    }
  };
  return Oi.AddedLmIntent = e, Oi;
}
var Mi = {}, Kd;
function zw() {
  if (Kd) return Mi;
  Kd = 1, Object.defineProperty(Mi, "__esModule", { value: !0 }), Mi.IntentServiceRecognizer = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _();
  let o = class extends r.ServiceRecognizerBase {
    constructor(a, s, n, c, u) {
      super(a, s, n, c, u), this.privIntentRecognizer = u, this.privIntentDataSent = !1, c.recognitionEndpointVersion = "1";
    }
    setIntents(a, s) {
      this.privAddedLmIntents = a, this.privUmbrellaIntent = s, this.privIntentDataSent = !0;
    }
    processTypeSpecificMessages(a) {
      let s, n, c = !1;
      const u = new t.PropertyCollection();
      switch (a.messageType === e.MessageType.Text && u.setProperty(t.PropertyId.SpeechServiceResponse_JsonResult, a.textBody), a.path.toLowerCase()) {
        case "speech.hypothesis":
          const p = r.SpeechHypothesis.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (s = new t.IntentRecognitionResult(void 0, this.privRequestSession.requestId, t.ResultReason.RecognizingIntent, p.Text, p.Duration, p.Offset, p.Language, p.LanguageDetectionConfidence, void 0, p.asJson(), u), this.privRequestSession.onHypothesis(s.offset), n = new t.IntentRecognitionEventArgs(s, p.Offset, this.privRequestSession.sessionId), this.privIntentRecognizer.recognizing)
            try {
              this.privIntentRecognizer.recognizing(this.privIntentRecognizer, n);
            } catch {
            }
          c = !0;
          break;
        case "speech.phrase":
          const h = r.SimpleSpeechPhrase.fromJSON(a.textBody, this.privRequestSession.currentTurnAudioOffset);
          s = new t.IntentRecognitionResult(void 0, this.privRequestSession.requestId, r.EnumTranslation.implTranslateRecognitionResult(h.RecognitionStatus), h.DisplayText, h.Duration, h.Offset, h.Language, h.LanguageDetectionConfidence, void 0, h.asJson(), u), n = new t.IntentRecognitionEventArgs(s, s.offset, this.privRequestSession.sessionId);
          const d = () => {
            if (this.privIntentRecognizer.recognized)
              try {
                this.privIntentRecognizer.recognized(this.privIntentRecognizer, n);
              } catch {
              }
            if (this.privSuccessCallback) {
              try {
                this.privSuccessCallback(s);
              } catch (g) {
                this.privErrorCallback && this.privErrorCallback(g);
              }
              this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
            }
          };
          this.privIntentDataSent === !1 || t.ResultReason.NoMatch === n.result.reason ? (this.privRequestSession.onPhraseRecognized(n.offset + n.result.duration), d()) : this.privPendingIntentArgs = n, c = !0;
          break;
        case "response":
          if (n = this.privPendingIntentArgs, this.privPendingIntentArgs = void 0, n === void 0) {
            if (a.textBody === "")
              return;
            n = new t.IntentRecognitionEventArgs(new t.IntentRecognitionResult(), 0, this.privRequestSession.sessionId);
          }
          const f = r.IntentResponse.fromJSON(a.textBody);
          if (f !== null && f.topScoringIntent && f.topScoringIntent.intent) {
            let g = this.privAddedLmIntents[f.topScoringIntent.intent];
            if (this.privUmbrellaIntent !== void 0 && (g = this.privUmbrellaIntent), g) {
              const m = g === void 0 || g.intentName === void 0 ? f.topScoringIntent.intent : g.intentName;
              let v = n.result.reason;
              m !== void 0 && (v = t.ResultReason.RecognizedIntent);
              const y = n.result.properties !== void 0 ? n.result.properties : new t.PropertyCollection();
              y.setProperty(t.PropertyId.LanguageUnderstandingServiceResponse_JsonResult, a.textBody), n = new t.IntentRecognitionEventArgs(new t.IntentRecognitionResult(m, n.result.resultId, v, n.result.text, n.result.duration, n.result.offset, void 0, void 0, n.result.errorDetails, n.result.json, y), n.offset, n.sessionId);
            }
          }
          if (this.privRequestSession.onPhraseRecognized(n.offset + n.result.duration), this.privIntentRecognizer.recognized)
            try {
              this.privIntentRecognizer.recognized(this.privIntentRecognizer, n);
            } catch {
            }
          if (this.privSuccessCallback) {
            try {
              this.privSuccessCallback(n.result);
            } catch (g) {
              this.privErrorCallback && this.privErrorCallback(g);
            }
            this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
          }
          c = !0;
          break;
      }
      const l = new e.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(a, s, n, c, u) {
      const l = new t.PropertyCollection();
      if (l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]), this.privIntentRecognizer.canceled) {
        const p = new t.IntentRecognitionCanceledEventArgs(n, u, c, void 0, void 0, a);
        try {
          this.privIntentRecognizer.canceled(this.privIntentRecognizer, p);
        } catch {
        }
      }
      if (this.privSuccessCallback) {
        const p = new t.IntentRecognitionResult(
          void 0,
          // Intent Id
          s,
          t.ResultReason.Canceled,
          void 0,
          // Text
          void 0,
          // Duration
          void 0,
          // Offset
          void 0,
          // Language
          void 0,
          // LanguageDetectionConfidence
          u,
          void 0,
          // Json
          l
        );
        try {
          this.privSuccessCallback(p), this.privSuccessCallback = void 0;
        } catch {
        }
      }
    }
  };
  return Mi.IntentServiceRecognizer = o, Mi;
}
var Di = {}, Jd;
function Lw() {
  if (Jd) return Di;
  Jd = 1, Object.defineProperty(Di, "__esModule", { value: !0 }), Di.IntentResponse = void 0;
  let e = class Kv {
    constructor(r) {
      r === "" ? this.privIntentResponse = {} : this.privIntentResponse = JSON.parse(r);
    }
    static fromJSON(r) {
      return new Kv(r);
    }
    get query() {
      return this.privIntentResponse.query;
    }
    get topScoringIntent() {
      return this.privIntentResponse.topScoringIntent;
    }
    get entities() {
      return this.privIntentResponse.entities;
    }
  };
  return Di.IntentResponse = e, Di;
}
var Ca = {}, Gd;
function jw() {
  return Gd || (Gd = 1, Object.defineProperty(Ca, "__esModule", { value: !0 })), Ca;
}
var Ni = {}, xi = {}, Qd;
function qw() {
  if (Qd) return xi;
  Qd = 1, Object.defineProperty(xi, "__esModule", { value: !0 }), xi.ServiceTelemetryListener = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ dc();
  class r {
    constructor(i, a, s) {
      this.privIsDisposed = !1, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privRequestId = i, this.privAudioSourceId = a, this.privAudioNodeId = s, this.privReceivedMessages = {}, this.privPhraseLatencies = [], this.privHypothesisLatencies = [];
    }
    phraseReceived(i) {
      i > 0 && this.privPhraseLatencies.push(Date.now() - i);
    }
    hypothesisReceived(i) {
      i > 0 && this.privHypothesisLatencies.push(Date.now() - i);
    }
    onEvent(i) {
      this.privIsDisposed || (i instanceof t.RecognitionTriggeredEvent && i.requestId === this.privRequestId && (this.privListeningTriggerMetric = {
        End: i.eventTime,
        Name: "ListeningTrigger",
        Start: i.eventTime
      }), i instanceof e.AudioStreamNodeAttachingEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = i.eventTime), i instanceof e.AudioStreamNodeAttachedEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicStartTime = i.eventTime), i instanceof e.AudioSourceErrorEvent && i.audioSourceId === this.privAudioSourceId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Error: i.error,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof e.AudioStreamNodeErrorEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Error: i.error,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof e.AudioStreamNodeDetachedEvent && i.audioSourceId === this.privAudioSourceId && i.audioNodeId === this.privAudioNodeId && (this.privMicMetric || (this.privMicMetric = {
        End: i.eventTime,
        Name: "Microphone",
        Start: this.privMicStartTime
      })), i instanceof t.ConnectingToServiceEvent && i.requestId === this.privRequestId && (this.privConnectionId = i.sessionId), i instanceof e.ConnectionStartEvent && i.connectionId === this.privConnectionId && (this.privConnectionStartTime = i.eventTime), i instanceof e.ConnectionEstablishedEvent && i.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
        End: i.eventTime,
        Id: this.privConnectionId,
        Name: "Connection",
        Start: this.privConnectionStartTime
      })), i instanceof e.ConnectionEstablishErrorEvent && i.connectionId === this.privConnectionId && (this.privConnectionEstablishMetric || (this.privConnectionEstablishMetric = {
        End: i.eventTime,
        Error: this.getConnectionError(i.statusCode),
        Id: this.privConnectionId,
        Name: "Connection",
        Start: this.privConnectionStartTime
      })), i instanceof e.ConnectionMessageReceivedEvent && i.connectionId === this.privConnectionId && i.message && i.message.headers && i.message.headers.path && (this.privReceivedMessages[i.message.headers.path] || (this.privReceivedMessages[i.message.headers.path] = new Array()), this.privReceivedMessages[i.message.headers.path].length < 50 && this.privReceivedMessages[i.message.headers.path].push(i.networkReceivedTime)));
    }
    getTelemetry() {
      const i = new Array();
      this.privListeningTriggerMetric && i.push(this.privListeningTriggerMetric), this.privMicMetric && i.push(this.privMicMetric), this.privConnectionEstablishMetric && i.push(this.privConnectionEstablishMetric), this.privPhraseLatencies.length > 0 && i.push({
        PhraseLatencyMs: this.privPhraseLatencies
      }), this.privHypothesisLatencies.length > 0 && i.push({
        FirstHypothesisLatencyMs: this.privHypothesisLatencies
      });
      const a = {
        Metrics: i,
        ReceivedMessages: this.privReceivedMessages
      }, s = JSON.stringify(a);
      return this.privReceivedMessages = {}, this.privListeningTriggerMetric = null, this.privMicMetric = null, this.privConnectionEstablishMetric = null, this.privPhraseLatencies = [], this.privHypothesisLatencies = [], s;
    }
    // Determines if there are any telemetry events to send to the service.
    get hasTelemetry() {
      return Object.keys(this.privReceivedMessages).length !== 0 || this.privListeningTriggerMetric !== null || this.privMicMetric !== null || this.privConnectionEstablishMetric !== null || this.privPhraseLatencies.length !== 0 || this.privHypothesisLatencies.length !== 0;
    }
    dispose() {
      this.privIsDisposed = !0;
    }
    getConnectionError(i) {
      switch (i) {
        case 400:
        case 1002:
        case 1003:
        case 1005:
        case 1007:
        case 1008:
        case 1009:
          return "BadRequest";
        case 401:
          return "Unauthorized";
        case 403:
          return "Forbidden";
        case 503:
        case 1001:
          return "ServerUnavailable";
        case 500:
        case 1011:
          return "ServerError";
        case 408:
        case 504:
          return "Timeout";
        default:
          return "statuscode:" + i.toString();
      }
    }
  }
  return xi.ServiceTelemetryListener = r, xi;
}
var Yd;
function Fw() {
  if (Yd) return Ni;
  Yd = 1, Object.defineProperty(Ni, "__esModule", { value: !0 }), Ni.RequestSession = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ dc(), r = /* @__PURE__ */ qw();
  let o = class {
    constructor(a) {
      this.privIsDisposed = !1, this.privDetachables = new Array(), this.privIsAudioNodeDetached = !1, this.privIsRecognizing = !1, this.privIsSpeechEnded = !1, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privHypothesisReceived = !1, this.privBytesSent = 0, this.privRecognitionBytesSent = 0, this.privRecogNumber = 0, this.privInTurn = !1, this.privConnectionAttempts = 0, this.privAudioSourceId = a, this.privRequestId = (0, e.createNoDashGuid)(), this.privAudioNodeId = (0, e.createNoDashGuid)(), this.privTurnDeferral = new e.Deferred(), this.privTurnDeferral.resolve();
    }
    get sessionId() {
      return this.privSessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get audioNodeId() {
      return this.privAudioNodeId;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSpeechEnded() {
      return this.privIsSpeechEnded;
    }
    get isRecognizing() {
      return this.privIsRecognizing;
    }
    get currentTurnAudioOffset() {
      return this.privTurnStartAudioOffset;
    }
    get recogNumber() {
      return this.privRecogNumber;
    }
    get numConnectionAttempts() {
      return this.privConnectionAttempts;
    }
    // The number of bytes sent for the current connection.
    // Counter is reset to 0 each time a connection is established.
    get bytesSent() {
      return this.privBytesSent;
    }
    // The number of bytes sent for the current recognition.
    // Counter is reset to 0 each time recognition is started.
    get recognitionBytesSent() {
      return this.privRecognitionBytesSent;
    }
    listenForServiceTelemetry(a) {
      this.privServiceTelemetryListener && this.privDetachables.push(a.attachListener(this.privServiceTelemetryListener));
    }
    startNewRecognition() {
      this.privRecognitionBytesSent = 0, this.privIsSpeechEnded = !1, this.privIsRecognizing = !0, this.privTurnStartAudioOffset = 0, this.privLastRecoOffset = 0, this.privRecogNumber++, this.privServiceTelemetryListener = new r.ServiceTelemetryListener(this.privRequestId, this.privAudioSourceId, this.privAudioNodeId), this.onEvent(new t.RecognitionTriggeredEvent(this.requestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
    async onAudioSourceAttachCompleted(a, s) {
      this.privAudioNode = a, this.privIsAudioNodeDetached = !1, s ? await this.onComplete() : this.onEvent(new t.ListeningStartedEvent(this.privRequestId, this.privSessionId, this.privAudioSourceId, this.privAudioNodeId));
    }
    onPreConnectionStart(a, s) {
      this.privAuthFetchEventId = a, this.privSessionId = s, this.onEvent(new t.ConnectingToServiceEvent(this.privRequestId, this.privAuthFetchEventId, this.privSessionId));
    }
    async onAuthCompleted(a) {
      a && await this.onComplete();
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    async onConnectionEstablishCompleted(a, s) {
      if (a === 200) {
        this.onEvent(new t.RecognitionStartedEvent(this.requestId, this.privAudioSourceId, this.privAudioNodeId, this.privAuthFetchEventId, this.privSessionId)), this.privAudioNode && this.privAudioNode.replay(), this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privBytesSent = 0;
        return;
      } else a === 403 && await this.onComplete();
    }
    async onServiceTurnEndResponse(a) {
      this.privTurnDeferral.resolve(), !a || this.isSpeechEnded ? (await this.onComplete(), this.privInTurn = !1) : (this.privTurnStartAudioOffset = this.privLastRecoOffset, this.privAudioNode.replay());
    }
    onSpeechContext() {
      this.privRequestId = (0, e.createNoDashGuid)();
    }
    onServiceTurnStartResponse() {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new e.Deferred();
    }
    onHypothesis(a) {
      this.privHypothesisReceived || (this.privHypothesisReceived = !0, this.privServiceTelemetryListener.hypothesisReceived(this.privAudioNode.findTimeAtOffset(a)));
    }
    onPhraseRecognized(a) {
      this.privServiceTelemetryListener.phraseReceived(this.privAudioNode.findTimeAtOffset(a)), this.onServiceRecognized(a);
    }
    onServiceRecognized(a) {
      this.privLastRecoOffset = a, this.privHypothesisReceived = !1, this.privAudioNode.shrinkBuffers(a), this.privConnectionAttempts = 0;
    }
    onAudioSent(a) {
      this.privBytesSent += a, this.privRecognitionBytesSent += a;
    }
    onRetryConnection() {
      this.privConnectionAttempts++;
    }
    async dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = !0;
        for (const a of this.privDetachables)
          await a.detach();
        this.privServiceTelemetryListener && this.privServiceTelemetryListener.dispose(), this.privIsRecognizing = !1;
      }
    }
    getTelemetry() {
      return this.privServiceTelemetryListener.hasTelemetry ? this.privServiceTelemetryListener.getTelemetry() : null;
    }
    async onStopRecognizing() {
      await this.onComplete();
    }
    // Should be called with the audioNode for this session has indicated that it is out of speech.
    onSpeechEnded() {
      this.privIsSpeechEnded = !0;
    }
    onEvent(a) {
      this.privServiceTelemetryListener && this.privServiceTelemetryListener.onEvent(a), e.Events.instance.onEvent(a);
    }
    async onComplete() {
      this.privIsRecognizing && (this.privIsRecognizing = !1, await this.detachAudioNode());
    }
    async detachAudioNode() {
      this.privIsAudioNodeDetached || (this.privIsAudioNodeDetached = !0, this.privAudioNode && await this.privAudioNode.detach());
    }
  };
  return Ni.RequestSession = o, Ni;
}
var zi = {}, Ra = {}, Zd;
function Bw() {
  return Zd || (Zd = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TentativePhraseResultsOption = e.OutputFormat = e.PhraseExtension = e.PhraseOption = void 0, function(t) {
      t.WordTimings = "WordTimings", t.SNR = "SNR", t.Pronunciation = "Pronunciation", t.WordPronunciation = "WordPronunciation", t.WordConfidence = "WordConfidence", t.Words = "Words", t.Sentiment = "Sentiment", t.PronunciationAssessment = "PronunciationAssessment", t.ContentAssessment = "ContentAssessment", t.PhraseAMScore = "PhraseAMScore", t.PhraseLMScore = "PhraseLMScore", t.WordAMScore = "WordAMScore", t.WordLMScore = "WordLMScore", t.RuleTree = "RuleTree", t.NBestTimings = "NBestTimings", t.DecoderDiagnostics = "DecoderDiagnostics", t.DisplayWordTimings = "DisplayWordTimings", t.DisplayWords = "DisplayWords";
    }(e.PhraseOption || (e.PhraseOption = {})), function(t) {
      t.Graph = "Graph", t.Corrections = "Corrections", t.Sentiment = "Sentiment";
    }(e.PhraseExtension || (e.PhraseExtension = {})), function(t) {
      t.Simple = "Simple", t.Detailed = "Detailed";
    }(e.OutputFormat || (e.OutputFormat = {})), function(t) {
      t.None = "None", t.Always = "Always";
    }(e.TentativePhraseResultsOption || (e.TentativePhraseResultsOption = {}));
  }(Ra)), Ra;
}
var Xd;
function Uw() {
  if (Xd) return zi;
  Xd = 1, Object.defineProperty(zi, "__esModule", { value: !0 }), zi.SpeechContext = void 0;
  const e = /* @__PURE__ */ Re(), t = /* @__PURE__ */ Bw();
  let r = class {
    constructor(i) {
      this.privContext = {}, this.privDynamicGrammar = i;
    }
    getContext() {
      return this.privContext;
    }
    /**
     * @Internal
     * This is only used by pronunciation assessment config.
     * Do not use externally, object returned will change without warning or notice.
     */
    setPronunciationAssessmentParams(i, a, s = !1) {
      this.privContext.phraseDetection === void 0 && (this.privContext.phraseDetection = {
        enrichment: {
          pronunciationAssessment: {}
        }
      }), this.privContext.phraseDetection.enrichment === void 0 && (this.privContext.phraseDetection.enrichment = {
        pronunciationAssessment: {}
      }), this.privContext.phraseDetection.enrichment.pronunciationAssessment = JSON.parse(i) || {}, s && (this.privContext.phraseDetection.mode = e.RecognitionMode.Conversation), this.setWordLevelTimings(), this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.PronunciationAssessment), this.privContext.phraseOutput.detailed.options.indexOf(t.PhraseOption.SNR) === -1 && this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.SNR), a && (this.privContext.phraseDetection.enrichment.contentAssessment = {
        topic: a
      }, this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.ContentAssessment));
    }
    setDetailedOutputFormat() {
      this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
        detailed: {
          options: []
        }
      }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
        options: []
      }), this.privContext.phraseOutput.format = t.OutputFormat.Detailed;
    }
    setWordLevelTimings() {
      this.privContext.phraseOutput === void 0 && (this.privContext.phraseOutput = {
        detailed: {
          options: []
        }
      }), this.privContext.phraseOutput.detailed === void 0 && (this.privContext.phraseOutput.detailed = {
        options: []
      }), this.privContext.phraseOutput.format = t.OutputFormat.Detailed, this.privContext.phraseOutput.detailed.options.indexOf(t.PhraseOption.WordTimings) === -1 && this.privContext.phraseOutput.detailed.options.push(t.PhraseOption.WordTimings);
    }
    setSpeakerDiarizationAudioOffsetMs(i) {
      this.privContext.phraseDetection.speakerDiarization.audioOffsetMs = i;
    }
    toJSON() {
      const i = this.privDynamicGrammar.generateGrammarObject();
      return this.privContext.dgi = i, JSON.stringify(this.privContext);
    }
  };
  return zi.SpeechContext = r, zi;
}
var Li = {}, Pa = {}, eh;
function $w() {
  return eh || (eh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SubstringMatchType = e.GroupType = void 0, function(t) {
      t.IntentText = "IntentText", t.IntentEntity = "IntentEntity", t.Generic = "Generic", t.People = "People", t.Place = "Place", t.DynamicEntity = "DynamicEntity";
    }(e.GroupType || (e.GroupType = {})), function(t) {
      t.None = "None", t.LeftRooted = "LeftRooted", t.PartialName = "PartialName", t.MiddleOfSentence = "MiddleOfSentence";
    }(e.SubstringMatchType || (e.SubstringMatchType = {}));
  }(Pa)), Pa;
}
var th;
function Vw() {
  if (th) return Li;
  th = 1, Object.defineProperty(Li, "__esModule", { value: !0 }), Li.DynamicGrammarBuilder = void 0;
  const e = /* @__PURE__ */ $w();
  let t = class {
    // Adds one more reference phrases to the dynamic grammar to send.
    // All added phrases are generic phrases.
    addPhrase(o) {
      this.privPhrases || (this.privPhrases = []), o instanceof Array ? this.privPhrases = this.privPhrases.concat(o) : this.privPhrases.push(o);
    }
    // Clears all phrases stored in the current object.
    clearPhrases() {
      this.privPhrases = void 0;
    }
    // Adds one or more reference grammars to the current grammar.
    addReferenceGrammar(o) {
      this.privGrammars || (this.privGrammars = []), o instanceof Array ? this.privGrammars = this.privGrammars.concat(o) : this.privGrammars.push(o);
    }
    // clears all grammars stored on the recognizer.
    clearGrammars() {
      this.privGrammars = void 0;
    }
    // Generates an object that represents the dynamic grammar used by the Speech Service.
    // This is done by building an object with the correct layout based on the phrases and reference grammars added to this instance
    // of a DynamicGrammarBuilder
    generateGrammarObject() {
      if (this.privGrammars === void 0 && this.privPhrases === void 0)
        return;
      const o = {};
      if (o.referenceGrammars = this.privGrammars, this.privPhrases !== void 0 && this.privPhrases.length !== 0) {
        const i = [];
        this.privPhrases.forEach((a) => {
          i.push({
            text: a
          });
        }), o.groups = [{ type: e.GroupType.Generic, items: i }];
      }
      return o;
    }
  };
  return Li.DynamicGrammarBuilder = t, Li;
}
var ji = {}, qi = {}, Fi = {}, wa = {}, rh;
function Jv() {
  return rh || (rh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.MessageDataStreamType = e.ActivityPayloadResponse = void 0;
    class t {
      constructor(o) {
        this.privActivityResponse = JSON.parse(o);
      }
      static fromJSON(o) {
        return new t(o);
      }
      get conversationId() {
        return this.privActivityResponse.conversationId;
      }
      get messageDataStreamType() {
        return this.privActivityResponse.messageDataStreamType;
      }
      get messagePayload() {
        return this.privActivityResponse.messagePayload;
      }
      get version() {
        return this.privActivityResponse.version;
      }
    }
    e.ActivityPayloadResponse = t, function(r) {
      r[r.None = 0] = "None", r[r.TextToSpeechAudio = 1] = "TextToSpeechAudio";
    }(e.MessageDataStreamType || (e.MessageDataStreamType = {}));
  }(wa)), wa;
}
var nh;
function Ww() {
  if (nh) return Fi;
  nh = 1, Object.defineProperty(Fi, "__esModule", { value: !0 }), Fi.DialogServiceTurnState = void 0;
  const e = /* @__PURE__ */ Ss(), t = /* @__PURE__ */ Wt(), r = /* @__PURE__ */ Jv();
  let o = class {
    constructor(a, s) {
      this.privRequestId = s, this.privIsCompleted = !1, this.privAudioStream = null, this.privTurnManager = a, this.resetTurnEndTimeout();
    }
    get audioStream() {
      return this.resetTurnEndTimeout(), this.privAudioStream;
    }
    processActivityPayload(a, s) {
      return a.messageDataStreamType === r.MessageDataStreamType.TextToSpeechAudio && (this.privAudioStream = t.AudioOutputStream.createPullStream(), this.privAudioStream.format = s !== void 0 ? s : e.AudioOutputFormatImpl.getDefaultOutputFormat()), this.privAudioStream;
    }
    endAudioStream() {
      this.privAudioStream !== null && !this.privAudioStream.isClosed && this.privAudioStream.close();
    }
    complete() {
      this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.endAudioStream();
    }
    resetTurnEndTimeout() {
      this.privTimeoutToken !== void 0 && clearTimeout(this.privTimeoutToken), this.privTimeoutToken = setTimeout(() => {
        this.privTurnManager.CompleteTurn(this.privRequestId);
      }, 2e3);
    }
  };
  return Fi.DialogServiceTurnState = o, Fi;
}
var ih;
function Hw() {
  if (ih) return qi;
  ih = 1, Object.defineProperty(qi, "__esModule", { value: !0 }), qi.DialogServiceTurnStateManager = void 0;
  const e = /* @__PURE__ */ Ne(), t = /* @__PURE__ */ Ww();
  let r = class {
    constructor() {
      this.privTurnMap = /* @__PURE__ */ new Map();
    }
    StartTurn(i) {
      if (this.privTurnMap.has(i))
        throw new e.InvalidOperationError("Service error: There is already a turn with id:" + i);
      const a = new t.DialogServiceTurnState(this, i);
      return this.privTurnMap.set(i, a), this.privTurnMap.get(i);
    }
    GetTurn(i) {
      return this.privTurnMap.get(i);
    }
    CompleteTurn(i) {
      if (!this.privTurnMap.has(i))
        throw new e.InvalidOperationError("Service error: Received turn end for an unknown turn id:" + i);
      const a = this.privTurnMap.get(i);
      return a.complete(), this.privTurnMap.delete(i), a;
    }
  };
  return qi.DialogServiceTurnStateManager = r, qi;
}
var ba = {}, sh;
function Kw() {
  return sh || (sh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.InvocationSource = void 0, function(t) {
      t.None = "None", t.VoiceActivationWithKeyword = "VoiceActivationWithKeyword";
    }(e.InvocationSource || (e.InvocationSource = {}));
  }(ba)), ba;
}
var Ea = {}, oh;
function Jw() {
  return oh || (oh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.OnRejectAction = e.KeywordDetectionType = void 0, function(t) {
      t.StartTrigger = "StartTrigger";
    }(e.KeywordDetectionType || (e.KeywordDetectionType = {})), function(t) {
      t.EndOfTurn = "EndOfTurn", t.Continue = "Continue";
    }(e.OnRejectAction || (e.OnRejectAction = {}));
  }(Ea)), Ea;
}
var ah;
function Gw() {
  if (ah) return ji;
  ah = 1, Object.defineProperty(ji, "__esModule", { value: !0 }), ji.DialogServiceAdapter = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ tv(), r = /* @__PURE__ */ k(), o = /* @__PURE__ */ Ss(), i = /* @__PURE__ */ I(), a = /* @__PURE__ */ Hw(), s = /* @__PURE__ */ _(), n = /* @__PURE__ */ Jv(), c = /* @__PURE__ */ Kw(), u = /* @__PURE__ */ Jw(), l = /* @__PURE__ */ Ht();
  let p = class extends s.ServiceRecognizerBase {
    constructor(d, f, g, m, v) {
      super(d, f, g, m, v), this.privEvents = new r.EventSource(), this.privDialogServiceConnector = v, this.receiveMessageOverride = () => this.receiveDialogMessageOverride(), this.privTurnStateManager = new a.DialogServiceTurnStateManager(), this.recognizeOverride = (y, S, C) => this.listenOnce(y, S, C), this.postConnectImplOverride = (y) => this.dialogConnectImpl(y), this.configConnectionOverride = (y) => this.configConnection(y), this.disconnectOverride = () => this.privDisconnect(), this.privDialogAudioSource = g, this.agentConfigSent = !1, this.privLastResult = null, this.connectionEvents.attach((y) => {
        y.name === "ConnectionClosedEvent" && (this.terminateMessageLoop = !0);
      });
    }
    async sendMessage(d) {
      const f = (0, r.createGuid)(), g = (0, r.createNoDashGuid)(), m = {
        context: {
          interactionId: f
        },
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        messagePayload: JSON.parse(d),
        version: 0.5
      }, v = JSON.stringify(m);
      await (await this.fetchConnection()).send(new l.SpeechConnectionMessage(r.MessageType.Text, "agent", g, "application/json", v));
    }
    async privDisconnect() {
      await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, this.agentConfigSent = !1;
    }
    processTypeSpecificMessages(d) {
      const f = new i.PropertyCollection();
      d.messageType === r.MessageType.Text && f.setProperty(i.PropertyId.SpeechServiceResponse_JsonResult, d.textBody);
      let g, m;
      switch (d.path.toLowerCase()) {
        case "speech.phrase":
          const y = s.SimpleSpeechPhrase.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          if (this.privRequestSession.onPhraseRecognized(y.Offset + y.Duration), y.RecognitionStatus !== s.RecognitionStatus.TooManyRequests && y.RecognitionStatus !== s.RecognitionStatus.Error) {
            const A = this.fireEventForResult(y, f);
            if (this.privLastResult = A.result, this.privDialogServiceConnector.recognized)
              try {
                this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, A);
              } catch {
              }
          }
          m = !0;
          break;
        case "speech.hypothesis":
          const S = s.SpeechHypothesis.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          g = new i.SpeechRecognitionResult(this.privRequestSession.requestId, i.ResultReason.RecognizingSpeech, S.Text, S.Duration, S.Offset, S.Language, S.LanguageDetectionConfidence, void 0, void 0, S.asJson(), f), this.privRequestSession.onHypothesis(S.Offset);
          const C = new i.SpeechRecognitionEventArgs(g, S.Offset, this.privRequestSession.sessionId);
          if (this.privDialogServiceConnector.recognizing)
            try {
              this.privDialogServiceConnector.recognizing(this.privDialogServiceConnector, C);
            } catch {
            }
          m = !0;
          break;
        case "speech.keyword":
          const w = s.SpeechKeyword.fromJSON(d.textBody, this.privRequestSession.currentTurnAudioOffset);
          g = new i.SpeechRecognitionResult(this.privRequestSession.requestId, w.Status === "Accepted" ? i.ResultReason.RecognizedKeyword : i.ResultReason.NoMatch, w.Text, w.Duration, w.Offset, void 0, void 0, void 0, void 0, w.asJson(), f), w.Status !== "Accepted" && (this.privLastResult = g);
          const b = new i.SpeechRecognitionEventArgs(g, g.duration, g.resultId);
          if (this.privDialogServiceConnector.recognized)
            try {
              this.privDialogServiceConnector.recognized(this.privDialogServiceConnector, b);
            } catch {
            }
          m = !0;
          break;
        case "audio":
          {
            const A = d.requestId.toUpperCase(), E = this.privTurnStateManager.GetTurn(A);
            try {
              d.binaryBody ? E.audioStream.write(d.binaryBody) : E.endAudioStream();
            } catch {
            }
          }
          m = !0;
          break;
        case "response":
          this.handleResponseMessage(d), m = !0;
          break;
      }
      const v = new r.Deferred();
      return v.resolve(m), v.promise;
    }
    // Cancels recognition.
    async cancelRecognition(d, f, g, m, v) {
      if (this.terminateMessageLoop = !0, this.privRequestSession.isRecognizing && await this.privRequestSession.onStopRecognizing(), this.privDialogServiceConnector.canceled) {
        const y = new i.PropertyCollection();
        y.setProperty(s.CancellationErrorCodePropertyName, i.CancellationErrorCode[m]);
        const S = new i.SpeechRecognitionCanceledEventArgs(g, v, m, void 0, d);
        try {
          this.privDialogServiceConnector.canceled(this.privDialogServiceConnector, S);
        } catch {
        }
        if (this.privSuccessCallback) {
          const C = new i.SpeechRecognitionResult(
            void 0,
            // ResultId
            i.ResultReason.Canceled,
            void 0,
            // Text
            void 0,
            // Duration
            void 0,
            // Offset
            void 0,
            // Language
            void 0,
            // Language Detection Confidence
            void 0,
            // Speaker Id
            v,
            void 0,
            // Json
            y
          );
          try {
            this.privSuccessCallback(C), this.privSuccessCallback = void 0;
          } catch {
          }
        }
      }
    }
    async listenOnce(d, f, g) {
      this.privRecognizerConfig.recognitionMode = d, this.privSuccessCallback = f, this.privErrorCallback = g, this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privDialogAudioSource.events), this.privRecognizerConfig.parameters.setProperty(i.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const m = this.connectImpl(), v = this.sendPreAudioMessages(), y = await this.privDialogAudioSource.attach(this.privRequestSession.audioNodeId), S = await this.privDialogAudioSource.format, C = await this.privDialogAudioSource.deviceInfo, w = new e.ReplayableAudioNode(y, S.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(w, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: C };
      try {
        await m, await v;
      } catch (E) {
        return await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.ConnectionFailure, E), Promise.resolve();
      }
      const b = new i.SessionEventArgs(this.privRequestSession.sessionId);
      this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, b), this.sendAudio(w).then(() => {
      }, async (E) => {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.RuntimeError, E);
      });
    }
    // Establishes a websocket connection to the end point.
    dialogConnectImpl(d) {
      return this.privConnectionLoop = this.startMessageLoop(), d;
    }
    receiveDialogMessageOverride() {
      const d = new r.Deferred(), f = async () => {
        try {
          const g = this.isDisposed(), m = !this.isDisposed() && this.terminateMessageLoop;
          if (g || m) {
            d.resolve(void 0);
            return;
          }
          const y = await (await this.fetchConnection()).read();
          if (!y)
            return f();
          const S = l.SpeechConnectionMessage.fromConnectionMessage(y);
          switch (S.path.toLowerCase()) {
            case "turn.start":
              {
                const R = S.requestId.toUpperCase(), j = this.privRequestSession.requestId.toUpperCase();
                R !== j ? this.privTurnStateManager.StartTurn(R) : this.privRequestSession.onServiceTurnStartResponse();
              }
              break;
            case "speech.startdetected":
              const w = s.SpeechDetected.fromJSON(S.textBody, this.privRequestSession.currentTurnAudioOffset), b = new i.RecognitionEventArgs(w.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechStartDetected && this.privRecognizer.speechStartDetected(this.privRecognizer, b);
              break;
            case "speech.enddetected":
              let A;
              S.textBody.length > 0 ? A = S.textBody : A = "{ Offset: 0 }";
              const E = s.SpeechDetected.fromJSON(A, this.privRequestSession.currentTurnAudioOffset);
              this.privRequestSession.onServiceRecognized(E.Offset);
              const M = new i.RecognitionEventArgs(E.Offset, this.privRequestSession.sessionId);
              this.privRecognizer.speechEndDetected && this.privRecognizer.speechEndDetected(this.privRecognizer, M);
              break;
            case "turn.end":
              {
                const R = S.requestId.toUpperCase(), j = this.privRequestSession.requestId.toUpperCase();
                if (R !== j)
                  this.privTurnStateManager.CompleteTurn(R);
                else {
                  const T = new i.SessionEventArgs(this.privRequestSession.sessionId);
                  if (await this.privRequestSession.onServiceTurnEndResponse(!1), (!this.privRecognizerConfig.isContinuousRecognition || this.privRequestSession.isSpeechEnded || !this.privRequestSession.isRecognizing) && this.privRecognizer.sessionStopped && this.privRecognizer.sessionStopped(this.privRecognizer, T), this.privSuccessCallback && this.privLastResult) {
                    try {
                      this.privSuccessCallback(this.privLastResult), this.privLastResult = null;
                    } catch (D) {
                      this.privErrorCallback && this.privErrorCallback(D);
                    }
                    this.privSuccessCallback = void 0, this.privErrorCallback = void 0;
                  }
                }
              }
              break;
            default:
              try {
                await this.processTypeSpecificMessages(S) || this.serviceEvents && this.serviceEvents.onEvent(new r.ServiceEvent(S.path.toLowerCase(), S.textBody));
              } catch {
              }
          }
          return f();
        } catch {
          this.terminateMessageLoop = !0, d.resolve();
        }
      };
      return f().catch((g) => {
        r.Events.instance.onEvent(new r.BackgroundEvent(g));
      }), d.promise;
    }
    async startMessageLoop() {
      this.terminateMessageLoop = !1;
      try {
        await this.receiveDialogMessageOverride();
      } catch (d) {
        await this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, i.CancellationReason.Error, i.CancellationErrorCode.RuntimeError, d);
      }
      return Promise.resolve();
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configConnection(d) {
      return this.terminateMessageLoop ? (this.terminateMessageLoop = !1, Promise.reject("Connection to service terminated.")) : (await this.sendSpeechServiceConfig(d, this.privRequestSession, this.privRecognizerConfig.SpeechServiceConfig.serialize()), await this.sendAgentConfig(d), d);
    }
    async sendPreAudioMessages() {
      const d = await this.fetchConnection();
      this.addKeywordContextData(), await this.sendSpeechContext(d, !0), await this.sendAgentContext(d), await this.sendWaveHeader(d);
    }
    sendAgentConfig(d) {
      if (this.agentConfig && !this.agentConfigSent) {
        if (this.privRecognizerConfig.parameters.getProperty(i.PropertyId.Conversation_DialogType) === i.DialogServiceConfig.DialogTypes.CustomCommands) {
          const g = this.agentConfig.get();
          g.botInfo.commandsCulture = this.privRecognizerConfig.parameters.getProperty(i.PropertyId.SpeechServiceConnection_RecoLanguage, "en-us"), this.agentConfig.set(g);
        }
        this.onEvent(new t.SendingAgentContextMessageEvent(this.agentConfig));
        const f = this.agentConfig.toJsonString();
        return this.agentConfigSent = !0, d.send(new l.SpeechConnectionMessage(r.MessageType.Text, "agent.config", this.privRequestSession.requestId, "application/json", f));
      }
    }
    sendAgentContext(d) {
      const f = (0, r.createGuid)(), g = this.privDialogServiceConnector.properties.getProperty(i.PropertyId.Conversation_Speech_Activity_Template), v = JSON.stringify({
        channelData: "",
        context: {
          interactionId: f
        },
        messagePayload: typeof g === void 0 ? void 0 : g,
        version: 0.5
      });
      return d.send(new l.SpeechConnectionMessage(r.MessageType.Text, "speech.agent.context", this.privRequestSession.requestId, "application/json", v));
    }
    fireEventForResult(d, f) {
      const g = s.EnumTranslation.implTranslateRecognitionResult(d.RecognitionStatus), m = new i.SpeechRecognitionResult(this.privRequestSession.requestId, g, d.DisplayText, d.Duration, d.Offset, d.Language, d.LanguageDetectionConfidence, void 0, void 0, d.asJson(), f);
      return new i.SpeechRecognitionEventArgs(m, d.Offset, this.privRequestSession.sessionId);
    }
    handleResponseMessage(d) {
      const f = JSON.parse(d.textBody);
      switch (f.messageType.toLowerCase()) {
        case "message":
          const g = d.requestId.toUpperCase(), m = n.ActivityPayloadResponse.fromJSON(d.textBody), v = this.privTurnStateManager.GetTurn(g);
          if (m.conversationId) {
            const C = this.agentConfig.get();
            C.botInfo.conversationId = m.conversationId, this.agentConfig.set(C);
          }
          const y = v.processActivityPayload(m, o.AudioOutputFormatImpl.fromSpeechSynthesisOutputFormatString(this.privDialogServiceConnector.properties.getProperty(i.PropertyId.SpeechServiceConnection_SynthOutputFormat, void 0))), S = new i.ActivityReceivedEventArgs(m.messagePayload, y);
          if (this.privDialogServiceConnector.activityReceived)
            try {
              this.privDialogServiceConnector.activityReceived(this.privDialogServiceConnector, S);
            } catch {
            }
          break;
        case "messagestatus":
          if (this.privDialogServiceConnector.turnStatusReceived)
            try {
              this.privDialogServiceConnector.turnStatusReceived(this.privDialogServiceConnector, new i.TurnStatusReceivedEventArgs(d.textBody));
            } catch {
            }
          break;
        default:
          r.Events.instance.onEvent(new r.BackgroundEvent(`Unexpected response of type ${f.messageType}. Ignoring.`));
          break;
      }
    }
    onEvent(d) {
      this.privEvents.onEvent(d), r.Events.instance.onEvent(d);
    }
    addKeywordContextData() {
      const d = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect");
      if (d === void 0)
        return;
      const f = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Offsets"), g = this.privRecognizerConfig.parameters.getProperty("SPEECH-KeywordsToDetect-Durations"), m = d.split(";"), v = f === void 0 ? [] : f.split(";"), y = g === void 0 ? [] : g.split(";"), S = [];
      for (let C = 0; C < m.length; C++) {
        const w = {
          text: m[C]
        };
        C < v.length && (w.startOffset = Number(v[C])), C < y.length && (w.duration = Number(y[C])), S.push(w);
      }
      this.speechContext.getContext().invocationSource = c.InvocationSource.VoiceActivationWithKeyword, this.speechContext.getContext().keywordDetection = [{
        clientDetectedKeywords: S,
        onReject: { action: u.OnRejectAction.EndOfTurn },
        type: u.KeywordDetectionType.StartTrigger
      }];
    }
  };
  return ji.DialogServiceAdapter = p, ji;
}
var Bi = {}, ch;
function Qw() {
  if (ch) return Bi;
  ch = 1, Object.defineProperty(Bi, "__esModule", { value: !0 }), Bi.AgentConfig = void 0;
  let e = class {
    toJsonString() {
      return JSON.stringify(this.iPrivConfig);
    }
    get() {
      return this.iPrivConfig;
    }
    /**
     * Setter for the agent.config object.
     * @param value a JSON serializable object.
     */
    set(r) {
      this.iPrivConfig = r;
    }
  };
  return Bi.AgentConfig = e, Bi;
}
var Ia = {}, Ui = {}, $i = {}, uh;
function hc() {
  if (uh) return $i;
  uh = 1, Object.defineProperty($i, "__esModule", { value: !0 }), $i.ConversationConnectionConfig = void 0;
  const e = /* @__PURE__ */ Fv();
  let t = class Xe extends e.RestConfigBase {
    static get host() {
      return Xe.privHost;
    }
    static get apiVersion() {
      return Xe.privApiVersion;
    }
    static get clientAppId() {
      return Xe.privClientAppId;
    }
    static get defaultLanguageCode() {
      return Xe.privDefaultLanguageCode;
    }
    static get restPath() {
      return Xe.privRestPath;
    }
    static get webSocketPath() {
      return Xe.privWebSocketPath;
    }
    static get transcriptionEventKeys() {
      return Xe.privTranscriptionEventKeys;
    }
  };
  return $i.ConversationConnectionConfig = t, t.privHost = "dev.microsofttranslator.com", t.privRestPath = "/capito/room", t.privApiVersion = "2.0", t.privDefaultLanguageCode = "en-US", t.privClientAppId = "FC539C22-1767-4F1F-84BC-B4D811114F15", t.privWebSocketPath = "/capito/translate", t.privTranscriptionEventKeys = ["iCalUid", "callId", "organizer", "FLAC", "MTUri", "DifferentiateGuestSpeakers", "audiorecording", "Threadid", "OrganizerMri", "OrganizerTenantId", "UserToken"], $i;
}
var lh;
function Yw() {
  if (lh) return Ui;
  lh = 1, Object.defineProperty(Ui, "__esModule", { value: !0 }), Ui.ConversationManager = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ hc();
  let i = class {
    constructor() {
      this.privRequestParams = o.ConversationConnectionConfig.configParams, this.privErrors = o.ConversationConnectionConfig.restErrors, this.privHost = o.ConversationConnectionConfig.host, this.privApiVersion = o.ConversationConnectionConfig.apiVersion, this.privRestPath = o.ConversationConnectionConfig.restPath, this.privRestAdapter = new e.RestMessageAdapter({});
    }
    /**
     * Make a POST request to the Conversation Manager service endpoint to create or join a conversation.
     * @param args
     * @param conversationCode
     * @param callback
     * @param errorCallback
     */
    createOrJoin(s, n, c, u) {
      try {
        t.Contracts.throwIfNullOrUndefined(s, "args");
        const l = s.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage, o.ConversationConnectionConfig.defaultLanguageCode), p = s.getProperty(r.PropertyId.ConversationTranslator_Name, "conversation_host"), h = s.getProperty(r.PropertyId.ConversationTranslator_Host, this.privHost), d = s.getProperty(r.PropertyId.ConversationTranslator_CorrelationId), f = s.getProperty(r.PropertyId.SpeechServiceConnection_Key), g = s.getProperty(r.PropertyId.SpeechServiceConnection_Region), m = s.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
        t.Contracts.throwIfNullOrWhitespace(l, "languageCode"), t.Contracts.throwIfNullOrWhitespace(p, "nickname"), t.Contracts.throwIfNullOrWhitespace(h, "endpointHost");
        const v = {};
        v[this.privRequestParams.apiVersion] = this.privApiVersion, v[this.privRequestParams.languageCode] = l, v[this.privRequestParams.nickname] = p;
        const y = {};
        d && (y[this.privRequestParams.correlationId] = d), y[this.privRequestParams.clientAppId] = o.ConversationConnectionConfig.clientAppId, n !== void 0 ? v[this.privRequestParams.roomId] = n : (t.Contracts.throwIfNullOrUndefined(g, this.privErrors.authInvalidSubscriptionRegion), y[this.privRequestParams.subscriptionRegion] = g, f ? y[this.privRequestParams.subscriptionKey] = f : m ? y[this.privRequestParams.authorization] = `Bearer ${m}` : t.Contracts.throwIfNullOrUndefined(f, this.privErrors.authInvalidSubscriptionKey));
        const S = {};
        S.headers = y, this.privRestAdapter.options = S;
        const C = `https://${h}${this.privRestPath}`;
        this.privRestAdapter.request(e.RestRequestType.Post, C, v, null).then((w) => {
          const b = e.RestMessageAdapter.extractHeaderValue(this.privRequestParams.requestId, w.headers);
          if (!w.ok) {
            if (u) {
              let E = this.privErrors.invalidCreateJoinConversationResponse.replace("{status}", w.status.toString()), M;
              try {
                M = JSON.parse(w.data), E += ` [${M.error.code}: ${M.error.message}]`;
              } catch {
                E += ` [${w.data}]`;
              }
              b && (E += ` ${b}`), u(E);
            }
            return;
          }
          const A = JSON.parse(w.data);
          if (A && (A.requestId = b), c) {
            try {
              c(A);
            } catch (E) {
              u && u(E);
            }
            c = void 0;
          }
        }).catch(() => {
        });
      } catch (l) {
        if (u)
          if (l instanceof Error) {
            const p = l;
            u(p.name + ": " + p.message);
          } else
            u(l);
      }
    }
    /**
     * Make a DELETE request to the Conversation Manager service endpoint to leave the conversation.
     * @param args
     * @param sessionToken
     * @param callback
     */
    leave(s, n) {
      return new Promise((c, u) => {
        try {
          t.Contracts.throwIfNullOrUndefined(s, this.privErrors.invalidArgs.replace("{arg}", "config")), t.Contracts.throwIfNullOrWhitespace(n, this.privErrors.invalidArgs.replace("{arg}", "token"));
          const l = s.getProperty(r.PropertyId.ConversationTranslator_Host, this.privHost), p = s.getProperty(r.PropertyId.ConversationTranslator_CorrelationId), h = {};
          h[this.privRequestParams.apiVersion] = this.privApiVersion, h[this.privRequestParams.sessionToken] = n;
          const d = {};
          p && (d[this.privRequestParams.correlationId] = p);
          const f = {};
          f.headers = d, this.privRestAdapter.options = f;
          const g = `https://${l}${this.privRestPath}`;
          this.privRestAdapter.request(e.RestRequestType.Delete, g, h, null).then((m) => {
            m.ok, c();
          }).catch(() => {
          });
        } catch (l) {
          if (l instanceof Error) {
            const p = l;
            u(p.name + ": " + p.message);
          } else
            u(l);
        }
      });
    }
  };
  return Ui.ConversationManager = i, Ui;
}
var It = {}, Vi = {}, Wi = {}, Hi = {}, ph;
function Gv() {
  if (ph) return Hi;
  ph = 1, Object.defineProperty(Hi, "__esModule", { value: !0 }), Hi.ConversationConnectionMessage = void 0;
  const e = /* @__PURE__ */ k();
  let t = class extends e.ConnectionMessage {
    constructor(o, i, a, s) {
      super(o, i, a, s);
      const n = JSON.parse(this.textBody);
      n.type !== void 0 && (this.privConversationMessageType = n.type);
    }
    get conversationMessageType() {
      return this.privConversationMessageType;
    }
  };
  return Hi.ConversationConnectionMessage = t, Hi;
}
var dh;
function Zw() {
  if (dh) return Wi;
  dh = 1, Object.defineProperty(Wi, "__esModule", { value: !0 }), Wi.ConversationWebsocketMessageFormatter = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ Gv();
  let r = class {
    /**
     * Format incoming messages: text (speech partial/final, IM) or binary (tts)
     */
    toConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = new t.ConversationConnectionMessage(i.messageType, i.textContent, {}, i.id);
          a.resolve(s);
        } else i.messageType === e.MessageType.Binary && a.resolve(new t.ConversationConnectionMessage(i.messageType, i.binaryContent, void 0, i.id));
      } catch (s) {
        a.reject(`Error formatting the message. Error: ${s}`);
      }
      return a.promise;
    }
    /**
     * Format outgoing messages: text (commands or IM)
     */
    fromConnectionMessage(i) {
      const a = new e.Deferred();
      try {
        if (i.messageType === e.MessageType.Text) {
          const s = `${i.textBody ? i.textBody : ""}`;
          a.resolve(new e.RawWebsocketMessage(e.MessageType.Text, s, i.id));
        }
      } catch (s) {
        a.reject(`Error formatting the message. ${s}`);
      }
      return a.promise;
    }
  };
  return Wi.ConversationWebsocketMessageFormatter = r, Wi;
}
var hh;
function Xw() {
  if (hh) return Vi;
  hh = 1, Object.defineProperty(Vi, "__esModule", { value: !0 }), Vi.ConversationConnectionFactory = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ ke(), a = /* @__PURE__ */ hc(), s = /* @__PURE__ */ Zw();
  let n = class extends i.ConnectionFactoryBase {
    create(u, l, p) {
      const h = u.parameters.getProperty(o.PropertyId.ConversationTranslator_Host, a.ConversationConnectionConfig.host), d = u.parameters.getProperty(o.PropertyId.ConversationTranslator_CorrelationId, (0, t.createGuid)()), f = `wss://${h}${a.ConversationConnectionConfig.webSocketPath}`, g = u.parameters.getProperty(o.PropertyId.ConversationTranslator_Token, void 0);
      r.Contracts.throwIfNullOrUndefined(g, "token");
      const m = {};
      m[a.ConversationConnectionConfig.configParams.apiVersion] = a.ConversationConnectionConfig.apiVersion, m[a.ConversationConnectionConfig.configParams.token] = g, m[a.ConversationConnectionConfig.configParams.correlationId] = d;
      const v = u.parameters.getProperty("SPEECH-EnableWebsocketCompression", "false") === "true";
      return Promise.resolve(new e.WebsocketConnection(f, m, {}, new s.ConversationWebsocketMessageFormatter(), e.ProxyInfo.fromRecognizerConfig(u), v, p));
    }
  };
  return Vi.ConversationConnectionFactory = n, Vi;
}
var Ki = {}, Ji = {}, fh;
function eb() {
  if (fh) return Ji;
  fh = 1, Object.defineProperty(Ji, "__esModule", { value: !0 }), Ji.ConversationRequestSession = void 0;
  const e = /* @__PURE__ */ k();
  let t = class {
    constructor(o) {
      this.privIsDisposed = !1, this.privDetachables = new Array(), this.privSessionId = o, this.privRequestId = (0, e.createNoDashGuid)(), this.privRequestCompletionDeferral = new e.Deferred();
    }
    get sessionId() {
      return this.privSessionId;
    }
    get requestId() {
      return this.privRequestId;
    }
    get completionPromise() {
      return this.privRequestCompletionDeferral.promise;
    }
    onPreConnectionStart(o, i) {
      this.privSessionId = i;
    }
    onAuthCompleted(o) {
      o && this.onComplete();
    }
    onConnectionEstablishCompleted(o) {
      o !== 200 && o === 403 && this.onComplete();
    }
    onServiceTurnEndResponse(o) {
      o ? this.privRequestId = (0, e.createNoDashGuid)() : this.onComplete();
    }
    async dispose() {
      if (!this.privIsDisposed) {
        this.privIsDisposed = !0;
        for (const o of this.privDetachables)
          await o.detach();
      }
    }
    onComplete() {
    }
  };
  return Ji.ConversationRequestSession = t, Ji;
}
var ce = {}, vh;
function Qv() {
  if (vh) return ce;
  vh = 1, Object.defineProperty(ce, "__esModule", { value: !0 }), ce.ConversationReceivedTranslationEventArgs = ce.ParticipantsListEventArgs = ce.ParticipantAttributeEventArgs = ce.ParticipantEventArgs = ce.LockRoomEventArgs = ce.MuteAllEventArgs = void 0;
  const e = /* @__PURE__ */ I();
  class t extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsMuted = c;
    }
    get isMuted() {
      return this.privIsMuted;
    }
  }
  ce.MuteAllEventArgs = t;
  class r extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privIsLocked = c;
    }
    get isMuted() {
      return this.privIsLocked;
    }
  }
  ce.LockRoomEventArgs = r;
  class o extends e.SessionEventArgs {
    constructor(c, u) {
      super(u), this.privParticipant = c;
    }
    get participant() {
      return this.privParticipant;
    }
  }
  ce.ParticipantEventArgs = o;
  class i extends e.SessionEventArgs {
    constructor(c, u, l, p) {
      super(p), this.privKey = u, this.privValue = l, this.privParticipantId = c;
    }
    get value() {
      return this.privValue;
    }
    get key() {
      return this.privKey;
    }
    get id() {
      return this.privParticipantId;
    }
  }
  ce.ParticipantAttributeEventArgs = i;
  class a extends e.SessionEventArgs {
    constructor(c, u, l, p, h, d, f, g, m) {
      super(m), this.privRoomId = c, this.privSessionToken = u, this.privTranslateTo = l, this.privProfanityFilter = p, this.privRoomProfanityFilter = h, this.privIsRoomLocked = d, this.privIsRoomLocked = f, this.privParticipants = g;
    }
    get sessionToken() {
      return this.privSessionToken;
    }
    get conversationId() {
      return this.privRoomId;
    }
    get translateTo() {
      return this.privTranslateTo;
    }
    get profanityFilter() {
      return this.privProfanityFilter;
    }
    get roomProfanityFilter() {
      return this.privRoomProfanityFilter;
    }
    get isRoomLocked() {
      return this.privIsRoomLocked;
    }
    get isMuteAll() {
      return this.privIsMuteAll;
    }
    get participants() {
      return this.privParticipants;
    }
  }
  ce.ParticipantsListEventArgs = a;
  class s {
    constructor(c, u, l) {
      this.privPayload = u, this.privCommand = c, this.privSessionId = l;
    }
    get payload() {
      return this.privPayload;
    }
    get command() {
      return this.privCommand;
    }
    get sessionId() {
      return this.privSessionId;
    }
  }
  return ce.ConversationReceivedTranslationEventArgs = s, ce;
}
var Be = {}, gh;
function Yv() {
  if (gh) return Be;
  gh = 1, Object.defineProperty(Be, "__esModule", { value: !0 }), Be.ConversationTranslatorCommandTypes = Be.ConversationTranslatorMessageTypes = Be.InternalParticipants = void 0;
  class e {
    constructor(r = [], o) {
      this.participants = r, this.meId = o;
    }
    /**
     * Add or update a participant
     * @param value
     */
    addOrUpdateParticipant(r) {
      if (r === void 0)
        return;
      const o = this.getParticipantIndex(r.id);
      return o > -1 ? this.participants.splice(o, 1, r) : this.participants.push(r), this.getParticipant(r.id);
    }
    /**
     * Find the participant's position in the participants list.
     * @param id
     */
    getParticipantIndex(r) {
      return this.participants.findIndex((o) => o.id === r);
    }
    /**
     * Find the participant by id.
     * @param id
     */
    getParticipant(r) {
      return this.participants.find((o) => o.id === r);
    }
    /**
     * Remove a participant from the participants list.
     */
    deleteParticipant(r) {
      this.participants = this.participants.filter((o) => o.id !== r);
    }
    /**
     * Helper to return the conversation host.
     */
    get host() {
      return this.participants.find((r) => r.isHost === !0);
    }
    /**
     * Helper to return the current user.
     */
    get me() {
      return this.getParticipant(this.meId);
    }
  }
  return Be.InternalParticipants = e, Be.ConversationTranslatorMessageTypes = {
    command: "command",
    final: "final",
    info: "info",
    instantMessage: "instant_message",
    keepAlive: "keep_alive",
    partial: "partial",
    participantCommand: "participant_command",
    translatedMessage: "translated_message"
  }, Be.ConversationTranslatorCommandTypes = {
    changeNickname: "ChangeNickname",
    disconnectSession: "DisconnectSession",
    ejectParticipant: "EjectParticipant",
    instant_message: "instant_message",
    joinSession: "JoinSession",
    leaveSession: "LeaveSession",
    participantList: "ParticipantList",
    roomExpirationWarning: "RoomExpirationWarning",
    setLockState: "SetLockState",
    setMute: "SetMute",
    setMuteAll: "SetMuteAll",
    setProfanityFiltering: "SetProfanityFiltering",
    setTranslateToLanguages: "SetTranslateToLanguages",
    setUseTTS: "SetUseTTS"
  }, Be;
}
var Aa = {}, Gi = {}, mh;
function tb() {
  if (mh) return Gi;
  mh = 1, Object.defineProperty(Gi, "__esModule", { value: !0 }), Gi.CommandResponsePayload = void 0;
  const e = (r) => JSON.parse(r);
  let t = class Zv {
    constructor(o) {
      this.privCommandResponse = e(o);
    }
    get type() {
      return this.privCommandResponse.type;
    }
    get command() {
      return this.privCommandResponse.command;
    }
    get id() {
      return this.privCommandResponse.id;
    }
    get nickname() {
      return this.privCommandResponse.nickname;
    }
    get participantId() {
      return this.privCommandResponse.participantId;
    }
    get roomid() {
      return this.privCommandResponse.roomid;
    }
    get value() {
      return this.privCommandResponse.value;
    }
    get token() {
      return this.privCommandResponse.token;
    }
    static fromJSON(o) {
      return new Zv(o);
    }
  };
  return Gi.CommandResponsePayload = t, Gi;
}
var At = {}, yh;
function rb() {
  if (yh) return At;
  yh = 1, Object.defineProperty(At, "__esModule", { value: !0 }), At.ParticipantPayloadResponse = At.ParticipantsListPayloadResponse = void 0;
  const e = (i) => JSON.parse(i), t = (i) => JSON.parse(i);
  class r {
    constructor(a) {
      this.privParticipantsPayloadResponse = e(a);
    }
    get roomid() {
      return this.privParticipantsPayloadResponse.roomid;
    }
    get id() {
      return this.privParticipantsPayloadResponse.id;
    }
    get command() {
      return this.privParticipantsPayloadResponse.command;
    }
    get participants() {
      return this.privParticipantsPayloadResponse.participants;
    }
    get token() {
      return this.privParticipantsPayloadResponse.token;
    }
    get translateTo() {
      return this.privParticipantsPayloadResponse.translateTo;
    }
    get profanityFilter() {
      return this.privParticipantsPayloadResponse.profanityFilter;
    }
    get roomProfanityFilter() {
      return this.privParticipantsPayloadResponse.roomProfanityFilter;
    }
    get roomLocked() {
      return this.privParticipantsPayloadResponse.roomLocked;
    }
    get muteAll() {
      return this.privParticipantsPayloadResponse.muteAll;
    }
    get type() {
      return this.privParticipantsPayloadResponse.type;
    }
    static fromJSON(a) {
      return new r(a);
    }
  }
  At.ParticipantsListPayloadResponse = r;
  class o {
    constructor(a) {
      this.privParticipantPayloadResponse = t(a);
    }
    get nickname() {
      return this.privParticipantPayloadResponse.nickname;
    }
    get locale() {
      return this.privParticipantPayloadResponse.locale;
    }
    get usetts() {
      return this.privParticipantPayloadResponse.usetts;
    }
    get ismuted() {
      return this.privParticipantPayloadResponse.ismuted;
    }
    get ishost() {
      return this.privParticipantPayloadResponse.ishost;
    }
    get participantId() {
      return this.privParticipantPayloadResponse.participantId;
    }
    get avatar() {
      return this.privParticipantPayloadResponse.avatar;
    }
    static fromJSON(a) {
      return new o(a);
    }
  }
  return At.ParticipantPayloadResponse = o, At;
}
var Tt = {}, Sh;
function nb() {
  if (Sh) return Tt;
  Sh = 1, Object.defineProperty(Tt, "__esModule", { value: !0 }), Tt.TextResponsePayload = Tt.SpeechResponsePayload = void 0;
  const e = (i) => JSON.parse(i), t = (i) => JSON.parse(i);
  class r {
    constructor(a) {
      this.privSpeechResponse = e(a);
    }
    get recognition() {
      return this.privSpeechResponse.recognition;
    }
    get translations() {
      return this.privSpeechResponse.translations;
    }
    get id() {
      return this.privSpeechResponse.id;
    }
    get language() {
      return this.privSpeechResponse.language;
    }
    get nickname() {
      return this.privSpeechResponse.nickname;
    }
    get participantId() {
      return this.privSpeechResponse.participantId;
    }
    get roomid() {
      return this.privSpeechResponse.roomid;
    }
    get timestamp() {
      return this.privSpeechResponse.timestamp;
    }
    get type() {
      return this.privSpeechResponse.type;
    }
    get isFinal() {
      return this.privSpeechResponse.type === "final";
    }
    static fromJSON(a) {
      return new r(a);
    }
  }
  Tt.SpeechResponsePayload = r;
  class o {
    constructor(a) {
      this.privTextResponse = t(a);
    }
    get originalText() {
      return this.privTextResponse.originalText;
    }
    get translations() {
      return this.privTextResponse.translations;
    }
    get id() {
      return this.privTextResponse.id;
    }
    get language() {
      return this.privTextResponse.language;
    }
    get nickname() {
      return this.privTextResponse.nickname;
    }
    get participantId() {
      return this.privTextResponse.participantId;
    }
    get roomid() {
      return this.privTextResponse.roomid;
    }
    get timestamp() {
      return this.privTextResponse.timestamp;
    }
    get type() {
      return this.privTextResponse.type;
    }
    static fromJSON(a) {
      return new o(a);
    }
  }
  return Tt.TextResponsePayload = o, Tt;
}
var Ch;
function ib() {
  return Ch || (Ch = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.TextResponsePayload = e.SpeechResponsePayload = e.ParticipantPayloadResponse = e.ParticipantsListPayloadResponse = e.CommandResponsePayload = void 0;
    var t = /* @__PURE__ */ tb();
    Object.defineProperty(e, "CommandResponsePayload", { enumerable: !0, get: function() {
      return t.CommandResponsePayload;
    } });
    var r = /* @__PURE__ */ rb();
    Object.defineProperty(e, "ParticipantsListPayloadResponse", { enumerable: !0, get: function() {
      return r.ParticipantsListPayloadResponse;
    } }), Object.defineProperty(e, "ParticipantPayloadResponse", { enumerable: !0, get: function() {
      return r.ParticipantPayloadResponse;
    } });
    var o = /* @__PURE__ */ nb();
    Object.defineProperty(e, "SpeechResponsePayload", { enumerable: !0, get: function() {
      return o.SpeechResponsePayload;
    } }), Object.defineProperty(e, "TextResponsePayload", { enumerable: !0, get: function() {
      return o.TextResponsePayload;
    } });
  }(Aa)), Aa;
}
var Rh;
function sb() {
  if (Rh) return Ki;
  Rh = 1, Object.defineProperty(Ki, "__esModule", { value: !0 }), Ki.ConversationServiceAdapter = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Gv(), i = /* @__PURE__ */ eb(), a = /* @__PURE__ */ Qv(), s = /* @__PURE__ */ Yv(), n = /* @__PURE__ */ ib();
  let c = class extends r.ServiceRecognizerBase {
    constructor(l, p, h, d, f) {
      super(l, p, h, d, f), this.privConnectionConfigPromise = void 0, this.privLastPartialUtteranceId = "", this.privConversationServiceConnector = f, this.privConversationAuthentication = l, this.receiveMessageOverride = () => this.receiveConversationMessageOverride(), this.recognizeOverride = () => this.noOp(), this.postConnectImplOverride = (g) => this.conversationConnectImpl(g), this.configConnectionOverride = () => this.configConnection(), this.disconnectOverride = () => this.privDisconnect(), this.privConversationRequestSession = new i.ConversationRequestSession((0, e.createNoDashGuid)()), this.privConversationConnectionFactory = p, this.privConversationIsDisposed = !1;
    }
    isDisposed() {
      return super.isDisposed() || this.privConversationIsDisposed;
    }
    async dispose(l) {
      this.privConversationIsDisposed = !0, this.privConnectionConfigPromise !== void 0 && await (await this.privConnectionConfigPromise).dispose(l), await super.dispose(l);
    }
    async sendMessage(l) {
      return (await this.fetchConnection()).send(new o.ConversationConnectionMessage(e.MessageType.Text, l));
    }
    async sendMessageAsync(l) {
      await (await this.fetchConnection()).send(new o.ConversationConnectionMessage(e.MessageType.Text, l));
    }
    privDisconnect() {
      if (!this.terminateMessageLoop)
        return this.cancelRecognition(this.privConversationRequestSession.sessionId, this.privConversationRequestSession.requestId, t.CancellationReason.Error, t.CancellationErrorCode.NoError, "Disconnecting"), this.terminateMessageLoop = !0, Promise.resolve();
    }
    // eslint-disable-next-line @typescript-eslint/require-await
    async processTypeSpecificMessages() {
      return !0;
    }
    // Cancels recognition.
    cancelRecognition(l, p, h, d, f) {
      this.terminateMessageLoop = !0;
      const g = new t.ConversationTranslationCanceledEventArgs(h, f, d, void 0, l);
      try {
        this.privConversationServiceConnector.canceled && this.privConversationServiceConnector.canceled(this.privConversationServiceConnector, g);
      } catch {
      }
    }
    /**
     * Establishes a websocket connection to the end point.
     */
    async conversationConnectImpl(l) {
      return this.privConnectionLoop = this.startMessageLoop(), l;
    }
    /**
     * Process incoming websocket messages
     */
    async receiveConversationMessageOverride() {
      if (this.isDisposed() || this.terminateMessageLoop)
        return Promise.resolve();
      const l = new e.Deferred();
      try {
        const h = await (await this.fetchConnection()).read();
        if (this.isDisposed() || this.terminateMessageLoop)
          return l.resolve(), Promise.resolve();
        if (!h)
          return this.receiveConversationMessageOverride();
        const d = this.privConversationRequestSession.sessionId, f = h.conversationMessageType.toLowerCase();
        let g = !1;
        try {
          switch (f) {
            case "info":
            case "participant_command":
            case "command":
              const m = n.CommandResponsePayload.fromJSON(h.textBody);
              switch (m.command.toLowerCase()) {
                /**
                 * 'ParticpantList' is the first message sent to the user after the websocket connection has opened.
                 * The consuming client must wait for this message to arrive
                 * before starting to send their own data.
                 */
                case "participantlist":
                  const b = n.ParticipantsListPayloadResponse.fromJSON(h.textBody), A = b.participants.map((D) => ({
                    avatar: D.avatar,
                    displayName: D.nickname,
                    id: D.participantId,
                    isHost: D.ishost,
                    isMuted: D.ismuted,
                    isUsingTts: D.usetts,
                    preferredLanguage: D.locale
                  }));
                  this.privConversationServiceConnector.participantsListReceived && this.privConversationServiceConnector.participantsListReceived(this.privConversationServiceConnector, new a.ParticipantsListEventArgs(b.roomid, b.token, b.translateTo, b.profanityFilter, b.roomProfanityFilter, b.roomLocked, b.muteAll, A, d));
                  break;
                /**
                 * 'SetTranslateToLanguages' represents the list of languages being used in the Conversation by all users(?).
                 * This is sent at the start of the Conversation
                 */
                case "settranslatetolanguages":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setTranslateToLanguages, m.value, d));
                  break;
                /**
                 * 'SetProfanityFiltering' lets the client set the level of profanity filtering.
                 * If sent by the participant the setting will effect only their own profanity level.
                 * If sent by the host, the setting will effect all participants including the host.
                 * Note: the profanity filters differ from Speech Service (?): 'marked', 'raw', 'removed', 'tagged'
                 */
                case "setprofanityfiltering":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setProfanityFiltering, m.value, d));
                  break;
                /**
                 * 'SetMute' is sent if the participant has been muted by the host.
                 * Check the 'participantId' to determine if the current user has been muted.
                 */
                case "setmute":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setMute, m.value, d));
                  break;
                /**
                 * 'SetMuteAll' is sent if the Conversation has been muted by the host.
                 */
                case "setmuteall":
                  this.privConversationServiceConnector.muteAllCommandReceived && this.privConversationServiceConnector.muteAllCommandReceived(this.privConversationServiceConnector, new a.MuteAllEventArgs(m.value, d));
                  break;
                /**
                 * 'RoomExpirationWarning' is sent towards the end of the Conversation session to give a timeout warning.
                 */
                case "roomexpirationwarning":
                  this.privConversationServiceConnector.conversationExpiration && this.privConversationServiceConnector.conversationExpiration(this.privConversationServiceConnector, new t.ConversationExpirationEventArgs(m.value, this.privConversationRequestSession.sessionId));
                  break;
                /**
                 * 'SetUseTts' is sent as a confirmation if the user requests TTS to be turned on or off.
                 */
                case "setusetts":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.setUseTTS, m.value, d));
                  break;
                /**
                 * 'SetLockState' is set if the host has locked or unlocked the Conversation.
                 */
                case "setlockstate":
                  this.privConversationServiceConnector.lockRoomCommandReceived && this.privConversationServiceConnector.lockRoomCommandReceived(this.privConversationServiceConnector, new a.LockRoomEventArgs(m.value, d));
                  break;
                /**
                 * 'ChangeNickname' is received if a user changes their display name.
                 * Any cached particpiants list should be updated to reflect the display name.
                 */
                case "changenickname":
                  this.privConversationServiceConnector.participantUpdateCommandReceived && this.privConversationServiceConnector.participantUpdateCommandReceived(this.privConversationServiceConnector, new a.ParticipantAttributeEventArgs(m.participantId, s.ConversationTranslatorCommandTypes.changeNickname, m.value, d));
                  break;
                /**
                 * 'JoinSession' is sent when a user joins the Conversation.
                 */
                case "joinsession":
                  const E = n.ParticipantPayloadResponse.fromJSON(h.textBody), M = {
                    avatar: E.avatar,
                    displayName: E.nickname,
                    id: E.participantId,
                    isHost: E.ishost,
                    isMuted: E.ismuted,
                    isUsingTts: E.usetts,
                    preferredLanguage: E.locale
                  };
                  this.privConversationServiceConnector.participantJoinCommandReceived && this.privConversationServiceConnector.participantJoinCommandReceived(this.privConversationServiceConnector, new a.ParticipantEventArgs(M, d));
                  break;
                /**
                 * 'LeaveSession' is sent when a user leaves the Conversation'.
                 */
                case "leavesession":
                  const R = {
                    id: m.participantId
                  };
                  this.privConversationServiceConnector.participantLeaveCommandReceived && this.privConversationServiceConnector.participantLeaveCommandReceived(this.privConversationServiceConnector, new a.ParticipantEventArgs(R, d));
                  break;
                /**
                 * 'DisconnectSession' is sent when a user is disconnected from the session (e.g. network problem).
                 * Check the 'ParticipantId' to check whether the message is for the current user.
                 */
                case "disconnectsession":
                  const j = {
                    id: m.participantId
                  };
                  break;
                case "token":
                  const T = new r.CognitiveTokenAuthentication(() => {
                    const D = m.token;
                    return Promise.resolve(D);
                  }, () => {
                    const D = m.token;
                    return Promise.resolve(D);
                  });
                  this.authentication = T, this.privConversationServiceConnector.onToken(T);
                  break;
                /**
                 * Message not recognized.
                 */
                default:
                  break;
              }
              break;
            /**
             * 'partial' (or 'hypothesis') represents a unfinalized speech message.
             */
            case "partial":
            /**
             * 'final' (or 'phrase') represents a finalized speech message.
             */
            case "final":
              const v = n.SpeechResponsePayload.fromJSON(h.textBody), y = f === "final" ? t.ResultReason.TranslatedParticipantSpeech : t.ResultReason.TranslatingParticipantSpeech, S = new t.ConversationTranslationResult(v.participantId, this.getTranslations(v.translations), v.language, v.id, y, v.recognition, void 0, void 0, h.textBody, void 0);
              v.isFinal ? ((S.text !== void 0 && S.text.length > 0 || v.id === this.privLastPartialUtteranceId) && (g = !0), g && this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.final, S, d))) : S.text !== void 0 && (this.privLastPartialUtteranceId = v.id, this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.partial, S, d)));
              break;
            /**
             * "translated_message" is a text message or instant message (IM).
             */
            case "translated_message":
              const C = n.TextResponsePayload.fromJSON(h.textBody), w = new t.ConversationTranslationResult(C.participantId, this.getTranslations(C.translations), C.language, void 0, void 0, C.originalText, void 0, void 0, void 0, h.textBody, void 0);
              this.privConversationServiceConnector.translationReceived && this.privConversationServiceConnector.translationReceived(this.privConversationServiceConnector, new a.ConversationReceivedTranslationEventArgs(s.ConversationTranslatorMessageTypes.instantMessage, w, d));
              break;
            default:
              break;
          }
        } catch {
        }
        return this.receiveConversationMessageOverride();
      } catch {
        this.terminateMessageLoop = !0;
      }
      return l.promise;
    }
    async startMessageLoop() {
      if (this.isDisposed())
        return Promise.resolve();
      this.terminateMessageLoop = !1;
      const l = this.receiveConversationMessageOverride();
      try {
        return await l;
      } catch (p) {
        return this.cancelRecognition(this.privRequestSession ? this.privRequestSession.sessionId : "", this.privRequestSession ? this.privRequestSession.requestId : "", t.CancellationReason.Error, t.CancellationErrorCode.RuntimeError, p), null;
      }
    }
    // Takes an established websocket connection to the endpoint
    configConnection() {
      return this.isDisposed() ? Promise.resolve(void 0) : this.privConnectionConfigPromise !== void 0 ? this.privConnectionConfigPromise.then((l) => l.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection()) : this.privConnectionConfigPromise, () => (this.privConnectionId = null, this.privConnectionConfigPromise = void 0, this.configConnection())) : this.terminateMessageLoop ? Promise.resolve(void 0) : (this.privConnectionConfigPromise = this.connectImpl().then((l) => l), this.privConnectionConfigPromise);
    }
    getTranslations(l) {
      let p;
      if (l !== void 0) {
        p = new t.Translations();
        for (const h of l)
          p.set(h.lang, h.translation);
      }
      return p;
    }
  };
  return Ki.ConversationServiceAdapter = c, Ki;
}
var Ph;
function ob() {
  if (Ph) return It;
  Ph = 1, Object.defineProperty(It, "__esModule", { value: !0 }), It.ConversationTranslatorRecognizer = It.ConversationRecognizerFactory = void 0;
  const e = /* @__PURE__ */ _(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ z(), o = /* @__PURE__ */ I(), i = /* @__PURE__ */ Xw(), a = /* @__PURE__ */ sb();
  class s {
    static fromConfig(u, l, p) {
      return new n(u, l, p);
    }
  }
  It.ConversationRecognizerFactory = s;
  let n = class extends o.Recognizer {
    constructor(u, l, p) {
      const h = l;
      r.Contracts.throwIfNull(h, "speechConfig");
      const d = u;
      r.Contracts.throwIfNull(d, "conversationImpl"), super(p, h.properties, new i.ConversationConnectionFactory()), this.privConversation = d, this.privIsDisposed = !1, this.privProperties = h.properties.clone(), this.privConnection = o.Connection.fromRecognizer(this), this.privProperties.getProperty(o.PropertyId.WebWorkerLoadType, "on").toLowerCase() === "on" && typeof Blob < "u" && typeof Worker < "u" ? (this.privSetTimeout = t.Timeout.setTimeout, this.privClearTimeout = t.Timeout.clearTimeout) : typeof window < "u" ? (this.privSetTimeout = window.setTimeout.bind(window), this.privClearTimeout = window.clearTimeout.bind(window)) : (this.privSetTimeout = setTimeout, this.privClearTimeout = clearTimeout);
    }
    set connected(u) {
      this.privConnection.connected = u;
    }
    set disconnected(u) {
      this.privConnection.disconnected = u;
    }
    /**
     * Return the speech language used by the recognizer
     */
    get speechRecognitionLanguage() {
      return this.privSpeechRecognitionLanguage;
    }
    /**
     * Return the properties for the recognizer
     */
    get properties() {
      return this.privProperties;
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    /**
     * Connect to the recognizer
     * @param token
     */
    connect(u, l, p) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), r.Contracts.throwIfNullOrWhitespace(u, "token"), this.privReco.conversationTranslatorToken = u, this.resetConversationTimeout(), this.privReco.connectAsync(l, p);
      } catch (h) {
        if (p)
          if (h instanceof Error) {
            const d = h;
            p(d.name + ": " + d.message);
          } else
            p(h);
      }
    }
    /**
     * Disconnect from the recognizer
     */
    disconnect(u, l) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privReco.disconnect().then(() => {
          u && u();
        }, (p) => {
          l && l(p);
        });
      } catch (p) {
        if (l)
          if (p instanceof Error) {
            const h = p;
            l(h.name + ": " + h.message);
          } else
            l(p);
        this.dispose(!0).catch((h) => {
          t.Events.instance.onEvent(new t.BackgroundEvent(h));
        });
      }
    }
    /**
     * Send the mute all participants command to the websocket
     * @param conversationId
     * @param participantId
     * @param isMuted
     */
    sendRequest(u, l, p) {
      try {
        r.Contracts.throwIfDisposed(this.privIsDisposed), this.sendMessage(u, l, p);
      } catch (h) {
        if (p)
          if (h instanceof Error) {
            const d = h;
            p(d.name + ": " + d.message);
          } else
            p(h);
        this.dispose(!0).catch((d) => {
          t.Events.instance.onEvent(new t.BackgroundEvent(d));
        });
      }
    }
    /**
     * Handle update of service auth token (#694)
     */
    onToken(u) {
      this.privConversation.onToken(u);
    }
    /**
     * Close and dispose the recognizer
     */
    async close() {
      this.privIsDisposed || (this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close()), this.privConnection = void 0, await this.dispose(!0));
    }
    /**
     * Dispose the recognizer
     * @param disposing
     */
    async dispose(u) {
      this.privIsDisposed || u && (this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privIsDisposed = !0, this.privConnection && (this.privConnection.closeConnection(), this.privConnection.close(), this.privConnection = void 0), await super.dispose(u));
    }
    /**
     * Create the config for the recognizer
     * @param speechConfig
     */
    createRecognizerConfig(u) {
      return new e.RecognizerConfig(u, this.privProperties);
    }
    /**
     * Create the service recognizer.
     * The audio source is redundnant here but is required by the implementation.
     * @param authentication
     * @param connectionFactory
     * @param audioConfig
     * @param recognizerConfig
     */
    createServiceRecognizer(u, l, p, h) {
      const d = p;
      return new a.ConversationServiceAdapter(u, l, d, h, this);
    }
    sendMessage(u, l, p) {
      const h = this.privReco;
      ((f, g, m) => {
        f !== void 0 ? f.then(() => {
          try {
            g && g();
          } catch (v) {
            m && m(`'Unhandled error on promise callback: ${v}'`);
          }
        }, (v) => {
          try {
            m && m(v);
          } catch {
          }
        }) : m && m("Null promise");
      })(h.sendMessageAsync(u), l, p), this.resetConversationTimeout();
    }
    resetConversationTimeout() {
      this.privTimeoutToken !== void 0 && this.privClearTimeout(this.privTimeoutToken), this.privTimeoutToken = this.privSetTimeout(() => {
        this.sendRequest(this.privConversation.getKeepAlive());
      }, 6e4);
    }
  };
  return It.ConversationTranslatorRecognizer = n, It;
}
var Qi = {}, wh;
function ab() {
  if (wh) return Qi;
  wh = 1, Object.defineProperty(Qi, "__esModule", { value: !0 }), Qi.TranscriberRecognizer = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ z(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Re();
  let a = class extends r.Recognizer {
    /**
     * TranscriberRecognizer constructor.
     * @constructor
     * @param {SpeechTranslationConfig} speechTranslationConfig - Non-audio configuration associated with the recognizer
     * @param {AudioConfig} audioConfig - An audio configuration associated with the recognizer
     */
    constructor(n, c) {
      const u = n;
      t.Contracts.throwIfNull(u, "speechTranslationConfig");
      const l = c;
      t.Contracts.throwIfNull(l, "audioConfigImpl"), t.Contracts.throwIfNullOrWhitespace(u.speechRecognitionLanguage, r.PropertyId[r.PropertyId.SpeechServiceConnection_RecoLanguage]), super(c, u.properties, new o.TranscriberConnectionFactory()), this.privDisposedRecognizer = !1, this.isMeetingRecognizer = !1;
    }
    get speechRecognitionLanguage() {
      return t.Contracts.throwIfDisposed(this.privDisposedRecognizer), this.properties.getProperty(r.PropertyId.SpeechServiceConnection_RecoLanguage);
    }
    get properties() {
      return this.privProperties;
    }
    get authorizationToken() {
      return this.properties.getProperty(r.PropertyId.SpeechServiceAuthorization_Token);
    }
    set authorizationToken(n) {
      t.Contracts.throwIfNullOrWhitespace(n, "token"), this.properties.setProperty(r.PropertyId.SpeechServiceAuthorization_Token, n);
    }
    set conversation(n) {
      t.Contracts.throwIfNullOrUndefined(n, "Conversation"), this.isMeetingRecognizer = !1, this.privConversation = n;
    }
    getConversationInfo() {
      return t.Contracts.throwIfNullOrUndefined(this.privConversation, "Conversation"), this.privConversation.conversationInfo;
    }
    set meeting(n) {
      t.Contracts.throwIfNullOrUndefined(n, "Meeting"), this.isMeetingRecognizer = !0, this.privMeeting = n;
    }
    getMeetingInfo() {
      return t.Contracts.throwIfNullOrUndefined(this.privMeeting, "Meeting"), this.privMeeting.meetingInfo;
    }
    IsMeetingRecognizer() {
      return this.isMeetingRecognizer;
    }
    startContinuousRecognitionAsync(n, c) {
      (0, e.marshalPromiseToCallbacks)(this.startContinuousRecognitionAsyncImpl(i.RecognitionMode.Conversation), n, c);
    }
    stopContinuousRecognitionAsync(n, c) {
      (0, e.marshalPromiseToCallbacks)(this.stopContinuousRecognitionAsyncImpl(), n, c);
    }
    async close() {
      this.privDisposedRecognizer || await this.dispose(!0);
    }
    // Push async join/leave conversation message via serviceRecognizer
    async pushConversationEvent(n, c) {
      const u = this.privReco;
      t.Contracts.throwIfNullOrUndefined(u, "serviceRecognizer"), await u.sendSpeechEventAsync(n, c);
    }
    // Push async join/leave meeting message via serviceRecognizer
    async pushMeetingEvent(n, c) {
      const u = this.privReco;
      t.Contracts.throwIfNullOrUndefined(u, "serviceRecognizer"), await u.sendMeetingSpeechEventAsync(n, c);
    }
    async enforceAudioGating() {
      const u = (await this.audioConfig.format).channels;
      if (u === 1) {
        if (this.properties.getProperty("f0f5debc-f8c9-4892-ac4b-90a7ab359fd2", "false").toLowerCase() !== "true")
          throw new Error("Single channel audio configuration for MeetingTranscriber is currently under private preview, please contact diarizationrequest@microsoft.com for more details");
      } else if (u !== 8)
        throw new Error(`Unsupported audio configuration: Detected ${u}-channel audio`);
    }
    connectMeetingCallbacks(n) {
      this.isMeetingRecognizer = !0, this.canceled = (c, u) => {
        n.canceled && n.canceled(n, u);
      }, this.recognizing = (c, u) => {
        n.transcribing && n.transcribing(n, u);
      }, this.recognized = (c, u) => {
        n.transcribed && n.transcribed(n, u);
      }, this.sessionStarted = (c, u) => {
        n.sessionStarted && n.sessionStarted(n, u);
      }, this.sessionStopped = (c, u) => {
        n.sessionStopped && n.sessionStopped(n, u);
      };
    }
    disconnectCallbacks() {
      this.canceled = void 0, this.recognizing = void 0, this.recognized = void 0, this.sessionStarted = void 0, this.sessionStopped = void 0;
    }
    /**
     * Disposes any resources held by the object.
     * @member ConversationTranscriber.prototype.dispose
     * @function
     * @public
     * @param {boolean} disposing - true if disposing the object.
     */
    async dispose(n) {
      this.privDisposedRecognizer || (n && (this.privDisposedRecognizer = !0, await this.implRecognizerStop()), await super.dispose(n));
    }
    createRecognizerConfig(n) {
      return new o.RecognizerConfig(n, this.properties);
    }
    createServiceRecognizer(n, c, u, l) {
      const p = u;
      return new o.TranscriptionServiceRecognizer(n, c, p, l, this);
    }
  };
  return Qi.TranscriberRecognizer = a, Qi;
}
var bh;
function cb() {
  return bh || (bh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.InternalParticipants = e.ConversationTranslatorMessageTypes = e.ConversationTranslatorCommandTypes = e.ParticipantsListEventArgs = e.ParticipantEventArgs = e.ParticipantAttributeEventArgs = e.MuteAllEventArgs = e.LockRoomEventArgs = e.ConversationReceivedTranslationEventArgs = e.TranscriberRecognizer = e.ConversationRecognizerFactory = e.ConversationConnectionConfig = e.ConversationManager = void 0;
    var t = /* @__PURE__ */ Yw();
    Object.defineProperty(e, "ConversationManager", { enumerable: !0, get: function() {
      return t.ConversationManager;
    } });
    var r = /* @__PURE__ */ hc();
    Object.defineProperty(e, "ConversationConnectionConfig", { enumerable: !0, get: function() {
      return r.ConversationConnectionConfig;
    } });
    var o = /* @__PURE__ */ ob();
    Object.defineProperty(e, "ConversationRecognizerFactory", { enumerable: !0, get: function() {
      return o.ConversationRecognizerFactory;
    } });
    var i = /* @__PURE__ */ ab();
    Object.defineProperty(e, "TranscriberRecognizer", { enumerable: !0, get: function() {
      return i.TranscriberRecognizer;
    } });
    var a = /* @__PURE__ */ Qv();
    Object.defineProperty(e, "ConversationReceivedTranslationEventArgs", { enumerable: !0, get: function() {
      return a.ConversationReceivedTranslationEventArgs;
    } }), Object.defineProperty(e, "LockRoomEventArgs", { enumerable: !0, get: function() {
      return a.LockRoomEventArgs;
    } }), Object.defineProperty(e, "MuteAllEventArgs", { enumerable: !0, get: function() {
      return a.MuteAllEventArgs;
    } }), Object.defineProperty(e, "ParticipantAttributeEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantAttributeEventArgs;
    } }), Object.defineProperty(e, "ParticipantEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantEventArgs;
    } }), Object.defineProperty(e, "ParticipantsListEventArgs", { enumerable: !0, get: function() {
      return a.ParticipantsListEventArgs;
    } });
    var s = /* @__PURE__ */ Yv();
    Object.defineProperty(e, "ConversationTranslatorCommandTypes", { enumerable: !0, get: function() {
      return s.ConversationTranslatorCommandTypes;
    } }), Object.defineProperty(e, "ConversationTranslatorMessageTypes", { enumerable: !0, get: function() {
      return s.ConversationTranslatorMessageTypes;
    } }), Object.defineProperty(e, "InternalParticipants", { enumerable: !0, get: function() {
      return s.InternalParticipants;
    } });
  }(Ia)), Ia;
}
var Ta = {}, Eh;
function Xv() {
  return Eh || (Eh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SynthesisAudioMetadata = e.MetadataType = void 0, function(r) {
      r.WordBoundary = "WordBoundary", r.Bookmark = "Bookmark", r.Viseme = "Viseme", r.SentenceBoundary = "SentenceBoundary", r.SessionEnd = "SessionEnd", r.AvatarSignal = "TalkingAvatarSignal";
    }(e.MetadataType || (e.MetadataType = {}));
    class t {
      constructor(o) {
        this.privSynthesisAudioMetadata = JSON.parse(o);
      }
      static fromJSON(o) {
        return new t(o);
      }
      get Metadata() {
        return this.privSynthesisAudioMetadata.Metadata;
      }
    }
    e.SynthesisAudioMetadata = t;
  }(Ta)), Ta;
}
var Yi = {}, Te = {}, Ih;
function ub() {
  if (Ih) return Te;
  Ih = 1, Object.defineProperty(Te, "__esModule", { value: !0 }), Te.SynthesisStartedEvent = Te.ConnectingToSynthesisServiceEvent = Te.SynthesisTriggeredEvent = Te.SpeechSynthesisEvent = void 0;
  const e = /* @__PURE__ */ k();
  class t extends e.PlatformEvent {
    constructor(s, n, c = e.EventType.Info) {
      super(s, c), this.privRequestId = n;
    }
    get requestId() {
      return this.privRequestId;
    }
  }
  Te.SpeechSynthesisEvent = t;
  class r extends t {
    constructor(s, n, c) {
      super("SynthesisTriggeredEvent", s), this.privSessionAudioDestinationId = n, this.privTurnAudioDestinationId = c;
    }
    get audioSessionDestinationId() {
      return this.privSessionAudioDestinationId;
    }
    get audioTurnDestinationId() {
      return this.privTurnAudioDestinationId;
    }
  }
  Te.SynthesisTriggeredEvent = r;
  class o extends t {
    constructor(s, n) {
      super("ConnectingToSynthesisServiceEvent", s), this.privAuthFetchEventId = n;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  Te.ConnectingToSynthesisServiceEvent = o;
  class i extends t {
    constructor(s, n) {
      super("SynthesisStartedEvent", s), this.privAuthFetchEventId = n;
    }
    get authFetchEventId() {
      return this.privAuthFetchEventId;
    }
  }
  return Te.SynthesisStartedEvent = i, Te;
}
var Ah;
function lb() {
  if (Ah) return Yi;
  Ah = 1, Object.defineProperty(Yi, "__esModule", { value: !0 }), Yi.SynthesisTurn = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ Wt(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ Xv(), i = /* @__PURE__ */ ub();
  let a = class Ja {
    constructor() {
      this.privIsDisposed = !1, this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !1, this.privBytesReceived = 0, this.privInTurn = !1, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privRequestId = (0, e.createNoDashGuid)(), this.privTurnDeferral = new e.Deferred(), this.privTurnDeferral.resolve();
    }
    get requestId() {
      return this.privRequestId;
    }
    get streamId() {
      return this.privStreamId;
    }
    set streamId(n) {
      this.privStreamId = n;
    }
    get audioOutputFormat() {
      return this.privAudioOutputFormat;
    }
    set audioOutputFormat(n) {
      this.privAudioOutputFormat = n;
    }
    get turnCompletionPromise() {
      return this.privTurnDeferral.promise;
    }
    get isSynthesisEnded() {
      return this.privIsSynthesisEnded;
    }
    get isSynthesizing() {
      return this.privIsSynthesizing;
    }
    get currentTextOffset() {
      return this.privTextOffset;
    }
    get currentSentenceOffset() {
      return this.privSentenceOffset;
    }
    // The number of bytes received for current turn
    get bytesReceived() {
      return this.privBytesReceived;
    }
    get audioDuration() {
      return this.privAudioDuration;
    }
    get extraProperties() {
      if (this.privWebRTCSDP) {
        const n = new r.PropertyCollection();
        return n.setProperty(r.PropertyId.TalkingAvatarService_WebRTC_SDP, this.privWebRTCSDP), n;
      }
    }
    async getAllReceivedAudio() {
      return this.privReceivedAudio ? Promise.resolve(this.privReceivedAudio) : this.privIsSynthesisEnded ? (await this.readAllAudioFromStream(), Promise.resolve(this.privReceivedAudio)) : null;
    }
    async getAllReceivedAudioWithHeader() {
      if (this.privReceivedAudioWithHeader)
        return this.privReceivedAudioWithHeader;
      if (!this.privIsSynthesisEnded)
        return null;
      if (this.audioOutputFormat.hasHeader) {
        const n = await this.getAllReceivedAudio();
        return this.privReceivedAudioWithHeader = this.audioOutputFormat.addHeader(n), this.privReceivedAudioWithHeader;
      } else
        return this.getAllReceivedAudio();
    }
    startNewSynthesis(n, c, u, l) {
      this.privIsSynthesisEnded = !1, this.privIsSynthesizing = !0, this.privRequestId = n, this.privRawText = c, this.privIsSSML = u, this.privAudioOutputStream = new t.PullAudioOutputStreamImpl(), this.privAudioOutputStream.format = this.privAudioOutputFormat, this.privReceivedAudio = null, this.privReceivedAudioWithHeader = null, this.privBytesReceived = 0, this.privTextOffset = 0, this.privNextSearchTextIndex = 0, this.privSentenceOffset = 0, this.privNextSearchSentenceIndex = 0, this.privPartialVisemeAnimation = "", this.privWebRTCSDP = "", l !== void 0 && (this.privTurnAudioDestination = l, this.privTurnAudioDestination.format = this.privAudioOutputFormat), this.onEvent(new i.SynthesisTriggeredEvent(this.requestId, void 0, l === void 0 ? void 0 : l.id()));
    }
    onPreConnectionStart(n) {
      this.privAuthFetchEventId = n, this.onEvent(new i.ConnectingToSynthesisServiceEvent(this.privRequestId, this.privAuthFetchEventId));
    }
    onAuthCompleted(n) {
      n && this.onComplete();
    }
    onConnectionEstablishCompleted(n) {
      if (n === 200) {
        this.onEvent(new i.SynthesisStartedEvent(this.requestId, this.privAuthFetchEventId)), this.privBytesReceived = 0;
        return;
      } else n === 403 && this.onComplete();
    }
    onServiceResponseMessage(n) {
      const c = JSON.parse(n);
      this.streamId = c.audio.streamId;
    }
    onServiceTurnEndResponse() {
      this.privInTurn = !1, this.privTurnDeferral.resolve(), this.onComplete();
    }
    onServiceTurnStartResponse(n) {
      this.privTurnDeferral && this.privInTurn && (this.privTurnDeferral.reject("Another turn started before current completed."), this.privTurnDeferral.promise.then().catch(() => {
      })), this.privInTurn = !0, this.privTurnDeferral = new e.Deferred();
      const c = JSON.parse(n);
      c.webrtc && (this.privWebRTCSDP = c.webrtc.connectionString);
    }
    onAudioChunkReceived(n) {
      this.isSynthesizing && (this.privAudioOutputStream.write(n), this.privBytesReceived += n.byteLength, this.privTurnAudioDestination !== void 0 && this.privTurnAudioDestination.write(n));
    }
    onTextBoundaryEvent(n) {
      this.updateTextOffset(n.Data.text.Text, n.Type);
    }
    onVisemeMetadataReceived(n) {
      n.Data.AnimationChunk !== void 0 && (this.privPartialVisemeAnimation += n.Data.AnimationChunk);
    }
    onSessionEnd(n) {
      this.privAudioDuration = n.Data.Offset;
    }
    async constructSynthesisResult() {
      const n = await this.getAllReceivedAudioWithHeader();
      return new r.SpeechSynthesisResult(this.requestId, r.ResultReason.SynthesizingAudioCompleted, n, void 0, this.extraProperties, this.audioDuration);
    }
    dispose() {
      this.privIsDisposed || (this.privIsDisposed = !0);
    }
    onStopSynthesizing() {
      this.onComplete();
    }
    /**
     * Gets the viseme animation string (merged from animation chunk), and clears the internal
     * partial animation.
     */
    getAndClearVisemeAnimation() {
      const n = this.privPartialVisemeAnimation;
      return this.privPartialVisemeAnimation = "", n;
    }
    onEvent(n) {
      e.Events.instance.onEvent(n);
    }
    /**
     * Check if the text is an XML(SSML) tag
     * @param text
     * @private
     */
    static isXmlTag(n) {
      return n.length >= 2 && n[0] === "<" && n[n.length - 1] === ">";
    }
    updateTextOffset(n, c) {
      c === o.MetadataType.WordBoundary ? (this.privTextOffset = this.privRawText.indexOf(n, this.privNextSearchTextIndex), this.privTextOffset >= 0 && (this.privNextSearchTextIndex = this.privTextOffset + n.length, this.privIsSSML && this.withinXmlTag(this.privTextOffset) && !Ja.isXmlTag(n) && this.updateTextOffset(n, c))) : (this.privSentenceOffset = this.privRawText.indexOf(n, this.privNextSearchSentenceIndex), this.privSentenceOffset >= 0 && (this.privNextSearchSentenceIndex = this.privSentenceOffset + n.length, this.privIsSSML && this.withinXmlTag(this.privSentenceOffset) && !Ja.isXmlTag(n) && this.updateTextOffset(n, c)));
    }
    onComplete() {
      this.privIsSynthesizing && (this.privIsSynthesizing = !1, this.privIsSynthesisEnded = !0, this.privAudioOutputStream.close(), this.privInTurn = !1, this.privTurnAudioDestination !== void 0 && (this.privTurnAudioDestination.close(), this.privTurnAudioDestination = void 0));
    }
    async readAllAudioFromStream() {
      if (this.privIsSynthesisEnded) {
        this.privReceivedAudio = new ArrayBuffer(this.bytesReceived);
        try {
          await this.privAudioOutputStream.read(this.privReceivedAudio);
        } catch {
          this.privReceivedAudio = new ArrayBuffer(0);
        }
      }
    }
    /**
     * Check if current idx is in XML(SSML) tag
     * @param idx
     * @private
     */
    withinXmlTag(n) {
      return this.privRawText.indexOf("<", n + 1) > this.privRawText.indexOf(">", n + 1);
    }
  };
  return Yi.SynthesisTurn = a, Yi;
}
var Zi = {}, Th;
function pb() {
  if (Th) return Zi;
  Th = 1, Object.defineProperty(Zi, "__esModule", { value: !0 }), Zi.SynthesisAdapterBase = void 0;
  const e = /* @__PURE__ */ k(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ _(), o = /* @__PURE__ */ Ht();
  let i = class {
    constructor(s, n, c, u) {
      if (this.speakOverride = void 0, this.receiveMessageOverride = void 0, this.connectImplOverride = void 0, this.configConnectionOverride = void 0, this.privConnectionConfigurationPromise = void 0, !s)
        throw new e.ArgumentNullError("authentication");
      if (!n)
        throw new e.ArgumentNullError("connectionFactory");
      if (!c)
        throw new e.ArgumentNullError("synthesizerConfig");
      this.privAuthentication = s, this.privConnectionFactory = n, this.privSynthesizerConfig = c, this.privIsDisposed = !1, this.privSessionAudioDestination = u, this.privSynthesisTurn = new r.SynthesisTurn(), this.privConnectionEvents = new e.EventSource(), this.privServiceEvents = new e.EventSource(), this.privSynthesisContext = new r.SynthesisContext(), this.privAgentConfig = new r.AgentConfig(), this.connectionEvents.attach((l) => {
        if (l.name === "ConnectionClosedEvent") {
          const p = l;
          p.statusCode !== 1e3 && this.cancelSynthesisLocal(t.CancellationReason.Error, p.statusCode === 1007 ? t.CancellationErrorCode.BadRequestParameters : t.CancellationErrorCode.ConnectionFailure, `${p.reason} websocket error code: ${p.statusCode}`);
        }
      });
    }
    get synthesisContext() {
      return this.privSynthesisContext;
    }
    get agentConfig() {
      return this.privAgentConfig;
    }
    get connectionEvents() {
      return this.privConnectionEvents;
    }
    get serviceEvents() {
      return this.privServiceEvents;
    }
    set activityTemplate(s) {
      this.privActivityTemplate = s;
    }
    get activityTemplate() {
      return this.privActivityTemplate;
    }
    set audioOutputFormat(s) {
      this.privAudioOutputFormat = s, this.privSynthesisTurn.audioOutputFormat = s, this.privSessionAudioDestination !== void 0 && (this.privSessionAudioDestination.format = s), this.synthesisContext !== void 0 && (this.synthesisContext.audioOutputFormat = s);
    }
    isDisposed() {
      return this.privIsDisposed;
    }
    async dispose(s) {
      this.privIsDisposed = !0, this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.close(), this.privConnectionConfigurationPromise !== void 0 && await (await this.privConnectionConfigurationPromise).dispose(s);
    }
    async connect() {
      await this.connectImpl();
    }
    async sendNetworkMessage(s, n) {
      const c = typeof n == "string" ? e.MessageType.Text : e.MessageType.Binary, u = typeof n == "string" ? "application/json" : "";
      return (await this.fetchConnection()).send(new o.SpeechConnectionMessage(c, s, this.privSynthesisTurn.requestId, u, n));
    }
    async Speak(s, n, c, u, l, p) {
      let h;
      if (n ? h = s : h = this.privSynthesizer.buildSsml(s), this.speakOverride !== void 0)
        return this.speakOverride(h, c, u, l);
      this.privSuccessCallback = u, this.privErrorCallback = l, this.privSynthesisTurn.startNewSynthesis(c, s, n, p);
      try {
        await this.connectImpl();
        const d = await this.fetchConnection();
        await this.sendSynthesisContext(d), await this.sendSsmlMessage(d, h, c), this.onSynthesisStarted(c), this.receiveMessage();
      } catch (d) {
        return this.cancelSynthesisLocal(t.CancellationReason.Error, t.CancellationErrorCode.ConnectionFailure, d), Promise.reject(d);
      }
    }
    async stopSpeaking() {
      return await this.connectImpl(), (await this.fetchConnection()).send(new o.SpeechConnectionMessage(e.MessageType.Text, "synthesis.control", this.privSynthesisTurn.requestId, "application/json", JSON.stringify({
        action: "stop"
      })));
    }
    // Cancels synthesis.
    cancelSynthesis(s, n, c, u) {
      const l = new t.PropertyCollection();
      l.setProperty(r.CancellationErrorCodePropertyName, t.CancellationErrorCode[c]);
      const p = new t.SpeechSynthesisResult(s, t.ResultReason.Canceled, void 0, u, l);
      if (this.onSynthesisCancelled(p), this.privSuccessCallback)
        try {
          this.privSuccessCallback(p);
        } catch {
        }
    }
    // Cancels synthesis.
    cancelSynthesisLocal(s, n, c) {
      this.privSynthesisTurn.isSynthesizing && (this.privSynthesisTurn.onStopSynthesizing(), this.cancelSynthesis(this.privSynthesisTurn.requestId, s, n, c));
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    processTypeSpecificMessages(s) {
      return !0;
    }
    async receiveMessage() {
      try {
        const n = await (await this.fetchConnection()).read();
        if (this.receiveMessageOverride !== void 0)
          return this.receiveMessageOverride();
        if (this.privIsDisposed)
          return;
        if (!n)
          return this.privSynthesisTurn.isSynthesizing ? this.receiveMessage() : void 0;
        const c = o.SpeechConnectionMessage.fromConnectionMessage(n);
        if (c.requestId.toLowerCase() === this.privSynthesisTurn.requestId.toLowerCase())
          switch (c.path.toLowerCase()) {
            case "turn.start":
              this.privSynthesisTurn.onServiceTurnStartResponse(c.textBody);
              break;
            case "response":
              this.privSynthesisTurn.onServiceResponseMessage(c.textBody);
              break;
            case "audio":
              this.privSynthesisTurn.streamId.toLowerCase() === c.streamId.toLowerCase() && c.binaryBody && (this.privSynthesisTurn.onAudioChunkReceived(c.binaryBody), this.onSynthesizing(c.binaryBody), this.privSessionAudioDestination !== void 0 && this.privSessionAudioDestination.write(c.binaryBody));
              break;
            case "audio.metadata":
              const u = r.SynthesisAudioMetadata.fromJSON(c.textBody).Metadata;
              for (const p of u)
                switch (p.Type) {
                  case r.MetadataType.WordBoundary:
                  case r.MetadataType.SentenceBoundary:
                    this.privSynthesisTurn.onTextBoundaryEvent(p);
                    const h = new t.SpeechSynthesisWordBoundaryEventArgs(p.Data.Offset, p.Data.Duration, p.Data.text.Text, p.Data.text.Length, p.Type === r.MetadataType.WordBoundary ? this.privSynthesisTurn.currentTextOffset : this.privSynthesisTurn.currentSentenceOffset, p.Data.text.BoundaryType);
                    this.onWordBoundary(h);
                    break;
                  case r.MetadataType.Bookmark:
                    const d = new t.SpeechSynthesisBookmarkEventArgs(p.Data.Offset, p.Data.Bookmark);
                    this.onBookmarkReached(d);
                    break;
                  case r.MetadataType.Viseme:
                    if (this.privSynthesisTurn.onVisemeMetadataReceived(p), p.Data.IsLastAnimation) {
                      const f = new t.SpeechSynthesisVisemeEventArgs(p.Data.Offset, p.Data.VisemeId, this.privSynthesisTurn.getAndClearVisemeAnimation());
                      this.onVisemeReceived(f);
                    }
                    break;
                  case r.MetadataType.AvatarSignal:
                    this.onAvatarEvent(p);
                    break;
                  case r.MetadataType.SessionEnd:
                    this.privSynthesisTurn.onSessionEnd(p);
                    break;
                }
              break;
            case "turn.end":
              this.privSynthesisTurn.onServiceTurnEndResponse();
              let l;
              try {
                l = await this.privSynthesisTurn.constructSynthesisResult(), this.privSuccessCallback && this.privSuccessCallback(l);
              } catch (p) {
                this.privErrorCallback && this.privErrorCallback(p);
              }
              this.onSynthesisCompleted(l);
              break;
            default:
              this.processTypeSpecificMessages(c) || this.privServiceEvents && this.serviceEvents.onEvent(new e.ServiceEvent(c.path.toLowerCase(), c.textBody));
          }
        return this.receiveMessage();
      } catch {
      }
    }
    sendSynthesisContext(s) {
      this.setSynthesisContextSynthesisSection();
      const n = this.synthesisContext.toJSON();
      if (n)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "synthesis.context", this.privSynthesisTurn.requestId, "application/json", n));
    }
    setSpeechConfigSynthesisSection() {
    }
    connectImpl(s = !1) {
      if (this.privConnectionPromise != null)
        return this.privConnectionPromise.then((c) => c.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()) : this.privConnectionPromise, () => (this.privConnectionId = null, this.privConnectionPromise = null, this.connectImpl()));
      this.privAuthFetchEventId = (0, e.createNoDashGuid)(), this.privConnectionId = (0, e.createNoDashGuid)(), this.privSynthesisTurn.onPreConnectionStart(this.privAuthFetchEventId);
      const n = s ? this.privAuthentication.fetchOnExpiry(this.privAuthFetchEventId) : this.privAuthentication.fetch(this.privAuthFetchEventId);
      return this.privConnectionPromise = n.then(async (c) => {
        this.privSynthesisTurn.onAuthCompleted(!1);
        const u = await this.privConnectionFactory.create(this.privSynthesizerConfig, c, this.privConnectionId);
        u.events.attach((p) => {
          this.connectionEvents.onEvent(p);
        });
        const l = await u.open();
        return l.statusCode === 200 ? (this.privSynthesisTurn.onConnectionEstablishCompleted(l.statusCode), Promise.resolve(u)) : l.statusCode === 403 && !s ? this.connectImpl(!0) : (this.privSynthesisTurn.onConnectionEstablishCompleted(l.statusCode), Promise.reject(`Unable to contact server. StatusCode: ${l.statusCode},
                    ${this.privSynthesizerConfig.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Url)} Reason: ${l.reason}`));
      }, (c) => {
        throw this.privSynthesisTurn.onAuthCompleted(!0), new Error(c);
      }), this.privConnectionPromise.catch(() => {
      }), this.privConnectionPromise;
    }
    sendSpeechServiceConfig(s, n) {
      if (n)
        return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "speech.config", this.privSynthesisTurn.requestId, "application/json", n));
    }
    sendSsmlMessage(s, n, c) {
      return s.send(new o.SpeechConnectionMessage(e.MessageType.Text, "ssml", c, "application/ssml+xml", n));
    }
    async fetchConnection() {
      return this.privConnectionConfigurationPromise !== void 0 ? this.privConnectionConfigurationPromise.then((s) => s.state() === e.ConnectionState.Disconnected ? (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection()) : this.privConnectionConfigurationPromise, () => (this.privConnectionId = null, this.privConnectionConfigurationPromise = void 0, this.fetchConnection())) : (this.privConnectionConfigurationPromise = this.configureConnection(), await this.privConnectionConfigurationPromise);
    }
    // Takes an established websocket connection to the endpoint and sends speech configuration information.
    async configureConnection() {
      const s = await this.connectImpl();
      return this.configConnectionOverride !== void 0 ? this.configConnectionOverride(s) : (this.setSpeechConfigSynthesisSection(), await this.sendSpeechServiceConfig(s, this.privSynthesizerConfig.SpeechServiceConfig.serialize()), s);
    }
    onAvatarEvent(s) {
    }
    onSynthesisStarted(s) {
    }
    onSynthesizing(s) {
    }
    onSynthesisCancelled(s) {
    }
    onSynthesisCompleted(s) {
    }
    onWordBoundary(s) {
    }
    onVisemeReceived(s) {
    }
    onBookmarkReached(s) {
    }
  };
  return Zi.SynthesisAdapterBase = i, i.telemetryDataEnabled = !0, Zi;
}
var Xi = {}, _h;
function db() {
  if (_h) return Xi;
  _h = 1, Object.defineProperty(Xi, "__esModule", { value: !0 }), Xi.AvatarSynthesisAdapter = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class extends t.SynthesisAdapterBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, void 0), this.privAvatarSynthesizer = n, this.privSynthesizer = n, this.privAvatarConfig = c;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(void 0);
    }
    setSpeechConfigSynthesisSection() {
      this.privSynthesizerConfig.synthesisVideoSection = {
        format: {
          bitrate: this.privAvatarConfig.videoFormat?.bitrate,
          codec: this.privAvatarConfig.videoFormat?.codec,
          crop: {
            bottomRight: {
              x: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.x,
              y: this.privAvatarConfig.videoFormat?.cropRange?.bottomRight?.y
            },
            topLeft: {
              x: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.x,
              y: this.privAvatarConfig.videoFormat?.cropRange?.topLeft?.y
            }
          },
          resolution: {
            height: this.privAvatarConfig.videoFormat?.height,
            width: this.privAvatarConfig.videoFormat?.width
          }
        },
        protocol: {
          name: "WebRTC",
          webrtcConfig: {
            clientDescription: btoa(this.privSynthesizerConfig.parameters.getProperty(e.PropertyId.TalkingAvatarService_WebRTC_SDP)),
            iceServers: this.privAvatarConfig.remoteIceServers ?? this.privAvatarSynthesizer.iceServers
          }
        },
        talkingAvatar: {
          background: {
            color: this.privAvatarConfig.backgroundColor,
            image: {
              url: this.privAvatarConfig.backgroundImage?.toString()
            }
          },
          character: this.privAvatarConfig.character,
          customized: this.privAvatarConfig.customized,
          style: this.privAvatarConfig.style,
          useBuiltInVoice: this.privAvatarConfig.useBuiltInVoice
        }
      };
    }
    onAvatarEvent(i) {
      if (this.privAvatarSynthesizer.avatarEventReceived) {
        const a = new e.AvatarEventArgs(i.Data.Offset, i.Data.Name);
        try {
          this.privAvatarSynthesizer.avatarEventReceived(this.privAvatarSynthesizer, a);
        } catch {
        }
      }
    }
  };
  return Xi.AvatarSynthesisAdapter = r, Xi;
}
var es = {}, kh;
function hb() {
  if (kh) return es;
  kh = 1, Object.defineProperty(es, "__esModule", { value: !0 }), es.SpeechSynthesisAdapter = void 0;
  const e = /* @__PURE__ */ I(), t = /* @__PURE__ */ _();
  let r = class extends t.SynthesisAdapterBase {
    constructor(i, a, s, n, c) {
      super(i, a, s, c), this.privSpeechSynthesizer = n, this.privSynthesizer = n;
    }
    setSynthesisContextSynthesisSection() {
      this.privSynthesisContext.setSynthesisSection(this.privSpeechSynthesizer);
    }
    onSynthesisStarted(i) {
      const a = new e.SpeechSynthesisEventArgs(new e.SpeechSynthesisResult(i, e.ResultReason.SynthesizingAudioStarted));
      this.privSpeechSynthesizer.synthesisStarted && this.privSpeechSynthesizer.synthesisStarted(this.privSpeechSynthesizer, a);
    }
    onSynthesizing(i) {
      if (this.privSpeechSynthesizer.synthesizing)
        try {
          const a = this.privSynthesisTurn.audioOutputFormat.addHeader(i), s = new e.SpeechSynthesisEventArgs(new e.SpeechSynthesisResult(this.privSynthesisTurn.requestId, e.ResultReason.SynthesizingAudio, a));
          this.privSpeechSynthesizer.synthesizing(this.privSpeechSynthesizer, s);
        } catch {
        }
    }
    onSynthesisCancelled(i) {
      if (this.privSpeechSynthesizer.SynthesisCanceled) {
        const a = new e.SpeechSynthesisEventArgs(i);
        try {
          this.privSpeechSynthesizer.SynthesisCanceled(this.privSpeechSynthesizer, a);
        } catch {
        }
      }
    }
    onSynthesisCompleted(i) {
      if (this.privSpeechSynthesizer.synthesisCompleted)
        try {
          this.privSpeechSynthesizer.synthesisCompleted(this.privSpeechSynthesizer, new e.SpeechSynthesisEventArgs(i));
        } catch {
        }
    }
    onWordBoundary(i) {
      if (this.privSpeechSynthesizer.wordBoundary)
        try {
          this.privSpeechSynthesizer.wordBoundary(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
    onVisemeReceived(i) {
      if (this.privSpeechSynthesizer.visemeReceived)
        try {
          this.privSpeechSynthesizer.visemeReceived(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
    onBookmarkReached(i) {
      if (this.privSpeechSynthesizer.bookmarkReached)
        try {
          this.privSpeechSynthesizer.bookmarkReached(this.privSpeechSynthesizer, i);
        } catch {
        }
    }
  };
  return es.SpeechSynthesisAdapter = r, es;
}
var ts = {}, Oh;
function fb() {
  if (Oh) return ts;
  Oh = 1, Object.defineProperty(ts, "__esModule", { value: !0 }), ts.SynthesisRestAdapter = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ I(), r = /* @__PURE__ */ ke(), o = /* @__PURE__ */ le();
  let i = class {
    constructor(s, n) {
      let c = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Endpoint, void 0);
      if (!c) {
        const l = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Region, "westus"), p = r.ConnectionFactoryBase.getHostSuffix(l);
        c = s.parameters.getProperty(t.PropertyId.SpeechServiceConnection_Host, `https://${l}.tts.speech${p}`);
      }
      this.privUri = `${c}/cognitiveservices/voices/list`;
      const u = e.RestConfigBase.requestOptions;
      this.privRestAdapter = new e.RestMessageAdapter(u), this.privAuthentication = n;
    }
    /**
     * Sends list voices request to endpoint.
     * @function
     * @public
     * @param connectionId - guid for connectionId
     * @returns {Promise<IRestResponse>} rest response to status request
     */
    getVoicesList(s) {
      return this.privRestAdapter.setHeaders(o.HeaderNames.ConnectionId, s), this.privAuthentication.fetch(s).then((n) => (this.privRestAdapter.setHeaders(n.headerName, n.token), this.privRestAdapter.request(e.RestRequestType.Get, this.privUri)));
    }
  };
  return ts.SynthesisRestAdapter = i, ts;
}
var _a = {}, Mh;
function vb() {
  return Mh || (Mh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.SynthesizerConfig = e.SynthesisServiceType = void 0;
    const t = /* @__PURE__ */ _();
    var r;
    (function(i) {
      i[i.Standard = 0] = "Standard", i[i.Custom = 1] = "Custom";
    })(r = e.SynthesisServiceType || (e.SynthesisServiceType = {}));
    class o {
      constructor(a, s) {
        this.privSynthesisServiceType = r.Standard, this.avatarEnabled = !1, this.privSpeechServiceConfig = a || new t.SpeechServiceConfig(new t.Context(null)), this.privParameters = s;
      }
      get parameters() {
        return this.privParameters;
      }
      get synthesisServiceType() {
        return this.privSynthesisServiceType;
      }
      set synthesisServiceType(a) {
        this.privSynthesisServiceType = a;
      }
      set synthesisVideoSection(a) {
        this.privSpeechServiceConfig.Context.synthesis = {
          video: a
        };
      }
      get SpeechServiceConfig() {
        return this.privSpeechServiceConfig;
      }
    }
    e.SynthesizerConfig = o;
  }(_a)), _a;
}
var rs = {}, Dh;
function gb() {
  if (Dh) return rs;
  Dh = 1, Object.defineProperty(rs, "__esModule", { value: !0 }), rs.SynthesisContext = void 0;
  const e = /* @__PURE__ */ I();
  let t = class {
    constructor() {
      this.privContext = {};
    }
    /**
     * Adds a section to the synthesis.context object.
     * @param sectionName Name of the section to add.
     * @param value JSON serializable object that represents the value.
     */
    setSection(o, i) {
      this.privContext[o] = i;
    }
    /**
     * Sets the audio output format for synthesis context generation.
     * @param format {AudioOutputFormatImpl} the output format
     */
    set audioOutputFormat(o) {
      this.privAudioOutputFormat = o;
    }
    toJSON() {
      return JSON.stringify(this.privContext);
    }
    setSynthesisSection(o) {
      const i = this.buildSynthesisContext(o);
      this.setSection("synthesis", i);
    }
    buildSynthesisContext(o) {
      return {
        audio: {
          metadataOptions: {
            bookmarkEnabled: !!o?.bookmarkReached,
            punctuationBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestPunctuationBoundary, !!o?.wordBoundary),
            sentenceBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestSentenceBoundary, !1),
            sessionEndEnabled: !0,
            visemeEnabled: !!o?.visemeReceived,
            wordBoundaryEnabled: o?.properties.getProperty(e.PropertyId.SpeechServiceResponse_RequestWordBoundary, !!o?.wordBoundary)
          },
          outputFormat: this.privAudioOutputFormat.requestAudioFormatString
        },
        language: {
          autoDetection: o?.autoDetectSourceLanguage
        }
      };
    }
  };
  return rs.SynthesisContext = t, rs;
}
var ns = {}, Nh;
function mb() {
  if (Nh) return ns;
  Nh = 1, Object.defineProperty(ns, "__esModule", { value: !0 }), ns.SpeakerRecognitionConfig = void 0;
  const e = /* @__PURE__ */ _();
  let t = class {
    constructor(o, i) {
      this.privContext = o || new e.Context(null), this.privParameters = i;
    }
    get parameters() {
      return this.privParameters;
    }
    get Context() {
      return this.privContext;
    }
  };
  return ns.SpeakerRecognitionConfig = t, ns;
}
var is = {}, xh;
function yb() {
  if (xh) return is;
  xh = 1, Object.defineProperty(is, "__esModule", { value: !0 }), is.SpeakerServiceRecognizer = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Ht();
  let a = class extends o.ServiceRecognizerBase {
    constructor(n, c, u, l, p) {
      super(n, c, u, l, p), this.privSpeakerRecognizer = p, this.privSpeakerAudioSource = u, this.recognizeSpeaker = (h) => this.recognizeSpeakerOnce(h), this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    processTypeSpecificMessages(n) {
      let c = !1;
      const u = new r.PropertyCollection();
      switch (n.messageType === t.MessageType.Text && u.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, n.textBody), n.path.toLowerCase()) {
        case "speaker.response":
          const p = JSON.parse(n.textBody);
          let h;
          p.status.statusCode.toLowerCase() !== "success" ? h = new r.SpeakerRecognitionResult(p, r.ResultReason.Canceled, r.CancellationErrorCode.ServiceError, p.status.reason) : h = new r.SpeakerRecognitionResult(p, r.ResultReason.RecognizedSpeaker), this.privResultDeferral && this.privResultDeferral.resolve(h), c = !0;
          break;
      }
      const l = new t.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(n, c, u, l, p) {
      if (new r.PropertyCollection().setProperty(o.CancellationErrorCodePropertyName, r.CancellationErrorCode[l]), this.privResultDeferral) {
        const d = new r.SpeakerRecognitionResult({
          scenario: this.privSpeakerModel.scenario,
          status: { statusCode: p, reason: p }
        }, r.ResultReason.Canceled, l, p);
        try {
          this.privResultDeferral.resolve(d);
        } catch (f) {
          this.privResultDeferral.reject(f);
        }
      }
    }
    async recognizeSpeakerOnce(n) {
      this.privSpeakerModel = n, this.voiceProfileType = n.scenario, this.privResultDeferral || (this.privResultDeferral = new t.Deferred()), this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(r.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const c = this.connectImpl(), u = this.sendPreAudioMessages(this.extractSpeakerContext(n)), l = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), p = await this.privSpeakerAudioSource.format, h = await this.privSpeakerAudioSource.deviceInfo, d = new e.ReplayableAudioNode(l, p.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(d, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: h };
      try {
        await c, await u;
      } catch (m) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, m);
      }
      const f = new r.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, f), this.receiveMessage(), this.sendAudio(d).then(() => {
      }, (m) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, m);
      }), this.privResultDeferral.promise;
    }
    async sendPreAudioMessages(n) {
      const c = await this.fetchConnection();
      await this.sendSpeakerRecognition(c, n);
    }
    async sendSpeakerRecognition(n, c) {
      const u = JSON.stringify(c);
      return n.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.context", this.privRequestSession.requestId, "application/json; charset=utf-8", u));
    }
    extractSpeakerContext(n) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: n.profileIds,
        scenario: n.scenario
      };
    }
  };
  return is.SpeakerServiceRecognizer = a, is;
}
var ss = {}, zh;
function Sb() {
  if (zh) return ss;
  zh = 1, Object.defineProperty(ss, "__esModule", { value: !0 }), ss.VoiceServiceRecognizer = void 0;
  const e = /* @__PURE__ */ ee(), t = /* @__PURE__ */ k(), r = /* @__PURE__ */ I(), o = /* @__PURE__ */ _(), i = /* @__PURE__ */ Ht();
  let a = class extends o.ServiceRecognizerBase {
    constructor(n, c, u, l, p) {
      super(n, c, u, l, p), this.privDeferralMap = new t.DeferralMap(), this.privSpeakerAudioSource = u, this.sendPrePayloadJSONOverride = () => this.noOp();
    }
    set SpeakerAudioSource(n) {
      this.privSpeakerAudioSource = n;
    }
    processTypeSpecificMessages(n) {
      let c = !1;
      const u = new r.PropertyCollection();
      switch (n.messageType === t.MessageType.Text && u.setProperty(r.PropertyId.SpeechServiceResponse_JsonResult, n.textBody), n.path.toLowerCase()) {
        // Profile management response for create, fetch, delete, reset
        case "speaker.profiles":
          const p = JSON.parse(n.textBody);
          switch (p.operation.toLowerCase()) {
            case "create":
              this.handleCreateResponse(p, n.requestId);
              break;
            case "delete":
            case "reset":
              this.handleResultResponse(p, n.requestId);
              break;
            case "fetch":
              const g = JSON.parse(n.textBody);
              this.handleFetchResponse(g, n.requestId);
              break;
          }
          c = !0;
          break;
        // Activation and authorization phrase response
        case "speaker.phrases":
          const h = JSON.parse(n.textBody);
          this.handlePhrasesResponse(h, n.requestId), c = !0;
          break;
        // Enrollment response
        case "speaker.profile.enrollment":
          const d = JSON.parse(n.textBody), f = new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(d.enrollment ? d.enrollment.enrollmentStatus : d.status.statusCode), d.enrollment ? JSON.stringify(d.enrollment) : void 0, d.status.reason);
          this.privDeferralMap.getId(n.requestId) && this.privDeferralMap.complete(n.requestId, f), this.privRequestSession.onSpeechEnded(), c = !0;
          break;
      }
      const l = new t.Deferred();
      return l.resolve(c), l.promise;
    }
    // Cancels recognition.
    cancelRecognition(n, c, u, l, p) {
      new r.PropertyCollection().setProperty(o.CancellationErrorCodePropertyName, r.CancellationErrorCode[l]);
      const d = new r.VoiceProfileEnrollmentResult(r.ResultReason.Canceled, p, p);
      this.privDeferralMap.getId(c) && this.privDeferralMap.complete(c, d);
    }
    async createProfile(n, c) {
      this.voiceProfileType = n.toString();
      const u = this.connectImpl();
      try {
        const l = new t.Deferred();
        return await u, await this.sendCreateProfile(l, n, c), this.receiveMessage(), l.promise;
      } catch (l) {
        throw l;
      }
    }
    async resetProfile(n) {
      return this.voiceProfileType = n.profileType.toString(), this.sendCommonRequest("reset", n.profileType, n);
    }
    async deleteProfile(n) {
      return this.voiceProfileType = n.profileType.toString(), this.sendCommonRequest("delete", n.profileType, n);
    }
    async retrieveEnrollmentResult(n) {
      return this.voiceProfileType = n.profileType.toString(), this.privExpectedProfileId = n.profileId, this.sendCommonRequest("fetch", n.profileType, n);
    }
    async getAllProfiles(n) {
      return this.voiceProfileType = n.toString(), this.sendCommonRequest("fetch", n);
    }
    async getActivationPhrases(n, c) {
      this.voiceProfileType = n.toString();
      const u = this.connectImpl();
      try {
        const l = new t.Deferred();
        return await u, await this.sendPhrasesRequest(l, n, c), this.receiveMessage(), l.promise;
      } catch (l) {
        throw l;
      }
    }
    async enrollProfile(n) {
      this.voiceProfileType = n.profileType.toString();
      const c = new t.Deferred();
      this.privRequestSession.startNewRecognition(), this.privRequestSession.listenForServiceTelemetry(this.privSpeakerAudioSource.events), this.privRecognizerConfig.parameters.setProperty(r.PropertyId.Speech_SessionId, this.privRequestSession.sessionId);
      const u = this.connectImpl(), l = this.sendPreAudioMessages(n, c), p = await this.privSpeakerAudioSource.attach(this.privRequestSession.audioNodeId), h = await this.privSpeakerAudioSource.format, d = await this.privSpeakerAudioSource.deviceInfo, f = new e.ReplayableAudioNode(p, h.avgBytesPerSec);
      await this.privRequestSession.onAudioSourceAttachCompleted(f, !1), this.privRecognizerConfig.SpeechServiceConfig.Context.audio = { source: d };
      try {
        await u, await l;
      } catch (v) {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.ConnectionFailure, v);
      }
      const g = new r.SessionEventArgs(this.privRequestSession.sessionId);
      return this.privRecognizer.sessionStarted && this.privRecognizer.sessionStarted(this.privRecognizer, g), this.receiveMessage(), this.sendAudio(f).then(() => {
      }, (v) => {
        this.cancelRecognition(this.privRequestSession.sessionId, this.privRequestSession.requestId, r.CancellationReason.Error, r.CancellationErrorCode.RuntimeError, v);
      }), c.promise;
    }
    async sendPreAudioMessages(n, c) {
      const u = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, c), await this.sendBaseRequest(u, "enroll", this.scenarioFrom(n.profileType), n);
    }
    async sendPhrasesRequest(n, c, u) {
      const l = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, n);
      const p = this.scenarioFrom(c), h = {
        locale: u,
        scenario: p
      };
      return l.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.profile.phrases", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(h)));
    }
    async sendCreateProfile(n, c, u) {
      const l = await this.fetchConnection();
      this.privRequestSession.onSpeechContext(), this.privDeferralMap.add(this.privRequestSession.requestId, n);
      const p = c === r.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : c === r.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification", h = {
        locale: u,
        number: "1",
        scenario: p
      };
      return l.send(new i.SpeechConnectionMessage(t.MessageType.Text, "speaker.profile.create", this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(h)));
    }
    async sendCommonRequest(n, c, u = void 0) {
      const l = this.connectImpl();
      try {
        const p = new t.Deferred();
        this.privRequestSession.onSpeechContext(), await l;
        const h = await this.fetchConnection();
        return this.privDeferralMap.add(this.privRequestSession.requestId, p), await this.sendBaseRequest(h, n, this.scenarioFrom(c), u), this.receiveMessage(), p.promise;
      } catch (p) {
        throw p;
      }
    }
    async sendBaseRequest(n, c, u, l) {
      const p = {
        scenario: u
      };
      return l ? p.profileIds = [l.profileId] : p.maxPageSize = -1, n.send(new i.SpeechConnectionMessage(t.MessageType.Text, `speaker.profile.${c}`, this.privRequestSession.requestId, "application/json; charset=utf-8", JSON.stringify(p)));
    }
    extractSpeakerContext(n) {
      return {
        features: {
          interimResult: "enabled",
          progressiveDetection: "disabled"
        },
        profileIds: n.profileIds,
        scenario: n.scenario
      };
    }
    handlePhrasesResponse(n, c) {
      if (this.privDeferralMap.getId(c))
        if (n.status.statusCode.toLowerCase() !== "success") {
          const u = r.ResultReason.Canceled, l = new r.VoiceProfilePhraseResult(u, n.status.statusCode, n.passPhraseType, []);
          this.privDeferralMap.complete(c, l);
        } else if (n.phrases && n.phrases.length > 0) {
          const u = r.ResultReason.EnrollingVoiceProfile, l = new r.VoiceProfilePhraseResult(u, n.status.statusCode, n.passPhraseType, n.phrases);
          this.privDeferralMap.complete(c, l);
        } else
          throw new Error("Voice Profile get activation phrases failed, no phrases received");
      else
        throw new Error(`Voice Profile get activation phrases request for requestID ${c} not found`);
    }
    handleCreateResponse(n, c) {
      if (n.profiles && n.profiles.length > 0)
        if (this.privDeferralMap.getId(c)) {
          const u = n.profiles.map((l) => l.profileId);
          this.privDeferralMap.complete(c, u);
        } else
          throw new Error(`Voice Profile create request for requestID ${c} not found`);
      else
        throw new Error("Voice Profile create failed, no profile id received");
    }
    handleResultResponse(n, c) {
      if (this.privDeferralMap.getId(c)) {
        const u = n.operation.toLowerCase() === "delete" ? r.ResultReason.DeletedVoiceProfile : r.ResultReason.ResetVoiceProfile, l = n.status.statusCode.toLowerCase() === "success" ? u : r.ResultReason.Canceled, p = new r.VoiceProfileResult(l, `statusCode: ${n.status.statusCode}, errorDetails: ${n.status.reason}`);
        this.privDeferralMap.complete(c, p);
      } else
        throw new Error(`Voice Profile create request for requestID ${c} not found`);
    }
    handleFetchResponse(n, c) {
      if (this.privDeferralMap.getId(c) && n.profiles[0]) {
        if (this.privExpectedProfileId && n.profiles.length === 1 && n.profiles[0].profileId === this.privExpectedProfileId) {
          this.privExpectedProfileId = void 0;
          const u = n.profiles[0], l = new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(u.enrollmentStatus), JSON.stringify(u), n.status.reason);
          this.privDeferralMap.complete(c, l);
        } else if (n.profiles.length > 0) {
          const u = n.profiles, l = [];
          for (const p of u)
            l.push(new r.VoiceProfileEnrollmentResult(this.enrollmentReasonFrom(p.enrollmentStatus), JSON.stringify(p), n.status.reason));
          this.privDeferralMap.complete(c, l);
        }
      } else
        throw new Error(`Voice Profile fetch request for requestID ${c} not found`);
    }
    enrollmentReasonFrom(n) {
      switch (n.toLowerCase()) {
        case "enrolled":
          return r.ResultReason.EnrolledVoiceProfile;
        case "invalidlocale":
        case "invalidphrase":
        case "invalidaudioformat":
        case "invalidscenario":
        case "invalidprofilecount":
        case "invalidoperation":
        case "audiotooshort":
        case "audiotoolong":
        case "toomanyenrollments":
        case "storageconflict":
        case "profilenotfound":
        case "incompatibleprofiles":
        case "incompleteenrollment":
          return r.ResultReason.Canceled;
        default:
          return r.ResultReason.EnrollingVoiceProfile;
      }
    }
    scenarioFrom(n) {
      return n === r.VoiceProfileType.TextIndependentIdentification ? "TextIndependentIdentification" : n === r.VoiceProfileType.TextIndependentVerification ? "TextIndependentVerification" : "TextDependentVerification";
    }
  };
  return ss.VoiceServiceRecognizer = a, ss;
}
var ka = {}, Lh;
function Cb() {
  return Lh || (Lh = 1, function(e) {
    Object.defineProperty(e, "__esModule", { value: !0 }), e.type = e.connectivity = e.Device = e.OS = e.System = e.Context = e.SpeechServiceConfig = void 0;
    class t {
      constructor(n) {
        this.context = n;
      }
      serialize() {
        return JSON.stringify(this, (n, c) => {
          if (c && typeof c == "object" && !Array.isArray(c)) {
            const u = {};
            for (const l in c)
              Object.hasOwnProperty.call(c, l) && (u[l && l.charAt(0).toLowerCase() + l.substring(1)] = c[l]);
            return u;
          }
          return c;
        });
      }
      get Context() {
        return this.context;
      }
      get Recognition() {
        return this.recognition;
      }
      set Recognition(n) {
        this.recognition = n.toLowerCase();
      }
    }
    e.SpeechServiceConfig = t;
    class r {
      constructor(n) {
        this.system = new o(), this.os = n;
      }
    }
    e.Context = r;
    class o {
      constructor() {
        const n = "1.44.1";
        this.name = "SpeechSDK", this.version = n, this.build = "JavaScript", this.lang = "JavaScript";
      }
    }
    e.System = o;
    class i {
      constructor(n, c, u) {
        this.platform = n, this.name = c, this.version = u;
      }
    }
    e.OS = i;
    class a {
      constructor(n, c, u) {
        this.manufacturer = n, this.model = c, this.version = u;
      }
    }
    e.Device = a, function(s) {
      s.Bluetooth = "Bluetooth", s.Wired = "Wired", s.WiFi = "WiFi", s.Cellular = "Cellular", s.InBuilt = "InBuilt", s.Unknown = "Unknown";
    }(e.connectivity || (e.connectivity = {})), function(s) {
      s.Phone = "Phone", s.Speaker = "Speaker", s.Car = "Car", s.Headset = "Headset", s.Thermostat = "Thermostat", s.Microphones = "Microphones", s.Deskphone = "Deskphone", s.RemoteControl = "RemoteControl", s.Unknown = "Unknown", s.File = "File", s.Stream = "Stream";
    }(e.type || (e.type = {}));
  }(ka)), ka;
}
var jh;
function _() {
  return jh || (jh = 1, function(e) {
    var t = at && at.__createBinding || (Object.create ? function(a, s, n, c) {
      c === void 0 && (c = n), Object.defineProperty(a, c, { enumerable: !0, get: function() {
        return s[n];
      } });
    } : function(a, s, n, c) {
      c === void 0 && (c = n), a[c] = s[n];
    }), r = at && at.__exportStar || function(a, s) {
      for (var n in a) n !== "default" && !Object.prototype.hasOwnProperty.call(s, n) && t(s, a, n);
    };
    Object.defineProperty(e, "__esModule", { value: !0 }), e.AutoDetectSourceLanguagesOpenRangeOptionName = e.ForceDictationPropertyName = e.ServicePropertiesPropertyName = e.CancellationErrorCodePropertyName = e.OutputFormatPropertyName = e.SpeechSynthesisAdapter = e.AvatarSynthesisAdapter = void 0, r(/* @__PURE__ */ GC(), e), r(/* @__PURE__ */ QC(), e), r(/* @__PURE__ */ ac(), e), r(/* @__PURE__ */ YC(), e), r(/* @__PURE__ */ ZC(), e), r(/* @__PURE__ */ ew(), e), r(/* @__PURE__ */ tw(), e), r(/* @__PURE__ */ dc(), e), r(/* @__PURE__ */ pw(), e), r(/* @__PURE__ */ dw(), e), r(/* @__PURE__ */ hw(), e), r(/* @__PURE__ */ fw(), e), r(/* @__PURE__ */ vw(), e), r(/* @__PURE__ */ gw(), e), r(/* @__PURE__ */ mw(), e), r(/* @__PURE__ */ yw(), e), r(/* @__PURE__ */ Sw(), e), r(/* @__PURE__ */ jv(), e), r(/* @__PURE__ */ Cw(), e), r(/* @__PURE__ */ Rw(), e), r(/* @__PURE__ */ Pw(), e), r(/* @__PURE__ */ ww(), e), r(/* @__PURE__ */ bw(), e), r(/* @__PURE__ */ Ew(), e), r(/* @__PURE__ */ Iw(), e), r(/* @__PURE__ */ Aw(), e), r(/* @__PURE__ */ Tw(), e), r(/* @__PURE__ */ _w(), e), r(/* @__PURE__ */ Ow(), e), r(/* @__PURE__ */ Mw(), e), r(/* @__PURE__ */ Dw(), e), r(/* @__PURE__ */ Nw(), e), r(/* @__PURE__ */ xw(), e), r(/* @__PURE__ */ zw(), e), r(/* @__PURE__ */ Lw(), e), r(/* @__PURE__ */ jw(), e), r(/* @__PURE__ */ Fw(), e), r(/* @__PURE__ */ Uw(), e), r(/* @__PURE__ */ Vw(), e), r(/* @__PURE__ */ Gw(), e), r(/* @__PURE__ */ Qw(), e), r(/* @__PURE__ */ cb(), e), r(/* @__PURE__ */ Xv(), e), r(/* @__PURE__ */ lb(), e), r(/* @__PURE__ */ pb(), e);
    var o = /* @__PURE__ */ db();
    Object.defineProperty(e, "AvatarSynthesisAdapter", { enumerable: !0, get: function() {
      return o.AvatarSynthesisAdapter;
    } });
    var i = /* @__PURE__ */ hb();
    Object.defineProperty(e, "SpeechSynthesisAdapter", { enumerable: !0, get: function() {
      return i.SpeechSynthesisAdapter;
    } }), r(/* @__PURE__ */ fb(), e), r(/* @__PURE__ */ vb(), e), r(/* @__PURE__ */ gb(), e), r(/* @__PURE__ */ mb(), e), r(/* @__PURE__ */ yb(), e), r(/* @__PURE__ */ Sb(), e), r(/* @__PURE__ */ Cb(), e), e.OutputFormatPropertyName = "OutputFormat", e.CancellationErrorCodePropertyName = "CancellationErrorCode", e.ServicePropertiesPropertyName = "ServiceProperties", e.ForceDictationPropertyName = "ForceDictation", e.AutoDetectSourceLanguagesOpenRangeOptionName = "UND";
  }(at)), at;
}
var qh;
function Rb() {
  return qh || (qh = 1, function(e) {
    var t = ot && ot.__createBinding || (Object.create ? function(i, a, s, n) {
      n === void 0 && (n = s), Object.defineProperty(i, n, { enumerable: !0, get: function() {
        return a[s];
      } });
    } : function(i, a, s, n) {
      n === void 0 && (n = s), i[n] = a[s];
    }), r = ot && ot.__exportStar || function(i, a) {
      for (var s in i) s !== "default" && !Object.prototype.hasOwnProperty.call(a, s) && t(a, i, s);
    };
    Object.defineProperty(e, "__esModule", { value: !0 });
    const o = /* @__PURE__ */ _();
    new o.AgentConfig(), r(/* @__PURE__ */ I(), e);
  }(ot)), ot;
}
var os = /* @__PURE__ */ Rb();
const Pb = gs.Provider, wb = gs.Root, bb = gs.Trigger, eg = Z.forwardRef(({ className: e, sideOffset: t = 4, ...r }, o) => /* @__PURE__ */ P(
  gs.Content,
  {
    ref: o,
    sideOffset: t,
    className: Ce(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      e
    ),
    ...r
  }
));
eg.displayName = gs.Content.displayName;
const Eb = {
  en: "en-US",
  es: "es-ES",
  pt: "pt-PT",
  fr: "fr-FR",
  de: "de-DE",
  zh: "zh-CN",
  ja: "ja-JP",
  hi: "hi-IN",
  ar: "ar-SA",
  ru: "ru-RU"
};
function tg({
  avatarName: e,
  disabled: t = !1,
  voiceMode: r,
  setSpokenText: o,
  setIsSpeaking: i,
  setInterruptReplica: a,
  region: s,
  speechKey: n
}) {
  const [c, u] = O(!1), [l, p] = O(!1), [h, d] = O(null), [f, g] = O("en");
  $(() => {
    typeof window < "u" && g(localStorage.getItem("lang") || "en");
  }, []);
  const m = c ? `You're now talking to ${e}` : `Click here to talk to ${e}`;
  $(() => (c ? v() : y(), () => {
    y();
  }), [c]);
  const v = async () => {
    try {
      const C = os.SpeechConfig.fromSubscription(
        n,
        s
      );
      C.speechRecognitionLanguage = Eb[f || "en"];
      const w = os.AudioConfig.fromDefaultMicrophoneInput(), b = new os.SpeechRecognizer(C, w);
      b.recognizing = (A, E) => {
        console.log(`RECOGNIZING: Text=${E.result.text}`);
      }, b.recognized = (A, E) => {
        E.result.reason === os.ResultReason.RecognizedSpeech && (console.log(`RECOGNIZED: Text=${E.result.text}`), E.result.text && (o(E.result.text), u(!1), i(!1), a(!1)));
      }, b.canceled = (A, E) => {
        console.log(`CANCELED: Reason=${E.reason}`), E.reason === os.CancellationReason.Error && console.error(`ERROR: Details=${E.errorDetails}`), u(!1), i(!1);
      }, b.sessionStopped = () => {
        u(!1), i(!1);
      }, await b.startContinuousRecognitionAsync(), d(b), i(!0), a(!0);
    } catch (C) {
      console.error("Error starting continuous recognition:", C), u(!1), i(!1);
    }
  }, y = async () => {
    if (h)
      try {
        await h.stopContinuousRecognitionAsync(), h.close(), d(null);
      } catch (C) {
        console.error("Error stopping recognition:", C);
      }
  }, S = () => {
    t || l || u(!c);
  };
  return r ? /* @__PURE__ */ P(Pb, { children: /* @__PURE__ */ N(wb, { children: [
    /* @__PURE__ */ P(bb, { asChild: !0, children: /* @__PURE__ */ P(
      $t,
      {
        variant: "outline",
        size: "icon",
        onClick: S,
        disabled: t || l || !1,
        className: "rounded-full bg-primary hover:bg-secondary h-9 w-9",
        children: l ? /* @__PURE__ */ P(Na, { className: "w-6 h-6 text-white animate-spin" }) : c ? /* @__PURE__ */ P(Og, { className: "w-6 h-6 text-white" }) : /* @__PURE__ */ P(Mg, { className: "w-6 h-6 text-white" })
      }
    ) }),
    /* @__PURE__ */ P(eg, { children: /* @__PURE__ */ P("p", { children: m }) })
  ] }) }) : null;
}
const Fh = async (e, t = "", r = "", o = "chat", i = "", a = 0, s = 1, n = "en", c) => {
  for (let u = 0; u < s; u++) {
    const l = new Headers();
    l.append("Accept", "application/json");
    const p = e + "Language: " + n, h = "52533633434137384342", d = new FormData();
    d.append("Input", p), d.append("UserId", t || h), d.append("BusinessId", r), d.append("Intent", o), d.append("SessionId", i), d.append("Platform", "EF0306CD"), c && c.size > 0 ? (d.append("Files", c), console.log("File appended to FormData")) : console.log("No file to append");
    const f = new AbortController(), g = setTimeout(() => f.abort(), 9e4), m = {
      method: "POST",
      headers: l,
      body: d,
      signal: f.signal
      // Add the abort signal to the request
    };
    try {
      const y = await fetch(
        "https://developmentapis.azure-api.net/sandbox/v1/api/AI/assistant",
        m
      );
      if (clearTimeout(g), !y.ok) {
        const C = await y.json();
        throw new Error(
          C?.Message || `HTTP error! Status: ${y.status}`
        );
      }
      const S = await y.json();
      if (S.Success && (S.Data?.Message === null || S.Data?.Message.toUpperCase() === "INVALID JSON" || S.Data?.Message === "local variable 'result' referenced before assignment" || S.Data?.Message === "Object reference not set to an instance of an object." || S.Data?.Message?.toLowerCase().includes("exception thrown"))) {
        console.warn(
          `Attempt ${u + 1}: Success but received null data. Retrying...`
        ), a > 0 && await new Promise((C) => setTimeout(C, a));
        continue;
      }
      return S;
    } catch (v) {
      if (clearTimeout(g), v instanceof Error && v.name === "AbortError")
        return console.error("Request timed out after 90 seconds"), { Success: !1, Message: "ERROR: API timed out", Data: null };
      console.error("Error in chat API:", v);
    }
  }
  return {
    Success: !1,
    Message: "API call failed after all retries",
    Data: null
  };
}, Ib = () => "https://developmentapis.azure-api.net/sandbox/v1/api", rg = (e) => {
  const t = Ib().replace(/\/$/, "");
  let r = e.startsWith("/") ? e : `/${e}`;
  return t.endsWith("/api") && r.startsWith("/api/") && (r = r.replace(/^\/api/, "")), `${t}${r}`;
}, Ab = ({
  onStart: e,
  loading: t,
  buttonText: r = "Start Conversation",
  videoRef: o,
  platform: i,
  replicaId: a,
  containerClassName: s = "",
  imageHeight: n = "auto",
  buttonSize: c = "md",
  learningPrompts: u,
  onPromptClick: l,
  userCredits: p,
  avatars: h,
  personaName: d,
  config: f
}) => {
  const [g, m] = O("en");
  $(() => {
    typeof window < "u" && m(localStorage.getItem("lang") || "en");
  }, []);
  const [v, y] = O({ loading: "Loading...", avatarNotFound: "Avatar not found" }), S = h.find((w) => w.ExternalId === a), C = {
    sm: "text-sm px-4 py-2",
    md: "text-base px-6 py-3",
    lg: "text-lg px-8 py-4"
  };
  return $(() => {
    (async () => {
      if (g !== "en") {
        const [b, A] = await Ks(["Loading...", "Avatar not found"], g, "en", f?.azureTranslatorKey || "", f?.azureTranslatorEndpoint || "", f?.azureTranslatorRegion || "");
        y({ loading: b, avatarNotFound: A });
      } else
        y({ loading: "Loading...", avatarNotFound: "Avatar not found" });
    })();
  }, [g]), /* @__PURE__ */ N("div", { className: `flex flex-col items-center justify-center ${s}`, children: [
    /* @__PURE__ */ P("div", { className: `w-full ${n} max-h-[300px] mb-6 relative`, children: S ? /* @__PURE__ */ N(Ns, { children: [
      /* @__PURE__ */ P(
        "img",
        {
          ref: o,
          src: S.ImageUrl,
          alt: S.Name,
          className: "w-full h-full object-cover rounded-lg"
        }
      ),
      /* @__PURE__ */ N("div", { className: "absolute top-3 right-3 flex items-center bg-black/70 px-2 py-1 rounded-full text-white text-xs font-medium shadow-md", children: [
        /* @__PURE__ */ N("div", { className: "relative flex h-3 w-3 mr-1.5", children: [
          /* @__PURE__ */ P("span", { className: "animate-ping absolute inline-flex h-full w-full rounded-full bg-green-500 opacity-75" }),
          /* @__PURE__ */ P("span", { className: "relative inline-flex rounded-full h-3 w-3 bg-green-600" })
        ] }),
        /* @__PURE__ */ P("span", { children: "LIVE" })
      ] }),
      /* @__PURE__ */ N("div", { className: "absolute bottom-3 left-3 right-3 bg-gradient-to-t from-black/70 to-transparent p-3 rounded-b-lg", children: [
        /* @__PURE__ */ P("h3", { className: "text-white font-semibold text-sm", children: S.Name }),
        /* @__PURE__ */ P("p", { className: "text-white/80 text-xs", children: d })
      ] })
    ] }) : /* @__PURE__ */ P("div", { className: "w-full h-full bg-light rounded-lg flex items-center justify-center", children: /* @__PURE__ */ P("p", { className: "text-secondary", children: v.avatarNotFound }) }) }),
    /* @__PURE__ */ P(
      "button",
      {
        onClick: e,
        disabled: t || p !== void 0 && p <= 0,
        className: `bg-primary text-white rounded-full font-semibold hover:bg-secondary transition-colors disabled:opacity-50 disabled:cursor-not-allowed ${C[c]}`,
        children: t ? v.loading : r
      }
    ),
    u && u.length > 0 && /* @__PURE__ */ N("div", { className: "mt-6 w-full", children: [
      /* @__PURE__ */ P("h3", { className: "text-lg font-semibold mb-3", children: "Try asking about:" }),
      /* @__PURE__ */ P("div", { className: "space-y-2", children: u.map((w, b) => /* @__PURE__ */ P(
        "button",
        {
          onClick: () => l?.(w),
          className: "w-full text-left p-3 bg-gray-50 hover:bg-gray-100 rounded-lg transition-colors",
          children: w
        },
        b
      )) })
    ] })
  ] });
}, ng = ({ id: e, style: t = {} }) => {
  const r = hf(e), o = r?.isOff, [i, a] = O(!1), s = Ve(null);
  return $(() => {
    const n = s.current;
    if (!n) return;
    const c = () => a(!0);
    return n.addEventListener("canplay", c), () => {
      n.removeEventListener("canplay", c);
    };
  }, [r]), /* @__PURE__ */ N(
    "div",
    {
      className: `w-full rounded-lg overflow-hidden bg-slate-100 relative transition-all duration-300 mx-auto\r
                    h-[200px] sm:h-[250px] md:h-[350px] lg:h-[450px] xl:h-[500px]`,
      style: t,
      children: [
        e && /* @__PURE__ */ P(
          Lg,
          {
            automirror: !0,
            sessionId: e,
            type: "video",
            ref: s,
            style: {
              width: "100%",
              height: "100%",
              objectFit: "cover",
              display: o || !i ? "none" : "block"
            }
          }
        ),
        !i && !o && /* @__PURE__ */ P("div", { className: "absolute top-0 left-0 w-full h-full flex items-center justify-center bg-slate-100 z-10", children: /* @__PURE__ */ N(
          "svg",
          {
            className: "animate-spin h-8 w-8 text-blue-500",
            xmlns: "http://www.w3.org/2000/svg",
            fill: "none",
            viewBox: "0 0 24 24",
            children: [
              /* @__PURE__ */ P(
                "circle",
                {
                  className: "opacity-25",
                  cx: "12",
                  cy: "12",
                  r: "10",
                  stroke: "currentColor",
                  strokeWidth: "4"
                }
              ),
              /* @__PURE__ */ P(
                "path",
                {
                  className: "opacity-75",
                  fill: "currentColor",
                  d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"
                }
              )
            ]
          }
        ) }),
        o && /* @__PURE__ */ P("div", { className: "absolute top-0 left-0 w-full h-full flex items-center justify-center bg-slate-100 z-5", children: /* @__PURE__ */ P(
          "svg",
          {
            className: "h-1/2 w-auto",
            width: "24px",
            height: "24px",
            viewBox: "0 0 24 24",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg",
            children: /* @__PURE__ */ N("g", { stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: [
              /* @__PURE__ */ P(
                "path",
                {
                  d: "M18.571,4 C19.142,4 19.557,4.23 19.815,4.689 C20.073,5.148 20.073,5.622 19.815,6.111 L16,12 L19.815,17.889 C20.073,18.377 20.073,18.852 19.815,19.311 C19.557,19.77 19.142,20 18.571,20 L5.429,20 C4.857,20 4.443,19.77 4.185,19.311 C3.927,18.852 3.927,18.377 4.185,17.889 L8,12 L4.185,6.111 C3.927,5.622 3.927,5.148 4.185,4.689 C4.443,4.23 4.857,4 5.429,4 L18.571,4 Z",
                  fill: "#555555"
                }
              ),
              /* @__PURE__ */ P(
                "line",
                {
                  x1: "4",
                  y1: "4",
                  x2: "20",
                  y2: "20",
                  stroke: "#E92A09",
                  strokeWidth: "2.5",
                  strokeLinecap: "round"
                }
              )
            ] })
          }
        ) })
      ]
    }
  );
}, Tb = ({
  handleJoin: e,
  handleEnd: t,
  platform: r,
  setScreen: o,
  containerClassName: i = "",
  videoDimensions: a = { width: "100%", height: "auto" },
  buttonsSize: s = "md"
}) => {
  const n = ff(), c = Us();
  $(() => {
    (async () => {
      if (c) {
        const p = c?.meetingState();
        if (p === "new" || p === "loading")
          try {
            c.startCamera({ startVideoOff: !0, startAudioOff: !0 }), o("call");
          } catch (h) {
            console.warn("Failed to start camera:", h);
          }
        else
          console.log("Call already started, skipping startCamera()");
      }
    })();
  }, [c, n]);
  const u = {
    sm: "px-3 py-1.5 text-xs",
    md: "px-4 py-2 text-sm",
    lg: "px-6 py-3 text-base"
  };
  return /* @__PURE__ */ N(
    zg.div,
    {
      className: `flex flex-col items-center ${i}`,
      initial: { opacity: 0 },
      animate: { opacity: 1 },
      transition: { duration: 0.3 },
      children: [
        /* @__PURE__ */ N("div", { className: "mb-4 flex flex-col items-center justify-center gap-4 text-center w-full max-w-2xl mx-auto mt-4 px-2", children: [
          /* @__PURE__ */ P("h2", { className: "text-xl font-bold text-secondary mb-1", children: "Check your camera and microphone" }),
          /* @__PURE__ */ P("p", { className: "text-sm text-secondary", children: "Make sure your devices are working properly before joining" })
        ] }),
        /* @__PURE__ */ P("div", { className: "w-full max-w-lg mb-6 rounded-lg border border-gray-300 overflow-hidden bg-gray-100", children: /* @__PURE__ */ P("div", { className: "p-8 flex items-center justify-center bg-gradient-to-b from-gray-800 to-primary/60 text-white", children: /* @__PURE__ */ N("div", { className: "text-center", children: [
          /* @__PURE__ */ P("div", { className: "mx-auto h-24 w-24 rounded-full bg-black/80 flex items-center justify-center mb-4", children: /* @__PURE__ */ N(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "32",
              height: "32",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              strokeWidth: "2",
              strokeLinecap: "round",
              strokeLinejoin: "round",
              children: [
                /* @__PURE__ */ P("path", { d: "M23 7l-7 5 7 5V7z" }),
                /* @__PURE__ */ P("rect", { x: "1", y: "5", width: "15", height: "14", rx: "2", ry: "2" })
              ]
            }
          ) }),
          /* @__PURE__ */ P(
            "div",
            {
              className: "relative rounded-xl border-4 border-primary overflow-hidden shadow-lg",
              style: {
                width: a.width || "100%",
                height: a.height || "auto"
              },
              children: /* @__PURE__ */ P(ng, { id: n })
            }
          )
        ] }) }) }),
        /* @__PURE__ */ N("div", { className: `flex flex-wrap gap-4 mt-2 justify-center ${s === "sm" ? "scale-90" : s === "lg" ? "scale-110" : ""}`, children: [
          /* @__PURE__ */ N("div", { className: "flex items-center gap-2 px-3 py-2 bg-black/5 rounded-md", children: [
            /* @__PURE__ */ N(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "18",
                height: "18",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ P("path", { d: "M23 7l-7 5 7 5V7z" }),
                  /* @__PURE__ */ P("rect", { x: "1", y: "5", width: "15", height: "14", rx: "2", ry: "2" })
                ]
              }
            ),
            /* @__PURE__ */ P("span", { className: "text-sm", children: "Camera: Ready" })
          ] }),
          /* @__PURE__ */ N("div", { className: "flex items-center gap-2 px-3 py-2 bg-black/5 rounded-md", children: [
            /* @__PURE__ */ N(
              "svg",
              {
                xmlns: "http://www.w3.org/2000/svg",
                width: "18",
                height: "18",
                viewBox: "0 0 24 24",
                fill: "none",
                stroke: "currentColor",
                strokeWidth: "2",
                strokeLinecap: "round",
                strokeLinejoin: "round",
                children: [
                  /* @__PURE__ */ P("path", { d: "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" }),
                  /* @__PURE__ */ P("path", { d: "M19 10v2a7 7 0 0 1-14 0v-2" }),
                  /* @__PURE__ */ P("line", { x1: "12", y1: "19", x2: "12", y2: "23" }),
                  /* @__PURE__ */ P("line", { x1: "8", y1: "23", x2: "16", y2: "23" })
                ]
              }
            ),
            /* @__PURE__ */ P("span", { className: "text-sm", children: "Microphone: Ready" })
          ] })
        ] }),
        /* @__PURE__ */ N("div", { className: "flex gap-4 mt-6", children: [
          /* @__PURE__ */ P(
            "button",
            {
              onClick: t,
              className: `border border-primary text-primary rounded-md hover:bg-secondary transition ${u[s]}`,
              children: "Cancel"
            }
          ),
          /* @__PURE__ */ P(
            "button",
            {
              onClick: e,
              className: `bg-primary hover:bg-secondary text-white rounded-md transition ${u[s]}`,
              children: "Join Conversation"
            }
          )
        ] })
      ]
    }
  );
}, _b = ({
  actionLabel: e,
  onAction: t,
  cancelLabel: r,
  onCancel: o,
  chatLabel: i,
  onChat: a,
  chatVisible: s = !1,
  platform: n,
  setInterruptReplica: c,
  setIsSpeaking: u,
  setSpokenText: l,
  region: p,
  speechKey: h
}) => {
  Us();
  const { currentCam: d, currentMic: f, refreshDevices: g } = jg(), m = ff(), v = hf(m), y = qg(m);
  v.isOff, y.isOff;
  const [S, C] = O(!1);
  return $(() => {
    (() => {
      document.querySelectorAll("[data-replit-metadata]").forEach((A) => {
        A.hasAttribute("data-replit-metadata") && A.removeAttribute("data-replit-metadata");
      });
    })();
  }, []), Fg(
    "camera-error",
    ec(() => {
      C(!0);
    }, [])
  ), /* @__PURE__ */ N("div", { className: "mt-2 p-2 rounded-lg max-w-md flex gap-4 justify-around items-center mx-auto bg-primary", children: [
    /* @__PURE__ */ P("div", { className: "flex items-center", children: /* @__PURE__ */ P(
      tg,
      {
        avatarName: n === "university" ? "Instructor" : n === "pr" ? "PR Strategist" : n === "business_advisor" ? "Medical Advisor" : n === "survey" ? "AI Surveyor" : n === "concierge" ? "Concierge" : "Business Expert",
        disabled: !1,
        voiceMode: !0,
        setSpokenText: l,
        setIsSpeaking: u,
        setInterruptReplica: c,
        region: p,
        speechKey: h
      }
    ) }),
    e && e === "End Conversation" && /* @__PURE__ */ P(
      "button",
      {
        onClick: t,
        disabled: S || (!d || !f) && n !== "home" && n !== "university" && n !== "concierge" && n !== "pr" && n !== "business_advisor" && n !== "survey",
        className: "flex items-center justify-center p-1 rounded-full border border-white text-white w-10 h-10",
        children: /* @__PURE__ */ P(Wg, { className: "w-6 h-6" })
      }
    )
  ] });
};
var Oa, Bh;
function kb() {
  return Bh || (Bh = 1, Oa = function(e, t) {
    t = t || {}, t.listUnicodeChar = t.hasOwnProperty("listUnicodeChar") ? t.listUnicodeChar : !1, t.stripListLeaders = t.hasOwnProperty("stripListLeaders") ? t.stripListLeaders : !0, t.gfm = t.hasOwnProperty("gfm") ? t.gfm : !0, t.useImgAltText = t.hasOwnProperty("useImgAltText") ? t.useImgAltText : !0, t.abbr = t.hasOwnProperty("abbr") ? t.abbr : !1, t.replaceLinksWithURL = t.hasOwnProperty("replaceLinksWithURL") ? t.replaceLinksWithURL : !1, t.htmlTagsToSkip = t.hasOwnProperty("htmlTagsToSkip") ? t.htmlTagsToSkip : [], t.throwError = t.hasOwnProperty("throwError") ? t.throwError : !1;
    var r = e || "";
    r = r.replace(/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/gm, "");
    try {
      t.stripListLeaders && (t.listUnicodeChar ? r = r.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, t.listUnicodeChar + " $1") : r = r.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1")), t.gfm && (r = r.replace(/\n={2,}/g, `
`).replace(/~{3}.*\n/g, "").replace(/~~/g, "").replace(/```(?:.*)\n([\s\S]*?)```/g, (i, a) => a.trim())), t.abbr && (r = r.replace(/\*\[.*\]:.*\n/, ""));
      let o = /<[^>]*>/g;
      if (t.htmlTagsToSkip && t.htmlTagsToSkip.length > 0) {
        const i = t.htmlTagsToSkip.join("|");
        o = new RegExp(
          `<(?!/?(${i})(?=>|s[^>]*>))[^>]*>`,
          "g"
        );
      }
      r = r.replace(o, "").replace(/^[=\-]{2,}\s*$/g, "").replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(/\!\[(.*?)\][\[\(].*?[\]\)]/g, t.useImgAltText ? "$1" : "").replace(/\[([\s\S]*?)\]\s*[\(\[].*?[\)\]]/g, t.replaceLinksWithURL ? "$2" : "$1").replace(/^(\n)?\s{0,3}>\s?/gm, "$1").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(/^(\n)?\s{0,}#{1,6}\s*( (.+))? +#+$|^(\n)?\s{0,}#{1,6}\s*( (.+))?$/gm, "$1$3$4$6").replace(/([\*]+)(\S)(.*?\S)??\1/g, "$2$3").replace(/(^|\W)([_]+)(\S)(.*?\S)??\2($|\W)/g, "$1$3$4$5").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/`(.+?)`/g, "$1").replace(/~(.*?)~/g, "$1");
    } catch (o) {
      if (t.throwError) throw o;
      return console.error("remove-markdown encountered error: %s", o), e;
    }
    return r;
  }), Oa;
}
var Ob = kb();
const Mb = /* @__PURE__ */ hC(Ob), Db = ({
  conversationId: e,
  platform: t,
  videoMode: r,
  endConv: o,
  onAction: i,
  videoHeight: a = "auto",
  aspectRatio: s = "16:9",
  setInterruptReplica: n,
  currentScript: c,
  interruptReplica: u,
  personaName: l,
  config: p
}) => {
  const h = Us(), d = Bg({ filter: "remote" }), [f, g] = O("full"), [m, v] = O([]), [y, S] = O(!1), [C, w] = O("en");
  $(() => {
    typeof window < "u" && w(localStorage.getItem("lang") || "en");
  }, []);
  const b = Ug({
    onAppMessage: ec((T) => {
      const D = T.data;
      v((q) => [...q, D]);
    }, [])
  }), [A, E] = O({ waiting: `${l} will be here shortly...`, endConversation: "Ending Conversation..." });
  $(() => {
    (async () => {
      if (C !== "en") {
        const [D, q] = await Ks([`${l} will be here shortly...`, "Ending Conversation..."], C, "en", p?.azureTranslatorKey || "", p?.azureTranslatorEndpoint || "", p?.azureTranslatorRegion || "");
        E({ waiting: D, endConversation: q });
      } else
        E({ waiting: `${l} will be here shortly...`, endConversation: "Ending Conversation..." });
    })();
  }, [C]);
  const M = (T) => T ? Mb(T).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "").replace(/[^\w\s.,!?'"-]/g, "").replace(/\s+/g, " ").trim() : "";
  $(() => {
    const T = () => S(!0);
    return h && h.on("joined-meeting", T), () => {
      h && h.off("joined-meeting", T);
    };
  }, [h]), $(() => {
    try {
      if (h && y && c) {
        n(!1);
        const T = M(c);
        R(T);
      }
    } catch (T) {
      console.error("Error sending echo interaction:", T);
    }
  }, [c, y]), $(() => {
    h && y && u && j();
  }, [u]), $(() => {
    r && g(r);
  }, [r]);
  const R = (T) => {
    const D = {
      message_type: "conversation",
      event_type: "conversation.echo",
      conversation_id: e,
      properties: {
        modality: "text",
        text: `${T}`
      }
    };
    console.log("Sending Echo Interaction:", D), b(D, "*");
  }, j = () => {
    const T = {
      message_type: "conversation",
      event_type: "conversation.interrupt",
      conversation_id: e
    };
    console.log("Sending Echo Interaction:", T), b(T, "*");
  };
  return /* @__PURE__ */ N(Ns, { children: [
    /* @__PURE__ */ P("div", { className: "flex flex-col items-center justify-center gap-4 text-center mx-auto px-2 h-full overflow-hidden", children: /* @__PURE__ */ P("div", { className: "relative w-full h-full rounded-xl border-4 border-neutral overflow-hidden shadow-lg", children: d.length > 0 ? /* @__PURE__ */ P(
      "div",
      {
        className: "relative w-full h-full",
        style: {
          backgroundColor: "#000",
          position: "relative",
          overflow: "hidden"
          // To contain absolutely positioned elements
        },
        children: /* @__PURE__ */ P(
          "div",
          {
            style: {
              position: "absolute",
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              display: "flex",
              // Add flex to center content if needed
              justifyContent: "center",
              // Center content horizontally
              alignItems: "center"
              // Center content vertically
            },
            children: /* @__PURE__ */ P(
              ng,
              {
                id: d[0],
                style: {
                  borderRadius: "0px",
                  objectFit: "contain",
                  width: "100%",
                  height: "100%",
                  backgroundColor: "#000"
                }
              }
            )
          }
        )
      }
    ) : /* @__PURE__ */ P(
      "div",
      {
        className: "relative flex justify-center items-center w-full h-full",
        style: {
          backgroundColor: "#000",
          width: "100%",
          height: "100%",
          position: "relative"
        },
        children: /* @__PURE__ */ P("div", { className: "absolute inset-0 flex justify-center items-center", children: /* @__PURE__ */ P("h2", { className: "text-white text-xl text-center px-4", children: o ? A.endConversation : A.waiting }) })
      }
    ) }) }),
    /* @__PURE__ */ P($g, {})
  ] });
}, Nb = ({
  conversation: e,
  handleEnd: t,
  platform: r,
  videoMode: o,
  endConv: i,
  chatVisible: a,
  toggleChat: s,
  containerClassName: n = "",
  videoHeight: c = "auto",
  controlsSize: u = "md",
  aspectRatio: l = "16:9",
  setInterruptReplica: p,
  currentScript: h,
  setCurrentScript: d,
  interruptReplica: f,
  setIsSpeaking: g,
  setSpokenText: m,
  region: v,
  speechKey: y,
  personaName: S,
  config: C
}) => {
  const w = Us();
  $(() => {
    (() => {
      document.querySelectorAll("[data-replit-metadata]").forEach((T) => {
        T.hasAttribute("data-replit-metadata") && T.removeAttribute("data-replit-metadata");
      });
    })();
  }, []), $(() => {
    if (e && w) {
      const { conversation_url: R } = e;
      w.join({
        url: R
      });
    }
  }, [w, e]);
  const b = async () => {
    await w?.leave(), t();
  }, A = {
    sm: "scale-75",
    md: "",
    lg: "scale-125"
  }, E = "bottom-4", M = () => c === "auto" ? "min-h-[360px]" : c;
  return /* @__PURE__ */ P("div", { className: `flex flex-col w-full h-full relative ${n}`, children: /* @__PURE__ */ N("div", { className: "flex-1 w-full h-full relative overflow-hidden", children: [
    /* @__PURE__ */ P(
      Db,
      {
        conversationId: e.conversation_id,
        platform: r,
        videoMode: o,
        endConv: i,
        onAction: b,
        videoHeight: M(),
        aspectRatio: l,
        setInterruptReplica: p,
        currentScript: h,
        interruptReplica: f,
        config: C,
        personaName: S
      }
    ),
    /* @__PURE__ */ P("div", { className: `absolute ${E} left-0 right-0 z-10 flex justify-center ${A[u]}`, children: /* @__PURE__ */ P(
      _b,
      {
        actionLabel: "End Conversation",
        onAction: b,
        platform: r,
        chatLabel: "Open Chat",
        onChat: s,
        chatVisible: a,
        setInterruptReplica: p,
        setIsSpeaking: g,
        setSpokenText: m,
        region: v,
        speechKey: y
      }
    ) })
  ] }) });
}, xb = async ({
  replicaId: e,
  personaId: t,
  conversationName: r,
  conversationalContext: o,
  customGreeting: i,
  language: a,
  apiKey: s
}) => {
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "x-api-key": s
    },
    body: JSON.stringify({
      replica_id: e,
      persona_id: t,
      conversation_name: r,
      conversational_context: o,
      custom_greeting: i,
      properties: {
        enable_recording: !1,
        participant_absent_timeout: 180,
        language: a
      }
    })
  };
  try {
    const c = await fetch(
      "https://tavusapi.com/v2/conversations",
      n
    );
    if (!c.ok) {
      const l = c.headers.get("content-type");
      let p;
      throw l && l.includes("application/json") ? p = await c.json() : p = { message: await c.text() }, new Error(
        p?.message || `HTTP error! Status: ${c.status}`
      );
    }
    return await c.json();
  } catch (c) {
    throw console.error("Error creating Tavus conversation:", c), c;
  }
}, Uh = async ({
  conversationId: e,
  apiKey: t
}) => {
  const r = {
    method: "POST",
    headers: {
      "x-api-key": t
    }
  };
  try {
    await fetch(
      `https://tavusapi.com/v2/conversations/${e}/end`,
      r
    );
  } catch {
  }
}, ig = async () => {
  const e = new Headers();
  e.append("Accept", "application/json");
  const t = {
    method: "GET",
    headers: e,
    redirect: "follow"
  };
  let r;
  try {
    const o = await fetch(rg("/api/Avatar/get/all"), t);
    if (!o.ok)
      throw new Error(`HTTP error! status: ${o.status}`);
    r = o.headers.get("content-length") === "0" ? { Success: !0, Data: [] } : await o.json();
  } catch (o) {
    console.error("Error fetching avatars:", o);
  }
  return r;
}, x = (e) => typeof e == "string", as = () => {
  let e, t;
  const r = new Promise((o, i) => {
    e = o, t = i;
  });
  return r.resolve = e, r.reject = t, r;
}, $h = (e) => e == null ? "" : "" + e, zb = (e, t, r) => {
  e.forEach((o) => {
    t[o] && (r[o] = t[o]);
  });
}, Lb = /###/g, Vh = (e) => e && e.indexOf("###") > -1 ? e.replace(Lb, ".") : e, Wh = (e) => !e || x(e), us = (e, t, r) => {
  const o = x(t) ? t.split(".") : t;
  let i = 0;
  for (; i < o.length - 1; ) {
    if (Wh(e)) return {};
    const a = Vh(o[i]);
    !e[a] && r && (e[a] = new r()), Object.prototype.hasOwnProperty.call(e, a) ? e = e[a] : e = {}, ++i;
  }
  return Wh(e) ? {} : {
    obj: e,
    k: Vh(o[i])
  };
}, Hh = (e, t, r) => {
  const {
    obj: o,
    k: i
  } = us(e, t, Object);
  if (o !== void 0 || t.length === 1) {
    o[i] = r;
    return;
  }
  let a = t[t.length - 1], s = t.slice(0, t.length - 1), n = us(e, s, Object);
  for (; n.obj === void 0 && s.length; )
    a = `${s[s.length - 1]}.${a}`, s = s.slice(0, s.length - 1), n = us(e, s, Object), n?.obj && typeof n.obj[`${n.k}.${a}`] < "u" && (n.obj = void 0);
  n.obj[`${n.k}.${a}`] = r;
}, jb = (e, t, r, o) => {
  const {
    obj: i,
    k: a
  } = us(e, t, Object);
  i[a] = i[a] || [], i[a].push(r);
}, Ls = (e, t) => {
  const {
    obj: r,
    k: o
  } = us(e, t);
  if (r && Object.prototype.hasOwnProperty.call(r, o))
    return r[o];
}, qb = (e, t, r) => {
  const o = Ls(e, r);
  return o !== void 0 ? o : Ls(t, r);
}, sg = (e, t, r) => {
  for (const o in t)
    o !== "__proto__" && o !== "constructor" && (o in e ? x(e[o]) || e[o] instanceof String || x(t[o]) || t[o] instanceof String ? r && (e[o] = t[o]) : sg(e[o], t[o], r) : e[o] = t[o]);
  return e;
}, qt = (e) => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var Fb = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const Bb = (e) => x(e) ? e.replace(/[&<>"'\/]/g, (t) => Fb[t]) : e;
class Ub {
  constructor(t) {
    this.capacity = t, this.regExpMap = /* @__PURE__ */ new Map(), this.regExpQueue = [];
  }
  getRegExp(t) {
    const r = this.regExpMap.get(t);
    if (r !== void 0)
      return r;
    const o = new RegExp(t);
    return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, o), this.regExpQueue.push(t), o;
  }
}
const $b = [" ", ",", "?", "!", ";"], Vb = new Ub(20), Wb = (e, t, r) => {
  t = t || "", r = r || "";
  const o = $b.filter((s) => t.indexOf(s) < 0 && r.indexOf(s) < 0);
  if (o.length === 0) return !0;
  const i = Vb.getRegExp(`(${o.map((s) => s === "?" ? "\\?" : s).join("|")})`);
  let a = !i.test(e);
  if (!a) {
    const s = e.indexOf(r);
    s > 0 && !i.test(e.substring(0, s)) && (a = !0);
  }
  return a;
}, Ga = (e, t, r = ".") => {
  if (!e) return;
  if (e[t])
    return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0;
  const o = t.split(r);
  let i = e;
  for (let a = 0; a < o.length; ) {
    if (!i || typeof i != "object")
      return;
    let s, n = "";
    for (let c = a; c < o.length; ++c)
      if (c !== a && (n += r), n += o[c], s = i[n], s !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof s) > -1 && c < o.length - 1)
          continue;
        a += c - a + 1;
        break;
      }
    i = s;
  }
  return i;
}, ds = (e) => e?.replace("_", "-"), Hb = {
  type: "logger",
  log(e) {
    this.output("log", e);
  },
  warn(e) {
    this.output("warn", e);
  },
  error(e) {
    this.output("error", e);
  },
  output(e, t) {
    console?.[e]?.apply?.(console, t);
  }
};
class js {
  constructor(t, r = {}) {
    this.init(t, r);
  }
  init(t, r = {}) {
    this.prefix = r.prefix || "i18next:", this.logger = t || Hb, this.options = r, this.debug = r.debug;
  }
  log(...t) {
    return this.forward(t, "log", "", !0);
  }
  warn(...t) {
    return this.forward(t, "warn", "", !0);
  }
  error(...t) {
    return this.forward(t, "error", "");
  }
  deprecate(...t) {
    return this.forward(t, "warn", "WARNING DEPRECATED: ", !0);
  }
  forward(t, r, o, i) {
    return i && !this.debug ? null : (x(t[0]) && (t[0] = `${o}${this.prefix} ${t[0]}`), this.logger[r](t));
  }
  create(t) {
    return new js(this.logger, {
      prefix: `${this.prefix}:${t}:`,
      ...this.options
    });
  }
  clone(t) {
    return t = t || this.options, t.prefix = t.prefix || this.prefix, new js(this.logger, t);
  }
}
var Me = new js();
class Qs {
  constructor() {
    this.observers = {};
  }
  on(t, r) {
    return t.split(" ").forEach((o) => {
      this.observers[o] || (this.observers[o] = /* @__PURE__ */ new Map());
      const i = this.observers[o].get(r) || 0;
      this.observers[o].set(r, i + 1);
    }), this;
  }
  off(t, r) {
    if (this.observers[t]) {
      if (!r) {
        delete this.observers[t];
        return;
      }
      this.observers[t].delete(r);
    }
  }
  emit(t, ...r) {
    this.observers[t] && Array.from(this.observers[t].entries()).forEach(([i, a]) => {
      for (let s = 0; s < a; s++)
        i(...r);
    }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([i, a]) => {
      for (let s = 0; s < a; s++)
        i.apply(i, [t, ...r]);
    });
  }
}
class Kh extends Qs {
  constructor(t, r = {
    ns: ["translation"],
    defaultNS: "translation"
  }) {
    super(), this.data = t || {}, this.options = r, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0);
  }
  addNamespaces(t) {
    this.options.ns.indexOf(t) < 0 && this.options.ns.push(t);
  }
  removeNamespaces(t) {
    const r = this.options.ns.indexOf(t);
    r > -1 && this.options.ns.splice(r, 1);
  }
  getResource(t, r, o, i = {}) {
    const a = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, s = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let n;
    t.indexOf(".") > -1 ? n = t.split(".") : (n = [t, r], o && (Array.isArray(o) ? n.push(...o) : x(o) && a ? n.push(...o.split(a)) : n.push(o)));
    const c = Ls(this.data, n);
    return !c && !r && !o && t.indexOf(".") > -1 && (t = n[0], r = n[1], o = n.slice(2).join(".")), c || !s || !x(o) ? c : Ga(this.data?.[t]?.[r], o, a);
  }
  addResource(t, r, o, i, a = {
    silent: !1
  }) {
    const s = a.keySeparator !== void 0 ? a.keySeparator : this.options.keySeparator;
    let n = [t, r];
    o && (n = n.concat(s ? o.split(s) : o)), t.indexOf(".") > -1 && (n = t.split("."), i = r, r = n[1]), this.addNamespaces(r), Hh(this.data, n, i), a.silent || this.emit("added", t, r, o, i);
  }
  addResources(t, r, o, i = {
    silent: !1
  }) {
    for (const a in o)
      (x(o[a]) || Array.isArray(o[a])) && this.addResource(t, r, a, o[a], {
        silent: !0
      });
    i.silent || this.emit("added", t, r, o);
  }
  addResourceBundle(t, r, o, i, a, s = {
    silent: !1,
    skipCopy: !1
  }) {
    let n = [t, r];
    t.indexOf(".") > -1 && (n = t.split("."), i = o, o = r, r = n[1]), this.addNamespaces(r);
    let c = Ls(this.data, n) || {};
    s.skipCopy || (o = JSON.parse(JSON.stringify(o))), i ? sg(c, o, a) : c = {
      ...c,
      ...o
    }, Hh(this.data, n, c), s.silent || this.emit("added", t, r, o);
  }
  removeResourceBundle(t, r) {
    this.hasResourceBundle(t, r) && delete this.data[t][r], this.removeNamespaces(r), this.emit("removed", t, r);
  }
  hasResourceBundle(t, r) {
    return this.getResource(t, r) !== void 0;
  }
  getResourceBundle(t, r) {
    return r || (r = this.options.defaultNS), this.getResource(t, r);
  }
  getDataByLanguage(t) {
    return this.data[t];
  }
  hasLanguageSomeTranslations(t) {
    const r = this.getDataByLanguage(t);
    return !!(r && Object.keys(r) || []).find((i) => r[i] && Object.keys(r[i]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var og = {
  processors: {},
  addPostProcessor(e) {
    this.processors[e.name] = e;
  },
  handle(e, t, r, o, i) {
    return e.forEach((a) => {
      t = this.processors[a]?.process(t, r, o, i) ?? t;
    }), t;
  }
};
const ag = Symbol("i18next/PATH_KEY");
function Kb() {
  const e = [], t = /* @__PURE__ */ Object.create(null);
  let r;
  return t.get = (o, i) => (r?.revoke?.(), i === ag ? e : (e.push(i), r = Proxy.revocable(o, t), r.proxy)), Proxy.revocable(/* @__PURE__ */ Object.create(null), t).proxy;
}
function Qa(e, t) {
  const {
    [ag]: r
  } = e(Kb());
  return r.join(t?.keySeparator ?? ".");
}
const Jh = {}, Gh = (e) => !x(e) && typeof e != "boolean" && typeof e != "number";
class qs extends Qs {
  constructor(t, r = {}) {
    super(), zb(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = r, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Me.create("translator");
  }
  changeLanguage(t) {
    t && (this.language = t);
  }
  exists(t, r = {
    interpolation: {}
  }) {
    const o = {
      ...r
    };
    return t == null ? !1 : this.resolve(t, o)?.res !== void 0;
  }
  extractFromKey(t, r) {
    let o = r.nsSeparator !== void 0 ? r.nsSeparator : this.options.nsSeparator;
    o === void 0 && (o = ":");
    const i = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator;
    let a = r.ns || this.options.defaultNS || [];
    const s = o && t.indexOf(o) > -1, n = !this.options.userDefinedKeySeparator && !r.keySeparator && !this.options.userDefinedNsSeparator && !r.nsSeparator && !Wb(t, o, i);
    if (s && !n) {
      const c = t.match(this.interpolator.nestingRegexp);
      if (c && c.length > 0)
        return {
          key: t,
          namespaces: x(a) ? [a] : a
        };
      const u = t.split(o);
      (o !== i || o === i && this.options.ns.indexOf(u[0]) > -1) && (a = u.shift()), t = u.join(i);
    }
    return {
      key: t,
      namespaces: x(a) ? [a] : a
    };
  }
  translate(t, r, o) {
    let i = typeof r == "object" ? {
      ...r
    } : r;
    if (typeof i != "object" && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), typeof i == "object" && (i = {
      ...i
    }), i || (i = {}), t == null) return "";
    typeof t == "function" && (t = Qa(t, {
      ...this.options,
      ...i
    })), Array.isArray(t) || (t = [String(t)]);
    const a = i.returnDetails !== void 0 ? i.returnDetails : this.options.returnDetails, s = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, {
      key: n,
      namespaces: c
    } = this.extractFromKey(t[t.length - 1], i), u = c[c.length - 1];
    let l = i.nsSeparator !== void 0 ? i.nsSeparator : this.options.nsSeparator;
    l === void 0 && (l = ":");
    const p = i.lng || this.language, h = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (p?.toLowerCase() === "cimode")
      return h ? a ? {
        res: `${u}${l}${n}`,
        usedKey: n,
        exactUsedKey: n,
        usedLng: p,
        usedNS: u,
        usedParams: this.getUsedParamsDetails(i)
      } : `${u}${l}${n}` : a ? {
        res: n,
        usedKey: n,
        exactUsedKey: n,
        usedLng: p,
        usedNS: u,
        usedParams: this.getUsedParamsDetails(i)
      } : n;
    const d = this.resolve(t, i);
    let f = d?.res;
    const g = d?.usedKey || n, m = d?.exactUsedKey || n, v = ["[object Number]", "[object Function]", "[object RegExp]"], y = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays, S = !this.i18nFormat || this.i18nFormat.handleAsObject, C = i.count !== void 0 && !x(i.count), w = qs.hasDefaultValue(i), b = C ? this.pluralResolver.getSuffix(p, i.count, i) : "", A = i.ordinal && C ? this.pluralResolver.getSuffix(p, i.count, {
      ordinal: !1
    }) : "", E = C && !i.ordinal && i.count === 0, M = E && i[`defaultValue${this.options.pluralSeparator}zero`] || i[`defaultValue${b}`] || i[`defaultValue${A}`] || i.defaultValue;
    let R = f;
    S && !f && w && (R = M);
    const j = Gh(R), T = Object.prototype.toString.apply(R);
    if (S && R && j && v.indexOf(T) < 0 && !(x(y) && Array.isArray(R))) {
      if (!i.returnObjects && !this.options.returnObjects) {
        this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        const D = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(g, R, {
          ...i,
          ns: c
        }) : `key '${n} (${this.language})' returned an object instead of string.`;
        return a ? (d.res = D, d.usedParams = this.getUsedParamsDetails(i), d) : D;
      }
      if (s) {
        const D = Array.isArray(R), q = D ? [] : {}, pe = D ? m : g;
        for (const W in R)
          if (Object.prototype.hasOwnProperty.call(R, W)) {
            const G = `${pe}${s}${W}`;
            w && !f ? q[W] = this.translate(G, {
              ...i,
              defaultValue: Gh(M) ? M[W] : void 0,
              joinArrays: !1,
              ns: c
            }) : q[W] = this.translate(G, {
              ...i,
              joinArrays: !1,
              ns: c
            }), q[W] === G && (q[W] = R[W]);
          }
        f = q;
      }
    } else if (S && x(y) && Array.isArray(f))
      f = f.join(y), f && (f = this.extendTranslation(f, t, i, o));
    else {
      let D = !1, q = !1;
      !this.isValidLookup(f) && w && (D = !0, f = M), this.isValidLookup(f) || (q = !0, f = n);
      const W = (i.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && q ? void 0 : f, G = w && M !== f && this.options.updateMissing;
      if (q || D || G) {
        if (this.logger.log(G ? "updateKey" : "missingKey", p, u, n, G ? M : f), s) {
          const V = this.resolve(n, {
            ...i,
            keySeparator: !1
          });
          V && V.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let re = [];
        const oe = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && oe && oe[0])
          for (let V = 0; V < oe.length; V++)
            re.push(oe[V]);
        else this.options.saveMissingTo === "all" ? re = this.languageUtils.toResolveHierarchy(i.lng || this.language) : re.push(i.lng || this.language);
        const me = (V, te, Pe) => {
          const ye = w && Pe !== f ? Pe : W;
          this.options.missingKeyHandler ? this.options.missingKeyHandler(V, u, te, ye, G, i) : this.backendConnector?.saveMissing && this.backendConnector.saveMissing(V, u, te, ye, G, i), this.emit("missingKey", V, u, te, f);
        };
        this.options.saveMissing && (this.options.saveMissingPlurals && C ? re.forEach((V) => {
          const te = this.pluralResolver.getSuffixes(V, i);
          E && i[`defaultValue${this.options.pluralSeparator}zero`] && te.indexOf(`${this.options.pluralSeparator}zero`) < 0 && te.push(`${this.options.pluralSeparator}zero`), te.forEach((Pe) => {
            me([V], n + Pe, i[`defaultValue${Pe}`] || M);
          });
        }) : me(re, n, M));
      }
      f = this.extendTranslation(f, t, i, d, o), q && f === n && this.options.appendNamespaceToMissingKey && (f = `${u}${l}${n}`), (q || D) && this.options.parseMissingKeyHandler && (f = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${u}${l}${n}` : n, D ? f : void 0, i));
    }
    return a ? (d.res = f, d.usedParams = this.getUsedParamsDetails(i), d) : f;
  }
  extendTranslation(t, r, o, i, a) {
    if (this.i18nFormat?.parse)
      t = this.i18nFormat.parse(t, {
        ...this.options.interpolation.defaultVariables,
        ...o
      }, o.lng || this.language || i.usedLng, i.usedNS, i.usedKey, {
        resolved: i
      });
    else if (!o.skipInterpolation) {
      o.interpolation && this.interpolator.init({
        ...o,
        interpolation: {
          ...this.options.interpolation,
          ...o.interpolation
        }
      });
      const c = x(t) && (o?.interpolation?.skipOnVariables !== void 0 ? o.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let u;
      if (c) {
        const p = t.match(this.interpolator.nestingRegexp);
        u = p && p.length;
      }
      let l = o.replace && !x(o.replace) ? o.replace : o;
      if (this.options.interpolation.defaultVariables && (l = {
        ...this.options.interpolation.defaultVariables,
        ...l
      }), t = this.interpolator.interpolate(t, l, o.lng || this.language || i.usedLng, o), c) {
        const p = t.match(this.interpolator.nestingRegexp), h = p && p.length;
        u < h && (o.nest = !1);
      }
      !o.lng && i && i.res && (o.lng = this.language || i.usedLng), o.nest !== !1 && (t = this.interpolator.nest(t, (...p) => a?.[0] === p[0] && !o.context ? (this.logger.warn(`It seems you are nesting recursively key: ${p[0]} in key: ${r[0]}`), null) : this.translate(...p, r), o)), o.interpolation && this.interpolator.reset();
    }
    const s = o.postProcess || this.options.postProcess, n = x(s) ? [s] : s;
    return t != null && n?.length && o.applyPostProcessor !== !1 && (t = og.handle(n, t, r, this.options && this.options.postProcessPassResolved ? {
      i18nResolved: {
        ...i,
        usedParams: this.getUsedParamsDetails(o)
      },
      ...o
    } : o, this)), t;
  }
  resolve(t, r = {}) {
    let o, i, a, s, n;
    return x(t) && (t = [t]), t.forEach((c) => {
      if (this.isValidLookup(o)) return;
      const u = this.extractFromKey(c, r), l = u.key;
      i = l;
      let p = u.namespaces;
      this.options.fallbackNS && (p = p.concat(this.options.fallbackNS));
      const h = r.count !== void 0 && !x(r.count), d = h && !r.ordinal && r.count === 0, f = r.context !== void 0 && (x(r.context) || typeof r.context == "number") && r.context !== "", g = r.lngs ? r.lngs : this.languageUtils.toResolveHierarchy(r.lng || this.language, r.fallbackLng);
      p.forEach((m) => {
        this.isValidLookup(o) || (n = m, !Jh[`${g[0]}-${m}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(n) && (Jh[`${g[0]}-${m}`] = !0, this.logger.warn(`key "${i}" for languages "${g.join(", ")}" won't get resolved as namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), g.forEach((v) => {
          if (this.isValidLookup(o)) return;
          s = v;
          const y = [l];
          if (this.i18nFormat?.addLookupKeys)
            this.i18nFormat.addLookupKeys(y, l, v, m, r);
          else {
            let C;
            h && (C = this.pluralResolver.getSuffix(v, r.count, r));
            const w = `${this.options.pluralSeparator}zero`, b = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (h && (r.ordinal && C.indexOf(b) === 0 && y.push(l + C.replace(b, this.options.pluralSeparator)), y.push(l + C), d && y.push(l + w)), f) {
              const A = `${l}${this.options.contextSeparator || "_"}${r.context}`;
              y.push(A), h && (r.ordinal && C.indexOf(b) === 0 && y.push(A + C.replace(b, this.options.pluralSeparator)), y.push(A + C), d && y.push(A + w));
            }
          }
          let S;
          for (; S = y.pop(); )
            this.isValidLookup(o) || (a = S, o = this.getResource(v, m, S, r));
        }));
      });
    }), {
      res: o,
      usedKey: i,
      exactUsedKey: a,
      usedLng: s,
      usedNS: n
    };
  }
  isValidLookup(t) {
    return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "");
  }
  getResource(t, r, o, i = {}) {
    return this.i18nFormat?.getResource ? this.i18nFormat.getResource(t, r, o, i) : this.resourceStore.getResource(t, r, o, i);
  }
  getUsedParamsDetails(t = {}) {
    const r = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], o = t.replace && !x(t.replace);
    let i = o ? t.replace : t;
    if (o && typeof t.count < "u" && (i.count = t.count), this.options.interpolation.defaultVariables && (i = {
      ...this.options.interpolation.defaultVariables,
      ...i
    }), !o) {
      i = {
        ...i
      };
      for (const a of r)
        delete i[a];
    }
    return i;
  }
  static hasDefaultValue(t) {
    const r = "defaultValue";
    for (const o in t)
      if (Object.prototype.hasOwnProperty.call(t, o) && r === o.substring(0, r.length) && t[o] !== void 0)
        return !0;
    return !1;
  }
}
class Qh {
  constructor(t) {
    this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Me.create("languageUtils");
  }
  getScriptPartFromCode(t) {
    if (t = ds(t), !t || t.indexOf("-") < 0) return null;
    const r = t.split("-");
    return r.length === 2 || (r.pop(), r[r.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(r.join("-"));
  }
  getLanguagePartFromCode(t) {
    if (t = ds(t), !t || t.indexOf("-") < 0) return t;
    const r = t.split("-");
    return this.formatLanguageCode(r[0]);
  }
  formatLanguageCode(t) {
    if (x(t) && t.indexOf("-") > -1) {
      let r;
      try {
        r = Intl.getCanonicalLocales(t)[0];
      } catch {
      }
      return r && this.options.lowerCaseLng && (r = r.toLowerCase()), r || (this.options.lowerCaseLng ? t.toLowerCase() : t);
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t;
  }
  isSupportedCode(t) {
    return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1;
  }
  getBestMatchFromCodes(t) {
    if (!t) return null;
    let r;
    return t.forEach((o) => {
      if (r) return;
      const i = this.formatLanguageCode(o);
      (!this.options.supportedLngs || this.isSupportedCode(i)) && (r = i);
    }), !r && this.options.supportedLngs && t.forEach((o) => {
      if (r) return;
      const i = this.getScriptPartFromCode(o);
      if (this.isSupportedCode(i)) return r = i;
      const a = this.getLanguagePartFromCode(o);
      if (this.isSupportedCode(a)) return r = a;
      r = this.options.supportedLngs.find((s) => {
        if (s === a) return s;
        if (!(s.indexOf("-") < 0 && a.indexOf("-") < 0) && (s.indexOf("-") > 0 && a.indexOf("-") < 0 && s.substring(0, s.indexOf("-")) === a || s.indexOf(a) === 0 && a.length > 1))
          return s;
      });
    }), r || (r = this.getFallbackCodes(this.options.fallbackLng)[0]), r;
  }
  getFallbackCodes(t, r) {
    if (!t) return [];
    if (typeof t == "function" && (t = t(r)), x(t) && (t = [t]), Array.isArray(t)) return t;
    if (!r) return t.default || [];
    let o = t[r];
    return o || (o = t[this.getScriptPartFromCode(r)]), o || (o = t[this.formatLanguageCode(r)]), o || (o = t[this.getLanguagePartFromCode(r)]), o || (o = t.default), o || [];
  }
  toResolveHierarchy(t, r) {
    const o = this.getFallbackCodes((r === !1 ? [] : r) || this.options.fallbackLng || [], t), i = [], a = (s) => {
      s && (this.isSupportedCode(s) ? i.push(s) : this.logger.warn(`rejecting language code not found in supportedLngs: ${s}`));
    };
    return x(t) && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && a(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && a(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && a(this.getLanguagePartFromCode(t))) : x(t) && a(this.formatLanguageCode(t)), o.forEach((s) => {
      i.indexOf(s) < 0 && a(this.formatLanguageCode(s));
    }), i;
  }
}
const Yh = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
}, Zh = {
  select: (e) => e === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class Jb {
  constructor(t, r = {}) {
    this.languageUtils = t, this.options = r, this.logger = Me.create("pluralResolver"), this.pluralRulesCache = {};
  }
  addRule(t, r) {
    this.rules[t] = r;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(t, r = {}) {
    const o = ds(t === "dev" ? "en" : t), i = r.ordinal ? "ordinal" : "cardinal", a = JSON.stringify({
      cleanedCode: o,
      type: i
    });
    if (a in this.pluralRulesCache)
      return this.pluralRulesCache[a];
    let s;
    try {
      s = new Intl.PluralRules(o, {
        type: i
      });
    } catch {
      if (!Intl)
        return this.logger.error("No Intl support, please use an Intl polyfill!"), Zh;
      if (!t.match(/-|_/)) return Zh;
      const c = this.languageUtils.getLanguagePartFromCode(t);
      s = this.getRule(c, r);
    }
    return this.pluralRulesCache[a] = s, s;
  }
  needsPlural(t, r = {}) {
    let o = this.getRule(t, r);
    return o || (o = this.getRule("dev", r)), o?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(t, r, o = {}) {
    return this.getSuffixes(t, o).map((i) => `${r}${i}`);
  }
  getSuffixes(t, r = {}) {
    let o = this.getRule(t, r);
    return o || (o = this.getRule("dev", r)), o ? o.resolvedOptions().pluralCategories.sort((i, a) => Yh[i] - Yh[a]).map((i) => `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : [];
  }
  getSuffix(t, r, o = {}) {
    const i = this.getRule(t, o);
    return i ? `${this.options.prepend}${o.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(r)}` : (this.logger.warn(`no plural rule found for: ${t}`), this.getSuffix("dev", r, o));
  }
}
const Xh = (e, t, r, o = ".", i = !0) => {
  let a = qb(e, t, r);
  return !a && i && x(r) && (a = Ga(e, r, o), a === void 0 && (a = Ga(t, r, o))), a;
}, Ma = (e) => e.replace(/\$/g, "$$$$");
class Gb {
  constructor(t = {}) {
    this.logger = Me.create("interpolator"), this.options = t, this.format = t?.interpolation?.format || ((r) => r), this.init(t);
  }
  init(t = {}) {
    t.interpolation || (t.interpolation = {
      escapeValue: !0
    });
    const {
      escape: r,
      escapeValue: o,
      useRawValueToEscape: i,
      prefix: a,
      prefixEscaped: s,
      suffix: n,
      suffixEscaped: c,
      formatSeparator: u,
      unescapeSuffix: l,
      unescapePrefix: p,
      nestingPrefix: h,
      nestingPrefixEscaped: d,
      nestingSuffix: f,
      nestingSuffixEscaped: g,
      nestingOptionsSeparator: m,
      maxReplaces: v,
      alwaysFormat: y
    } = t.interpolation;
    this.escape = r !== void 0 ? r : Bb, this.escapeValue = o !== void 0 ? o : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = a ? qt(a) : s || "{{", this.suffix = n ? qt(n) : c || "}}", this.formatSeparator = u || ",", this.unescapePrefix = l ? "" : p || "-", this.unescapeSuffix = this.unescapePrefix ? "" : l || "", this.nestingPrefix = h ? qt(h) : d || qt("$t("), this.nestingSuffix = f ? qt(f) : g || qt(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = v || 1e3, this.alwaysFormat = y !== void 0 ? y : !1, this.resetRegExp();
  }
  reset() {
    this.options && this.init(this.options);
  }
  resetRegExp() {
    const t = (r, o) => r?.source === o ? (r.lastIndex = 0, r) : new RegExp(o, "g");
    this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`);
  }
  interpolate(t, r, o, i) {
    let a, s, n;
    const c = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, u = (d) => {
      if (d.indexOf(this.formatSeparator) < 0) {
        const v = Xh(r, c, d, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(v, void 0, o, {
          ...i,
          ...r,
          interpolationkey: d
        }) : v;
      }
      const f = d.split(this.formatSeparator), g = f.shift().trim(), m = f.join(this.formatSeparator).trim();
      return this.format(Xh(r, c, g, this.options.keySeparator, this.options.ignoreJSONStructure), m, o, {
        ...i,
        ...r,
        interpolationkey: g
      });
    };
    this.resetRegExp();
    const l = i?.missingInterpolationHandler || this.options.missingInterpolationHandler, p = i?.interpolation?.skipOnVariables !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    return [{
      regex: this.regexpUnescape,
      safeValue: (d) => Ma(d)
    }, {
      regex: this.regexp,
      safeValue: (d) => this.escapeValue ? Ma(this.escape(d)) : Ma(d)
    }].forEach((d) => {
      for (n = 0; a = d.regex.exec(t); ) {
        const f = a[1].trim();
        if (s = u(f), s === void 0)
          if (typeof l == "function") {
            const m = l(t, a, i);
            s = x(m) ? m : "";
          } else if (i && Object.prototype.hasOwnProperty.call(i, f))
            s = "";
          else if (p) {
            s = a[0];
            continue;
          } else
            this.logger.warn(`missed to pass in variable ${f} for interpolating ${t}`), s = "";
        else !x(s) && !this.useRawValueToEscape && (s = $h(s));
        const g = d.safeValue(s);
        if (t = t.replace(a[0], g), p ? (d.regex.lastIndex += s.length, d.regex.lastIndex -= a[0].length) : d.regex.lastIndex = 0, n++, n >= this.maxReplaces)
          break;
      }
    }), t;
  }
  nest(t, r, o = {}) {
    let i, a, s;
    const n = (c, u) => {
      const l = this.nestingOptionsSeparator;
      if (c.indexOf(l) < 0) return c;
      const p = c.split(new RegExp(`${l}[ ]*{`));
      let h = `{${p[1]}`;
      c = p[0], h = this.interpolate(h, s);
      const d = h.match(/'/g), f = h.match(/"/g);
      ((d?.length ?? 0) % 2 === 0 && !f || f.length % 2 !== 0) && (h = h.replace(/'/g, '"'));
      try {
        s = JSON.parse(h), u && (s = {
          ...u,
          ...s
        });
      } catch (g) {
        return this.logger.warn(`failed parsing options string in nesting for key ${c}`, g), `${c}${l}${h}`;
      }
      return s.defaultValue && s.defaultValue.indexOf(this.prefix) > -1 && delete s.defaultValue, c;
    };
    for (; i = this.nestingRegexp.exec(t); ) {
      let c = [];
      s = {
        ...o
      }, s = s.replace && !x(s.replace) ? s.replace : s, s.applyPostProcessor = !1, delete s.defaultValue;
      const u = /{.*}/.test(i[1]) ? i[1].lastIndexOf("}") + 1 : i[1].indexOf(this.formatSeparator);
      if (u !== -1 && (c = i[1].slice(u).split(this.formatSeparator).map((l) => l.trim()).filter(Boolean), i[1] = i[1].slice(0, u)), a = r(n.call(this, i[1].trim(), s), s), a && i[0] === t && !x(a)) return a;
      x(a) || (a = $h(a)), a || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`), a = ""), c.length && (a = c.reduce((l, p) => this.format(l, p, o.lng, {
        ...o,
        interpolationkey: i[1].trim()
      }), a.trim())), t = t.replace(i[0], a), this.regexp.lastIndex = 0;
    }
    return t;
  }
}
const Qb = (e) => {
  let t = e.toLowerCase().trim();
  const r = {};
  if (e.indexOf("(") > -1) {
    const o = e.split("(");
    t = o[0].toLowerCase().trim();
    const i = o[1].substring(0, o[1].length - 1);
    t === "currency" && i.indexOf(":") < 0 ? r.currency || (r.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? r.range || (r.range = i.trim()) : i.split(";").forEach((s) => {
      if (s) {
        const [n, ...c] = s.split(":"), u = c.join(":").trim().replace(/^'+|'+$/g, ""), l = n.trim();
        r[l] || (r[l] = u), u === "false" && (r[l] = !1), u === "true" && (r[l] = !0), isNaN(u) || (r[l] = parseInt(u, 10));
      }
    });
  }
  return {
    formatName: t,
    formatOptions: r
  };
}, ef = (e) => {
  const t = {};
  return (r, o, i) => {
    let a = i;
    i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (a = {
      ...a,
      [i.interpolationkey]: void 0
    });
    const s = o + JSON.stringify(a);
    let n = t[s];
    return n || (n = e(ds(o), i), t[s] = n), n(r);
  };
}, Yb = (e) => (t, r, o) => e(ds(r), o)(t);
class Zb {
  constructor(t = {}) {
    this.logger = Me.create("formatter"), this.options = t, this.init(t);
  }
  init(t, r = {
    interpolation: {}
  }) {
    this.formatSeparator = r.interpolation.formatSeparator || ",";
    const o = r.cacheInBuiltFormats ? ef : Yb;
    this.formats = {
      number: o((i, a) => {
        const s = new Intl.NumberFormat(i, {
          ...a
        });
        return (n) => s.format(n);
      }),
      currency: o((i, a) => {
        const s = new Intl.NumberFormat(i, {
          ...a,
          style: "currency"
        });
        return (n) => s.format(n);
      }),
      datetime: o((i, a) => {
        const s = new Intl.DateTimeFormat(i, {
          ...a
        });
        return (n) => s.format(n);
      }),
      relativetime: o((i, a) => {
        const s = new Intl.RelativeTimeFormat(i, {
          ...a
        });
        return (n) => s.format(n, a.range || "day");
      }),
      list: o((i, a) => {
        const s = new Intl.ListFormat(i, {
          ...a
        });
        return (n) => s.format(n);
      })
    };
  }
  add(t, r) {
    this.formats[t.toLowerCase().trim()] = r;
  }
  addCached(t, r) {
    this.formats[t.toLowerCase().trim()] = ef(r);
  }
  format(t, r, o, i = {}) {
    const a = r.split(this.formatSeparator);
    if (a.length > 1 && a[0].indexOf("(") > 1 && a[0].indexOf(")") < 0 && a.find((n) => n.indexOf(")") > -1)) {
      const n = a.findIndex((c) => c.indexOf(")") > -1);
      a[0] = [a[0], ...a.splice(1, n)].join(this.formatSeparator);
    }
    return a.reduce((n, c) => {
      const {
        formatName: u,
        formatOptions: l
      } = Qb(c);
      if (this.formats[u]) {
        let p = n;
        try {
          const h = i?.formatParams?.[i.interpolationkey] || {}, d = h.locale || h.lng || i.locale || i.lng || o;
          p = this.formats[u](n, d, {
            ...l,
            ...i,
            ...h
          });
        } catch (h) {
          this.logger.warn(h);
        }
        return p;
      } else
        this.logger.warn(`there was no format function for ${u}`);
      return n;
    }, t);
  }
}
const Xb = (e, t) => {
  e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--);
};
class eE extends Qs {
  constructor(t, r, o, i = {}) {
    super(), this.backend = t, this.store = r, this.services = o, this.languageUtils = o.languageUtils, this.options = i, this.logger = Me.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], this.backend?.init?.(o, i.backend, i);
  }
  queueLoad(t, r, o, i) {
    const a = {}, s = {}, n = {}, c = {};
    return t.forEach((u) => {
      let l = !0;
      r.forEach((p) => {
        const h = `${u}|${p}`;
        !o.reload && this.store.hasResourceBundle(u, p) ? this.state[h] = 2 : this.state[h] < 0 || (this.state[h] === 1 ? s[h] === void 0 && (s[h] = !0) : (this.state[h] = 1, l = !1, s[h] === void 0 && (s[h] = !0), a[h] === void 0 && (a[h] = !0), c[p] === void 0 && (c[p] = !0)));
      }), l || (n[u] = !0);
    }), (Object.keys(a).length || Object.keys(s).length) && this.queue.push({
      pending: s,
      pendingCount: Object.keys(s).length,
      loaded: {},
      errors: [],
      callback: i
    }), {
      toLoad: Object.keys(a),
      pending: Object.keys(s),
      toLoadLanguages: Object.keys(n),
      toLoadNamespaces: Object.keys(c)
    };
  }
  loaded(t, r, o) {
    const i = t.split("|"), a = i[0], s = i[1];
    r && this.emit("failedLoading", a, s, r), !r && o && this.store.addResourceBundle(a, s, o, void 0, void 0, {
      skipCopy: !0
    }), this.state[t] = r ? -1 : 2, r && o && (this.state[t] = 0);
    const n = {};
    this.queue.forEach((c) => {
      jb(c.loaded, [a], s), Xb(c, t), r && c.errors.push(r), c.pendingCount === 0 && !c.done && (Object.keys(c.loaded).forEach((u) => {
        n[u] || (n[u] = {});
        const l = c.loaded[u];
        l.length && l.forEach((p) => {
          n[u][p] === void 0 && (n[u][p] = !0);
        });
      }), c.done = !0, c.errors.length ? c.callback(c.errors) : c.callback());
    }), this.emit("loaded", n), this.queue = this.queue.filter((c) => !c.done);
  }
  read(t, r, o, i = 0, a = this.retryTimeout, s) {
    if (!t.length) return s(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng: t,
        ns: r,
        fcName: o,
        tried: i,
        wait: a,
        callback: s
      });
      return;
    }
    this.readingCalls++;
    const n = (u, l) => {
      if (this.readingCalls--, this.waitingReads.length > 0) {
        const p = this.waitingReads.shift();
        this.read(p.lng, p.ns, p.fcName, p.tried, p.wait, p.callback);
      }
      if (u && l && i < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, t, r, o, i + 1, a * 2, s);
        }, a);
        return;
      }
      s(u, l);
    }, c = this.backend[o].bind(this.backend);
    if (c.length === 2) {
      try {
        const u = c(t, r);
        u && typeof u.then == "function" ? u.then((l) => n(null, l)).catch(n) : n(null, u);
      } catch (u) {
        n(u);
      }
      return;
    }
    return c(t, r, n);
  }
  prepareLoading(t, r, o = {}, i) {
    if (!this.backend)
      return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i();
    x(t) && (t = this.languageUtils.toResolveHierarchy(t)), x(r) && (r = [r]);
    const a = this.queueLoad(t, r, o, i);
    if (!a.toLoad.length)
      return a.pending.length || i(), null;
    a.toLoad.forEach((s) => {
      this.loadOne(s);
    });
  }
  load(t, r, o) {
    this.prepareLoading(t, r, {}, o);
  }
  reload(t, r, o) {
    this.prepareLoading(t, r, {
      reload: !0
    }, o);
  }
  loadOne(t, r = "") {
    const o = t.split("|"), i = o[0], a = o[1];
    this.read(i, a, "read", void 0, void 0, (s, n) => {
      s && this.logger.warn(`${r}loading namespace ${a} for language ${i} failed`, s), !s && n && this.logger.log(`${r}loaded namespace ${a} for language ${i}`, n), this.loaded(t, s, n);
    });
  }
  saveMissing(t, r, o, i, a, s = {}, n = () => {
  }) {
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(r)) {
      this.logger.warn(`did not save key "${o}" as the namespace "${r}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (!(o == null || o === "")) {
      if (this.backend?.create) {
        const c = {
          ...s,
          isUpdate: a
        }, u = this.backend.create.bind(this.backend);
        if (u.length < 6)
          try {
            let l;
            u.length === 5 ? l = u(t, r, o, i, c) : l = u(t, r, o, i), l && typeof l.then == "function" ? l.then((p) => n(null, p)).catch(n) : n(null, l);
          } catch (l) {
            n(l);
          }
        else
          u(t, r, o, i, n, c);
      }
      !t || !t[0] || this.store.addResource(t[0], r, o, i);
    }
  }
}
const tf = () => ({
  debug: !1,
  initAsync: !0,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: !1,
  supportedLngs: !1,
  nonExplicitSupportedLngs: !1,
  load: "all",
  preload: !1,
  simplifyPluralSuffix: !0,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: !1,
  saveMissing: !1,
  updateMissing: !1,
  saveMissingTo: "fallback",
  saveMissingPlurals: !0,
  missingKeyHandler: !1,
  missingInterpolationHandler: !1,
  postProcess: !1,
  postProcessPassResolved: !1,
  returnNull: !1,
  returnEmptyString: !0,
  returnObjects: !1,
  joinArrays: !1,
  returnedObjectHandler: !1,
  parseMissingKeyHandler: !1,
  appendNamespaceToMissingKey: !1,
  appendNamespaceToCIMode: !1,
  overloadTranslationOptionHandler: (e) => {
    let t = {};
    if (typeof e[1] == "object" && (t = e[1]), x(e[1]) && (t.defaultValue = e[1]), x(e[2]) && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") {
      const r = e[3] || e[2];
      Object.keys(r).forEach((o) => {
        t[o] = r[o];
      });
    }
    return t;
  },
  interpolation: {
    escapeValue: !0,
    format: (e) => e,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: !0
  },
  cacheInBuiltFormats: !0
}), rf = (e) => (x(e.ns) && (e.ns = [e.ns]), x(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), x(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), e.supportedLngs?.indexOf?.("cimode") < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), typeof e.initImmediate == "boolean" && (e.initAsync = e.initImmediate), e), _s = () => {
}, tE = (e) => {
  Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((r) => {
    typeof e[r] == "function" && (e[r] = e[r].bind(e));
  });
};
class hs extends Qs {
  constructor(t = {}, r) {
    if (super(), this.options = rf(t), this.services = {}, this.logger = Me, this.modules = {
      external: []
    }, tE(this), r && !this.isInitialized && !t.isClone) {
      if (!this.options.initAsync)
        return this.init(t, r), this;
      setTimeout(() => {
        this.init(t, r);
      }, 0);
    }
  }
  init(t = {}, r) {
    this.isInitializing = !0, typeof t == "function" && (r = t, t = {}), t.defaultNS == null && t.ns && (x(t.ns) ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0]));
    const o = tf();
    this.options = {
      ...o,
      ...this.options,
      ...rf(t)
    }, this.options.interpolation = {
      ...o.interpolation,
      ...this.options.interpolation
    }, t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator);
    const i = (u) => u ? typeof u == "function" ? new u() : u : null;
    if (!this.options.isClone) {
      this.modules.logger ? Me.init(i(this.modules.logger), this.options) : Me.init(null, this.options);
      let u;
      this.modules.formatter ? u = this.modules.formatter : u = Zb;
      const l = new Qh(this.options);
      this.store = new Kh(this.options.resources, this.options);
      const p = this.services;
      p.logger = Me, p.resourceStore = this.store, p.languageUtils = l, p.pluralResolver = new Jb(l, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      }), this.options.interpolation.format && this.options.interpolation.format !== o.interpolation.format && this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), u && (!this.options.interpolation.format || this.options.interpolation.format === o.interpolation.format) && (p.formatter = i(u), p.formatter.init && p.formatter.init(p, this.options), this.options.interpolation.format = p.formatter.format.bind(p.formatter)), p.interpolator = new Gb(this.options), p.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      }, p.backendConnector = new eE(i(this.modules.backend), p.resourceStore, p, this.options), p.backendConnector.on("*", (d, ...f) => {
        this.emit(d, ...f);
      }), this.modules.languageDetector && (p.languageDetector = i(this.modules.languageDetector), p.languageDetector.init && p.languageDetector.init(p, this.options.detection, this.options)), this.modules.i18nFormat && (p.i18nFormat = i(this.modules.i18nFormat), p.i18nFormat.init && p.i18nFormat.init(this)), this.translator = new qs(this.services, this.options), this.translator.on("*", (d, ...f) => {
        this.emit(d, ...f);
      }), this.modules.external.forEach((d) => {
        d.init && d.init(this);
      });
    }
    if (this.format = this.options.interpolation.format, r || (r = _s), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const u = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      u.length > 0 && u[0] !== "dev" && (this.options.lng = u[0]);
    }
    !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach((u) => {
      this[u] = (...l) => this.store[u](...l);
    }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach((u) => {
      this[u] = (...l) => (this.store[u](...l), this);
    });
    const n = as(), c = () => {
      const u = (l, p) => {
        this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), n.resolve(p), r(l, p);
      };
      if (this.languages && !this.isInitialized) return u(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, u);
    };
    return this.options.resources || !this.options.initAsync ? c() : setTimeout(c, 0), n;
  }
  loadResources(t, r = _s) {
    let o = r;
    const i = x(t) ? t : this.language;
    if (typeof t == "function" && (o = t), !this.options.resources || this.options.partialBundledLanguages) {
      if (i?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return o();
      const a = [], s = (n) => {
        if (!n || n === "cimode") return;
        this.services.languageUtils.toResolveHierarchy(n).forEach((u) => {
          u !== "cimode" && a.indexOf(u) < 0 && a.push(u);
        });
      };
      i ? s(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach((c) => s(c)), this.options.preload?.forEach?.((n) => s(n)), this.services.backendConnector.load(a, this.options.ns, (n) => {
        !n && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), o(n);
      });
    } else
      o(null);
  }
  reloadResources(t, r, o) {
    const i = as();
    return typeof t == "function" && (o = t, t = void 0), typeof r == "function" && (o = r, r = void 0), t || (t = this.languages), r || (r = this.options.ns), o || (o = _s), this.services.backendConnector.reload(t, r, (a) => {
      i.resolve(), o(a);
    }), i;
  }
  use(t) {
    if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && og.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this;
  }
  setResolvedLanguage(t) {
    if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1)) {
      for (let r = 0; r < this.languages.length; r++) {
        const o = this.languages[r];
        if (!(["cimode", "dev"].indexOf(o) > -1) && this.store.hasLanguageSomeTranslations(o)) {
          this.resolvedLanguage = o;
          break;
        }
      }
      !this.resolvedLanguage && this.languages.indexOf(t) < 0 && this.store.hasLanguageSomeTranslations(t) && (this.resolvedLanguage = t, this.languages.unshift(t));
    }
  }
  changeLanguage(t, r) {
    this.isLanguageChangingTo = t;
    const o = as();
    this.emit("languageChanging", t);
    const i = (n) => {
      this.language = n, this.languages = this.services.languageUtils.toResolveHierarchy(n), this.resolvedLanguage = void 0, this.setResolvedLanguage(n);
    }, a = (n, c) => {
      c ? this.isLanguageChangingTo === t && (i(c), this.translator.changeLanguage(c), this.isLanguageChangingTo = void 0, this.emit("languageChanged", c), this.logger.log("languageChanged", c)) : this.isLanguageChangingTo = void 0, o.resolve((...u) => this.t(...u)), r && r(n, (...u) => this.t(...u));
    }, s = (n) => {
      !t && !n && this.services.languageDetector && (n = []);
      const c = x(n) ? n : n && n[0], u = this.store.hasLanguageSomeTranslations(c) ? c : this.services.languageUtils.getBestMatchFromCodes(x(n) ? [n] : n);
      u && (this.language || i(u), this.translator.language || this.translator.changeLanguage(u), this.services.languageDetector?.cacheUserLanguage?.(u)), this.loadResources(u, (l) => {
        a(l, u);
      });
    };
    return !t && this.services.languageDetector && !this.services.languageDetector.async ? s(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(s) : this.services.languageDetector.detect(s) : s(t), o;
  }
  getFixedT(t, r, o) {
    const i = (a, s, ...n) => {
      let c;
      typeof s != "object" ? c = this.options.overloadTranslationOptionHandler([a, s].concat(n)) : c = {
        ...s
      }, c.lng = c.lng || i.lng, c.lngs = c.lngs || i.lngs, c.ns = c.ns || i.ns, c.keyPrefix !== "" && (c.keyPrefix = c.keyPrefix || o || i.keyPrefix);
      const u = this.options.keySeparator || ".";
      let l;
      return c.keyPrefix && Array.isArray(a) ? l = a.map((p) => (typeof p == "function" && (p = Qa(p, {
        ...this.options,
        ...s
      })), `${c.keyPrefix}${u}${p}`)) : (typeof a == "function" && (a = Qa(a, {
        ...this.options,
        ...s
      })), l = c.keyPrefix ? `${c.keyPrefix}${u}${a}` : a), this.t(l, c);
    };
    return x(t) ? i.lng = t : i.lngs = t, i.ns = r, i.keyPrefix = o, i;
  }
  t(...t) {
    return this.translator?.translate(...t);
  }
  exists(...t) {
    return this.translator?.exists(...t);
  }
  setDefaultNamespace(t) {
    this.options.defaultNS = t;
  }
  hasLoadedNamespace(t, r = {}) {
    if (!this.isInitialized)
      return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
    if (!this.languages || !this.languages.length)
      return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
    const o = r.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, a = this.languages[this.languages.length - 1];
    if (o.toLowerCase() === "cimode") return !0;
    const s = (n, c) => {
      const u = this.services.backendConnector.state[`${n}|${c}`];
      return u === -1 || u === 0 || u === 2;
    };
    if (r.precheck) {
      const n = r.precheck(this, s);
      if (n !== void 0) return n;
    }
    return !!(this.hasResourceBundle(o, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || s(o, t) && (!i || s(a, t)));
  }
  loadNamespaces(t, r) {
    const o = as();
    return this.options.ns ? (x(t) && (t = [t]), t.forEach((i) => {
      this.options.ns.indexOf(i) < 0 && this.options.ns.push(i);
    }), this.loadResources((i) => {
      o.resolve(), r && r(i);
    }), o) : (r && r(), Promise.resolve());
  }
  loadLanguages(t, r) {
    const o = as();
    x(t) && (t = [t]);
    const i = this.options.preload || [], a = t.filter((s) => i.indexOf(s) < 0 && this.services.languageUtils.isSupportedCode(s));
    return a.length ? (this.options.preload = i.concat(a), this.loadResources((s) => {
      o.resolve(), r && r(s);
    }), o) : (r && r(), Promise.resolve());
  }
  dir(t) {
    if (t || (t = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language)), !t) return "rtl";
    try {
      const i = new Intl.Locale(t);
      if (i && i.getTextInfo) {
        const a = i.getTextInfo();
        if (a && a.direction) return a.direction;
      }
    } catch {
    }
    const r = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], o = this.services?.languageUtils || new Qh(tf());
    return t.toLowerCase().indexOf("-latn") > 1 ? "ltr" : r.indexOf(o.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance(t = {}, r) {
    return new hs(t, r);
  }
  cloneInstance(t = {}, r = _s) {
    const o = t.forkResourceStore;
    o && delete t.forkResourceStore;
    const i = {
      ...this.options,
      ...t,
      isClone: !0
    }, a = new hs(i);
    if ((t.debug !== void 0 || t.prefix !== void 0) && (a.logger = a.logger.clone(t)), ["store", "services", "language"].forEach((n) => {
      a[n] = this[n];
    }), a.services = {
      ...this.services
    }, a.services.utils = {
      hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
    }, o) {
      const n = Object.keys(this.store.data).reduce((c, u) => (c[u] = {
        ...this.store.data[u]
      }, c[u] = Object.keys(c[u]).reduce((l, p) => (l[p] = {
        ...c[u][p]
      }, l), c[u]), c), {});
      a.store = new Kh(n, i), a.services.resourceStore = a.store;
    }
    return a.translator = new qs(a.services, i), a.translator.on("*", (n, ...c) => {
      a.emit(n, ...c);
    }), a.init(i, r), a.translator.options = i, a.translator.backendConnector.services.utils = {
      hasLoadedNamespace: a.hasLoadedNamespace.bind(a)
    }, a;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const se = hs.createInstance();
se.createInstance = hs.createInstance;
se.createInstance;
se.dir;
se.init;
se.loadResources;
se.reloadResources;
se.use;
se.changeLanguage;
se.getFixedT;
se.t;
se.exists;
se.setDefaultNamespace;
se.hasLoadedNamespace;
se.loadNamespaces;
se.loadLanguages;
var Ys = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(e) {
    return this.listeners.add(e), this.onSubscribe(), () => {
      this.listeners.delete(e), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, Zs = typeof window > "u" || "Deno" in globalThis;
function _e() {
}
function rE(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function nE(e) {
  return typeof e == "number" && e >= 0 && e !== 1 / 0;
}
function iE(e, t) {
  return Math.max(e + (t || 0) - Date.now(), 0);
}
function Ya(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function sE(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function nf(e, t) {
  const {
    type: r = "all",
    exact: o,
    fetchStatus: i,
    predicate: a,
    queryKey: s,
    stale: n
  } = e;
  if (s) {
    if (o) {
      if (t.queryHash !== fc(s, t.options))
        return !1;
    } else if (!vs(t.queryKey, s))
      return !1;
  }
  if (r !== "all") {
    const c = t.isActive();
    if (r === "active" && !c || r === "inactive" && c)
      return !1;
  }
  return !(typeof n == "boolean" && t.isStale() !== n || i && i !== t.state.fetchStatus || a && !a(t));
}
function sf(e, t) {
  const { exact: r, status: o, predicate: i, mutationKey: a } = e;
  if (a) {
    if (!t.options.mutationKey)
      return !1;
    if (r) {
      if (fs(t.options.mutationKey) !== fs(a))
        return !1;
    } else if (!vs(t.options.mutationKey, a))
      return !1;
  }
  return !(o && t.state.status !== o || i && !i(t));
}
function fc(e, t) {
  return (t?.queryKeyHashFn || fs)(e);
}
function fs(e) {
  return JSON.stringify(
    e,
    (t, r) => Xa(r) ? Object.keys(r).sort().reduce((o, i) => (o[i] = r[i], o), {}) : r
  );
}
function vs(e, t) {
  return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every((r) => vs(e[r], t[r])) : !1;
}
function Za(e, t) {
  if (e === t)
    return e;
  const r = of(e) && of(t);
  if (r || Xa(e) && Xa(t)) {
    const o = r ? e : Object.keys(e), i = o.length, a = r ? t : Object.keys(t), s = a.length, n = r ? [] : {}, c = new Set(o);
    let u = 0;
    for (let l = 0; l < s; l++) {
      const p = r ? l : a[l];
      (!r && c.has(p) || r) && e[p] === void 0 && t[p] === void 0 ? (n[p] = void 0, u++) : (n[p] = Za(e[p], t[p]), n[p] === e[p] && e[p] !== void 0 && u++);
    }
    return i === s && u === i ? e : n;
  }
  return t;
}
function of(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function Xa(e) {
  if (!af(e))
    return !1;
  const t = e.constructor;
  if (t === void 0)
    return !0;
  const r = t.prototype;
  return !(!af(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype);
}
function af(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function oE(e) {
  return new Promise((t) => {
    setTimeout(t, e);
  });
}
function aE(e, t, r) {
  if (typeof r.structuralSharing == "function")
    return r.structuralSharing(e, t);
  if (r.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return Za(e, t);
      } catch (o) {
        throw console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${r.queryHash}]: ${o}`
        ), o;
      }
    return Za(e, t);
  }
  return t;
}
function cE(e, t, r = 0) {
  const o = [...e, t];
  return r && o.length > r ? o.slice(1) : o;
}
function uE(e, t, r = 0) {
  const o = [t, ...e];
  return r && o.length > r ? o.slice(0, -1) : o;
}
var Fs = Symbol();
function cg(e, t) {
  return process.env.NODE_ENV !== "production" && e.queryFn === Fs && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${e.queryHash}'`
  ), !e.queryFn && t?.initialPromise ? () => t.initialPromise : !e.queryFn || e.queryFn === Fs ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn;
}
var lE = class extends Ys {
  #e;
  #t;
  #r;
  constructor() {
    super(), this.#r = (e) => {
      if (!Zs && window.addEventListener) {
        const t = () => e();
        return window.addEventListener("visibilitychange", t, !1), () => {
          window.removeEventListener("visibilitychange", t);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#r);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(e) {
    this.#r = e, this.#t?.(), this.#t = e((t) => {
      typeof t == "boolean" ? this.setFocused(t) : this.onFocus();
    });
  }
  setFocused(e) {
    this.#e !== e && (this.#e = e, this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((t) => {
      t(e);
    });
  }
  isFocused() {
    return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden";
  }
}, ug = new lE(), pE = class extends Ys {
  #e = !0;
  #t;
  #r;
  constructor() {
    super(), this.#r = (e) => {
      if (!Zs && window.addEventListener) {
        const t = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", t, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", t), window.removeEventListener("offline", r);
        };
      }
    };
  }
  onSubscribe() {
    this.#t || this.setEventListener(this.#r);
  }
  onUnsubscribe() {
    this.hasListeners() || (this.#t?.(), this.#t = void 0);
  }
  setEventListener(e) {
    this.#r = e, this.#t?.(), this.#t = e(this.setOnline.bind(this));
  }
  setOnline(e) {
    this.#e !== e && (this.#e = e, this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return this.#e;
  }
}, Bs = new pE();
function dE() {
  let e, t;
  const r = new Promise((i, a) => {
    e = i, t = a;
  });
  r.status = "pending", r.catch(() => {
  });
  function o(i) {
    Object.assign(r, i), delete r.resolve, delete r.reject;
  }
  return r.resolve = (i) => {
    o({
      status: "fulfilled",
      value: i
    }), e(i);
  }, r.reject = (i) => {
    o({
      status: "rejected",
      reason: i
    }), t(i);
  }, r;
}
function hE(e) {
  return Math.min(1e3 * 2 ** e, 3e4);
}
function lg(e) {
  return (e ?? "online") === "online" ? Bs.isOnline() : !0;
}
var pg = class extends Error {
  constructor(e) {
    super("CancelledError"), this.revert = e?.revert, this.silent = e?.silent;
  }
};
function Da(e) {
  return e instanceof pg;
}
function dg(e) {
  let t = !1, r = 0, o = !1, i;
  const a = dE(), s = (g) => {
    o || (h(new pg(g)), e.abort?.());
  }, n = () => {
    t = !0;
  }, c = () => {
    t = !1;
  }, u = () => ug.isFocused() && (e.networkMode === "always" || Bs.isOnline()) && e.canRun(), l = () => lg(e.networkMode) && e.canRun(), p = (g) => {
    o || (o = !0, e.onSuccess?.(g), i?.(), a.resolve(g));
  }, h = (g) => {
    o || (o = !0, e.onError?.(g), i?.(), a.reject(g));
  }, d = () => new Promise((g) => {
    i = (m) => {
      (o || u()) && g(m);
    }, e.onPause?.();
  }).then(() => {
    i = void 0, o || e.onContinue?.();
  }), f = () => {
    if (o)
      return;
    let g;
    const m = r === 0 ? e.initialPromise : void 0;
    try {
      g = m ?? e.fn();
    } catch (v) {
      g = Promise.reject(v);
    }
    Promise.resolve(g).then(p).catch((v) => {
      if (o)
        return;
      const y = e.retry ?? (Zs ? 0 : 3), S = e.retryDelay ?? hE, C = typeof S == "function" ? S(r, v) : S, w = y === !0 || typeof y == "number" && r < y || typeof y == "function" && y(r, v);
      if (t || !w) {
        h(v);
        return;
      }
      r++, e.onFail?.(r, v), oE(C).then(() => u() ? void 0 : d()).then(() => {
        t ? h(v) : f();
      });
    });
  };
  return {
    promise: a,
    cancel: s,
    continue: () => (i?.(), a),
    cancelRetry: n,
    continueRetry: c,
    canStart: l,
    start: () => (l() ? f() : d().then(f), a)
  };
}
var fE = (e) => setTimeout(e, 0);
function vE() {
  let e = [], t = 0, r = (n) => {
    n();
  }, o = (n) => {
    n();
  }, i = fE;
  const a = (n) => {
    t ? e.push(n) : i(() => {
      r(n);
    });
  }, s = () => {
    const n = e;
    e = [], n.length && i(() => {
      o(() => {
        n.forEach((c) => {
          r(c);
        });
      });
    });
  };
  return {
    batch: (n) => {
      let c;
      t++;
      try {
        c = n();
      } finally {
        t--, t || s();
      }
      return c;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (n) => (...c) => {
      a(() => {
        n(...c);
      });
    },
    schedule: a,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (n) => {
      r = n;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (n) => {
      o = n;
    },
    setScheduler: (n) => {
      i = n;
    }
  };
}
var ue = vE(), hg = class {
  #e;
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), nE(this.gcTime) && (this.#e = setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(e) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      e ?? (Zs ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    this.#e && (clearTimeout(this.#e), this.#e = void 0);
  }
}, gE = class extends hg {
  #e;
  #t;
  #r;
  #i;
  #n;
  #o;
  #a;
  constructor(e) {
    super(), this.#a = !1, this.#o = e.defaultOptions, this.setOptions(e.options), this.observers = [], this.#i = e.client, this.#r = this.#i.getQueryCache(), this.queryKey = e.queryKey, this.queryHash = e.queryHash, this.#e = yE(this.options), this.state = e.state ?? this.#e, this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    return this.#n?.promise;
  }
  setOptions(e) {
    this.options = { ...this.#o, ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && this.#r.remove(this);
  }
  setData(e, t) {
    const r = aE(this.state.data, e, this.options);
    return this.#s({
      data: r,
      type: "success",
      dataUpdatedAt: t?.updatedAt,
      manual: t?.manual
    }), r;
  }
  setState(e, t) {
    this.#s({ type: "setState", state: e, setStateOptions: t });
  }
  cancel(e) {
    const t = this.#n?.promise;
    return this.#n?.cancel(e), t ? t.then(_e).catch(_e) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(this.#e);
  }
  isActive() {
    return this.observers.some(
      (e) => sE(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Fs || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => Ya(e.options.staleTime, this) === "static"
    ) : !1;
  }
  isStale() {
    return this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(e = 0) {
    return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !iE(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    this.observers.find((t) => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#n?.continue();
  }
  onOnline() {
    this.observers.find((t) => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#n?.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), this.#r.notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((t) => t !== e), this.observers.length || (this.#n && (this.#a ? this.#n.cancel({ revert: !0 }) : this.#n.cancelRetry()), this.scheduleGc()), this.#r.notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || this.#s({ type: "invalidate" });
  }
  fetch(e, t) {
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && t?.cancelRefetch)
        this.cancel({ silent: !0 });
      else if (this.#n)
        return this.#n.continueRetry(), this.#n.promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const c = this.observers.find((u) => u.options.queryFn);
      c && this.setOptions(c.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), o = (c) => {
      Object.defineProperty(c, "signal", {
        enumerable: !0,
        get: () => (this.#a = !0, r.signal)
      });
    }, i = () => {
      const c = cg(this.options, t), l = (() => {
        const p = {
          client: this.#i,
          queryKey: this.queryKey,
          meta: this.meta
        };
        return o(p), p;
      })();
      return this.#a = !1, this.options.persister ? this.options.persister(
        c,
        l,
        this
      ) : c(l);
    }, s = (() => {
      const c = {
        fetchOptions: t,
        options: this.options,
        queryKey: this.queryKey,
        client: this.#i,
        state: this.state,
        fetchFn: i
      };
      return o(c), c;
    })();
    this.options.behavior?.onFetch(s, this), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== s.fetchOptions?.meta) && this.#s({ type: "fetch", meta: s.fetchOptions?.meta });
    const n = (c) => {
      Da(c) && c.silent || this.#s({
        type: "error",
        error: c
      }), Da(c) || (this.#r.config.onError?.(
        c,
        this
      ), this.#r.config.onSettled?.(
        this.state.data,
        c,
        this
      )), this.scheduleGc();
    };
    return this.#n = dg({
      initialPromise: t?.initialPromise,
      fn: s.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (c) => {
        if (c === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), n(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(c);
        } catch (u) {
          n(u);
          return;
        }
        this.#r.config.onSuccess?.(c, this), this.#r.config.onSettled?.(
          c,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: n,
      onFail: (c, u) => {
        this.#s({ type: "failed", failureCount: c, error: u });
      },
      onPause: () => {
        this.#s({ type: "pause" });
      },
      onContinue: () => {
        this.#s({ type: "continue" });
      },
      retry: s.options.retry,
      retryDelay: s.options.retryDelay,
      networkMode: s.options.networkMode,
      canRun: () => !0
    }), this.#n.start();
  }
  #s(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return {
            ...r,
            fetchFailureCount: e.failureCount,
            fetchFailureReason: e.error
          };
        case "pause":
          return {
            ...r,
            fetchStatus: "paused"
          };
        case "continue":
          return {
            ...r,
            fetchStatus: "fetching"
          };
        case "fetch":
          return {
            ...r,
            ...mE(r.data, this.options),
            fetchMeta: e.meta ?? null
          };
        case "success":
          return this.#t = void 0, {
            ...r,
            data: e.data,
            dataUpdateCount: r.dataUpdateCount + 1,
            dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
            error: null,
            isInvalidated: !1,
            status: "success",
            ...!e.manual && {
              fetchStatus: "idle",
              fetchFailureCount: 0,
              fetchFailureReason: null
            }
          };
        case "error":
          const o = e.error;
          return Da(o) && o.revert && this.#t ? { ...this.#t, fetchStatus: "idle" } : {
            ...r,
            error: o,
            errorUpdateCount: r.errorUpdateCount + 1,
            errorUpdatedAt: Date.now(),
            fetchFailureCount: r.fetchFailureCount + 1,
            fetchFailureReason: o,
            fetchStatus: "idle",
            status: "error"
          };
        case "invalidate":
          return {
            ...r,
            isInvalidated: !0
          };
        case "setState":
          return {
            ...r,
            ...e.state
          };
      }
    };
    this.state = t(this.state), ue.batch(() => {
      this.observers.forEach((r) => {
        r.onQueryUpdate();
      }), this.#r.notify({ query: this, type: "updated", action: e });
    });
  }
};
function mE(e, t) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: lg(t.networkMode) ? "fetching" : "paused",
    ...e === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function yE(e) {
  const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, r = t !== void 0, o = r ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0;
  return {
    data: t,
    dataUpdateCount: 0,
    dataUpdatedAt: r ? o ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: r ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var SE = class extends Ys {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Map();
  }
  #e;
  build(e, t, r) {
    const o = t.queryKey, i = t.queryHash ?? fc(o, t);
    let a = this.get(i);
    return a || (a = new gE({
      client: e,
      queryKey: o,
      queryHash: i,
      options: e.defaultQueryOptions(t),
      state: r,
      defaultOptions: e.getQueryDefaults(o)
    }), this.add(a)), a;
  }
  add(e) {
    this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e), this.notify({
      type: "added",
      query: e
    }));
  }
  remove(e) {
    const t = this.#e.get(e.queryHash);
    t && (e.destroy(), t === e && this.#e.delete(e.queryHash), this.notify({ type: "removed", query: e }));
  }
  clear() {
    ue.batch(() => {
      this.getAll().forEach((e) => {
        this.remove(e);
      });
    });
  }
  get(e) {
    return this.#e.get(e);
  }
  getAll() {
    return [...this.#e.values()];
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (r) => nf(t, r)
    );
  }
  findAll(e = {}) {
    const t = this.getAll();
    return Object.keys(e).length > 0 ? t.filter((r) => nf(e, r)) : t;
  }
  notify(e) {
    ue.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  onFocus() {
    ue.batch(() => {
      this.getAll().forEach((e) => {
        e.onFocus();
      });
    });
  }
  onOnline() {
    ue.batch(() => {
      this.getAll().forEach((e) => {
        e.onOnline();
      });
    });
  }
}, CE = class extends hg {
  #e;
  #t;
  #r;
  constructor(e) {
    super(), this.mutationId = e.mutationId, this.#t = e.mutationCache, this.#e = [], this.state = e.state || RE(), this.setOptions(e.options), this.scheduleGc();
  }
  setOptions(e) {
    this.options = e, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(e) {
    this.#e.includes(e) || (this.#e.push(e), this.clearGcTimeout(), this.#t.notify({
      type: "observerAdded",
      mutation: this,
      observer: e
    }));
  }
  removeObserver(e) {
    this.#e = this.#e.filter((t) => t !== e), this.scheduleGc(), this.#t.notify({
      type: "observerRemoved",
      mutation: this,
      observer: e
    });
  }
  optionalRemove() {
    this.#e.length || (this.state.status === "pending" ? this.scheduleGc() : this.#t.remove(this));
  }
  continue() {
    return this.#r?.continue() ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(e) {
    const t = () => {
      this.#i({ type: "continue" });
    };
    this.#r = dg({
      fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
      onFail: (i, a) => {
        this.#i({ type: "failed", failureCount: i, error: a });
      },
      onPause: () => {
        this.#i({ type: "pause" });
      },
      onContinue: t,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => this.#t.canRun(this)
    });
    const r = this.state.status === "pending", o = !this.#r.canStart();
    try {
      if (r)
        t();
      else {
        this.#i({ type: "pending", variables: e, isPaused: o }), await this.#t.config.onMutate?.(
          e,
          this
        );
        const a = await this.options.onMutate?.(e);
        a !== this.state.context && this.#i({
          type: "pending",
          context: a,
          variables: e,
          isPaused: o
        });
      }
      const i = await this.#r.start();
      return await this.#t.config.onSuccess?.(
        i,
        e,
        this.state.context,
        this
      ), await this.options.onSuccess?.(i, e, this.state.context), await this.#t.config.onSettled?.(
        i,
        null,
        this.state.variables,
        this.state.context,
        this
      ), await this.options.onSettled?.(i, null, e, this.state.context), this.#i({ type: "success", data: i }), i;
    } catch (i) {
      try {
        throw await this.#t.config.onError?.(
          i,
          e,
          this.state.context,
          this
        ), await this.options.onError?.(
          i,
          e,
          this.state.context
        ), await this.#t.config.onSettled?.(
          void 0,
          i,
          this.state.variables,
          this.state.context,
          this
        ), await this.options.onSettled?.(
          void 0,
          i,
          e,
          this.state.context
        ), i;
      } finally {
        this.#i({ type: "error", error: i });
      }
    } finally {
      this.#t.runNext(this);
    }
  }
  #i(e) {
    const t = (r) => {
      switch (e.type) {
        case "failed":
          return {
            ...r,
            failureCount: e.failureCount,
            failureReason: e.error
          };
        case "pause":
          return {
            ...r,
            isPaused: !0
          };
        case "continue":
          return {
            ...r,
            isPaused: !1
          };
        case "pending":
          return {
            ...r,
            context: e.context,
            data: void 0,
            failureCount: 0,
            failureReason: null,
            error: null,
            isPaused: e.isPaused,
            status: "pending",
            variables: e.variables,
            submittedAt: Date.now()
          };
        case "success":
          return {
            ...r,
            data: e.data,
            failureCount: 0,
            failureReason: null,
            error: null,
            status: "success",
            isPaused: !1
          };
        case "error":
          return {
            ...r,
            data: void 0,
            error: e.error,
            failureCount: r.failureCount + 1,
            failureReason: e.error,
            isPaused: !1,
            status: "error"
          };
      }
    };
    this.state = t(this.state), ue.batch(() => {
      this.#e.forEach((r) => {
        r.onMutationUpdate(e);
      }), this.#t.notify({
        mutation: this,
        type: "updated",
        action: e
      });
    });
  }
};
function RE() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var PE = class extends Ys {
  constructor(e = {}) {
    super(), this.config = e, this.#e = /* @__PURE__ */ new Set(), this.#t = /* @__PURE__ */ new Map(), this.#r = 0;
  }
  #e;
  #t;
  #r;
  build(e, t, r) {
    const o = new CE({
      mutationCache: this,
      mutationId: ++this.#r,
      options: e.defaultMutationOptions(t),
      state: r
    });
    return this.add(o), o;
  }
  add(e) {
    this.#e.add(e);
    const t = ks(e);
    if (typeof t == "string") {
      const r = this.#t.get(t);
      r ? r.push(e) : this.#t.set(t, [e]);
    }
    this.notify({ type: "added", mutation: e });
  }
  remove(e) {
    if (this.#e.delete(e)) {
      const t = ks(e);
      if (typeof t == "string") {
        const r = this.#t.get(t);
        if (r)
          if (r.length > 1) {
            const o = r.indexOf(e);
            o !== -1 && r.splice(o, 1);
          } else r[0] === e && this.#t.delete(t);
      }
    }
    this.notify({ type: "removed", mutation: e });
  }
  canRun(e) {
    const t = ks(e);
    if (typeof t == "string") {
      const o = this.#t.get(t)?.find(
        (i) => i.state.status === "pending"
      );
      return !o || o === e;
    } else
      return !0;
  }
  runNext(e) {
    const t = ks(e);
    return typeof t == "string" ? this.#t.get(t)?.find((o) => o !== e && o.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve();
  }
  clear() {
    ue.batch(() => {
      this.#e.forEach((e) => {
        this.notify({ type: "removed", mutation: e });
      }), this.#e.clear(), this.#t.clear();
    });
  }
  getAll() {
    return Array.from(this.#e);
  }
  find(e) {
    const t = { exact: !0, ...e };
    return this.getAll().find(
      (r) => sf(t, r)
    );
  }
  findAll(e = {}) {
    return this.getAll().filter((t) => sf(e, t));
  }
  notify(e) {
    ue.batch(() => {
      this.listeners.forEach((t) => {
        t(e);
      });
    });
  }
  resumePausedMutations() {
    const e = this.getAll().filter((t) => t.state.isPaused);
    return ue.batch(
      () => Promise.all(
        e.map((t) => t.continue().catch(_e))
      )
    );
  }
};
function ks(e) {
  return e.options.scope?.id;
}
function cf(e) {
  return {
    onFetch: (t, r) => {
      const o = t.options, i = t.fetchOptions?.meta?.fetchMore?.direction, a = t.state.data?.pages || [], s = t.state.data?.pageParams || [];
      let n = { pages: [], pageParams: [] }, c = 0;
      const u = async () => {
        let l = !1;
        const p = (f) => {
          Object.defineProperty(f, "signal", {
            enumerable: !0,
            get: () => (t.signal.aborted ? l = !0 : t.signal.addEventListener("abort", () => {
              l = !0;
            }), t.signal)
          });
        }, h = cg(t.options, t.fetchOptions), d = async (f, g, m) => {
          if (l)
            return Promise.reject();
          if (g == null && f.pages.length)
            return Promise.resolve(f);
          const y = (() => {
            const b = {
              client: t.client,
              queryKey: t.queryKey,
              pageParam: g,
              direction: m ? "backward" : "forward",
              meta: t.options.meta
            };
            return p(b), b;
          })(), S = await h(y), { maxPages: C } = t.options, w = m ? uE : cE;
          return {
            pages: w(f.pages, S, C),
            pageParams: w(f.pageParams, g, C)
          };
        };
        if (i && a.length) {
          const f = i === "backward", g = f ? wE : uf, m = {
            pages: a,
            pageParams: s
          }, v = g(o, m);
          n = await d(m, v, f);
        } else {
          const f = e ?? a.length;
          do {
            const g = c === 0 ? s[0] ?? o.initialPageParam : uf(o, n);
            if (c > 0 && g == null)
              break;
            n = await d(n, g), c++;
          } while (c < f);
        }
        return n;
      };
      t.options.persister ? t.fetchFn = () => t.options.persister?.(
        u,
        {
          client: t.client,
          queryKey: t.queryKey,
          meta: t.options.meta,
          signal: t.signal
        },
        r
      ) : t.fetchFn = u;
    }
  };
}
function uf(e, { pages: t, pageParams: r }) {
  const o = t.length - 1;
  return t.length > 0 ? e.getNextPageParam(
    t[o],
    t,
    r[o],
    r
  ) : void 0;
}
function wE(e, { pages: t, pageParams: r }) {
  return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, r[0], r) : void 0;
}
var bE = class {
  #e;
  #t;
  #r;
  #i;
  #n;
  #o;
  #a;
  #s;
  constructor(e = {}) {
    this.#e = e.queryCache || new SE(), this.#t = e.mutationCache || new PE(), this.#r = e.defaultOptions || {}, this.#i = /* @__PURE__ */ new Map(), this.#n = /* @__PURE__ */ new Map(), this.#o = 0;
  }
  mount() {
    this.#o++, this.#o === 1 && (this.#a = ug.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onFocus());
    }), this.#s = Bs.subscribe(async (e) => {
      e && (await this.resumePausedMutations(), this.#e.onOnline());
    }));
  }
  unmount() {
    this.#o--, this.#o === 0 && (this.#a?.(), this.#a = void 0, this.#s?.(), this.#s = void 0);
  }
  isFetching(e) {
    return this.#e.findAll({ ...e, fetchStatus: "fetching" }).length;
  }
  isMutating(e) {
    return this.#t.findAll({ ...e, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(t.queryHash)?.state.data;
  }
  ensureQueryData(e) {
    const t = this.defaultQueryOptions(e), r = this.#e.build(this, t), o = r.state.data;
    return o === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && r.isStaleByTime(Ya(t.staleTime, r)) && this.prefetchQuery(t), Promise.resolve(o));
  }
  getQueriesData(e) {
    return this.#e.findAll(e).map(({ queryKey: t, state: r }) => {
      const o = r.data;
      return [t, o];
    });
  }
  setQueryData(e, t, r) {
    const o = this.defaultQueryOptions({ queryKey: e }), a = this.#e.get(
      o.queryHash
    )?.state.data, s = rE(t, a);
    if (s !== void 0)
      return this.#e.build(this, o).setData(s, { ...r, manual: !0 });
  }
  setQueriesData(e, t, r) {
    return ue.batch(
      () => this.#e.findAll(e).map(({ queryKey: o }) => [
        o,
        this.setQueryData(o, t, r)
      ])
    );
  }
  getQueryState(e) {
    const t = this.defaultQueryOptions({ queryKey: e });
    return this.#e.get(
      t.queryHash
    )?.state;
  }
  removeQueries(e) {
    const t = this.#e;
    ue.batch(() => {
      t.findAll(e).forEach((r) => {
        t.remove(r);
      });
    });
  }
  resetQueries(e, t) {
    const r = this.#e;
    return ue.batch(() => (r.findAll(e).forEach((o) => {
      o.reset();
    }), this.refetchQueries(
      {
        type: "active",
        ...e
      },
      t
    )));
  }
  cancelQueries(e, t = {}) {
    const r = { revert: !0, ...t }, o = ue.batch(
      () => this.#e.findAll(e).map((i) => i.cancel(r))
    );
    return Promise.all(o).then(_e).catch(_e);
  }
  invalidateQueries(e, t = {}) {
    return ue.batch(() => (this.#e.findAll(e).forEach((r) => {
      r.invalidate();
    }), e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries(
      {
        ...e,
        type: e?.refetchType ?? e?.type ?? "active"
      },
      t
    )));
  }
  refetchQueries(e, t = {}) {
    const r = {
      ...t,
      cancelRefetch: t.cancelRefetch ?? !0
    }, o = ue.batch(
      () => this.#e.findAll(e).filter((i) => !i.isDisabled() && !i.isStatic()).map((i) => {
        let a = i.fetch(void 0, r);
        return r.throwOnError || (a = a.catch(_e)), i.state.fetchStatus === "paused" ? Promise.resolve() : a;
      })
    );
    return Promise.all(o).then(_e);
  }
  fetchQuery(e) {
    const t = this.defaultQueryOptions(e);
    t.retry === void 0 && (t.retry = !1);
    const r = this.#e.build(this, t);
    return r.isStaleByTime(
      Ya(t.staleTime, r)
    ) ? r.fetch(t) : Promise.resolve(r.state.data);
  }
  prefetchQuery(e) {
    return this.fetchQuery(e).then(_e).catch(_e);
  }
  fetchInfiniteQuery(e) {
    return e.behavior = cf(e.pages), this.fetchQuery(e);
  }
  prefetchInfiniteQuery(e) {
    return this.fetchInfiniteQuery(e).then(_e).catch(_e);
  }
  ensureInfiniteQueryData(e) {
    return e.behavior = cf(e.pages), this.ensureQueryData(e);
  }
  resumePausedMutations() {
    return Bs.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve();
  }
  getQueryCache() {
    return this.#e;
  }
  getMutationCache() {
    return this.#t;
  }
  getDefaultOptions() {
    return this.#r;
  }
  setDefaultOptions(e) {
    this.#r = e;
  }
  setQueryDefaults(e, t) {
    this.#i.set(fs(e), {
      queryKey: e,
      defaultOptions: t
    });
  }
  getQueryDefaults(e) {
    const t = [...this.#i.values()], r = {};
    return t.forEach((o) => {
      vs(e, o.queryKey) && Object.assign(r, o.defaultOptions);
    }), r;
  }
  setMutationDefaults(e, t) {
    this.#n.set(fs(e), {
      mutationKey: e,
      defaultOptions: t
    });
  }
  getMutationDefaults(e) {
    const t = [...this.#n.values()], r = {};
    return t.forEach((o) => {
      vs(e, o.mutationKey) && Object.assign(r, o.defaultOptions);
    }), r;
  }
  defaultQueryOptions(e) {
    if (e._defaulted)
      return e;
    const t = {
      ...this.#r.queries,
      ...this.getQueryDefaults(e.queryKey),
      ...e,
      _defaulted: !0
    };
    return t.queryHash || (t.queryHash = fc(
      t.queryKey,
      t
    )), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === Fs && (t.enabled = !1), t;
  }
  defaultMutationOptions(e) {
    return e?._defaulted ? e : {
      ...this.#r.mutations,
      ...e?.mutationKey && this.getMutationDefaults(e.mutationKey),
      ...e,
      _defaulted: !0
    };
  }
  clear() {
    this.#e.clear(), this.#t.clear();
  }
};
async function EE(e) {
  if (!e.ok) {
    const t = await e.text() || e.statusText;
    throw new Error(`${e.status}: ${t}`);
  }
}
function IE() {
  return "https://developmentapis.azure-api.net/sandbox/v1/";
}
const AE = ({ on401: e }) => async ({ queryKey: t }) => {
  const r = t[0], o = r.startsWith("http") ? r : `${IE()}${r}`, i = await fetch(o, {
    credentials: "include"
  });
  return await EE(i), await i.json();
};
new bE({
  defaultOptions: {
    queries: {
      queryFn: AE({ on401: "throw" }),
      refetchInterval: !1,
      refetchOnWindowFocus: !1,
      staleTime: 1 / 0,
      retry: !1
    },
    mutations: {
      retry: !1
    }
  }
});
const TE = "Welcome to Your Personal AI Medical Concierge", _E = "Your intelligent health assistant will ask you key questions to understand your needs and build a personalized profile to support your well-being and care journey.", kE = { title: "How It Works", steps: ["Your AI concierge asks you questions to find out how {{brand}} can help you succeed", "The concierge will personalize recommendations based on your needs", "Access tailored resources, courses, and marketplace options"] }, OE = { resetChat: "Reset Chat", retry: "Retry", continue: "Continue", upload: "Upload", uploading: "Uploading..." }, ME = { yourAIConcierge: "Your AI Concierge", chooseAvatar: "Choose Your Avatar", startConversation: "Start Conversation" }, DE = { chooseAvatarTitle: "Choose Your Avatar", chooseAvatarMessage: "Please select an avatar from the left panel to start your conversation with your AI Concierge.", mode: "Chat Mode", modes: { care: "Care", clear: "Clear", clinical: "Clinical" } }, NE = {
  title: TE,
  description: _E,
  howItWorks: kE,
  buttons: OE,
  avatar: ME,
  chat: DE
}, xE = "Bienvenido a tu Asistente de IA Personal de Salud", zE = "Tu asistente digital inteligente te hará preguntas clave para entender tus necesidades y crear un perfil personalizado para apoyarte en tu viaje de bienestar y cuidado.", LE = { title: "Cómo Funciona", steps: ["Tu asistente de IA te hará preguntas para averiguar cómo {{brand}} puede ayudarte a tener éxito", "El asistente personalizará recomendaciones basadas en tus necesidades", "Accede a recursos, cursos y opciones de mercado personalizados"] }, jE = { resetChat: "Restablecer Chat", retry: "Reintentar", continue: "Continuar", upload: "Cargar", uploading: "Cargando..." }, qE = { yourAIConcierge: "Tu Asistente de IA", chooseAvatar: "Elige tu Avatar", startConversation: "Iniciar Conversación" }, FE = { chooseAvatarTitle: "Elige tu Avatar", chooseAvatarMessage: "Por favor, selecciona un avatar de la izquierda para iniciar tu conversación con tu Asistente de IA.", mode: "Modo de Chat", modes: { care: "Cuidado", clear: "Claro", clinical: "Clínico" } }, BE = {
  title: xE,
  description: zE,
  howItWorks: LE,
  buttons: jE,
  avatar: qE,
  chat: FE
}, UE = "Bienvenue chez votre Assistant IA de Santé", $E = "Votre assistant numérique intelligent vous posera des questions clés pour comprendre vos besoins et créer un profil personnalisé pour vous aider dans votre parcours de bien-être et de soins.", VE = { title: "Comment ça Marche", steps: ["Votre assistant IA vous pose des questions pour savoir comment {{brand}} peut vous aider", "L'assistant personnalise des recommandations selon vos besoins", "Accédez à des ressources, cours et options adaptées"] }, WE = { resetChat: "Réinitialiser le Chat", retry: "Réessayer", continue: "Continuer", upload: "Télécharger", uploading: "Téléchargement..." }, HE = { yourAIConcierge: "Votre Assistant IA", chooseAvatar: "Choisissez votre Avatar", startConversation: "Démarrer la Conversation" }, KE = { chooseAvatarTitle: "Choisissez votre Avatar", chooseAvatarMessage: "Veuillez sélectionner un avatar de la gauche pour démarrer votre conversation avec votre Assistant IA.", mode: "Mode de Chat", modes: { care: "Soins", clear: "Clair", clinical: "Clinique" } }, JE = {
  title: UE,
  description: $E,
  howItWorks: VE,
  buttons: WE,
  avatar: HE,
  chat: KE
}, GE = "Willkommen bei Ihrem persönlichen KI-Medizin-Assistenten", QE = "Ihr intelligenter digitaler Assistent stellt Fragen, um Ihre Bedürfnisse zu verstehen und ein persönliches Profil zu erstellen, um Ihre Gesundheit und Pflege zu unterstützen.", YE = { title: "So funktioniert es", steps: ["Ihr KI-Assistent stellt Fragen, um herauszufinden, wie {{brand}} Sie unterstützen kann", "Der Assistent personalisiert Empfehlungen basierend auf Ihren Bedürfnissen", "Zugriff auf maßgeschneiderte Ressourcen, Kurse und Marktplatzoptionen"] }, ZE = { resetChat: "Chat zurücksetzen", retry: "Wiederholen", continue: "Fortfahren", upload: "Datei hochladen", uploading: "Hochladen..." }, XE = { yourAIConcierge: "Ihr KI-Assistent", chooseAvatar: "Wählen Sie Ihren Avatar", startConversation: "Konversation starten" }, eI = { chooseAvatarTitle: "Wählen Sie Ihren Avatar", chooseAvatarMessage: "Bitte wählen Sie einen Avatar aus der linken Leiste, um mit Ihrem KI-Assistenten zu beginnen.", mode: "Chat-Modus", modes: { care: "Betreuung", clear: "Klar", clinical: "Klinisch" } }, tI = {
  title: GE,
  description: QE,
  howItWorks: YE,
  buttons: ZE,
  avatar: XE,
  chat: eI
}, rI = ["Analyzing your request", "Gathering insights", "Processing information", "Preparing response", "Almost there", "Finalizing thoughts", "Crafting the perfect response", "Connecting the dots", "Synthesizing information", "Optimizing recommendations"], nI = {
  loadingMessages: rI
}, iI = ["Analizando tu solicitud", "Recopilando información", "Procesando información", "Preparando respuesta", "Casi listo", "Finalizando pensamientos", "Elaborando la respuesta perfecta", "Conectando los puntos", "Sintetizando información", "Optimizando recomendaciones"], sI = {
  loadingMessages: iI
}, oI = ["Analyse de votre demande", "Collecte d'informations", "Traitement des informations", "Préparation de la réponse", "Presque terminé", "Finalisation des réflexions", "Élaboration de la réponse parfaite", "Connexion des points", "Synthèse des informations", "Optimisation des recommandations"], aI = {
  loadingMessages: oI
}, cI = ["Analysiere Ihre Anfrage", "Sammle Erkenntnisse", "Verarbeite Informationen", "Bereite Antwort vor", "Fast fertig", "Finalisiere Gedanken", "Erstelle die perfekte Antwort", "Verbinde die Punkte", "Synthetisiere Informationen", "Optimiere Empfehlungen"], uI = {
  loadingMessages: cI
}, lI = {
  en: {
    concierge: NE,
    common: {
      loadingMessages: nI
    }
  },
  es: {
    concierge: BE,
    common: {
      loadingMessages: sI
    }
  },
  fr: {
    concierge: JE,
    common: {
      loadingMessages: aI
    }
  },
  de: {
    concierge: tI,
    common: {
      loadingMessages: uI
    }
  }
};
se.use(Hg).init({
  resources: lI,
  lng: "en",
  // Default language
  fallbackLng: "en",
  interpolation: {
    escapeValue: !1
    // React already handles escaping
  }
});
const pI = [
  { code: "en", name: "English" },
  { code: "es", name: "Spanish" },
  { code: "fr", name: "French" },
  { code: "de", name: "German" }
], fg = {
  region: "",
  apiBaseUrl: "",
  speechKey: "",
  azureTranslatorKey: "",
  azureTranslatorEndpoint: "",
  azureTranslatorRegion: "",
  tavusApiKey: ""
}, vg = pf(fg), dI = () => df(vg), hI = ({ value: e, children: t }) => {
  const r = { ...fg, ...e };
  return /* @__PURE__ */ P(vg.Provider, { value: r, children: t });
}, fI = Eg(
  ({
    replicaId: e = "r82081c7f26d",
    personaId: t = "pc9cb547c05e",
    personaName: r = "Concierge",
    conversationName: o = "Demo Conversation",
    conversationalContext: i,
    customGreeting: a,
    platform: s = "home",
    buttonText: n,
    videoMode: c,
    chatVisible: u,
    toggleChat: l,
    learningPrompts: p = [],
    onPromptClick: h,
    width: d = "100%",
    height: f = "100%",
    maxWidth: g = "2xl",
    className: m = "",
    setVoiceMode: v,
    setConversationStarted: y,
    setConversationId: S,
    setConversationUrl: C,
    setInterruptReplica: w,
    currentScript: b,
    setCurrentScript: A,
    interruptReplica: E,
    setIsSpeaking: M,
    setSpokenText: R,
    region: j,
    speechKey: T,
    config: D
  }, q) => {
    const [pe, W] = O("welcome"), [G, re] = O(null), [oe, me] = O(!1), [V, te] = O(!1), Pe = Ve(null), [ye, Kt] = O([]), [xe, ze] = O("16:9"), { tavusApiKey: xt } = dI(), [we, Jt] = O("en");
    $(() => {
      typeof window < "u" && Jt(localStorage.getItem("lang") || "en");
    }, []);
    const tt = pI.find((F) => F.code === we)?.name || "English", rt = Ve("en");
    $(() => {
      typeof window < "u" && (rt.current = localStorage.getItem("lang") || "en");
    }, []), $(() => {
      (async () => {
        if (ye.length === 0)
          try {
            const X = await ig();
            X?.Success && X.Data && Kt(X.Data);
          } catch (X) {
            console.error("Error fetching avatars:", X);
          }
      })();
    }, [ye.length]);
    const He = ye.find((F) => F.ExternalId === e);
    $(() => {
      we && we !== "en" && we !== rt.current && (rt.current = we, de());
    }, [we]), $(() => {
      (async () => {
        if (He?.ImageUrl) {
          const X = new Image();
          X.onload = () => {
            const Lt = X.width / X.height;
            Math.abs(Lt - 1.7777777777777777) < Math.abs(Lt - 0.5625) ? ze("16:9") : ze("9:16");
          }, X.onerror = () => {
            ze("16:9");
          }, X.src = He.ImageUrl;
        }
      })();
    }, [He?.ImageUrl]), $(() => () => {
      G && Uh({
        conversationId: G.conversation_id,
        apiKey: xt
      });
    }, [G]), $(() => {
      s === "concierge" && nt();
    }, [s]);
    const nt = async () => {
      try {
        te(!1), me(!0), v(!0), y(!0), Pe.current && Pe.current.pause();
        const F = await xb({
          replicaId: e || "r82081c7f26d",
          personaId: t || "pc9cb547c05e",
          conversationName: o || "Demo Conversation",
          conversationalContext: i ?? "",
          customGreeting: a ?? "",
          language: tt,
          apiKey: xt
        });
        if (F?.conversation_id && F.conversation_url)
          re(F), S(F.conversation_id), C(F.conversation_url), W("hairCheck");
        else
          throw new Error("Failed to start conversation");
      } catch (F) {
        console.error("Conversation error:", F);
      } finally {
        me(!1);
      }
    }, de = async () => {
      te(!0), y(!1);
      try {
        if (!G) return;
        await Uh({ conversationId: G.conversation_id, apiKey: xt });
      } catch (F) {
        console.error(F);
      } finally {
        re(null), W("welcome");
      }
    }, Rs = () => {
      W("call");
    };
    Ig(q, () => ({
      handleEnd: de,
      handleStart: nt
    }));
    const Ps = (F) => typeof F == "string" ? F : F ? `${F}px` : "100%", ws = (F) => typeof F == "string" ? F : F ? `${F}px` : "100%", zt = Ps(d), Oe = ws(f), Ke = (F) => {
      if (!F) return;
      const X = typeof F == "string" ? F : `${F}px`;
      return X.includes("sm") || parseInt(X) < 350 ? "sm" : X.includes("lg") || parseInt(X) > 600 ? "lg" : "md";
    }, ae = typeof g == "string" ? g : g ? `${g}px` : void 0, Gt = ae && !ae.includes("px") && !ae.includes("%") ? `max-w-${ae} mx-auto` : "";
    return /* @__PURE__ */ P("main", { className: `${m} relative w-full h-full`, style: { width: zt, height: Oe }, children: /* @__PURE__ */ P(Vg, { children: /* @__PURE__ */ N("div", { className: `h-full w-full ${Gt}`, style: ae && ae.includes("px") ? { maxWidth: ae } : {}, children: [
      pe === "welcome" && /* @__PURE__ */ P(
        Ab,
        {
          onStart: nt,
          loading: oe,
          buttonText: n,
          platform: s || "home",
          replicaId: e || "r82081c7f26d",
          containerClassName: m,
          imageHeight: Oe === "100%" ? "auto" : Oe,
          buttonSize: Ke(d) || "md",
          learningPrompts: p,
          onPromptClick: h,
          userCredits: 100,
          avatars: ye,
          config: D,
          personaName: r
        }
      ),
      pe === "hairCheck" && /* @__PURE__ */ P(
        Tb,
        {
          handleEnd: de,
          handleJoin: Rs,
          setScreen: W,
          platform: s || "home",
          containerClassName: m,
          videoDimensions: {
            width: zt,
            height: Oe === "100%" ? "auto" : Oe
          },
          buttonsSize: Ke(d) || "md"
        }
      ),
      pe === "call" && G && /* @__PURE__ */ P("div", { className: "w-full h-full", children: /* @__PURE__ */ P(
        Nb,
        {
          conversation: G,
          handleEnd: de,
          platform: s || "home",
          videoMode: c ?? "full",
          endConv: V,
          chatVisible: u ?? !1,
          toggleChat: l,
          containerClassName: m,
          videoHeight: Oe === "100%" ? "auto" : Oe,
          controlsSize: Ke(d) || "md",
          aspectRatio: xe,
          setInterruptReplica: w,
          currentScript: b,
          setCurrentScript: A,
          interruptReplica: E,
          setIsSpeaking: M,
          setSpokenText: R,
          region: j,
          speechKey: T,
          config: D,
          personaName: r
        }
      ) })
    ] }) }) });
  }
), vI = async (e, t, r, o, i = !1, a = !1) => {
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify({
      UserId: e,
      CourseId: t,
      Query: r,
      Answer: o,
      Avatar: i,
      STT: a
    })
  };
  let c;
  try {
    const u = rg("/api/User/chathistory/post"), l = await fetch(u, n);
    if (!l.ok) {
      let p = {};
      const h = l.headers.get("content-type");
      throw h && h.includes("application/json") ? p = await l.json() : p = { message: await l.text() }, console.error("Error details:", p), new Error(
        `Failed to post chat history: ${l.status} ${l.statusText} - ${JSON.stringify(p)}`
      );
    }
    return c = l.headers.get("content-length") === "0" ? { Data: !0, Success: !0, Message: "Ok" } : await l.json(), c;
  } catch (u) {
    return console.error("Error posting chat history:", u), {
      Success: !1,
      Message: u instanceof Error ? u.message : "Unknown error occurred",
      Data: null
    };
  }
}, lf = ({
  children: e,
  fallback: t = /* @__PURE__ */ P("div", { children: "Loading..." })
}) => {
  const [r, o] = O(!1);
  return $(() => {
    o(!0);
  }, []), r ? /* @__PURE__ */ P(Ns, { children: e }) : /* @__PURE__ */ P(Ns, { children: t });
}, gI = [
  { id: 1, text: "Explain my report", icon: Dg },
  { id: 5, text: "Analyze my medical reports.", icon: Ng },
  { id: 6, text: "Answer my questions like a personal coach", icon: xg }
], mI = "r89e4f7ec536";
function yI({
  brandName: e = "Growth Hub",
  className: t = "",
  personaName: r = "Personal AI Concierge",
  suggestedPrompts: o = gI,
  welcomeMessage: i = "Hi there! I'm your personal health navigator. I can help you understand your lab results, explain medical terminology, and provide personalized health insights. Go ahead and upload any lab test or medical report. If you don’t have one, lets just talk.",
  language: a = "en",
  navigateTo: s = "",
  file: n,
  onFileChange: c,
  onApiResponse: u,
  config: l = {
    region: "",
    apiBaseUrl: "",
    speechKey: "",
    azureTranslatorKey: "",
    azureTranslatorEndpoint: "",
    azureTranslatorRegion: ""
  }
}) {
  const [p, h] = O([]), [d, f] = O(null), [g, m] = O("chat"), [v, y] = O(!1), [S, C] = O(!1), [w, b] = O(!1), [A, E] = O([]), [M, R] = O(!1), [j, T] = O({}), [D, q] = O(""), [pe, W] = O(!1), [G, re] = O(!1), [oe, me] = O(!1), [V, te] = O(!1), [Pe, ye] = O(""), Kt = Ve(null), [xe, ze] = O(""), [xt, we] = O(!1), [Jt, tt] = O(!1), [rt, He] = O(!1), [nt, de] = O(""), [Rs, Ps] = O(""), [ws, zt] = O(""), [Oe, Ke] = O(""), [ae, Gt] = O(!1), F = Ve(null), X = Ve(null), [Lt, bs] = O([]), Xs = Kg("(max-width: 768px)"), [Es, Is] = O({
    avatar: {
      chooseAvatar: `Choose Your ${r}`,
      startConversation: "Start Conversation",
      yourAIHealthNavigator: `Your ${r}`,
      description: "I'm here to help you with your health and wellness."
    },
    buttons: {
      resetChat: "Reset Chat",
      retry: "Retry",
      continue: "Continue",
      signUp: "Sign Up Free",
      uploading: "Uploading...",
      upload: "Upload report",
      buyNow: "Buy now"
    },
    howItWorks: {
      title: "How It Works",
      steps: [
        `Your AI ${r} asks you questions to find out how ${e} can help you.`,
        `The ${r} will personalize recommendations based on your needs`,
        "Access tailored resources, courses, and marketplace options."
      ]
    }
  });
  $(() => {
    typeof window < "u" && window.scrollTo(0, 0);
  }, []), $(() => {
    (async () => {
      try {
        const ie = await ig();
        if (ie?.Success && ie.Data) {
          const U = ie.Data.find((be) => be.ExternalId === mI);
          U && (h([U]), f(U));
        }
      } catch (ie) {
        console.error("Error fetching avatar:", ie);
      }
    })();
  }, []), $(() => {
    m(ae ? "voice" : "chat");
  }, [ae]), $(() => {
    if (!(!!l?.azureTranslatorKey && !!l?.azureTranslatorEndpoint && !!l?.azureTranslatorRegion)) {
      console.warn("Azure translation config is not yet ready.");
      return;
    }
    (async () => {
      if (a !== "en" && F.current !== a) {
        const [
          U,
          be,
          it,
          J,
          Ee,
          Se,
          Qt,
          to,
          Yt,
          ro,
          no,
          io,
          so,
          oo,
          ao
        ] = await Ks(
          [
            `Choose Your ${r}`,
            "Start Conversation",
            `Your ${r}`,
            `I'm here to help you with ${e}.`,
            "Reset Chat",
            "Retry",
            "Continue",
            "Sign Up Free",
            "Uploading...",
            "Upload Report",
            "Buy Now",
            "How It Works",
            `Your AI ${r} asks you questions to find out how ${e} can help you.`,
            `The ${r} will personalize recommendations based on your needs`,
            "Access tailored resources, courses, and marketplace options."
          ],
          a,
          "en",
          l.azureTranslatorKey,
          l.azureTranslatorEndpoint,
          l.azureTranslatorRegion
        );
        y(!1), q(""), E([]), Is({
          avatar: {
            chooseAvatar: U,
            startConversation: be,
            yourAIHealthNavigator: it,
            description: J
          },
          buttons: {
            resetChat: Ee,
            retry: Se,
            continue: Qt,
            signUp: to,
            uploading: Yt,
            upload: ro,
            buyNow: no
          },
          howItWorks: {
            title: io,
            steps: [so, oo, ao]
          }
        }), F.current = a;
      }
      a === "en" && F.current !== "en" && (y(!1), q(""), E([]), Is({
        avatar: {
          chooseAvatar: `Choose Your ${r}`,
          startConversation: "Start Conversation",
          yourAIHealthNavigator: `Your ${r}`,
          description: `I'm here to help you with ${e}.`
        },
        buttons: {
          resetChat: "Reset Chat",
          retry: "Retry",
          continue: "Continue",
          signUp: "Sign Up Free",
          uploading: "Uploading...",
          upload: "Upload Report",
          buyNow: "Buy Now"
        },
        howItWorks: {
          title: "How It Works",
          steps: [
            `Your AI ${r} asks you questions to find out how ${e} can help you.`,
            `The ${r} will personalize recommendations based on your needs`,
            "Access tailored resources, courses, and marketplace options."
          ]
        }
      }), F.current = "en");
    })();
  }, [
    a,
    l?.azureTranslatorKey,
    l?.azureTranslatorEndpoint,
    l?.azureTranslatorRegion,
    r,
    e
  ]), $(() => {
    n && (bs([n]), Je(`Uploaded file: ${n.name}`, [n]));
  }, [n]), ec(
    async (K) => {
      C(!0);
      const U = await Fh(
        "I am user",
        "",
        "",
        "interview",
        D,
        0,
        1,
        a
      );
      return U.Success && U.Data?.Message ? U.Data.Message.includes("ERROR") ? (C(!1), de(`Hello there! I'm ${K?.Name}, your ${r}. I'm here to help you with ${e}. Can you tell me your name?`), {
        id: "welcome-message",
        sender: "ai",
        text: `Hello there! I'm ${K?.Name}, your ${r}. I'm here to help you with ${e}. Can you tell me a little about yourself?`,
        timestamp: /* @__PURE__ */ new Date()
      }) : (C(!1), q(U.Data.SessionId || ""), de(U.Data.Message), {
        id: "welcome-message",
        sender: "ai",
        text: U.Data.Message,
        timestamp: /* @__PURE__ */ new Date()
      }) : (C(!1), {
        id: "welcome-message",
        sender: "ai",
        text: `Hello there! I'm ${K?.Name}, your ${r}. I'm here to help you with ${e}. Can you tell me a little about yourself?`,
        timestamp: /* @__PURE__ */ new Date()
      });
    },
    [e]
  ), $(() => {
    He(!0);
  }, []), $(() => {
    xe && xe.trim() !== "" && (Je(xe), ze(""));
  }, [xe]), $(() => {
    y(!!ae);
  }, [ae]);
  const Je = async (K, ie = []) => {
    V && te(!1);
    const U = {
      id: Date.now().toString(),
      sender: "user",
      text: K === "yes, continue" ? "Yes" : K,
      timestamp: /* @__PURE__ */ new Date()
    };
    ye(K), E((J) => [...J, U]), C(!0);
    let be = `${K}`;
    const it = [...Lt, ...ie];
    it.length > 0 && (be += "Summarize this file in 3–4 very simple sentences, as if you are explaining to a 3rd grader. Only include the most important points. Also, list anything in the file that should be double-checked or reviewed."), K === "yes, continue" && (be += "Start the interview. User clicked continue.");
    try {
      const J = await Fh(
        be,
        "52533633434137384342",
        // Send user ID instead of email - for testing hardcoding the userID
        "",
        // Business ID
        "interview",
        // Intent
        D,
        0,
        1,
        a,
        it.length > 0 ? it[0] : void 0
        // Only send last file
      );
      if (J.Success && J.Data?.Message) {
        if (J?.Data?.Message?.includes("ERROR") || J?.Data?.Type === "error") {
          C(!1);
          const Se = {
            id: (Date.now() + 1).toString(),
            sender: "ai",
            text: "Sorry, I couldn't process your request at the moment. Please try again.",
            timestamp: /* @__PURE__ */ new Date()
          };
          E((Qt) => [...Qt, Se]), de(Se.text), te(!0);
          return;
        }
        const Ee = {
          id: (Date.now() + 1).toString(),
          sender: "ai",
          text: J.Data.Message,
          timestamp: /* @__PURE__ */ new Date()
        };
        E((Se) => [...Se, Ee]), D || q(J?.Data?.SessionId || ""), de(J.Data.Message), (J.Data.Message.toLowerCase().includes("click continue") || J.Data.Message.toLowerCase().includes("continue")) && W(!0), (J.Data.Message.toLowerCase().includes("sign up") || J.Data.Message.toLowerCase().includes("thank you for choosing") || J.Data.Message.toLowerCase().includes("ready to connect")) && re(!0), (J.Data.Message.toLowerCase().includes("buy now") || J.Data.Message.toLowerCase().includes("ready to get your test kit")) && me(!0), u && u(J), await vI(
          "",
          "AIHealthNavigator",
          K,
          J.Data.Message || "",
          g === "voice",
          //isUserUsingAvatar
          K === xe
          // isUserSpeaking
        ), ye("");
      } else {
        const Ee = {
          id: (Date.now() + 1).toString(),
          sender: "ai",
          text: "Sorry, I couldn't process your request. Please try again.",
          timestamp: /* @__PURE__ */ new Date()
        };
        E((Se) => [...Se, Ee]), de(Ee.text), te(!0);
      }
    } catch (J) {
      console.error("Error fetching response from LLM: ", J);
      const Ee = {
        id: (Date.now() + 1).toString(),
        sender: "ai",
        text: "Sorry, I couldn't connect to the AI service. Please try again later.",
        timestamp: /* @__PURE__ */ new Date()
      };
      E((Se) => [...Se, Ee]), de(Ee.text), te(!0);
    } finally {
      C(!1);
    }
  }, ne = () => {
    console.log("Toggle chat visibility");
  }, eo = async (K) => {
    b(!0);
    const ie = Array.from(K.target.files || []);
    if (ie.length > 0) {
      const U = ie[0];
      bs([U]), c && c(U), b(!1), await Je(`Uploaded file: ${U.name}`, [U]);
    }
    K.target && (K.target.value = "");
  };
  return /* @__PURE__ */ N("div", { className: Ce("h-full min-h-0", t), children: [
    /* @__PURE__ */ N(Gf, { className: "h-full min-h-0 flex flex-col overflow-hidden border border-primary/20 shadow-2xl relative", children: [
      /* @__PURE__ */ P(Qf, { className: "flex-1 min-h-0 p-0 overflow-hidden", children: /* @__PURE__ */ N("div", { className: "h-full min-h-0 grid grid-cols-1 md:grid-cols-2 overflow-hidden", children: [
        /* @__PURE__ */ P("section", { className: "min-h-0 overflow-hidden p-4 md:p-6 border-b md:border-b-0 md:border-r border-primary/20", children: /* @__PURE__ */ P("div", { className: "h-full w-full min-h-0", children: v ? /* @__PURE__ */ P("div", { className: "h-full w-full rounded-xl overflow-hidden bg-white", children: d && /* @__PURE__ */ N(lf, { fallback: /* @__PURE__ */ P("div", { className: "w-full h-full bg-gray-200 rounded animate-pulse flex items-center justify-center", children: "Loading conversation..." }), children: [
          /* @__PURE__ */ N("div", { className: "hidden md:block text-center mb-6", children: [
            /* @__PURE__ */ P("div", { className: "inline-flex items-center justify-center w-12 h-12 md:w-16 md:h-16 bg-gradient-to-r from-green-500 to-blue-500 rounded-full mb-4", children: /* @__PURE__ */ P(mc, { className: "w-6 h-6 md:w-8 md:h-8 text-white" }) }),
            /* @__PURE__ */ P("h2", { className: "text-lg font-bold text-gray-900 mb-2", children: "🎉 Your Report Analysis is Ready!" })
          ] }),
          /* @__PURE__ */ P(
            fI,
            {
              ref: Kt,
              replicaId: d?.ExternalId || "",
              personaId: "pb5d44035dbd",
              personaName: r,
              conversationName: `Conversation with ${d?.Name || "your" + r} ${(/* @__PURE__ */ new Date()).toISOString()}`,
              conversationalContext: "Initial medical consultation",
              customGreeting: A.length > 0 && A[A.length - 1].sender === "ai" ? A[A.length - 1].text : i,
              platform: "concierge",
              buttonText: Es.avatar.startConversation,
              videoMode: "minimal",
              chatVisible: !1,
              toggleChat: ne,
              width: "100%",
              height: Xs ? "70%" : "55%",
              className: "w-full h-full",
              setVoiceMode: He,
              setConversationStarted: Gt,
              setConversationId: zt,
              setConversationUrl: Ke,
              setInterruptReplica: tt,
              currentScript: nt,
              setCurrentScript: de,
              interruptReplica: Jt,
              setIsSpeaking: we,
              setSpokenText: ze,
              region: l?.region || "",
              speechKey: l?.speechKey || "",
              config: l
            }
          ),
          /* @__PURE__ */ P("div", { className: "hidden md:block bg-gradient-to-r from-blue-50 to-teal-50 rounded-2xl p-6 mb-6", children: /* @__PURE__ */ N("div", { className: "flex items-start space-x-4", children: [
            /* @__PURE__ */ P("div", { className: "w-12 h-12 rounded-full overflow-hidden flex-shrink-0", children: /* @__PURE__ */ P(
              "img",
              {
                src: d?.ImageUrl,
                alt: d?.Name,
                className: "w-full h-full object-cover"
              }
            ) }),
            /* @__PURE__ */ P("div", { className: "flex-1 text-left", children: /* @__PURE__ */ N("p", { className: "text-gray-800 leading-relaxed", children: [
              /* @__PURE__ */ N("strong", { className: "text-[#3f62ec]", children: [
                r,
                ":"
              ] }),
              " ",
              `"Great news! I've analyzed your `,
              n?.name || "health report",
              ' and found some important insights for you."'
            ] }) })
          ] }) })
        ] }) }) : /* @__PURE__ */ N("div", { className: "flex flex-col items-center text-center", children: [
          /* @__PURE__ */ N("div", { className: "hidden md:block text-center mb-6", children: [
            /* @__PURE__ */ P("div", { className: "inline-flex items-center justify-center w-12 h-12 md:w-16 md:h-16 bg-gradient-to-r from-green-500 to-blue-500 rounded-full mb-4", children: /* @__PURE__ */ P(mc, { className: "w-6 h-6 md:w-8 md:h-8 text-white" }) }),
            /* @__PURE__ */ P("h2", { className: "text-lg md:text-xl font-bold text-gray-900 mb-2", children: "🎉 Your Report Analysis is Ready!" })
          ] }),
          /* @__PURE__ */ N("div", { className: "mb-4 flex flex-col items-center gap-2", children: [
            /* @__PURE__ */ P(
              "img",
              {
                src: d?.ImageUrl,
                alt: d?.Name,
                className: "w-full max-w-sm h-auto rounded-2xl mx-auto lg:mx-0 shadow-lg",
                "data-testid": "img-ai-health-concierge"
              }
            ),
            /* @__PURE__ */ P(
              $t,
              {
                onClick: () => y(!0),
                className: "w-auto bg-[#3f62ec] hover:bg-white hover:text-[#3f62ec] text-white py-3 px-6 rounded-lg font-semibold shadow-md transition",
                children: Es.avatar.startConversation
              }
            )
          ] }),
          /* @__PURE__ */ P("div", { className: "hidden md:block bg-gradient-to-r from-blue-50 to-teal-50 rounded-2xl p-6 mb-6 w-full max-w-xl", children: /* @__PURE__ */ N("div", { className: "flex flex-col sm:flex-row items-center sm:items-start gap-4", children: [
            /* @__PURE__ */ P("div", { className: "w-12 h-12 rounded-full overflow-hidden flex-shrink-0", children: /* @__PURE__ */ P(
              "img",
              {
                src: d?.ImageUrl,
                alt: d?.Name,
                className: "w-full h-full object-cover"
              }
            ) }),
            /* @__PURE__ */ P("div", { className: "flex-1 text-center sm:text-left", children: /* @__PURE__ */ N("p", { className: "text-gray-800 leading-relaxed", children: [
              /* @__PURE__ */ P("strong", { className: "text-[#3f62ec]", children: "AI Concierge:" }),
              " ",
              `"Great news! I've analyzed your `,
              n?.name || "health report",
              ' and found some important insights for you."'
            ] }) })
          ] }) })
        ] }) }) }),
        /* @__PURE__ */ P("section", { className: "min-h-0 overflow-hidden p-4 md:p-6", children: /* @__PURE__ */ P("div", { className: "h-full min-h-0 flex flex-col overflow-hidden", children: /* @__PURE__ */ P(
          cC,
          {
            language: a,
            config: l,
            setInterruptReplica: tt,
            messages: A,
            welcomeMessage: i,
            onSendMessage: Je,
            className: "h-full min-h-0",
            isLoading: S,
            rightElement: /* @__PURE__ */ P(lf, { fallback: /* @__PURE__ */ P("div", { className: "w-10 h-10 bg-gray-200 rounded animate-pulse" }), children: /* @__PURE__ */ P(
              tg,
              {
                avatarName: d?.Name || "AI Health Navigator",
                disabled: S,
                voiceMode: rt,
                setSpokenText: ze,
                setIsSpeaking: we,
                setInterruptReplica: tt,
                region: l?.region || "",
                speechKey: l?.speechKey || ""
              }
            ) }),
            suggestedPrompts: o,
            renderMessage: (K, ie) => K.sender === "ai" && K.id !== "welcome-message" ? (A.length - 1, /* @__PURE__ */ P("div", { className: "relative", children: /* @__PURE__ */ P(
              xa,
              {
                remarkPlugins: [qa],
                components: {
                  p: ({ children: U }) => /* @__PURE__ */ P("p", { className: "text-sm mb-2 break-words", children: U }),
                  ol: ({ children: U }) => /* @__PURE__ */ P("ol", { className: "list-decimal ml-6 mb-2", children: U }),
                  ul: ({ children: U }) => /* @__PURE__ */ P("ul", { className: "list-disc ml-6 mb-2", children: U }),
                  li: ({ children: U }) => /* @__PURE__ */ P("li", { className: "mb-1", children: U }),
                  img: (U) => /* @__PURE__ */ P("img", { ...U, className: "max-w-full max-h-64 object-contain rounded" }),
                  code: ({ children: U }) => /* @__PURE__ */ P("code", { className: "break-words whitespace-pre-wrap", children: U }),
                  a: ({ href: U, children: be }) => /* @__PURE__ */ P("a", { href: U, target: "_blank", rel: "noopener noreferrer", className: "text-blue-600 underline", children: be })
                },
                children: K.text
              }
            ) })) : /* @__PURE__ */ P(xa, { remarkPlugins: [qa], children: K.text })
          }
        ) }) })
      ] }) }),
      /* @__PURE__ */ P("div", { className: "pointer-events-none absolute -top-4 -right-4 w-72 h-72 bg-primary/20 rounded-full blur-3xl" }),
      /* @__PURE__ */ P("div", { className: "pointer-events-none absolute -bottom-8 -left-8 w-96 h-96 bg-secondary/10 rounded-full blur-3xl" })
    ] }),
    /* @__PURE__ */ P(
      "input",
      {
        type: "file",
        ref: X,
        onChange: eo,
        accept: ".pdf,.doc,.docx,.jpg,.jpeg,.png,.txt",
        className: "hidden"
      }
    )
  ] });
}
function VT(e) {
  return /* @__PURE__ */ P(hI, { value: e.config || {}, children: /* @__PURE__ */ P(yI, { ...e }) });
}
const gg = pf(void 0), WT = ({ children: e, value: t }) => /* @__PURE__ */ P(gg.Provider, { value: t, children: e }), HT = () => {
  const e = df(gg);
  if (!e)
    throw new Error("useConciergeContext must be used within a ConciergeProvider");
  return e;
};
function KT(e, t) {
  const [r, o] = O(() => {
    if (typeof window > "u")
      return t;
    try {
      const a = window.localStorage.getItem(e);
      return a ? JSON.parse(a) : t;
    } catch (a) {
      return console.log(a), t;
    }
  });
  return [r, (a) => {
    try {
      const s = a instanceof Function ? a(r) : a;
      o(s), typeof window < "u" && window.localStorage.setItem(e, JSON.stringify(s));
    } catch (s) {
      console.log(s);
    }
  }];
}
export {
  VT as ConciergeModule,
  yI as ConciergeModuleRaw,
  WT as ConciergeProvider,
  fI as ConversationComponent,
  lf as SSRSafeWrapper,
  tg as SpeechComponent,
  HT as useConciergeContext,
  KT as useLocalStorage
};
